import { g as pi, c as _, r as Se, a as hi } from "./index-45673b38.js";
function gi(e, r) {
  for (var n = 0; n < r.length; n++) {
    const t = r[n];
    if (typeof t != "string" && !Array.isArray(t)) {
      for (const i in t)
        if (i !== "default" && !(i in e)) {
          const l = Object.getOwnPropertyDescriptor(t, i);
          l && Object.defineProperty(e, i, l.get ? l : {
            enumerable: !0,
            get: () => t[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }));
}
var Qe = {}, Ve = {};
const _i = !1, mi = /\r?\n/, vi = /\bono[ @]/;
function yi(e) {
  return !!(e && e.configurable && typeof e.get == "function");
}
function xi(e) {
  return !!// If there is no stack property, then it's writable, since assigning it will create it
  (!e || e.writable || typeof e.set == "function");
}
function on(e, r) {
  let n = ln(e.stack), t = r ? r.stack : void 0;
  return n && t ? n + `

` + t : n || t;
}
function wi(e, r, n) {
  n ? Object.defineProperty(r, "stack", {
    get: () => {
      let t = e.get.apply(r);
      return on({ stack: t }, n);
    },
    enumerable: !1,
    configurable: !0
  }) : bi(r, e);
}
function ln(e) {
  if (e) {
    let r = e.split(mi), n;
    for (let t = 0; t < r.length; t++) {
      let i = r[t];
      if (vi.test(i))
        n === void 0 && (n = t);
      else if (n !== void 0) {
        r.splice(n, t - n);
        break;
      }
    }
    if (r.length > 0)
      return r.join(`
`);
  }
  return e;
}
function bi(e, r) {
  Object.defineProperty(e, "stack", {
    get: () => ln(r.get.apply(e)),
    enumerable: !1,
    configurable: !0
  });
}
const Ei = ["function", "symbol", "undefined"], Oi = ["constructor", "prototype", "__proto__"], Ai = Object.getPrototypeOf({});
function un() {
  let e = {}, r = this;
  for (let n of an(r))
    if (typeof n == "string") {
      let t = r[n], i = typeof t;
      Ei.includes(i) || (e[n] = t);
    }
  return e;
}
function an(e, r = []) {
  let n = [];
  for (; e && e !== Ai; )
    n = n.concat(Object.getOwnPropertyNames(e), Object.getOwnPropertySymbols(e)), e = Object.getPrototypeOf(e);
  let t = new Set(n);
  for (let i of r.concat(Oi))
    t.delete(i);
  return t;
}
const Pi = ["name", "message", "stack"];
function me(e, r, n) {
  let t = e;
  return Si(t, r), r && typeof r == "object" && $i(t, r), t.toJSON = un, n && typeof n == "object" && Object.assign(t, n), t;
}
function Si(e, r) {
  let n = Object.getOwnPropertyDescriptor(e, "stack");
  yi(n) ? wi(n, e, r) : xi(n) && (e.stack = on(e, r));
}
function $i(e, r) {
  let n = an(r, Pi), t = e, i = r;
  for (let l of n)
    if (t[l] === void 0)
      try {
        t[l] = i[l];
      } catch {
      }
}
function ji(e) {
  return e = e || {}, {
    concatMessages: e.concatMessages === void 0 ? !0 : !!e.concatMessages,
    format: e.format === void 0 ? _i : typeof e.format == "function" ? e.format : !1
  };
}
function Ci(e, r) {
  let n, t, i, l = "";
  return typeof e[0] == "string" ? i = e : typeof e[1] == "string" ? (e[0] instanceof Error ? n = e[0] : t = e[0], i = e.slice(1)) : (n = e[0], t = e[1], i = e.slice(2)), i.length > 0 && (r.format ? l = r.format.apply(void 0, i) : l = i.join(" ")), r.concatMessages && n && n.message && (l += (l ? ` 
` : "") + n.message), { originalError: n, props: t, message: l };
}
const Y = Xe;
function Xe(e, r) {
  r = ji(r);
  function n(...t) {
    let { originalError: i, props: l, message: o } = Ci(t, r), u = new e(o);
    return me(u, i, l);
  }
  return n[Symbol.species] = e, n;
}
Xe.toJSON = function(r) {
  return un.call(r);
};
Xe.extend = function(r, n, t) {
  return t || n instanceof Error ? me(r, n, t) : n ? me(r, void 0, n) : me(r);
};
const Ar = I;
I.error = new Y(Error);
I.eval = new Y(EvalError);
I.range = new Y(RangeError);
I.reference = new Y(ReferenceError);
I.syntax = new Y(SyntaxError);
I.type = new Y(TypeError);
I.uri = new Y(URIError);
const Ti = I;
function I(...e) {
  let r = e[0];
  if (typeof r == "object" && typeof r.name == "string") {
    for (let n of Object.values(Ti))
      if (typeof n == "function" && n.name === "ono") {
        let t = n[Symbol.species];
        if (t && t !== Error && (r instanceof t || r.name === t.name))
          return n.apply(void 0, e);
      }
  }
  return I.error.apply(void 0, e);
}
typeof module == "object" && typeof module.exports == "object" && (module.exports = Object.assign(module.exports.default, module.exports));
const Ri = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Ono: Y,
  default: Ar,
  ono: Ar
}, Symbol.toStringTag, { value: "Module" })), q = /* @__PURE__ */ pi(Ri);
var he = {}, ge = {}, O = {}, $e = {}, Mi = _ && _.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty($e, "__esModule", { value: !0 });
const Pr = Mi(Se);
function Fi(e) {
  var n, t, i, l;
  return e.startsWith("\\\\?\\") ? e : e.split((t = (n = Pr.default) == null ? void 0 : n.win32) == null ? void 0 : t.sep).join(((l = (i = Pr.default) == null ? void 0 : i.posix) == null ? void 0 : l.sep) ?? "/");
}
$e.default = Fi;
var je = {};
Object.defineProperty(je, "__esModule", { value: !0 });
je.isWindows = void 0;
const Ii = /^win/.test(globalThis.process ? globalThis.process.platform : ""), Di = () => Ii;
je.isWindows = Di;
var Ni = _ && _.__createBinding || (Object.create ? function(e, r, n, t) {
  t === void 0 && (t = n);
  var i = Object.getOwnPropertyDescriptor(r, n);
  (!i || ("get" in i ? !r.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return r[n];
  } }), Object.defineProperty(e, t, i);
} : function(e, r, n, t) {
  t === void 0 && (t = n), e[t] = r[n];
}), Li = _ && _.__setModuleDefault || (Object.create ? function(e, r) {
  Object.defineProperty(e, "default", { enumerable: !0, value: r });
} : function(e, r) {
  e.default = r;
}), Bi = _ && _.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var r = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && Ni(r, e, n);
  return Li(r, e), r;
}, Hi = _ && _.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(O, "__esModule", { value: !0 });
O.relative = O.safePointerToPath = O.toFileSystemPath = O.fromFileSystemPath = O.isFileSystemPath = O.isHttp = O.stripHash = O.getHash = O.stripQuery = O.getExtension = O.getProtocol = O.cwd = O.resolve = O.parse = void 0;
const ye = Hi($e), ke = Bi(Se), ki = /\//g, Ui = /^(\w{2,}):\/\//i, Yi = /~1/g, Gi = /~0/g, Wi = Se, ve = je, Ji = [
  [/\?/g, "%3F"],
  [/#/g, "%23"]
], Ie = [/%23/g, "#", /%24/g, "$", /%26/g, "&", /%2C/g, ",", /%40/g, "@"], qi = (e) => new URL(e);
O.parse = qi;
function cn(e, r) {
  var l;
  const n = new URL((0, ye.default)(e), "resolve://"), t = new URL((0, ye.default)(r), n), i = ((l = r.match(/(\s*)$/)) == null ? void 0 : l[1]) || "";
  if (t.protocol === "resolve:") {
    const { pathname: o, search: u, hash: a } = t;
    return o + u + a + i;
  }
  return t.toString() + i;
}
O.resolve = cn;
function fn() {
  if (typeof window < "u")
    return location.href;
  const e = process.cwd(), r = e.slice(-1);
  return r === "/" || r === "\\" ? e : e + "/";
}
O.cwd = fn;
function Ze(e) {
  const r = Ui.exec(e || "");
  if (r)
    return r[1].toLowerCase();
}
O.getProtocol = Ze;
function Ki(e) {
  const r = e.lastIndexOf(".");
  return r >= 0 ? sn(e.substr(r).toLowerCase()) : "";
}
O.getExtension = Ki;
function sn(e) {
  const r = e.indexOf("?");
  return r >= 0 && (e = e.substr(0, r)), e;
}
O.stripQuery = sn;
function dn(e) {
  if (!e)
    return "#";
  const r = e.indexOf("#");
  return r >= 0 ? e.substring(r) : "#";
}
O.getHash = dn;
function Ue(e) {
  if (!e)
    return "";
  const r = e.indexOf("#");
  return r >= 0 && (e = e.substring(0, r)), e;
}
O.stripHash = Ue;
function zi(e) {
  const r = Ze(e);
  return r === "http" || r === "https" ? !0 : r === void 0 ? typeof window < "u" : !1;
}
O.isHttp = zi;
function Ye(e) {
  if (typeof window < "u" || process.browser)
    return !1;
  const r = Ze(e);
  return r === void 0 || r === "file";
}
O.isFileSystemPath = Ye;
function Qi(e) {
  var r;
  if ((0, ve.isWindows)()) {
    const n = fn(), t = e.toUpperCase(), l = (0, ye.default)(n).toUpperCase(), o = t.includes(l), u = t.includes(l), a = ((r = ke.win32) == null ? void 0 : r.isAbsolute(e)) || e.startsWith("http://") || e.startsWith("https://") || e.startsWith("file://");
    !(o || u || a) && !n.startsWith("http") && (e = (0, Wi.join)(n, e)), e = (0, ye.default)(e);
  }
  e = encodeURI(e);
  for (const n of Ji)
    e = e.replace(n[0], n[1]);
  return e;
}
O.fromFileSystemPath = Qi;
function Vi(e, r) {
  e = decodeURI(e);
  for (let t = 0; t < Ie.length; t += 2)
    e = e.replace(Ie[t], Ie[t + 1]);
  let n = e.substr(0, 7).toLowerCase() === "file://";
  return n && (e = e[7] === "/" ? e.substr(8) : e.substr(7), (0, ve.isWindows)() && e[1] === "/" && (e = e[0] + ":" + e.substr(1)), r ? e = "file:///" + e : (n = !1, e = (0, ve.isWindows)() ? e : "/" + e)), (0, ve.isWindows)() && !n && (e = e.replace(ki, "\\"), e.substr(1, 2) === ":\\" && (e = e[0].toUpperCase() + e.substr(1))), e;
}
O.toFileSystemPath = Vi;
function Xi(e) {
  return e.length <= 1 || e[0] !== "#" || e[1] !== "/" ? [] : e.slice(2).split("/").map((r) => decodeURIComponent(r).replace(Yi, "/").replace(Gi, "~"));
}
O.safePointerToPath = Xi;
function Zi(e, r) {
  if (!Ye(e) || !Ye(r))
    return cn(e, r);
  const n = ke.default.dirname(Ue(e)), t = Ue(r);
  return ke.default.relative(n, t) + dn(r);
}
O.relative = Zi;
var A = {};
Object.defineProperty(A, "__esModule", { value: !0 });
A.normalizeError = A.isHandledError = A.InvalidPointerError = A.TimeoutError = A.MissingPointerError = A.UnmatchedResolverError = A.ResolverError = A.UnmatchedParserError = A.ParserError = A.JSONParserErrorGroup = A.JSONParserError = void 0;
const pn = q, er = O;
class N extends Error {
  constructor(r, n) {
    super(), this.code = "EUNKNOWN", this.name = "JSONParserError", this.message = r, this.source = n, this.path = null, pn.Ono.extend(this);
  }
  get footprint() {
    return `${this.path}+${this.source}+${this.code}+${this.message}`;
  }
}
A.JSONParserError = N;
class Ce extends Error {
  constructor(r) {
    super(), this.files = r, this.name = "JSONParserErrorGroup", this.message = `${this.errors.length} error${this.errors.length > 1 ? "s" : ""} occurred while reading '${(0, er.toFileSystemPath)(r.$refs._root$Ref.path)}'`, pn.Ono.extend(this);
  }
  static getParserErrors(r) {
    const n = [];
    for (const t of Object.values(r.$refs._$refs))
      t.errors && n.push(...t.errors);
    return n;
  }
  get errors() {
    return Ce.getParserErrors(this.files);
  }
}
A.JSONParserErrorGroup = Ce;
class et extends N {
  constructor(r, n) {
    super(`Error parsing ${n}: ${r}`, n), this.code = "EPARSER", this.name = "ParserError";
  }
}
A.ParserError = et;
class rt extends N {
  constructor(r) {
    super(`Could not find parser for "${r}"`, r), this.code = "EUNMATCHEDPARSER", this.name = "UnmatchedParserError";
  }
}
A.UnmatchedParserError = rt;
class nt extends N {
  constructor(r, n) {
    super(r.message || `Error reading file "${n}"`, n), this.code = "ERESOLVER", this.name = "ResolverError", "code" in r && (this.ioErrorCode = String(r.code));
  }
}
A.ResolverError = nt;
class it extends N {
  constructor(r) {
    super(`Could not find resolver for "${r}"`, r), this.code = "EUNMATCHEDRESOLVER", this.name = "UnmatchedResolverError";
  }
}
A.UnmatchedResolverError = it;
class tt extends N {
  constructor(r, n) {
    super(`Token "${r}" does not exist.`, (0, er.stripHash)(n)), this.code = "EUNMATCHEDRESOLVER", this.name = "MissingPointerError";
  }
}
A.MissingPointerError = tt;
class ot extends N {
  constructor(r) {
    super(`Dereferencing timeout reached: ${r}ms`), this.code = "ETIMEOUT", this.name = "TimeoutError";
  }
}
A.TimeoutError = ot;
class lt extends N {
  constructor(r, n) {
    super(`Invalid $ref pointer "${r}". Pointers must begin with "#/"`, (0, er.stripHash)(n)), this.code = "EUNMATCHEDRESOLVER", this.name = "InvalidPointerError";
  }
}
A.InvalidPointerError = lt;
function ut(e) {
  return e instanceof N || e instanceof Ce;
}
A.isHandledError = ut;
function at(e) {
  return e.path === null && (e.path = []), e;
}
A.normalizeError = at;
var Sr;
function Te() {
  if (Sr)
    return ge;
  Sr = 1;
  var e = _ && _.__createBinding || (Object.create ? function(d, c, x, E) {
    E === void 0 && (E = x);
    var v = Object.getOwnPropertyDescriptor(c, x);
    (!v || ("get" in v ? !c.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
      return c[x];
    } }), Object.defineProperty(d, E, v);
  } : function(d, c, x, E) {
    E === void 0 && (E = x), d[E] = c[x];
  }), r = _ && _.__setModuleDefault || (Object.create ? function(d, c) {
    Object.defineProperty(d, "default", { enumerable: !0, value: c });
  } : function(d, c) {
    d.default = c;
  }), n = _ && _.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var c = {};
    if (d != null)
      for (var x in d)
        x !== "default" && Object.prototype.hasOwnProperty.call(d, x) && e(c, d, x);
    return r(c, d), c;
  }, t = _ && _.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(ge, "__esModule", { value: !0 });
  const i = t(ce()), l = n(O), o = A, u = /\//g, a = /~/g, f = /~1/g, h = /~0/g, s = (d) => {
    try {
      return decodeURIComponent(d);
    } catch {
      return d;
    }
  };
  class p {
    constructor(c, x, E) {
      this.$ref = c, this.path = x, this.originalPath = E || x, this.value = void 0, this.circular = !1, this.indirections = 0;
    }
    /**
     * Resolves the value of a nested property within the given object.
     *
     * @param obj - The object that will be crawled
     * @param options
     * @param pathFromRoot - the path of place that initiated resolving
     *
     * @returns
     * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.
     * If resolving this value required resolving other JSON references, then
     * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path
     * of the resolved value.
     */
    resolve(c, x, E) {
      const v = p.parse(this.path, this.originalPath);
      this.value = y(c);
      for (let P = 0; P < v.length; P++) {
        if (g(this, x, E) && (this.path = p.join(this.path, v.slice(P))), typeof this.value == "object" && this.value !== null && !b(E) && "$ref" in this.value)
          return this;
        const L = v[P];
        if (this.value[L] === void 0 || this.value[L] === null && P === v.length - 1) {
          let Er = !1;
          for (let pe = v.length - 1; pe > P; pe--) {
            const Or = v.slice(P, pe + 1).join("/");
            if (this.value[Or] !== void 0) {
              this.value = this.value[Or], P = pe, Er = !0;
              break;
            }
          }
          if (Er)
            continue;
          throw this.value = null, new o.MissingPointerError(L, decodeURI(this.originalPath));
        } else
          this.value = this.value[L];
      }
      return (!this.value || this.value.$ref && l.resolve(this.path, this.value.$ref) !== E) && g(this, x, E), this;
    }
    /**
     * Sets the value of a nested property within the given object.
     *
     * @param obj - The object that will be crawled
     * @param value - the value to assign
     * @param options
     *
     * @returns
     * Returns the modified object, or an entirely new object if the entire object is overwritten.
     */
    set(c, x, E) {
      const v = p.parse(this.path);
      let P;
      if (v.length === 0)
        return this.value = x, x;
      this.value = y(c);
      for (let L = 0; L < v.length - 1; L++)
        g(this, E), P = v[L], this.value && this.value[P] !== void 0 ? this.value = this.value[P] : this.value = m(this, P, {});
      return g(this, E), P = v[v.length - 1], m(this, P, x), c;
    }
    /**
     * Parses a JSON pointer (or a path containing a JSON pointer in the hash)
     * and returns an array of the pointer's tokens.
     * (e.g. "schema.json#/definitions/person/name" => ["definitions", "person", "name"])
     *
     * The pointer is parsed according to RFC 6901
     * {@link https://tools.ietf.org/html/rfc6901#section-3}
     *
     * @param path
     * @param [originalPath]
     * @returns
     */
    static parse(c, x) {
      const E = l.getHash(c).substring(1);
      if (!E)
        return [];
      const v = E.split("/");
      for (let P = 0; P < v.length; P++)
        v[P] = s(v[P].replace(f, "/").replace(h, "~"));
      if (v[0] !== "")
        throw new o.InvalidPointerError(v, x === void 0 ? c : x);
      return v.slice(1);
    }
    /**
     * Creates a JSON pointer path, by joining one or more tokens to a base path.
     *
     * @param base - The base path (e.g. "schema.json#/definitions/person")
     * @param tokens - The token(s) to append (e.g. ["name", "first"])
     * @returns
     */
    static join(c, x) {
      c.indexOf("#") === -1 && (c += "#"), x = Array.isArray(x) ? x : [x];
      for (let E = 0; E < x.length; E++) {
        const v = x[E];
        c += "/" + encodeURIComponent(v.replace(a, "~0").replace(u, "~1"));
      }
      return c;
    }
  }
  function g(d, c, x) {
    if (i.default.isAllowed$Ref(d.value, c)) {
      const E = l.resolve(d.path, d.value.$ref);
      if (E === d.path && !b(x))
        d.circular = !0;
      else {
        const v = d.$ref.$refs._resolve(E, d.path, c);
        return v === null ? !1 : (d.indirections += v.indirections + 1, i.default.isExtended$Ref(d.value) ? (d.value = i.default.dereference(d.value, v.value), !1) : (d.$ref = v.$ref, d.path = v.path, d.value = v.value, !0));
      }
    }
  }
  ge.default = p;
  function m(d, c, x) {
    if (d.value && typeof d.value == "object")
      c === "-" && Array.isArray(d.value) ? d.value.push(x) : d.value[c] = x;
    else
      throw new o.JSONParserError(`Error assigning $ref pointer "${d.path}". 
Cannot set "${c}" of a non-object.`);
    return x;
  }
  function y(d) {
    if ((0, o.isHandledError)(d))
      throw d;
    return d;
  }
  function b(d) {
    return typeof d == "string" && p.parse(d).length == 0;
  }
  return ge;
}
var $r;
function ce() {
  if ($r)
    return he;
  $r = 1;
  var e = _ && _.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(he, "__esModule", { value: !0 });
  const r = e(Te()), n = A, t = O;
  class i {
    constructor(o) {
      this.errors = [], this.$refs = o;
    }
    /**
     * Pushes an error to errors array.
     *
     * @param err - The error to be pushed
     * @returns
     */
    addError(o) {
      this.errors === void 0 && (this.errors = []);
      const u = this.errors.map(({ footprint: a }) => a);
      "errors" in o && Array.isArray(o.errors) ? this.errors.push(...o.errors.map(n.normalizeError).filter(({ footprint: a }) => !u.includes(a))) : (!("footprint" in o) || !u.includes(o.footprint)) && this.errors.push((0, n.normalizeError)(o));
    }
    /**
     * Determines whether the given JSON reference exists within this {@link $Ref#value}.
     *
     * @param path - The full path being resolved, optionally with a JSON pointer in the hash
     * @param options
     * @returns
     */
    exists(o, u) {
      try {
        return this.resolve(o, u), !0;
      } catch {
        return !1;
      }
    }
    /**
     * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.
     *
     * @param path - The full path being resolved, optionally with a JSON pointer in the hash
     * @param options
     * @returns - Returns the resolved value
     */
    get(o, u) {
      var a;
      return (a = this.resolve(o, u)) == null ? void 0 : a.value;
    }
    /**
     * Resolves the given JSON reference within this {@link $Ref#value}.
     *
     * @param path - The full path being resolved, optionally with a JSON pointer in the hash
     * @param options
     * @param friendlyPath - The original user-specified path (used for error messages)
     * @param pathFromRoot - The path of `obj` from the schema root
     * @returns
     */
    resolve(o, u, a, f) {
      const h = new r.default(this, o, a);
      try {
        return h.resolve(this.value, u, f);
      } catch (s) {
        if (!u || !u.continueOnError || !(0, n.isHandledError)(s))
          throw s;
        return s.path === null && (s.path = (0, t.safePointerToPath)((0, t.getHash)(f))), s instanceof n.InvalidPointerError && (s.source = decodeURI((0, t.stripHash)(f))), this.addError(s), null;
      }
    }
    /**
     * Sets the value of a nested property within this {@link $Ref#value}.
     * If the property, or any of its parents don't exist, they will be created.
     *
     * @param path - The full path of the property to set, optionally with a JSON pointer in the hash
     * @param value - The value to assign
     */
    set(o, u) {
      const a = new r.default(this, o);
      this.value = a.set(this.value, u);
    }
    /**
     * Determines whether the given value is a JSON reference.
     *
     * @param value - The value to inspect
     * @returns
     */
    static is$Ref(o) {
      return !!o && typeof o == "object" && o !== null && "$ref" in o && typeof o.$ref == "string" && o.$ref.length > 0;
    }
    /**
     * Determines whether the given value is an external JSON reference.
     *
     * @param value - The value to inspect
     * @returns
     */
    static isExternal$Ref(o) {
      return i.is$Ref(o) && o.$ref[0] !== "#";
    }
    /**
     * Determines whether the given value is a JSON reference, and whether it is allowed by the options.
     * For example, if it references an external file, then options.resolve.external must be true.
     *
     * @param value - The value to inspect
     * @param options
     * @returns
     */
    static isAllowed$Ref(o, u) {
      var a;
      if (this.is$Ref(o)) {
        if (o.$ref.substring(0, 2) === "#/" || o.$ref === "#")
          return !0;
        if (o.$ref[0] !== "#" && (!u || (a = u.resolve) != null && a.external))
          return !0;
      }
    }
    /**
     * Determines whether the given value is a JSON reference that "extends" its resolved value.
     * That is, it has extra properties (in addition to "$ref"), so rather than simply pointing to
     * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved
     * value, plus the extra properties.
     *
     * @example: {
       person: {
         properties: {
           firstName: { type: string }
           lastName: { type: string }
         }
       }
       employee: {
         properties: {
           $ref: #/person/properties
           salary: { type: number }
         }
       }
     }
     *  In this example, "employee" is an extended $ref, since it extends "person" with an additional
     *  property (salary).  The result is a NEW value that looks like this:
     *
     *  {
     *    properties: {
     *      firstName: { type: string }
     *      lastName: { type: string }
     *      salary: { type: number }
     *    }
     *  }
     *
     * @param value - The value to inspect
     * @returns
     */
    static isExtended$Ref(o) {
      return i.is$Ref(o) && Object.keys(o).length > 1;
    }
    /**
     * Returns the resolved value of a JSON Reference.
     * If necessary, the resolved value is merged with the JSON Reference to create a new object
     *
     * @example: {
    person: {
      properties: {
        firstName: { type: string }
        lastName: { type: string }
      }
    }
    employee: {
      properties: {
        $ref: #/person/properties
        salary: { type: number }
      }
    }
    } When "person" and "employee" are merged, you end up with the following object:
     *
     *  {
     *    properties: {
     *      firstName: { type: string }
     *      lastName: { type: string }
     *      salary: { type: number }
     *    }
     *  }
     *
     * @param $ref - The JSON reference object (the one with the "$ref" property)
     * @param resolvedValue - The resolved value, which can be any type
     * @returns - Returns the dereferenced value
     */
    static dereference(o, u) {
      if (u && typeof u == "object" && i.isExtended$Ref(o)) {
        const a = {};
        for (const f of Object.keys(o))
          f !== "$ref" && (a[f] = o[f]);
        for (const f of Object.keys(u))
          f in a || (a[f] = u[f]);
        return a;
      } else
        return u;
    }
  }
  return he.default = i, he;
}
var ct = _ && _.__createBinding || (Object.create ? function(e, r, n, t) {
  t === void 0 && (t = n);
  var i = Object.getOwnPropertyDescriptor(r, n);
  (!i || ("get" in i ? !r.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return r[n];
  } }), Object.defineProperty(e, t, i);
} : function(e, r, n, t) {
  t === void 0 && (t = n), e[t] = r[n];
}), ft = _ && _.__setModuleDefault || (Object.create ? function(e, r) {
  Object.defineProperty(e, "default", { enumerable: !0, value: r });
} : function(e, r) {
  e.default = r;
}), st = _ && _.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var r = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && ct(r, e, n);
  return ft(r, e), r;
}, hn = _ && _.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ve, "__esModule", { value: !0 });
const jr = q, dt = hn(ce()), B = st(O), Cr = hn($e);
class pt {
  /**
   * Returns the paths/URLs of all the files in your schema (including the main schema file).
   *
   * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#pathstypes
   *
   * @param types (optional) Optionally only return certain types of paths ("file", "http", etc.)
   */
  paths(...r) {
    return Tr(this._$refs, r.flat()).map((t) => (0, Cr.default)(t.decoded));
  }
  /**
   * Returns a map of paths/URLs and their correspond values.
   *
   * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#valuestypes
   *
   * @param types (optional) Optionally only return values from certain locations ("file", "http", etc.)
   */
  values(...r) {
    const n = this._$refs;
    return Tr(n, r.flat()).reduce((i, l) => (i[(0, Cr.default)(l.decoded)] = n[l.encoded].value, i), {});
  }
  /**
   * Returns `true` if the given path exists in the schema; otherwise, returns `false`
   *
   * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#existsref
   *
   * @param $ref The JSON Reference path, optionally with a JSON Pointer in the hash
   */
  /**
   * Determines whether the given JSON reference exists.
   *
   * @param path - The path being resolved, optionally with a JSON pointer in the hash
   * @param [options]
   * @returns
   */
  exists(r, n) {
    try {
      return this._resolve(r, "", n), !0;
    } catch {
      return !1;
    }
  }
  /**
   * Resolves the given JSON reference and returns the resolved value.
   *
   * @param path - The path being resolved, with a JSON pointer in the hash
   * @param [options]
   * @returns - Returns the resolved value
   */
  get(r, n) {
    return this._resolve(r, "", n).value;
  }
  /**
   * Sets the value at the given path in the schema. If the property, or any of its parents, don't exist, they will be created.
   *
   * @param path The JSON Reference path, optionally with a JSON Pointer in the hash
   * @param value The value to assign. Can be anything (object, string, number, etc.)
   */
  set(r, n) {
    const t = B.resolve(this._root$Ref.path, r), i = B.stripHash(t), l = this._$refs[i];
    if (!l)
      throw (0, jr.ono)(`Error resolving $ref pointer "${r}". 
"${i}" not found.`);
    l.set(t, n);
  }
  /**
   * Returns the specified {@link $Ref} object, or undefined.
   *
   * @param path - The path being resolved, optionally with a JSON pointer in the hash
   * @returns
   * @protected
   */
  _get$Ref(r) {
    r = B.resolve(this._root$Ref.path, r);
    const n = B.stripHash(r);
    return this._$refs[n];
  }
  /**
   * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.
   *
   * @param path  - The file path or URL of the referenced file
   */
  _add(r) {
    const n = B.stripHash(r), t = new dt.default(this);
    return t.path = n, this._$refs[n] = t, this._root$Ref = this._root$Ref || t, t;
  }
  /**
   * Resolves the given JSON reference.
   *
   * @param path - The path being resolved, optionally with a JSON pointer in the hash
   * @param pathFromRoot - The path of `obj` from the schema root
   * @param [options]
   * @returns
   * @protected
   */
  _resolve(r, n, t) {
    const i = B.resolve(this._root$Ref.path, r), l = B.stripHash(i), o = this._$refs[l];
    if (!o)
      throw (0, jr.ono)(`Error resolving $ref pointer "${r}". 
"${l}" not found.`);
    return o.resolve(i, t, r, n);
  }
  constructor() {
    this._$refs = {}, this.toJSON = this.values, this.circular = !1, this._$refs = {}, this._root$Ref = null;
  }
}
Ve.default = pt;
function Tr(e, r) {
  let n = Object.keys(e);
  return r = Array.isArray(r[0]) ? r[0] : Array.prototype.slice.call(r), r.length > 0 && r[0] && (n = n.filter((t) => r.includes(e[t].pathType))), n.map((t) => ({
    encoded: t,
    decoded: e[t].pathType === "file" ? B.toFileSystemPath(t, !0) : t
  }));
}
var Re = {}, M = {};
Object.defineProperty(M, "__esModule", { value: !0 });
M.run = M.sort = M.filter = M.all = void 0;
function ht(e) {
  return Object.keys(e || {}).filter((r) => typeof e[r] == "object").map((r) => (e[r].name = r, e[r]));
}
M.all = ht;
function gt(e, r, n) {
  return e.filter((t) => !!gn(t, r, n));
}
M.filter = gt;
function _t(e) {
  for (const r of e)
    r.order = r.order || Number.MAX_SAFE_INTEGER;
  return e.sort((r, n) => r.order - n.order);
}
M.sort = _t;
async function mt(e, r, n, t) {
  let i, l, o = 0;
  return new Promise((u, a) => {
    f();
    function f() {
      if (i = e[o++], !i)
        return a(l);
      try {
        const g = gn(i, r, n, h, t);
        if (g && typeof g.then == "function")
          g.then(s, p);
        else if (g !== void 0)
          s(g);
        else if (o === e.length)
          throw new Error("No promise has been returned or callback has been called.");
      } catch (g) {
        p(g);
      }
    }
    function h(g, m) {
      g ? p(g) : s(m);
    }
    function s(g) {
      u({
        plugin: i,
        result: g
      });
    }
    function p(g) {
      l = {
        plugin: i,
        error: g
      }, f();
    }
  });
}
M.run = mt;
function gn(e, r, n, t, i) {
  const l = e[r];
  if (typeof l == "function")
    return l.apply(e, [n, t, i]);
  if (!t) {
    if (l instanceof RegExp)
      return l.test(n.url);
    if (typeof l == "string")
      return l === n.extension;
    if (Array.isArray(l))
      return l.indexOf(n.extension) !== -1;
  }
  return l;
}
var vt = _ && _.__createBinding || (Object.create ? function(e, r, n, t) {
  t === void 0 && (t = n);
  var i = Object.getOwnPropertyDescriptor(r, n);
  (!i || ("get" in i ? !r.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return r[n];
  } }), Object.defineProperty(e, t, i);
} : function(e, r, n, t) {
  t === void 0 && (t = n), e[t] = r[n];
}), yt = _ && _.__setModuleDefault || (Object.create ? function(e, r) {
  Object.defineProperty(e, "default", { enumerable: !0, value: r });
} : function(e, r) {
  e.default = r;
}), _n = _ && _.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var r = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && vt(r, e, n);
  return yt(r, e), r;
};
Object.defineProperty(Re, "__esModule", { value: !0 });
const Ge = q, xt = _n(O), H = _n(M), W = A;
async function wt(e, r, n) {
  const t = e.indexOf("#");
  let i = "";
  t >= 0 && (i = e.substring(t), e = e.substring(0, t));
  const l = r._add(e), o = {
    url: e,
    hash: i,
    extension: xt.getExtension(e)
  };
  try {
    const u = await bt(o, n, r);
    l.pathType = u.plugin.name, o.data = u.result;
    const a = await Et(o, n, r);
    return l.value = a.result, a.result;
  } catch (u) {
    throw (0, W.isHandledError)(u) && (l.value = u), u;
  }
}
async function bt(e, r, n) {
  let t = H.all(r.resolve);
  t = H.filter(t, "canRead", e), H.sort(t);
  try {
    return await H.run(t, "read", e, n);
  } catch (i) {
    throw !i && r.continueOnError ? new W.UnmatchedResolverError(e.url) : !i || !("error" in i) ? Ge.ono.syntax(`Unable to resolve $ref pointer "${e.url}"`) : i.error instanceof W.ResolverError ? i.error : new W.ResolverError(i, e.url);
  }
}
async function Et(e, r, n) {
  const t = H.all(r.parse), i = H.filter(t, "canParse", e), l = i.length > 0 ? i : t;
  H.sort(l);
  try {
    const o = await H.run(l, "parse", e, n);
    if (!o.plugin.allowEmpty && Ot(o.result))
      throw Ge.ono.syntax(`Error parsing "${e.url}" as ${o.plugin.name}. 
Parsed value is empty`);
    return o;
  } catch (o) {
    throw !o && r.continueOnError ? new W.UnmatchedParserError(e.url) : o && o.message && o.message.startsWith("Error parsing") ? o : !o || !("error" in o) ? Ge.ono.syntax(`Unable to parse ${e.url}`) : o.error instanceof W.ParserError ? o.error : new W.ParserError(o.error.message, e.url);
  }
}
function Ot(e) {
  return e === void 0 || typeof e == "object" && Object.keys(e).length === 0 || typeof e == "string" && e.trim().length === 0 || Buffer.isBuffer(e) && e.length === 0;
}
Re.default = wt;
var fe = {}, mn = {}, rr = {};
Object.defineProperty(rr, "__esModule", { value: !0 });
const Rr = A;
rr.default = {
  /**
   * The order that this parser will run, in relation to other parsers.
   */
  order: 100,
  /**
   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that match will be tried, in order, until one successfully parses the file.
   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
   * every parser will be tried.
   */
  canParse: ".json",
  /**
   * Allow JSON files with byte order marks (BOM)
   */
  allowBOM: !0,
  /**
   * Parses the given file as JSON
   */
  async parse(e) {
    let r = e.data;
    if (Buffer.isBuffer(r) && (r = r.toString()), typeof r == "string") {
      if (r.trim().length === 0)
        return;
      try {
        return JSON.parse(r);
      } catch (n) {
        if (this.allowBOM)
          try {
            const t = r.indexOf("{");
            return r = r.slice(t), JSON.parse(r);
          } catch (t) {
            throw new Rr.ParserError(t.message, e.url);
          }
        throw new Rr.ParserError(n.message, e.url);
      }
    } else
      return r;
  }
};
var nr = {}, $ = {}, ir = {}, R = {};
function vn(e) {
  return typeof e > "u" || e === null;
}
function At(e) {
  return typeof e == "object" && e !== null;
}
function Pt(e) {
  return Array.isArray(e) ? e : vn(e) ? [] : [e];
}
function St(e, r) {
  var n, t, i, l;
  if (r)
    for (l = Object.keys(r), n = 0, t = l.length; n < t; n += 1)
      i = l[n], e[i] = r[i];
  return e;
}
function $t(e, r) {
  var n = "", t;
  for (t = 0; t < r; t += 1)
    n += e;
  return n;
}
function jt(e) {
  return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
}
R.isNothing = vn;
R.isObject = At;
R.toArray = Pt;
R.repeat = $t;
R.isNegativeZero = jt;
R.extend = St;
function yn(e, r) {
  var n = "", t = e.reason || "(unknown reason)";
  return e.mark ? (e.mark.name && (n += 'in "' + e.mark.name + '" '), n += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")", !r && e.mark.snippet && (n += `

` + e.mark.snippet), t + " " + n) : t;
}
function te(e, r) {
  Error.call(this), this.name = "YAMLException", this.reason = e, this.mark = r, this.message = yn(this, !1), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
}
te.prototype = Object.create(Error.prototype);
te.prototype.constructor = te;
te.prototype.toString = function(r) {
  return this.name + ": " + yn(this, r);
};
var se = te, re = R;
function De(e, r, n, t, i) {
  var l = "", o = "", u = Math.floor(i / 2) - 1;
  return t - r > u && (l = " ... ", r = t - u + l.length), n - t > u && (o = " ...", n = t + u - o.length), {
    str: l + e.slice(r, n).replace(/\t/g, "→") + o,
    pos: t - r + l.length
    // relative position
  };
}
function Ne(e, r) {
  return re.repeat(" ", r - e.length) + e;
}
function Ct(e, r) {
  if (r = Object.create(r || null), !e.buffer)
    return null;
  r.maxLength || (r.maxLength = 79), typeof r.indent != "number" && (r.indent = 1), typeof r.linesBefore != "number" && (r.linesBefore = 3), typeof r.linesAfter != "number" && (r.linesAfter = 2);
  for (var n = /\r?\n|\r|\0/g, t = [0], i = [], l, o = -1; l = n.exec(e.buffer); )
    i.push(l.index), t.push(l.index + l[0].length), e.position <= l.index && o < 0 && (o = t.length - 2);
  o < 0 && (o = t.length - 1);
  var u = "", a, f, h = Math.min(e.line + r.linesAfter, i.length).toString().length, s = r.maxLength - (r.indent + h + 3);
  for (a = 1; a <= r.linesBefore && !(o - a < 0); a++)
    f = De(
      e.buffer,
      t[o - a],
      i[o - a],
      e.position - (t[o] - t[o - a]),
      s
    ), u = re.repeat(" ", r.indent) + Ne((e.line - a + 1).toString(), h) + " | " + f.str + `
` + u;
  for (f = De(e.buffer, t[o], i[o], e.position, s), u += re.repeat(" ", r.indent) + Ne((e.line + 1).toString(), h) + " | " + f.str + `
`, u += re.repeat("-", r.indent + h + 3 + f.pos) + `^
`, a = 1; a <= r.linesAfter && !(o + a >= i.length); a++)
    f = De(
      e.buffer,
      t[o + a],
      i[o + a],
      e.position - (t[o] - t[o + a]),
      s
    ), u += re.repeat(" ", r.indent) + Ne((e.line + a + 1).toString(), h) + " | " + f.str + `
`;
  return u.replace(/\n$/, "");
}
var Tt = Ct, Mr = se, Rt = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
], Mt = [
  "scalar",
  "sequence",
  "mapping"
];
function Ft(e) {
  var r = {};
  return e !== null && Object.keys(e).forEach(function(n) {
    e[n].forEach(function(t) {
      r[String(t)] = n;
    });
  }), r;
}
function It(e, r) {
  if (r = r || {}, Object.keys(r).forEach(function(n) {
    if (Rt.indexOf(n) === -1)
      throw new Mr('Unknown option "' + n + '" is met in definition of "' + e + '" YAML type.');
  }), this.options = r, this.tag = e, this.kind = r.kind || null, this.resolve = r.resolve || function() {
    return !0;
  }, this.construct = r.construct || function(n) {
    return n;
  }, this.instanceOf = r.instanceOf || null, this.predicate = r.predicate || null, this.represent = r.represent || null, this.representName = r.representName || null, this.defaultStyle = r.defaultStyle || null, this.multi = r.multi || !1, this.styleAliases = Ft(r.styleAliases || null), Mt.indexOf(this.kind) === -1)
    throw new Mr('Unknown kind "' + this.kind + '" is specified for "' + e + '" YAML type.');
}
var C = It, ee = se, Le = C;
function Fr(e, r) {
  var n = [];
  return e[r].forEach(function(t) {
    var i = n.length;
    n.forEach(function(l, o) {
      l.tag === t.tag && l.kind === t.kind && l.multi === t.multi && (i = o);
    }), n[i] = t;
  }), n;
}
function Dt() {
  var e = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, r, n;
  function t(i) {
    i.multi ? (e.multi[i.kind].push(i), e.multi.fallback.push(i)) : e[i.kind][i.tag] = e.fallback[i.tag] = i;
  }
  for (r = 0, n = arguments.length; r < n; r += 1)
    arguments[r].forEach(t);
  return e;
}
function We(e) {
  return this.extend(e);
}
We.prototype.extend = function(r) {
  var n = [], t = [];
  if (r instanceof Le)
    t.push(r);
  else if (Array.isArray(r))
    t = t.concat(r);
  else if (r && (Array.isArray(r.implicit) || Array.isArray(r.explicit)))
    r.implicit && (n = n.concat(r.implicit)), r.explicit && (t = t.concat(r.explicit));
  else
    throw new ee("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  n.forEach(function(l) {
    if (!(l instanceof Le))
      throw new ee("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    if (l.loadKind && l.loadKind !== "scalar")
      throw new ee("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    if (l.multi)
      throw new ee("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
  }), t.forEach(function(l) {
    if (!(l instanceof Le))
      throw new ee("Specified list of YAML types (or a single Type object) contains a non-Type object.");
  });
  var i = Object.create(We.prototype);
  return i.implicit = (this.implicit || []).concat(n), i.explicit = (this.explicit || []).concat(t), i.compiledImplicit = Fr(i, "implicit"), i.compiledExplicit = Fr(i, "explicit"), i.compiledTypeMap = Dt(i.compiledImplicit, i.compiledExplicit), i;
};
var xn = We, Nt = C, wn = new Nt("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(e) {
    return e !== null ? e : "";
  }
}), Lt = C, bn = new Lt("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(e) {
    return e !== null ? e : [];
  }
}), Bt = C, En = new Bt("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(e) {
    return e !== null ? e : {};
  }
}), Ht = xn, On = new Ht({
  explicit: [
    wn,
    bn,
    En
  ]
}), kt = C;
function Ut(e) {
  if (e === null)
    return !0;
  var r = e.length;
  return r === 1 && e === "~" || r === 4 && (e === "null" || e === "Null" || e === "NULL");
}
function Yt() {
  return null;
}
function Gt(e) {
  return e === null;
}
var An = new kt("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: Ut,
  construct: Yt,
  predicate: Gt,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
}), Wt = C;
function Jt(e) {
  if (e === null)
    return !1;
  var r = e.length;
  return r === 4 && (e === "true" || e === "True" || e === "TRUE") || r === 5 && (e === "false" || e === "False" || e === "FALSE");
}
function qt(e) {
  return e === "true" || e === "True" || e === "TRUE";
}
function Kt(e) {
  return Object.prototype.toString.call(e) === "[object Boolean]";
}
var Pn = new Wt("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: Jt,
  construct: qt,
  predicate: Kt,
  represent: {
    lowercase: function(e) {
      return e ? "true" : "false";
    },
    uppercase: function(e) {
      return e ? "TRUE" : "FALSE";
    },
    camelcase: function(e) {
      return e ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
}), zt = R, Qt = C;
function Vt(e) {
  return 48 <= e && e <= 57 || 65 <= e && e <= 70 || 97 <= e && e <= 102;
}
function Xt(e) {
  return 48 <= e && e <= 55;
}
function Zt(e) {
  return 48 <= e && e <= 57;
}
function eo(e) {
  if (e === null)
    return !1;
  var r = e.length, n = 0, t = !1, i;
  if (!r)
    return !1;
  if (i = e[n], (i === "-" || i === "+") && (i = e[++n]), i === "0") {
    if (n + 1 === r)
      return !0;
    if (i = e[++n], i === "b") {
      for (n++; n < r; n++)
        if (i = e[n], i !== "_") {
          if (i !== "0" && i !== "1")
            return !1;
          t = !0;
        }
      return t && i !== "_";
    }
    if (i === "x") {
      for (n++; n < r; n++)
        if (i = e[n], i !== "_") {
          if (!Vt(e.charCodeAt(n)))
            return !1;
          t = !0;
        }
      return t && i !== "_";
    }
    if (i === "o") {
      for (n++; n < r; n++)
        if (i = e[n], i !== "_") {
          if (!Xt(e.charCodeAt(n)))
            return !1;
          t = !0;
        }
      return t && i !== "_";
    }
  }
  if (i === "_")
    return !1;
  for (; n < r; n++)
    if (i = e[n], i !== "_") {
      if (!Zt(e.charCodeAt(n)))
        return !1;
      t = !0;
    }
  return !(!t || i === "_");
}
function ro(e) {
  var r = e, n = 1, t;
  if (r.indexOf("_") !== -1 && (r = r.replace(/_/g, "")), t = r[0], (t === "-" || t === "+") && (t === "-" && (n = -1), r = r.slice(1), t = r[0]), r === "0")
    return 0;
  if (t === "0") {
    if (r[1] === "b")
      return n * parseInt(r.slice(2), 2);
    if (r[1] === "x")
      return n * parseInt(r.slice(2), 16);
    if (r[1] === "o")
      return n * parseInt(r.slice(2), 8);
  }
  return n * parseInt(r, 10);
}
function no(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && e % 1 === 0 && !zt.isNegativeZero(e);
}
var Sn = new Qt("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: eo,
  construct: ro,
  predicate: no,
  represent: {
    binary: function(e) {
      return e >= 0 ? "0b" + e.toString(2) : "-0b" + e.toString(2).slice(1);
    },
    octal: function(e) {
      return e >= 0 ? "0o" + e.toString(8) : "-0o" + e.toString(8).slice(1);
    },
    decimal: function(e) {
      return e.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(e) {
      return e >= 0 ? "0x" + e.toString(16).toUpperCase() : "-0x" + e.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
}), $n = R, io = C, to = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function oo(e) {
  return !(e === null || !to.test(e) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  e[e.length - 1] === "_");
}
function lo(e) {
  var r, n;
  return r = e.replace(/_/g, "").toLowerCase(), n = r[0] === "-" ? -1 : 1, "+-".indexOf(r[0]) >= 0 && (r = r.slice(1)), r === ".inf" ? n === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : r === ".nan" ? NaN : n * parseFloat(r, 10);
}
var uo = /^[-+]?[0-9]+e/;
function ao(e, r) {
  var n;
  if (isNaN(e))
    switch (r) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  else if (Number.POSITIVE_INFINITY === e)
    switch (r) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  else if (Number.NEGATIVE_INFINITY === e)
    switch (r) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  else if ($n.isNegativeZero(e))
    return "-0.0";
  return n = e.toString(10), uo.test(n) ? n.replace("e", ".e") : n;
}
function co(e) {
  return Object.prototype.toString.call(e) === "[object Number]" && (e % 1 !== 0 || $n.isNegativeZero(e));
}
var jn = new io("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: oo,
  construct: lo,
  predicate: co,
  represent: ao,
  defaultStyle: "lowercase"
}), Cn = On.extend({
  implicit: [
    An,
    Pn,
    Sn,
    jn
  ]
}), Tn = Cn, fo = C, Rn = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
), Mn = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function so(e) {
  return e === null ? !1 : Rn.exec(e) !== null || Mn.exec(e) !== null;
}
function po(e) {
  var r, n, t, i, l, o, u, a = 0, f = null, h, s, p;
  if (r = Rn.exec(e), r === null && (r = Mn.exec(e)), r === null)
    throw new Error("Date resolve error");
  if (n = +r[1], t = +r[2] - 1, i = +r[3], !r[4])
    return new Date(Date.UTC(n, t, i));
  if (l = +r[4], o = +r[5], u = +r[6], r[7]) {
    for (a = r[7].slice(0, 3); a.length < 3; )
      a += "0";
    a = +a;
  }
  return r[9] && (h = +r[10], s = +(r[11] || 0), f = (h * 60 + s) * 6e4, r[9] === "-" && (f = -f)), p = new Date(Date.UTC(n, t, i, l, o, u, a)), f && p.setTime(p.getTime() - f), p;
}
function ho(e) {
  return e.toISOString();
}
var Fn = new fo("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: so,
  construct: po,
  instanceOf: Date,
  represent: ho
}), go = C;
function _o(e) {
  return e === "<<" || e === null;
}
var In = new go("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: _o
}), mo = C, tr = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function vo(e) {
  if (e === null)
    return !1;
  var r, n, t = 0, i = e.length, l = tr;
  for (n = 0; n < i; n++)
    if (r = l.indexOf(e.charAt(n)), !(r > 64)) {
      if (r < 0)
        return !1;
      t += 6;
    }
  return t % 8 === 0;
}
function yo(e) {
  var r, n, t = e.replace(/[\r\n=]/g, ""), i = t.length, l = tr, o = 0, u = [];
  for (r = 0; r < i; r++)
    r % 4 === 0 && r && (u.push(o >> 16 & 255), u.push(o >> 8 & 255), u.push(o & 255)), o = o << 6 | l.indexOf(t.charAt(r));
  return n = i % 4 * 6, n === 0 ? (u.push(o >> 16 & 255), u.push(o >> 8 & 255), u.push(o & 255)) : n === 18 ? (u.push(o >> 10 & 255), u.push(o >> 2 & 255)) : n === 12 && u.push(o >> 4 & 255), new Uint8Array(u);
}
function xo(e) {
  var r = "", n = 0, t, i, l = e.length, o = tr;
  for (t = 0; t < l; t++)
    t % 3 === 0 && t && (r += o[n >> 18 & 63], r += o[n >> 12 & 63], r += o[n >> 6 & 63], r += o[n & 63]), n = (n << 8) + e[t];
  return i = l % 3, i === 0 ? (r += o[n >> 18 & 63], r += o[n >> 12 & 63], r += o[n >> 6 & 63], r += o[n & 63]) : i === 2 ? (r += o[n >> 10 & 63], r += o[n >> 4 & 63], r += o[n << 2 & 63], r += o[64]) : i === 1 && (r += o[n >> 2 & 63], r += o[n << 4 & 63], r += o[64], r += o[64]), r;
}
function wo(e) {
  return Object.prototype.toString.call(e) === "[object Uint8Array]";
}
var Dn = new mo("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: vo,
  construct: yo,
  predicate: wo,
  represent: xo
}), bo = C, Eo = Object.prototype.hasOwnProperty, Oo = Object.prototype.toString;
function Ao(e) {
  if (e === null)
    return !0;
  var r = [], n, t, i, l, o, u = e;
  for (n = 0, t = u.length; n < t; n += 1) {
    if (i = u[n], o = !1, Oo.call(i) !== "[object Object]")
      return !1;
    for (l in i)
      if (Eo.call(i, l))
        if (!o)
          o = !0;
        else
          return !1;
    if (!o)
      return !1;
    if (r.indexOf(l) === -1)
      r.push(l);
    else
      return !1;
  }
  return !0;
}
function Po(e) {
  return e !== null ? e : [];
}
var Nn = new bo("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: Ao,
  construct: Po
}), So = C, $o = Object.prototype.toString;
function jo(e) {
  if (e === null)
    return !0;
  var r, n, t, i, l, o = e;
  for (l = new Array(o.length), r = 0, n = o.length; r < n; r += 1) {
    if (t = o[r], $o.call(t) !== "[object Object]" || (i = Object.keys(t), i.length !== 1))
      return !1;
    l[r] = [i[0], t[i[0]]];
  }
  return !0;
}
function Co(e) {
  if (e === null)
    return [];
  var r, n, t, i, l, o = e;
  for (l = new Array(o.length), r = 0, n = o.length; r < n; r += 1)
    t = o[r], i = Object.keys(t), l[r] = [i[0], t[i[0]]];
  return l;
}
var Ln = new So("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: jo,
  construct: Co
}), To = C, Ro = Object.prototype.hasOwnProperty;
function Mo(e) {
  if (e === null)
    return !0;
  var r, n = e;
  for (r in n)
    if (Ro.call(n, r) && n[r] !== null)
      return !1;
  return !0;
}
function Fo(e) {
  return e !== null ? e : {};
}
var Bn = new To("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: Mo,
  construct: Fo
}), or = Tn.extend({
  implicit: [
    Fn,
    In
  ],
  explicit: [
    Dn,
    Nn,
    Ln,
    Bn
  ]
}), G = R, Hn = se, Io = Tt, Do = or, U = Object.prototype.hasOwnProperty, xe = 1, kn = 2, Un = 3, we = 4, Be = 1, No = 2, Ir = 3, Lo = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, Bo = /[\x85\u2028\u2029]/, Ho = /[,\[\]\{\}]/, Yn = /^(?:!|!!|![a-z\-]+!)$/i, Gn = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function Dr(e) {
  return Object.prototype.toString.call(e);
}
function F(e) {
  return e === 10 || e === 13;
}
function J(e) {
  return e === 9 || e === 32;
}
function T(e) {
  return e === 9 || e === 32 || e === 10 || e === 13;
}
function V(e) {
  return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
}
function ko(e) {
  var r;
  return 48 <= e && e <= 57 ? e - 48 : (r = e | 32, 97 <= r && r <= 102 ? r - 97 + 10 : -1);
}
function Uo(e) {
  return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
}
function Yo(e) {
  return 48 <= e && e <= 57 ? e - 48 : -1;
}
function Nr(e) {
  return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? " " : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
}
function Go(e) {
  return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
    (e - 65536 >> 10) + 55296,
    (e - 65536 & 1023) + 56320
  );
}
var Wn = new Array(256), Jn = new Array(256);
for (var K = 0; K < 256; K++)
  Wn[K] = Nr(K) ? 1 : 0, Jn[K] = Nr(K);
function Wo(e, r) {
  this.input = e, this.filename = r.filename || null, this.schema = r.schema || Do, this.onWarning = r.onWarning || null, this.legacy = r.legacy || !1, this.json = r.json || !1, this.listener = r.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.firstTabInLine = -1, this.documents = [];
}
function qn(e, r) {
  var n = {
    name: e.filename,
    buffer: e.input.slice(0, -1),
    // omit trailing \0
    position: e.position,
    line: e.line,
    column: e.position - e.lineStart
  };
  return n.snippet = Io(n), new Hn(r, n);
}
function w(e, r) {
  throw qn(e, r);
}
function be(e, r) {
  e.onWarning && e.onWarning.call(null, qn(e, r));
}
var Lr = {
  YAML: function(r, n, t) {
    var i, l, o;
    r.version !== null && w(r, "duplication of %YAML directive"), t.length !== 1 && w(r, "YAML directive accepts exactly one argument"), i = /^([0-9]+)\.([0-9]+)$/.exec(t[0]), i === null && w(r, "ill-formed argument of the YAML directive"), l = parseInt(i[1], 10), o = parseInt(i[2], 10), l !== 1 && w(r, "unacceptable YAML version of the document"), r.version = t[0], r.checkLineBreaks = o < 2, o !== 1 && o !== 2 && be(r, "unsupported YAML version of the document");
  },
  TAG: function(r, n, t) {
    var i, l;
    t.length !== 2 && w(r, "TAG directive accepts exactly two arguments"), i = t[0], l = t[1], Yn.test(i) || w(r, "ill-formed tag handle (first argument) of the TAG directive"), U.call(r.tagMap, i) && w(r, 'there is a previously declared suffix for "' + i + '" tag handle'), Gn.test(l) || w(r, "ill-formed tag prefix (second argument) of the TAG directive");
    try {
      l = decodeURIComponent(l);
    } catch {
      w(r, "tag prefix is malformed: " + l);
    }
    r.tagMap[i] = l;
  }
};
function k(e, r, n, t) {
  var i, l, o, u;
  if (r < n) {
    if (u = e.input.slice(r, n), t)
      for (i = 0, l = u.length; i < l; i += 1)
        o = u.charCodeAt(i), o === 9 || 32 <= o && o <= 1114111 || w(e, "expected valid JSON character");
    else
      Lo.test(u) && w(e, "the stream contains non-printable characters");
    e.result += u;
  }
}
function Br(e, r, n, t) {
  var i, l, o, u;
  for (G.isObject(n) || w(e, "cannot merge mappings; the provided source object is unacceptable"), i = Object.keys(n), o = 0, u = i.length; o < u; o += 1)
    l = i[o], U.call(r, l) || (r[l] = n[l], t[l] = !0);
}
function X(e, r, n, t, i, l, o, u, a) {
  var f, h;
  if (Array.isArray(i))
    for (i = Array.prototype.slice.call(i), f = 0, h = i.length; f < h; f += 1)
      Array.isArray(i[f]) && w(e, "nested arrays are not supported inside keys"), typeof i == "object" && Dr(i[f]) === "[object Object]" && (i[f] = "[object Object]");
  if (typeof i == "object" && Dr(i) === "[object Object]" && (i = "[object Object]"), i = String(i), r === null && (r = {}), t === "tag:yaml.org,2002:merge")
    if (Array.isArray(l))
      for (f = 0, h = l.length; f < h; f += 1)
        Br(e, r, l[f], n);
    else
      Br(e, r, l, n);
  else
    !e.json && !U.call(n, i) && U.call(r, i) && (e.line = o || e.line, e.lineStart = u || e.lineStart, e.position = a || e.position, w(e, "duplicated mapping key")), i === "__proto__" ? Object.defineProperty(r, i, {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value: l
    }) : r[i] = l, delete n[i];
  return r;
}
function lr(e) {
  var r;
  r = e.input.charCodeAt(e.position), r === 10 ? e.position++ : r === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : w(e, "a line break is expected"), e.line += 1, e.lineStart = e.position, e.firstTabInLine = -1;
}
function S(e, r, n) {
  for (var t = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
    for (; J(i); )
      i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position), i = e.input.charCodeAt(++e.position);
    if (r && i === 35)
      do
        i = e.input.charCodeAt(++e.position);
      while (i !== 10 && i !== 13 && i !== 0);
    if (F(i))
      for (lr(e), i = e.input.charCodeAt(e.position), t++, e.lineIndent = 0; i === 32; )
        e.lineIndent++, i = e.input.charCodeAt(++e.position);
    else
      break;
  }
  return n !== -1 && t !== 0 && e.lineIndent < n && be(e, "deficient indentation"), t;
}
function Me(e) {
  var r = e.position, n;
  return n = e.input.charCodeAt(r), !!((n === 45 || n === 46) && n === e.input.charCodeAt(r + 1) && n === e.input.charCodeAt(r + 2) && (r += 3, n = e.input.charCodeAt(r), n === 0 || T(n)));
}
function ur(e, r) {
  r === 1 ? e.result += " " : r > 1 && (e.result += G.repeat(`
`, r - 1));
}
function Jo(e, r, n) {
  var t, i, l, o, u, a, f, h, s = e.kind, p = e.result, g;
  if (g = e.input.charCodeAt(e.position), T(g) || V(g) || g === 35 || g === 38 || g === 42 || g === 33 || g === 124 || g === 62 || g === 39 || g === 34 || g === 37 || g === 64 || g === 96 || (g === 63 || g === 45) && (i = e.input.charCodeAt(e.position + 1), T(i) || n && V(i)))
    return !1;
  for (e.kind = "scalar", e.result = "", l = o = e.position, u = !1; g !== 0; ) {
    if (g === 58) {
      if (i = e.input.charCodeAt(e.position + 1), T(i) || n && V(i))
        break;
    } else if (g === 35) {
      if (t = e.input.charCodeAt(e.position - 1), T(t))
        break;
    } else {
      if (e.position === e.lineStart && Me(e) || n && V(g))
        break;
      if (F(g))
        if (a = e.line, f = e.lineStart, h = e.lineIndent, S(e, !1, -1), e.lineIndent >= r) {
          u = !0, g = e.input.charCodeAt(e.position);
          continue;
        } else {
          e.position = o, e.line = a, e.lineStart = f, e.lineIndent = h;
          break;
        }
    }
    u && (k(e, l, o, !1), ur(e, e.line - a), l = o = e.position, u = !1), J(g) || (o = e.position + 1), g = e.input.charCodeAt(++e.position);
  }
  return k(e, l, o, !1), e.result ? !0 : (e.kind = s, e.result = p, !1);
}
function qo(e, r) {
  var n, t, i;
  if (n = e.input.charCodeAt(e.position), n !== 39)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, t = i = e.position; (n = e.input.charCodeAt(e.position)) !== 0; )
    if (n === 39)
      if (k(e, t, e.position, !0), n = e.input.charCodeAt(++e.position), n === 39)
        t = e.position, e.position++, i = e.position;
      else
        return !0;
    else
      F(n) ? (k(e, t, i, !0), ur(e, S(e, !1, r)), t = i = e.position) : e.position === e.lineStart && Me(e) ? w(e, "unexpected end of the document within a single quoted scalar") : (e.position++, i = e.position);
  w(e, "unexpected end of the stream within a single quoted scalar");
}
function Ko(e, r) {
  var n, t, i, l, o, u;
  if (u = e.input.charCodeAt(e.position), u !== 34)
    return !1;
  for (e.kind = "scalar", e.result = "", e.position++, n = t = e.position; (u = e.input.charCodeAt(e.position)) !== 0; ) {
    if (u === 34)
      return k(e, n, e.position, !0), e.position++, !0;
    if (u === 92) {
      if (k(e, n, e.position, !0), u = e.input.charCodeAt(++e.position), F(u))
        S(e, !1, r);
      else if (u < 256 && Wn[u])
        e.result += Jn[u], e.position++;
      else if ((o = Uo(u)) > 0) {
        for (i = o, l = 0; i > 0; i--)
          u = e.input.charCodeAt(++e.position), (o = ko(u)) >= 0 ? l = (l << 4) + o : w(e, "expected hexadecimal character");
        e.result += Go(l), e.position++;
      } else
        w(e, "unknown escape sequence");
      n = t = e.position;
    } else
      F(u) ? (k(e, n, t, !0), ur(e, S(e, !1, r)), n = t = e.position) : e.position === e.lineStart && Me(e) ? w(e, "unexpected end of the document within a double quoted scalar") : (e.position++, t = e.position);
  }
  w(e, "unexpected end of the stream within a double quoted scalar");
}
function zo(e, r) {
  var n = !0, t, i, l, o = e.tag, u, a = e.anchor, f, h, s, p, g, m = /* @__PURE__ */ Object.create(null), y, b, d, c;
  if (c = e.input.charCodeAt(e.position), c === 91)
    h = 93, g = !1, u = [];
  else if (c === 123)
    h = 125, g = !0, u = {};
  else
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = u), c = e.input.charCodeAt(++e.position); c !== 0; ) {
    if (S(e, !0, r), c = e.input.charCodeAt(e.position), c === h)
      return e.position++, e.tag = o, e.anchor = a, e.kind = g ? "mapping" : "sequence", e.result = u, !0;
    n ? c === 44 && w(e, "expected the node content, but found ','") : w(e, "missed comma between flow collection entries"), b = y = d = null, s = p = !1, c === 63 && (f = e.input.charCodeAt(e.position + 1), T(f) && (s = p = !0, e.position++, S(e, !0, r))), t = e.line, i = e.lineStart, l = e.position, Z(e, r, xe, !1, !0), b = e.tag, y = e.result, S(e, !0, r), c = e.input.charCodeAt(e.position), (p || e.line === t) && c === 58 && (s = !0, c = e.input.charCodeAt(++e.position), S(e, !0, r), Z(e, r, xe, !1, !0), d = e.result), g ? X(e, u, m, b, y, d, t, i, l) : s ? u.push(X(e, null, m, b, y, d, t, i, l)) : u.push(y), S(e, !0, r), c = e.input.charCodeAt(e.position), c === 44 ? (n = !0, c = e.input.charCodeAt(++e.position)) : n = !1;
  }
  w(e, "unexpected end of the stream within a flow collection");
}
function Qo(e, r) {
  var n, t, i = Be, l = !1, o = !1, u = r, a = 0, f = !1, h, s;
  if (s = e.input.charCodeAt(e.position), s === 124)
    t = !1;
  else if (s === 62)
    t = !0;
  else
    return !1;
  for (e.kind = "scalar", e.result = ""; s !== 0; )
    if (s = e.input.charCodeAt(++e.position), s === 43 || s === 45)
      Be === i ? i = s === 43 ? Ir : No : w(e, "repeat of a chomping mode identifier");
    else if ((h = Yo(s)) >= 0)
      h === 0 ? w(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : o ? w(e, "repeat of an indentation width identifier") : (u = r + h - 1, o = !0);
    else
      break;
  if (J(s)) {
    do
      s = e.input.charCodeAt(++e.position);
    while (J(s));
    if (s === 35)
      do
        s = e.input.charCodeAt(++e.position);
      while (!F(s) && s !== 0);
  }
  for (; s !== 0; ) {
    for (lr(e), e.lineIndent = 0, s = e.input.charCodeAt(e.position); (!o || e.lineIndent < u) && s === 32; )
      e.lineIndent++, s = e.input.charCodeAt(++e.position);
    if (!o && e.lineIndent > u && (u = e.lineIndent), F(s)) {
      a++;
      continue;
    }
    if (e.lineIndent < u) {
      i === Ir ? e.result += G.repeat(`
`, l ? 1 + a : a) : i === Be && l && (e.result += `
`);
      break;
    }
    for (t ? J(s) ? (f = !0, e.result += G.repeat(`
`, l ? 1 + a : a)) : f ? (f = !1, e.result += G.repeat(`
`, a + 1)) : a === 0 ? l && (e.result += " ") : e.result += G.repeat(`
`, a) : e.result += G.repeat(`
`, l ? 1 + a : a), l = !0, o = !0, a = 0, n = e.position; !F(s) && s !== 0; )
      s = e.input.charCodeAt(++e.position);
    k(e, n, e.position, !1);
  }
  return !0;
}
function Hr(e, r) {
  var n, t = e.tag, i = e.anchor, l = [], o, u = !1, a;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = l), a = e.input.charCodeAt(e.position); a !== 0 && (e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, w(e, "tab characters must not be used in indentation")), !(a !== 45 || (o = e.input.charCodeAt(e.position + 1), !T(o)))); ) {
    if (u = !0, e.position++, S(e, !0, -1) && e.lineIndent <= r) {
      l.push(null), a = e.input.charCodeAt(e.position);
      continue;
    }
    if (n = e.line, Z(e, r, Un, !1, !0), l.push(e.result), S(e, !0, -1), a = e.input.charCodeAt(e.position), (e.line === n || e.lineIndent > r) && a !== 0)
      w(e, "bad indentation of a sequence entry");
    else if (e.lineIndent < r)
      break;
  }
  return u ? (e.tag = t, e.anchor = i, e.kind = "sequence", e.result = l, !0) : !1;
}
function Vo(e, r, n) {
  var t, i, l, o, u, a, f = e.tag, h = e.anchor, s = {}, p = /* @__PURE__ */ Object.create(null), g = null, m = null, y = null, b = !1, d = !1, c;
  if (e.firstTabInLine !== -1)
    return !1;
  for (e.anchor !== null && (e.anchorMap[e.anchor] = s), c = e.input.charCodeAt(e.position); c !== 0; ) {
    if (!b && e.firstTabInLine !== -1 && (e.position = e.firstTabInLine, w(e, "tab characters must not be used in indentation")), t = e.input.charCodeAt(e.position + 1), l = e.line, (c === 63 || c === 58) && T(t))
      c === 63 ? (b && (X(e, s, p, g, m, null, o, u, a), g = m = y = null), d = !0, b = !0, i = !0) : b ? (b = !1, i = !0) : w(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, c = t;
    else {
      if (o = e.line, u = e.lineStart, a = e.position, !Z(e, n, kn, !1, !0))
        break;
      if (e.line === l) {
        for (c = e.input.charCodeAt(e.position); J(c); )
          c = e.input.charCodeAt(++e.position);
        if (c === 58)
          c = e.input.charCodeAt(++e.position), T(c) || w(e, "a whitespace character is expected after the key-value separator within a block mapping"), b && (X(e, s, p, g, m, null, o, u, a), g = m = y = null), d = !0, b = !1, i = !1, g = e.tag, m = e.result;
        else if (d)
          w(e, "can not read an implicit mapping pair; a colon is missed");
        else
          return e.tag = f, e.anchor = h, !0;
      } else if (d)
        w(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
      else
        return e.tag = f, e.anchor = h, !0;
    }
    if ((e.line === l || e.lineIndent > r) && (b && (o = e.line, u = e.lineStart, a = e.position), Z(e, r, we, !0, i) && (b ? m = e.result : y = e.result), b || (X(e, s, p, g, m, y, o, u, a), g = m = y = null), S(e, !0, -1), c = e.input.charCodeAt(e.position)), (e.line === l || e.lineIndent > r) && c !== 0)
      w(e, "bad indentation of a mapping entry");
    else if (e.lineIndent < r)
      break;
  }
  return b && X(e, s, p, g, m, null, o, u, a), d && (e.tag = f, e.anchor = h, e.kind = "mapping", e.result = s), d;
}
function Xo(e) {
  var r, n = !1, t = !1, i, l, o;
  if (o = e.input.charCodeAt(e.position), o !== 33)
    return !1;
  if (e.tag !== null && w(e, "duplication of a tag property"), o = e.input.charCodeAt(++e.position), o === 60 ? (n = !0, o = e.input.charCodeAt(++e.position)) : o === 33 ? (t = !0, i = "!!", o = e.input.charCodeAt(++e.position)) : i = "!", r = e.position, n) {
    do
      o = e.input.charCodeAt(++e.position);
    while (o !== 0 && o !== 62);
    e.position < e.length ? (l = e.input.slice(r, e.position), o = e.input.charCodeAt(++e.position)) : w(e, "unexpected end of the stream within a verbatim tag");
  } else {
    for (; o !== 0 && !T(o); )
      o === 33 && (t ? w(e, "tag suffix cannot contain exclamation marks") : (i = e.input.slice(r - 1, e.position + 1), Yn.test(i) || w(e, "named tag handle cannot contain such characters"), t = !0, r = e.position + 1)), o = e.input.charCodeAt(++e.position);
    l = e.input.slice(r, e.position), Ho.test(l) && w(e, "tag suffix cannot contain flow indicator characters");
  }
  l && !Gn.test(l) && w(e, "tag name cannot contain such characters: " + l);
  try {
    l = decodeURIComponent(l);
  } catch {
    w(e, "tag name is malformed: " + l);
  }
  return n ? e.tag = l : U.call(e.tagMap, i) ? e.tag = e.tagMap[i] + l : i === "!" ? e.tag = "!" + l : i === "!!" ? e.tag = "tag:yaml.org,2002:" + l : w(e, 'undeclared tag handle "' + i + '"'), !0;
}
function Zo(e) {
  var r, n;
  if (n = e.input.charCodeAt(e.position), n !== 38)
    return !1;
  for (e.anchor !== null && w(e, "duplication of an anchor property"), n = e.input.charCodeAt(++e.position), r = e.position; n !== 0 && !T(n) && !V(n); )
    n = e.input.charCodeAt(++e.position);
  return e.position === r && w(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(r, e.position), !0;
}
function el(e) {
  var r, n, t;
  if (t = e.input.charCodeAt(e.position), t !== 42)
    return !1;
  for (t = e.input.charCodeAt(++e.position), r = e.position; t !== 0 && !T(t) && !V(t); )
    t = e.input.charCodeAt(++e.position);
  return e.position === r && w(e, "name of an alias node must contain at least one character"), n = e.input.slice(r, e.position), U.call(e.anchorMap, n) || w(e, 'unidentified alias "' + n + '"'), e.result = e.anchorMap[n], S(e, !0, -1), !0;
}
function Z(e, r, n, t, i) {
  var l, o, u, a = 1, f = !1, h = !1, s, p, g, m, y, b;
  if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, l = o = u = we === n || Un === n, t && S(e, !0, -1) && (f = !0, e.lineIndent > r ? a = 1 : e.lineIndent === r ? a = 0 : e.lineIndent < r && (a = -1)), a === 1)
    for (; Xo(e) || Zo(e); )
      S(e, !0, -1) ? (f = !0, u = l, e.lineIndent > r ? a = 1 : e.lineIndent === r ? a = 0 : e.lineIndent < r && (a = -1)) : u = !1;
  if (u && (u = f || i), (a === 1 || we === n) && (xe === n || kn === n ? y = r : y = r + 1, b = e.position - e.lineStart, a === 1 ? u && (Hr(e, b) || Vo(e, b, y)) || zo(e, y) ? h = !0 : (o && Qo(e, y) || qo(e, y) || Ko(e, y) ? h = !0 : el(e) ? (h = !0, (e.tag !== null || e.anchor !== null) && w(e, "alias node should not have any properties")) : Jo(e, y, xe === n) && (h = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : a === 0 && (h = u && Hr(e, b))), e.tag === null)
    e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
  else if (e.tag === "?") {
    for (e.result !== null && e.kind !== "scalar" && w(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), s = 0, p = e.implicitTypes.length; s < p; s += 1)
      if (m = e.implicitTypes[s], m.resolve(e.result)) {
        e.result = m.construct(e.result), e.tag = m.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
        break;
      }
  } else if (e.tag !== "!") {
    if (U.call(e.typeMap[e.kind || "fallback"], e.tag))
      m = e.typeMap[e.kind || "fallback"][e.tag];
    else
      for (m = null, g = e.typeMap.multi[e.kind || "fallback"], s = 0, p = g.length; s < p; s += 1)
        if (e.tag.slice(0, g[s].tag.length) === g[s].tag) {
          m = g[s];
          break;
        }
    m || w(e, "unknown tag !<" + e.tag + ">"), e.result !== null && m.kind !== e.kind && w(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + m.kind + '", not "' + e.kind + '"'), m.resolve(e.result, e.tag) ? (e.result = m.construct(e.result, e.tag), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : w(e, "cannot resolve a node with !<" + e.tag + "> explicit tag");
  }
  return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || h;
}
function rl(e) {
  var r = e.position, n, t, i, l = !1, o;
  for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = /* @__PURE__ */ Object.create(null), e.anchorMap = /* @__PURE__ */ Object.create(null); (o = e.input.charCodeAt(e.position)) !== 0 && (S(e, !0, -1), o = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || o !== 37)); ) {
    for (l = !0, o = e.input.charCodeAt(++e.position), n = e.position; o !== 0 && !T(o); )
      o = e.input.charCodeAt(++e.position);
    for (t = e.input.slice(n, e.position), i = [], t.length < 1 && w(e, "directive name must not be less than one character in length"); o !== 0; ) {
      for (; J(o); )
        o = e.input.charCodeAt(++e.position);
      if (o === 35) {
        do
          o = e.input.charCodeAt(++e.position);
        while (o !== 0 && !F(o));
        break;
      }
      if (F(o))
        break;
      for (n = e.position; o !== 0 && !T(o); )
        o = e.input.charCodeAt(++e.position);
      i.push(e.input.slice(n, e.position));
    }
    o !== 0 && lr(e), U.call(Lr, t) ? Lr[t](e, t, i) : be(e, 'unknown document directive "' + t + '"');
  }
  if (S(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, S(e, !0, -1)) : l && w(e, "directives end mark is expected"), Z(e, e.lineIndent - 1, we, !1, !0), S(e, !0, -1), e.checkLineBreaks && Bo.test(e.input.slice(r, e.position)) && be(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && Me(e)) {
    e.input.charCodeAt(e.position) === 46 && (e.position += 3, S(e, !0, -1));
    return;
  }
  if (e.position < e.length - 1)
    w(e, "end of the stream or a document separator is expected");
  else
    return;
}
function Kn(e, r) {
  e = String(e), r = r || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
  var n = new Wo(e, r), t = e.indexOf("\0");
  for (t !== -1 && (n.position = t, w(n, "null byte is not allowed in input")), n.input += "\0"; n.input.charCodeAt(n.position) === 32; )
    n.lineIndent += 1, n.position += 1;
  for (; n.position < n.length - 1; )
    rl(n);
  return n.documents;
}
function nl(e, r, n) {
  r !== null && typeof r == "object" && typeof n > "u" && (n = r, r = null);
  var t = Kn(e, n);
  if (typeof r != "function")
    return t;
  for (var i = 0, l = t.length; i < l; i += 1)
    r(t[i]);
}
function il(e, r) {
  var n = Kn(e, r);
  if (n.length !== 0) {
    if (n.length === 1)
      return n[0];
    throw new Hn("expected a single document in the stream, but found more");
  }
}
ir.loadAll = nl;
ir.load = il;
var zn = {}, Fe = R, de = se, tl = or, Qn = Object.prototype.toString, Vn = Object.prototype.hasOwnProperty, ar = 65279, ol = 9, oe = 10, ll = 13, ul = 32, al = 33, cl = 34, Je = 35, fl = 37, sl = 38, dl = 39, pl = 42, Xn = 44, hl = 45, Ee = 58, gl = 61, _l = 62, ml = 63, vl = 64, Zn = 91, ei = 93, yl = 96, ri = 123, xl = 124, ni = 125, j = {};
j[0] = "\\0";
j[7] = "\\a";
j[8] = "\\b";
j[9] = "\\t";
j[10] = "\\n";
j[11] = "\\v";
j[12] = "\\f";
j[13] = "\\r";
j[27] = "\\e";
j[34] = '\\"';
j[92] = "\\\\";
j[133] = "\\N";
j[160] = "\\_";
j[8232] = "\\L";
j[8233] = "\\P";
var wl = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
], bl = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function El(e, r) {
  var n, t, i, l, o, u, a;
  if (r === null)
    return {};
  for (n = {}, t = Object.keys(r), i = 0, l = t.length; i < l; i += 1)
    o = t[i], u = String(r[o]), o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)), a = e.compiledTypeMap.fallback[o], a && Vn.call(a.styleAliases, u) && (u = a.styleAliases[u]), n[o] = u;
  return n;
}
function Ol(e) {
  var r, n, t;
  if (r = e.toString(16).toUpperCase(), e <= 255)
    n = "x", t = 2;
  else if (e <= 65535)
    n = "u", t = 4;
  else if (e <= 4294967295)
    n = "U", t = 8;
  else
    throw new de("code point within a string may not be greater than 0xFFFFFFFF");
  return "\\" + n + Fe.repeat("0", t - r.length) + r;
}
var Al = 1, le = 2;
function Pl(e) {
  this.schema = e.schema || tl, this.indent = Math.max(1, e.indent || 2), this.noArrayIndent = e.noArrayIndent || !1, this.skipInvalid = e.skipInvalid || !1, this.flowLevel = Fe.isNothing(e.flowLevel) ? -1 : e.flowLevel, this.styleMap = El(this.schema, e.styles || null), this.sortKeys = e.sortKeys || !1, this.lineWidth = e.lineWidth || 80, this.noRefs = e.noRefs || !1, this.noCompatMode = e.noCompatMode || !1, this.condenseFlow = e.condenseFlow || !1, this.quotingType = e.quotingType === '"' ? le : Al, this.forceQuotes = e.forceQuotes || !1, this.replacer = typeof e.replacer == "function" ? e.replacer : null, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
}
function kr(e, r) {
  for (var n = Fe.repeat(" ", r), t = 0, i = -1, l = "", o, u = e.length; t < u; )
    i = e.indexOf(`
`, t), i === -1 ? (o = e.slice(t), t = u) : (o = e.slice(t, i + 1), t = i + 1), o.length && o !== `
` && (l += n), l += o;
  return l;
}
function qe(e, r) {
  return `
` + Fe.repeat(" ", e.indent * r);
}
function Sl(e, r) {
  var n, t, i;
  for (n = 0, t = e.implicitTypes.length; n < t; n += 1)
    if (i = e.implicitTypes[n], i.resolve(r))
      return !0;
  return !1;
}
function Oe(e) {
  return e === ul || e === ol;
}
function ue(e) {
  return 32 <= e && e <= 126 || 161 <= e && e <= 55295 && e !== 8232 && e !== 8233 || 57344 <= e && e <= 65533 && e !== ar || 65536 <= e && e <= 1114111;
}
function Ur(e) {
  return ue(e) && e !== ar && e !== ll && e !== oe;
}
function Yr(e, r, n) {
  var t = Ur(e), i = t && !Oe(e);
  return (
    // ns-plain-safe
    (n ? (
      // c = flow-in
      t
    ) : t && e !== Xn && e !== Zn && e !== ei && e !== ri && e !== ni) && e !== Je && !(r === Ee && !i) || Ur(r) && !Oe(r) && e === Je || r === Ee && i
  );
}
function $l(e) {
  return ue(e) && e !== ar && !Oe(e) && e !== hl && e !== ml && e !== Ee && e !== Xn && e !== Zn && e !== ei && e !== ri && e !== ni && e !== Je && e !== sl && e !== pl && e !== al && e !== xl && e !== gl && e !== _l && e !== dl && e !== cl && e !== fl && e !== vl && e !== yl;
}
function jl(e) {
  return !Oe(e) && e !== Ee;
}
function ne(e, r) {
  var n = e.charCodeAt(r), t;
  return n >= 55296 && n <= 56319 && r + 1 < e.length && (t = e.charCodeAt(r + 1), t >= 56320 && t <= 57343) ? (n - 55296) * 1024 + t - 56320 + 65536 : n;
}
function ii(e) {
  var r = /^\n* /;
  return r.test(e);
}
var ti = 1, Ke = 2, oi = 3, li = 4, Q = 5;
function Cl(e, r, n, t, i, l, o, u) {
  var a, f = 0, h = null, s = !1, p = !1, g = t !== -1, m = -1, y = $l(ne(e, 0)) && jl(ne(e, e.length - 1));
  if (r || o)
    for (a = 0; a < e.length; f >= 65536 ? a += 2 : a++) {
      if (f = ne(e, a), !ue(f))
        return Q;
      y = y && Yr(f, h, u), h = f;
    }
  else {
    for (a = 0; a < e.length; f >= 65536 ? a += 2 : a++) {
      if (f = ne(e, a), f === oe)
        s = !0, g && (p = p || // Foldable line = too long, and not more-indented.
        a - m - 1 > t && e[m + 1] !== " ", m = a);
      else if (!ue(f))
        return Q;
      y = y && Yr(f, h, u), h = f;
    }
    p = p || g && a - m - 1 > t && e[m + 1] !== " ";
  }
  return !s && !p ? y && !o && !i(e) ? ti : l === le ? Q : Ke : n > 9 && ii(e) ? Q : o ? l === le ? Q : Ke : p ? li : oi;
}
function Tl(e, r, n, t, i) {
  e.dump = function() {
    if (r.length === 0)
      return e.quotingType === le ? '""' : "''";
    if (!e.noCompatMode && (wl.indexOf(r) !== -1 || bl.test(r)))
      return e.quotingType === le ? '"' + r + '"' : "'" + r + "'";
    var l = e.indent * Math.max(1, n), o = e.lineWidth === -1 ? -1 : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - l), u = t || e.flowLevel > -1 && n >= e.flowLevel;
    function a(f) {
      return Sl(e, f);
    }
    switch (Cl(
      r,
      u,
      e.indent,
      o,
      a,
      e.quotingType,
      e.forceQuotes && !t,
      i
    )) {
      case ti:
        return r;
      case Ke:
        return "'" + r.replace(/'/g, "''") + "'";
      case oi:
        return "|" + Gr(r, e.indent) + Wr(kr(r, l));
      case li:
        return ">" + Gr(r, e.indent) + Wr(kr(Rl(r, o), l));
      case Q:
        return '"' + Ml(r) + '"';
      default:
        throw new de("impossible error: invalid scalar style");
    }
  }();
}
function Gr(e, r) {
  var n = ii(e) ? String(r) : "", t = e[e.length - 1] === `
`, i = t && (e[e.length - 2] === `
` || e === `
`), l = i ? "+" : t ? "" : "-";
  return n + l + `
`;
}
function Wr(e) {
  return e[e.length - 1] === `
` ? e.slice(0, -1) : e;
}
function Rl(e, r) {
  for (var n = /(\n+)([^\n]*)/g, t = function() {
    var f = e.indexOf(`
`);
    return f = f !== -1 ? f : e.length, n.lastIndex = f, Jr(e.slice(0, f), r);
  }(), i = e[0] === `
` || e[0] === " ", l, o; o = n.exec(e); ) {
    var u = o[1], a = o[2];
    l = a[0] === " ", t += u + (!i && !l && a !== "" ? `
` : "") + Jr(a, r), i = l;
  }
  return t;
}
function Jr(e, r) {
  if (e === "" || e[0] === " ")
    return e;
  for (var n = / [^ ]/g, t, i = 0, l, o = 0, u = 0, a = ""; t = n.exec(e); )
    u = t.index, u - i > r && (l = o > i ? o : u, a += `
` + e.slice(i, l), i = l + 1), o = u;
  return a += `
`, e.length - i > r && o > i ? a += e.slice(i, o) + `
` + e.slice(o + 1) : a += e.slice(i), a.slice(1);
}
function Ml(e) {
  for (var r = "", n = 0, t, i = 0; i < e.length; n >= 65536 ? i += 2 : i++)
    n = ne(e, i), t = j[n], !t && ue(n) ? (r += e[i], n >= 65536 && (r += e[i + 1])) : r += t || Ol(n);
  return r;
}
function Fl(e, r, n) {
  var t = "", i = e.tag, l, o, u;
  for (l = 0, o = n.length; l < o; l += 1)
    u = n[l], e.replacer && (u = e.replacer.call(n, String(l), u)), (D(e, r, u, !1, !1) || typeof u > "u" && D(e, r, null, !1, !1)) && (t !== "" && (t += "," + (e.condenseFlow ? "" : " ")), t += e.dump);
  e.tag = i, e.dump = "[" + t + "]";
}
function qr(e, r, n, t) {
  var i = "", l = e.tag, o, u, a;
  for (o = 0, u = n.length; o < u; o += 1)
    a = n[o], e.replacer && (a = e.replacer.call(n, String(o), a)), (D(e, r + 1, a, !0, !0, !1, !0) || typeof a > "u" && D(e, r + 1, null, !0, !0, !1, !0)) && ((!t || i !== "") && (i += qe(e, r)), e.dump && oe === e.dump.charCodeAt(0) ? i += "-" : i += "- ", i += e.dump);
  e.tag = l, e.dump = i || "[]";
}
function Il(e, r, n) {
  var t = "", i = e.tag, l = Object.keys(n), o, u, a, f, h;
  for (o = 0, u = l.length; o < u; o += 1)
    h = "", t !== "" && (h += ", "), e.condenseFlow && (h += '"'), a = l[o], f = n[a], e.replacer && (f = e.replacer.call(n, a, f)), D(e, r, a, !1, !1) && (e.dump.length > 1024 && (h += "? "), h += e.dump + (e.condenseFlow ? '"' : "") + ":" + (e.condenseFlow ? "" : " "), D(e, r, f, !1, !1) && (h += e.dump, t += h));
  e.tag = i, e.dump = "{" + t + "}";
}
function Dl(e, r, n, t) {
  var i = "", l = e.tag, o = Object.keys(n), u, a, f, h, s, p;
  if (e.sortKeys === !0)
    o.sort();
  else if (typeof e.sortKeys == "function")
    o.sort(e.sortKeys);
  else if (e.sortKeys)
    throw new de("sortKeys must be a boolean or a function");
  for (u = 0, a = o.length; u < a; u += 1)
    p = "", (!t || i !== "") && (p += qe(e, r)), f = o[u], h = n[f], e.replacer && (h = e.replacer.call(n, f, h)), D(e, r + 1, f, !0, !0, !0) && (s = e.tag !== null && e.tag !== "?" || e.dump && e.dump.length > 1024, s && (e.dump && oe === e.dump.charCodeAt(0) ? p += "?" : p += "? "), p += e.dump, s && (p += qe(e, r)), D(e, r + 1, h, !0, s) && (e.dump && oe === e.dump.charCodeAt(0) ? p += ":" : p += ": ", p += e.dump, i += p));
  e.tag = l, e.dump = i || "{}";
}
function Kr(e, r, n) {
  var t, i, l, o, u, a;
  for (i = n ? e.explicitTypes : e.implicitTypes, l = 0, o = i.length; l < o; l += 1)
    if (u = i[l], (u.instanceOf || u.predicate) && (!u.instanceOf || typeof r == "object" && r instanceof u.instanceOf) && (!u.predicate || u.predicate(r))) {
      if (n ? u.multi && u.representName ? e.tag = u.representName(r) : e.tag = u.tag : e.tag = "?", u.represent) {
        if (a = e.styleMap[u.tag] || u.defaultStyle, Qn.call(u.represent) === "[object Function]")
          t = u.represent(r, a);
        else if (Vn.call(u.represent, a))
          t = u.represent[a](r, a);
        else
          throw new de("!<" + u.tag + '> tag resolver accepts not "' + a + '" style');
        e.dump = t;
      }
      return !0;
    }
  return !1;
}
function D(e, r, n, t, i, l, o) {
  e.tag = null, e.dump = n, Kr(e, n, !1) || Kr(e, n, !0);
  var u = Qn.call(e.dump), a = t, f;
  t && (t = e.flowLevel < 0 || e.flowLevel > r);
  var h = u === "[object Object]" || u === "[object Array]", s, p;
  if (h && (s = e.duplicates.indexOf(n), p = s !== -1), (e.tag !== null && e.tag !== "?" || p || e.indent !== 2 && r > 0) && (i = !1), p && e.usedDuplicates[s])
    e.dump = "*ref_" + s;
  else {
    if (h && p && !e.usedDuplicates[s] && (e.usedDuplicates[s] = !0), u === "[object Object]")
      t && Object.keys(e.dump).length !== 0 ? (Dl(e, r, e.dump, i), p && (e.dump = "&ref_" + s + e.dump)) : (Il(e, r, e.dump), p && (e.dump = "&ref_" + s + " " + e.dump));
    else if (u === "[object Array]")
      t && e.dump.length !== 0 ? (e.noArrayIndent && !o && r > 0 ? qr(e, r - 1, e.dump, i) : qr(e, r, e.dump, i), p && (e.dump = "&ref_" + s + e.dump)) : (Fl(e, r, e.dump), p && (e.dump = "&ref_" + s + " " + e.dump));
    else if (u === "[object String]")
      e.tag !== "?" && Tl(e, e.dump, r, l, a);
    else {
      if (u === "[object Undefined]")
        return !1;
      if (e.skipInvalid)
        return !1;
      throw new de("unacceptable kind of an object to dump " + u);
    }
    e.tag !== null && e.tag !== "?" && (f = encodeURI(
      e.tag[0] === "!" ? e.tag.slice(1) : e.tag
    ).replace(/!/g, "%21"), e.tag[0] === "!" ? f = "!" + f : f.slice(0, 18) === "tag:yaml.org,2002:" ? f = "!!" + f.slice(18) : f = "!<" + f + ">", e.dump = f + " " + e.dump);
  }
  return !0;
}
function Nl(e, r) {
  var n = [], t = [], i, l;
  for (ze(e, n, t), i = 0, l = t.length; i < l; i += 1)
    r.duplicates.push(n[t[i]]);
  r.usedDuplicates = new Array(l);
}
function ze(e, r, n) {
  var t, i, l;
  if (e !== null && typeof e == "object")
    if (i = r.indexOf(e), i !== -1)
      n.indexOf(i) === -1 && n.push(i);
    else if (r.push(e), Array.isArray(e))
      for (i = 0, l = e.length; i < l; i += 1)
        ze(e[i], r, n);
    else
      for (t = Object.keys(e), i = 0, l = t.length; i < l; i += 1)
        ze(e[t[i]], r, n);
}
function Ll(e, r) {
  r = r || {};
  var n = new Pl(r);
  n.noRefs || Nl(e, n);
  var t = e;
  return n.replacer && (t = n.replacer.call({ "": t }, "", t)), D(n, 0, t, !0, !0) ? n.dump + `
` : "";
}
zn.dump = Ll;
var ui = ir, Bl = zn;
function cr(e, r) {
  return function() {
    throw new Error("Function yaml." + e + " is removed in js-yaml 4. Use yaml." + r + " instead, which is now safe by default.");
  };
}
$.Type = C;
$.Schema = xn;
$.FAILSAFE_SCHEMA = On;
$.JSON_SCHEMA = Cn;
$.CORE_SCHEMA = Tn;
$.DEFAULT_SCHEMA = or;
$.load = ui.load;
$.loadAll = ui.loadAll;
$.dump = Bl.dump;
$.YAMLException = se;
$.types = {
  binary: Dn,
  float: jn,
  map: En,
  null: An,
  pairs: Ln,
  set: Bn,
  timestamp: Fn,
  bool: Pn,
  int: Sn,
  merge: In,
  omap: Nn,
  seq: bn,
  str: wn
};
$.safeLoad = cr("safeLoad", "load");
$.safeLoadAll = cr("safeLoadAll", "loadAll");
$.safeDump = cr("safeDump", "dump");
var Hl = _ && _.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(nr, "__esModule", { value: !0 });
const kl = A, Ul = Hl($), Yl = $;
nr.default = {
  /**
   * The order that this parser will run, in relation to other parsers.
   */
  order: 200,
  /**
   * Whether to allow "empty" files. This includes zero-byte files, as well as empty JSON objects.
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that match will be tried, in order, until one successfully parses the file.
   * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case
   * every parser will be tried.
   */
  canParse: [".yaml", ".yml", ".json"],
  // JSON is valid YAML
  /**
   * Parses the given file as YAML
   *
   * @param file           - An object containing information about the referenced file
   * @param file.url       - The full URL of the referenced file
   * @param file.extension - The lowercased file extension (e.g. ".txt", ".html", etc.)
   * @param file.data      - The file contents. This will be whatever data type was returned by the resolver
   * @returns
   */
  async parse(e) {
    let r = e.data;
    if (Buffer.isBuffer(r) && (r = r.toString()), typeof r == "string")
      try {
        return Ul.default.load(r, { schema: Yl.JSON_SCHEMA });
      } catch (n) {
        throw new kl.ParserError((n == null ? void 0 : n.message) || "Parser Error", e.url);
      }
    else
      return r;
  }
};
var fr = {};
Object.defineProperty(fr, "__esModule", { value: !0 });
const Gl = A, Wl = /\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;
fr.default = {
  /**
   * The order that this parser will run, in relation to other parsers.
   */
  order: 300,
  /**
   * Whether to allow "empty" files (zero bytes).
   */
  allowEmpty: !0,
  /**
   * The encoding that the text is expected to be in.
   */
  encoding: "utf8",
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that return true will be tried, in order, until one successfully parses the file.
   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
   * every parser will be tried.
   */
  canParse(e) {
    return (typeof e.data == "string" || Buffer.isBuffer(e.data)) && Wl.test(e.url);
  },
  /**
   * Parses the given file as text
   */
  parse(e) {
    if (typeof e.data == "string")
      return e.data;
    if (Buffer.isBuffer(e.data))
      return e.data.toString(this.encoding);
    throw new Gl.ParserError("data is not text", e.url);
  }
};
var sr = {};
Object.defineProperty(sr, "__esModule", { value: !0 });
const Jl = /\.(jpeg|jpg|gif|png|bmp|ico)$/i;
sr.default = {
  /**
   * The order that this parser will run, in relation to other parsers.
   */
  order: 400,
  /**
   * Whether to allow "empty" files (zero bytes).
   */
  allowEmpty: !0,
  /**
   * Determines whether this parser can parse a given file reference.
   * Parsers that return true will be tried, in order, until one successfully parses the file.
   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case
   * every parser will be tried.
   */
  canParse(e) {
    return Buffer.isBuffer(e.data) && Jl.test(e.url);
  },
  /**
   * Parses the given data as a Buffer (byte array).
   */
  parse(e) {
    return Buffer.isBuffer(e.data) ? e.data : Buffer.from(e.data);
  }
};
var dr = {}, ql = _ && _.__createBinding || (Object.create ? function(e, r, n, t) {
  t === void 0 && (t = n);
  var i = Object.getOwnPropertyDescriptor(r, n);
  (!i || ("get" in i ? !r.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return r[n];
  } }), Object.defineProperty(e, t, i);
} : function(e, r, n, t) {
  t === void 0 && (t = n), e[t] = r[n];
}), Kl = _ && _.__setModuleDefault || (Object.create ? function(e, r) {
  Object.defineProperty(e, "default", { enumerable: !0, value: r });
} : function(e, r) {
  e.default = r;
}), zl = _ && _.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var r = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && ql(r, e, n);
  return Kl(r, e), r;
}, Ql = _ && _.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(dr, "__esModule", { value: !0 });
const Vl = Ql(Se), zr = q, Qr = zl(O), Vr = A;
dr.default = {
  /**
   * The order that this resolver will run, in relation to other resolvers.
   */
  order: 100,
  /**
   * Determines whether this resolver can read a given file reference.
   * Resolvers that return true will be tried, in order, until one successfully resolves the file.
   * Resolvers that return false will not be given a chance to resolve the file.
   */
  canRead(e) {
    return Qr.isFileSystemPath(e.url);
  },
  /**
   * Reads the given file and returns its raw contents as a Buffer.
   */
  async read(e) {
    let r;
    try {
      r = Qr.toFileSystemPath(e.url);
    } catch (n) {
      throw new Vr.ResolverError(zr.ono.uri(n, `Malformed URI: ${e.url}`), e.url);
    }
    try {
      return await Vl.default.promises.readFile(r);
    } catch (n) {
      throw new Vr.ResolverError((0, zr.ono)(n, `Error opening file "${r}"`), r);
    }
  }
};
var pr = {}, Xl = _ && _.__createBinding || (Object.create ? function(e, r, n, t) {
  t === void 0 && (t = n);
  var i = Object.getOwnPropertyDescriptor(r, n);
  (!i || ("get" in i ? !r.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return r[n];
  } }), Object.defineProperty(e, t, i);
} : function(e, r, n, t) {
  t === void 0 && (t = n), e[t] = r[n];
}), Zl = _ && _.__setModuleDefault || (Object.create ? function(e, r) {
  Object.defineProperty(e, "default", { enumerable: !0, value: r });
} : function(e, r) {
  e.default = r;
}), eu = _ && _.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var r = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && Xl(r, e, n);
  return Zl(r, e), r;
};
Object.defineProperty(pr, "__esModule", { value: !0 });
const _e = q, ie = eu(O), Xr = A;
pr.default = {
  /**
   * The order that this resolver will run, in relation to other resolvers.
   */
  order: 200,
  /**
   * HTTP headers to send when downloading files.
   *
   * @example:
   * {
   *   "User-Agent": "JSON Schema $Ref Parser",
   *   Accept: "application/json"
   * }
   */
  headers: null,
  /**
   * HTTP request timeout (in milliseconds).
   */
  timeout: 5e3,
  // 5 seconds
  /**
   * The maximum number of HTTP redirects to follow.
   * To disable automatic following of redirects, set this to zero.
   */
  redirects: 5,
  /**
   * The `withCredentials` option of XMLHttpRequest.
   * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication
   */
  withCredentials: !1,
  /**
   * Determines whether this resolver can read a given file reference.
   * Resolvers that return true will be tried in order, until one successfully resolves the file.
   * Resolvers that return false will not be given a chance to resolve the file.
   */
  canRead(e) {
    return ie.isHttp(e.url);
  },
  /**
   * Reads the given URL and returns its raw contents as a Buffer.
   */
  read(e) {
    const r = ie.parse(e.url);
    return typeof window < "u" && !r.protocol && (r.protocol = ie.parse(location.href).protocol), ai(r, this);
  }
};
async function ai(e, r, n) {
  e = ie.parse(e);
  const t = n || [];
  t.push(e.href);
  try {
    const i = await ru(e, r);
    if (i.status >= 400)
      throw (0, _e.ono)({ status: i.status }, `HTTP ERROR ${i.status}`);
    if (i.status >= 300) {
      if (!Number.isNaN(r.redirects) && t.length > r.redirects)
        throw new Xr.ResolverError((0, _e.ono)({ status: i.status }, `Error downloading ${t[0]}. 
Too many redirects: 
  ${t.join(` 
  `)}`));
      if (!("location" in i.headers) || !i.headers.location)
        throw (0, _e.ono)({ status: i.status }, `HTTP ${i.status} redirect with no location header`);
      {
        const l = ie.resolve(e.href, i.headers.location);
        return ai(l, r, t);
      }
    } else {
      if (i.body) {
        const l = await i.arrayBuffer();
        return Buffer.from(l);
      }
      return Buffer.alloc(0);
    }
  } catch (i) {
    throw new Xr.ResolverError((0, _e.ono)(i, `Error downloading ${e.href}`), e.href);
  }
}
async function ru(e, r) {
  let n, t;
  r.timeout && (n = new AbortController(), t = setTimeout(() => n.abort(), r.timeout));
  const i = await fetch(e, {
    method: "GET",
    headers: r.headers || {},
    credentials: r.withCredentials ? "include" : "same-origin",
    signal: n ? n.signal : null
  });
  return t && clearTimeout(t), i;
}
(function(e) {
  var r = _ && _.__importDefault || function(p) {
    return p && p.__esModule ? p : { default: p };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.getNewOptions = e.getJsonSchemaRefParserDefaultOptions = void 0;
  const n = r(rr), t = r(nr), i = r(fr), l = r(sr), o = r(dr), u = r(pr), a = () => ({
    /**
     * Determines how different types of files will be parsed.
     *
     * You can add additional parsers of your own, replace an existing one with
     * your own implementation, or disable any parser by setting it to false.
     */
    parse: {
      json: { ...n.default },
      yaml: { ...t.default },
      text: { ...i.default },
      binary: { ...l.default }
    },
    /**
     * Determines how JSON References will be resolved.
     *
     * You can add additional resolvers of your own, replace an existing one with
     * your own implementation, or disable any resolver by setting it to false.
     */
    resolve: {
      file: { ...o.default },
      http: { ...u.default },
      /**
       * Determines whether external $ref pointers will be resolved.
       * If this option is disabled, then none of above resolvers will be called.
       * Instead, external $ref pointers will simply be ignored.
       *
       * @type {boolean}
       */
      external: !0
    },
    /**
     * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`
     * causes it to keep processing as much as possible and then throw a single error that contains all errors
     * that were encountered.
     */
    continueOnError: !1,
    /**
     * Determines the types of JSON references that are allowed.
     */
    dereference: {
      /**
       * Dereference circular (recursive) JSON references?
       * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.
       * If "ignore", then circular references will not be dereferenced.
       *
       * @type {boolean|string}
       */
      circular: !0,
      /**
       * A function, called for each path, which can return true to stop this path and all
       * subpaths from being dereferenced further. This is useful in schemas where some
       * subpaths contain literal $ref keys that should not be dereferenced.
       *
       * @type {function}
       */
      excludedPathMatcher: () => !1,
      referenceResolution: "relative"
    },
    mutateInputSchema: !0
  });
  e.getJsonSchemaRefParserDefaultOptions = a;
  const f = (p) => {
    const g = (0, e.getJsonSchemaRefParserDefaultOptions)();
    return p && h(g, p), g;
  };
  e.getNewOptions = f;
  function h(p, g) {
    if (s(g)) {
      const m = Object.keys(g).filter((y) => !["__proto__", "constructor", "prototype"].includes(y));
      for (let y = 0; y < m.length; y++) {
        const b = m[y], d = g[b], c = p[b];
        s(d) ? p[b] = h(c || {}, d) : d !== void 0 && (p[b] = d);
      }
    }
    return p;
  }
  function s(p) {
    return p && typeof p == "object" && !Array.isArray(p) && !(p instanceof RegExp) && !(p instanceof Date);
  }
})(mn);
Object.defineProperty(fe, "__esModule", { value: !0 });
fe.normalizeArgs = void 0;
const nu = mn;
function ci(e) {
  let r, n, t, i;
  const l = Array.prototype.slice.call(e);
  typeof l[l.length - 1] == "function" && (i = l.pop()), typeof l[0] == "string" ? (r = l[0], typeof l[2] == "object" ? (n = l[1], t = l[2]) : (n = void 0, t = l[1])) : (r = "", n = l[0], t = l[1]);
  try {
    t = (0, nu.getNewOptions)(t);
  } catch (o) {
    console.error(`JSON Schema Ref Parser: Error normalizing options: ${o}`);
  }
  return !t.mutateInputSchema && typeof n == "object" && (n = JSON.parse(JSON.stringify(n))), {
    path: r,
    schema: n,
    options: t,
    callback: i
  };
}
fe.normalizeArgs = ci;
fe.default = ci;
var hr = {}, iu = _ && _.__createBinding || (Object.create ? function(e, r, n, t) {
  t === void 0 && (t = n);
  var i = Object.getOwnPropertyDescriptor(r, n);
  (!i || ("get" in i ? !r.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return r[n];
  } }), Object.defineProperty(e, t, i);
} : function(e, r, n, t) {
  t === void 0 && (t = n), e[t] = r[n];
}), tu = _ && _.__setModuleDefault || (Object.create ? function(e, r) {
  Object.defineProperty(e, "default", { enumerable: !0, value: r });
} : function(e, r) {
  e.default = r;
}), ou = _ && _.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var r = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && iu(r, e, n);
  return tu(r, e), r;
}, gr = _ && _.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(hr, "__esModule", { value: !0 });
const lu = gr(ce()), uu = gr(Te()), au = gr(Re), z = ou(O), cu = A;
function fu(e, r) {
  var n;
  if (!((n = r.resolve) != null && n.external))
    return Promise.resolve();
  try {
    const t = _r(e.schema, e.$refs._root$Ref.path + "#", e.$refs, r);
    return Promise.all(t);
  } catch (t) {
    return Promise.reject(t);
  }
}
function _r(e, r, n, t, i, l) {
  i || (i = /* @__PURE__ */ new Set());
  let o = [];
  if (e && typeof e == "object" && !ArrayBuffer.isView(e) && !i.has(e)) {
    i.add(e), lu.default.isExternal$Ref(e) && o.push(su(e, r, n, t));
    const u = Object.keys(e);
    for (const a of u) {
      const f = uu.default.join(r, a), h = e[a];
      o = o.concat(_r(h, f, n, t, i));
    }
  }
  return o;
}
async function su(e, r, n, t) {
  var a;
  const i = ((a = t.dereference) == null ? void 0 : a.externalReferenceResolution) === "root", l = z.resolve(i ? z.cwd() : r, e.$ref), o = z.stripHash(l), u = n._$refs[o];
  if (u)
    return Promise.resolve(u.value);
  try {
    const f = await (0, au.default)(l, n, t), h = _r(f, o + "#", n, t, /* @__PURE__ */ new Set(), !0);
    return Promise.all(h);
  } catch (f) {
    if (!(t != null && t.continueOnError) || !(0, cu.isHandledError)(f))
      throw f;
    return n._$refs[o] && (f.source = decodeURI(z.stripHash(r)), f.path = z.safePointerToPath(z.getHash(r))), [];
  }
}
hr.default = fu;
var mr = {}, du = _ && _.__createBinding || (Object.create ? function(e, r, n, t) {
  t === void 0 && (t = n);
  var i = Object.getOwnPropertyDescriptor(r, n);
  (!i || ("get" in i ? !r.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return r[n];
  } }), Object.defineProperty(e, t, i);
} : function(e, r, n, t) {
  t === void 0 && (t = n), e[t] = r[n];
}), pu = _ && _.__setModuleDefault || (Object.create ? function(e, r) {
  Object.defineProperty(e, "default", { enumerable: !0, value: r });
} : function(e, r) {
  e.default = r;
}), hu = _ && _.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var r = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && du(r, e, n);
  return pu(r, e), r;
}, fi = _ && _.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(mr, "__esModule", { value: !0 });
const Ae = fi(ce()), ae = fi(Te()), He = hu(O);
function gu(e, r) {
  const n = [];
  vr(e, "schema", e.$refs._root$Ref.path + "#", "#", 0, n, e.$refs, r), _u(n);
}
function vr(e, r, n, t, i, l, o, u) {
  const a = r === null ? e : e[r];
  if (a && typeof a == "object" && !ArrayBuffer.isView(a))
    if (Ae.default.isAllowed$Ref(a))
      Zr(e, r, n, t, i, l, o, u);
    else {
      const f = Object.keys(a).sort((h, s) => h === "definitions" ? -1 : s === "definitions" ? 1 : h.length - s.length);
      for (const h of f) {
        const s = ae.default.join(n, h), p = ae.default.join(t, h), g = a[h];
        Ae.default.isAllowed$Ref(g) ? Zr(a, h, n, p, i, l, o, u) : vr(a, h, s, p, i, l, o, u);
      }
    }
}
function Zr(e, r, n, t, i, l, o, u) {
  const a = r === null ? e : e[r], f = He.resolve(n, a.$ref), h = o._resolve(f, t, u);
  if (h === null)
    return;
  const p = ae.default.parse(t).length, g = He.stripHash(h.path), m = He.getHash(h.path), y = g !== o._root$Ref.path, b = Ae.default.isExtended$Ref(a);
  i += h.indirections;
  const d = mu(l, e, r);
  if (d)
    if (p < d.depth || i < d.indirections)
      vu(l, d);
    else
      return;
  l.push({
    $ref: a,
    // The JSON Reference (e.g. {$ref: string})
    parent: e,
    // The object that contains this $ref pointer
    key: r,
    // The key in `parent` that is the $ref pointer
    pathFromRoot: t,
    // The path to the $ref pointer, from the JSON Schema root
    depth: p,
    // How far from the JSON Schema root is this $ref pointer?
    file: g,
    // The file that the $ref pointer resolves to
    hash: m,
    // The hash within `file` that the $ref pointer resolves to
    value: h.value,
    // The resolved value of the $ref pointer
    circular: h.circular,
    // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)
    extended: b,
    // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to "$ref")
    external: y,
    // Does this $ref pointer point to a file other than the main JSON Schema file?
    indirections: i
    // The number of indirect references that were traversed to resolve the value
  }), (!d || y) && vr(h.value, null, h.path, t, i + 1, l, o, u);
}
function _u(e) {
  e.sort((i, l) => {
    if (i.file !== l.file)
      return i.file < l.file ? -1 : 1;
    if (i.hash !== l.hash)
      return i.hash < l.hash ? -1 : 1;
    if (i.circular !== l.circular)
      return i.circular ? -1 : 1;
    if (i.extended !== l.extended)
      return i.extended ? 1 : -1;
    if (i.indirections !== l.indirections)
      return i.indirections - l.indirections;
    if (i.depth !== l.depth)
      return i.depth - l.depth;
    {
      const o = i.pathFromRoot.lastIndexOf("/definitions"), u = l.pathFromRoot.lastIndexOf("/definitions");
      return o !== u ? u - o : i.pathFromRoot.length - l.pathFromRoot.length;
    }
  });
  let r, n, t;
  for (const i of e)
    i.external ? i.file === r && i.hash === n ? i.$ref.$ref = t : i.file === r && i.hash.indexOf(n + "/") === 0 ? i.$ref.$ref = ae.default.join(t, ae.default.parse(i.hash.replace(n, "#"))) : (r = i.file, n = i.hash, t = i.pathFromRoot, i.$ref = i.parent[i.key] = Ae.default.dereference(i.$ref, i.value), i.circular && (i.$ref.$ref = i.pathFromRoot)) : i.$ref.$ref = i.hash;
}
function mu(e, r, n) {
  for (const t of e)
    if (t && t.parent === r && t.key === n)
      return t;
}
function vu(e, r) {
  const n = e.indexOf(r);
  e.splice(n, 1);
}
mr.default = gu;
var yr = {}, yu = _ && _.__createBinding || (Object.create ? function(e, r, n, t) {
  t === void 0 && (t = n);
  var i = Object.getOwnPropertyDescriptor(r, n);
  (!i || ("get" in i ? !r.__esModule : i.writable || i.configurable)) && (i = { enumerable: !0, get: function() {
    return r[n];
  } }), Object.defineProperty(e, t, i);
} : function(e, r, n, t) {
  t === void 0 && (t = n), e[t] = r[n];
}), xu = _ && _.__setModuleDefault || (Object.create ? function(e, r) {
  Object.defineProperty(e, "default", { enumerable: !0, value: r });
} : function(e, r) {
  e.default = r;
}), wu = _ && _.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var r = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && yu(r, e, n);
  return xu(r, e), r;
}, si = _ && _.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(yr, "__esModule", { value: !0 });
const Pe = si(ce()), en = si(Te()), bu = q, rn = wu(O), Eu = A;
yr.default = Ou;
function Ou(e, r) {
  const n = Date.now(), t = xr(e.schema, e.$refs._root$Ref.path, "#", /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Map(), e.$refs, r, n);
  e.$refs.circular = t.circular, e.schema = t.value;
}
function xr(e, r, n, t, i, l, o, u, a) {
  var g;
  let f;
  const h = {
    value: e,
    circular: !1
  };
  if (u && u.timeoutMs && Date.now() - a > u.timeoutMs)
    throw new Eu.TimeoutError(u.timeoutMs);
  const s = u.dereference || {}, p = s.excludedPathMatcher || (() => !1);
  if (((s == null ? void 0 : s.circular) === "ignore" || !i.has(e)) && e && typeof e == "object" && !ArrayBuffer.isView(e) && !p(n)) {
    if (t.add(e), i.add(e), Pe.default.isAllowed$Ref(e, u))
      f = nn(e, r, n, t, i, l, o, u, a), h.circular = f.circular, h.value = f.value;
    else
      for (const m of Object.keys(e)) {
        const y = en.default.join(r, m), b = en.default.join(n, m);
        if (p(b))
          continue;
        const d = e[m];
        let c = !1;
        Pe.default.isAllowed$Ref(d, u) ? (f = nn(d, y, b, t, i, l, o, u, a), c = f.circular, e[m] !== f.value && (e[m] = f.value, (g = s == null ? void 0 : s.onDereference) == null || g.call(s, d.$ref, e[m], e, m))) : t.has(d) ? c = di(y, o, u) : (f = xr(d, y, b, t, i, l, o, u, a), c = f.circular, e[m] !== f.value && (e[m] = f.value)), h.circular = h.circular || c;
      }
    t.delete(e);
  }
  return h;
}
function nn(e, r, n, t, i, l, o, u, a) {
  var c, x;
  const h = Pe.default.isExternal$Ref(e) && ((c = u == null ? void 0 : u.dereference) == null ? void 0 : c.externalReferenceResolution) === "root", s = rn.resolve(h ? rn.cwd() : r, e.$ref), p = l.get(s);
  if (p) {
    const E = Object.keys(e);
    if (E.length > 1) {
      const v = {};
      for (const P of E)
        P !== "$ref" && !(P in p.value) && (v[P] = e[P]);
      return {
        circular: p.circular,
        value: Object.assign({}, p.value, v)
      };
    }
    return p;
  }
  const g = o._resolve(s, r, u);
  if (g === null)
    return {
      circular: !1,
      value: null
    };
  const m = g.circular;
  let y = m || t.has(g.value);
  y && di(r, o, u);
  let b = Pe.default.dereference(e, g.value);
  if (!y) {
    const E = xr(b, g.path, n, t, i, l, o, u, a);
    y = E.circular, b = E.value;
  }
  y && !m && ((x = u.dereference) == null ? void 0 : x.circular) === "ignore" && (b = e), m && (b.$ref = n);
  const d = {
    circular: y,
    value: b
  };
  return Object.keys(e).length === 1 && l.set(s, d), d;
}
function di(e, r, n) {
  if (r.circular = !0, !n.dereference.circular)
    throw bu.ono.reference(`Circular $ref pointer found at ${e}`);
  return !0;
}
var wr = {}, br = {};
Object.defineProperty(br, "__esModule", { value: !0 });
function Au() {
  return typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : typeof setImmediate == "function" ? setImmediate : function(r) {
    setTimeout(r, 0);
  };
}
br.default = Au();
var Pu = _ && _.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(wr, "__esModule", { value: !0 });
const tn = Pu(br);
function Su(e, r) {
  if (e) {
    r.then(function(n) {
      (0, tn.default)(function() {
        e(null, n);
      });
    }, function(n) {
      (0, tn.default)(function() {
        e(n);
      });
    });
    return;
  } else
    return r;
}
wr.default = Su;
(function(e) {
  var r = _ && _.__createBinding || (Object.create ? function(d, c, x, E) {
    E === void 0 && (E = x);
    var v = Object.getOwnPropertyDescriptor(c, x);
    (!v || ("get" in v ? !c.__esModule : v.writable || v.configurable)) && (v = { enumerable: !0, get: function() {
      return c[x];
    } }), Object.defineProperty(d, E, v);
  } : function(d, c, x, E) {
    E === void 0 && (E = x), d[E] = c[x];
  }), n = _ && _.__setModuleDefault || (Object.create ? function(d, c) {
    Object.defineProperty(d, "default", { enumerable: !0, value: c });
  } : function(d, c) {
    d.default = c;
  }), t = _ && _.__importStar || function(d) {
    if (d && d.__esModule)
      return d;
    var c = {};
    if (d != null)
      for (var x in d)
        x !== "default" && Object.prototype.hasOwnProperty.call(d, x) && r(c, d, x);
    return n(c, d), c;
  }, i = _ && _.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.JSONParserErrorGroup = e.isHandledError = e.UnmatchedParserError = e.ParserError = e.ResolverError = e.MissingPointerError = e.InvalidPointerError = e.JSONParserError = e.UnmatchedResolverError = e.dereference = e.bundle = e.resolve = e.parse = e.$RefParser = void 0;
  const l = i(Ve), o = i(Re), u = i(fe), a = i(hr), f = i(mr), h = i(yr), s = t(O), p = A;
  Object.defineProperty(e, "JSONParserError", { enumerable: !0, get: function() {
    return p.JSONParserError;
  } }), Object.defineProperty(e, "InvalidPointerError", { enumerable: !0, get: function() {
    return p.InvalidPointerError;
  } }), Object.defineProperty(e, "MissingPointerError", { enumerable: !0, get: function() {
    return p.MissingPointerError;
  } }), Object.defineProperty(e, "ResolverError", { enumerable: !0, get: function() {
    return p.ResolverError;
  } }), Object.defineProperty(e, "ParserError", { enumerable: !0, get: function() {
    return p.ParserError;
  } }), Object.defineProperty(e, "UnmatchedParserError", { enumerable: !0, get: function() {
    return p.UnmatchedParserError;
  } }), Object.defineProperty(e, "UnmatchedResolverError", { enumerable: !0, get: function() {
    return p.UnmatchedResolverError;
  } }), Object.defineProperty(e, "isHandledError", { enumerable: !0, get: function() {
    return p.isHandledError;
  } }), Object.defineProperty(e, "JSONParserErrorGroup", { enumerable: !0, get: function() {
    return p.JSONParserErrorGroup;
  } });
  const g = q, m = i(wr);
  class y {
    constructor() {
      this.schema = null, this.$refs = new l.default();
    }
    async parse() {
      const c = (0, u.default)(arguments);
      let x;
      if (!c.path && !c.schema) {
        const v = (0, g.ono)(`Expected a file path, URL, or object. Got ${c.path || c.schema}`);
        return (0, m.default)(c.callback, Promise.reject(v));
      }
      this.schema = null, this.$refs = new l.default();
      let E = "http";
      if (s.isFileSystemPath(c.path))
        c.path = s.fromFileSystemPath(c.path), E = "file";
      else if (!c.path && c.schema && "$id" in c.schema && c.schema.$id) {
        const v = s.parse(c.schema.$id), P = v.protocol === "https:" ? 443 : 80;
        c.path = `${v.protocol}//${v.hostname}:${P}`;
      }
      if (c.path = s.resolve(s.cwd(), c.path), c.schema && typeof c.schema == "object") {
        const v = this.$refs._add(c.path);
        v.value = c.schema, v.pathType = E, x = Promise.resolve(c.schema);
      } else
        x = (0, o.default)(c.path, this.$refs, c.options);
      try {
        const v = await x;
        if (v !== null && typeof v == "object" && !Buffer.isBuffer(v))
          return this.schema = v, (0, m.default)(c.callback, Promise.resolve(this.schema));
        if (c.options.continueOnError)
          return this.schema = null, (0, m.default)(c.callback, Promise.resolve(this.schema));
        throw g.ono.syntax(`"${this.$refs._root$Ref.path || v}" is not a valid JSON Schema`);
      } catch (v) {
        return !c.options.continueOnError || !(0, p.isHandledError)(v) ? (0, m.default)(c.callback, Promise.reject(v)) : (this.$refs._$refs[s.stripHash(c.path)] && this.$refs._$refs[s.stripHash(c.path)].addError(v), (0, m.default)(c.callback, Promise.resolve(null)));
      }
    }
    static parse() {
      const c = new y();
      return c.parse.apply(c, arguments);
    }
    async resolve() {
      const c = (0, u.default)(arguments);
      try {
        return await this.parse(c.path, c.schema, c.options), await (0, a.default)(this, c.options), b(this), (0, m.default)(c.callback, Promise.resolve(this.$refs));
      } catch (x) {
        return (0, m.default)(c.callback, Promise.reject(x));
      }
    }
    static resolve() {
      const c = new y();
      return c.resolve.apply(c, arguments);
    }
    static bundle() {
      const c = new y();
      return c.bundle.apply(c, arguments);
    }
    async bundle() {
      const c = (0, u.default)(arguments);
      try {
        return await this.resolve(c.path, c.schema, c.options), (0, f.default)(this, c.options), b(this), (0, m.default)(c.callback, Promise.resolve(this.schema));
      } catch (x) {
        return (0, m.default)(c.callback, Promise.reject(x));
      }
    }
    static dereference() {
      const c = new y();
      return c.dereference.apply(c, arguments);
    }
    async dereference() {
      const c = (0, u.default)(arguments);
      try {
        return await this.resolve(c.path, c.schema, c.options), (0, h.default)(this, c.options), b(this), (0, m.default)(c.callback, Promise.resolve(this.schema));
      } catch (x) {
        return (0, m.default)(c.callback, Promise.reject(x));
      }
    }
  }
  e.$RefParser = y, e.default = y;
  function b(d) {
    if (p.JSONParserErrorGroup.getParserErrors(d).length > 0)
      throw new p.JSONParserErrorGroup(d);
  }
  e.parse = y.parse, e.resolve = y.resolve, e.bundle = y.bundle, e.dereference = y.dereference;
})(Qe);
const $u = /* @__PURE__ */ hi(Qe), Cu = /* @__PURE__ */ gi({
  __proto__: null,
  default: $u
}, [Qe]);
export {
  Cu as i
};
