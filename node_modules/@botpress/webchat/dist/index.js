import './style.css';
var SR = Object.defineProperty;
var ER = (e, t, n) => t in e ? SR(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Ee = (e, t, n) => ER(e, typeof t != "symbol" ? t + "" : t, n);
import * as x from "react";
import vt, { forwardRef as An, useState as He, useRef as Tt, useEffect as Pt, createContext as NS, useContext as ho, useCallback as ot, useId as _R, useLayoutEffect as mo, useMemo as zt, memo as qu, useImperativeHandle as kR, Fragment as TR, useReducer as CR } from "react";
import * as MS from "react-dom";
import { createPortal as OR } from "react-dom";
var yt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ye(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function $R(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var uh = { exports: {} }, Ao = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kg;
function RR() {
  if (kg) return Ao;
  kg = 1;
  var e = vt, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(s, c, l) {
    var u, f = {}, d = null, p = null;
    l !== void 0 && (d = "" + l), c.key !== void 0 && (d = "" + c.key), c.ref !== void 0 && (p = c.ref);
    for (u in c) r.call(c, u) && !a.hasOwnProperty(u) && (f[u] = c[u]);
    if (s && s.defaultProps) for (u in c = s.defaultProps, c) f[u] === void 0 && (f[u] = c[u]);
    return { $$typeof: t, type: s, key: d, ref: p, props: f, _owner: i.current };
  }
  return Ao.Fragment = n, Ao.jsx = o, Ao.jsxs = o, Ao;
}
var Po = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Tg;
function IR() {
  return Tg || (Tg = 1, process.env.NODE_ENV !== "production" && function() {
    var e = vt, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), l = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), f = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), p = Symbol.for("react.offscreen"), m = Symbol.iterator, h = "@@iterator";
    function y(P) {
      if (P === null || typeof P != "object")
        return null;
      var se = m && P[m] || P[h];
      return typeof se == "function" ? se : null;
    }
    var v = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function b(P) {
      {
        for (var se = arguments.length, ge = new Array(se > 1 ? se - 1 : 0), Ne = 1; Ne < se; Ne++)
          ge[Ne - 1] = arguments[Ne];
        w("error", P, ge);
      }
    }
    function w(P, se, ge) {
      {
        var Ne = v.ReactDebugCurrentFrame, ft = Ne.getStackAddendum();
        ft !== "" && (se += "%s", ge = ge.concat([ft]));
        var bt = ge.map(function(et) {
          return String(et);
        });
        bt.unshift("Warning: " + se), Function.prototype.apply.call(console[P], console, bt);
      }
    }
    var T = !1, E = !1, _ = !1, $ = !1, B = !1, U;
    U = Symbol.for("react.module.reference");
    function k(P) {
      return !!(typeof P == "string" || typeof P == "function" || P === r || P === a || B || P === i || P === l || P === u || $ || P === p || T || E || _ || typeof P == "object" && P !== null && (P.$$typeof === d || P.$$typeof === f || P.$$typeof === o || P.$$typeof === s || P.$$typeof === c || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      P.$$typeof === U || P.getModuleId !== void 0));
    }
    function D(P, se, ge) {
      var Ne = P.displayName;
      if (Ne)
        return Ne;
      var ft = se.displayName || se.name || "";
      return ft !== "" ? ge + "(" + ft + ")" : ge;
    }
    function q(P) {
      return P.displayName || "Context";
    }
    function L(P) {
      if (P == null)
        return null;
      if (typeof P.tag == "number" && b("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof P == "function")
        return P.displayName || P.name || null;
      if (typeof P == "string")
        return P;
      switch (P) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case a:
          return "Profiler";
        case i:
          return "StrictMode";
        case l:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof P == "object")
        switch (P.$$typeof) {
          case s:
            var se = P;
            return q(se) + ".Consumer";
          case o:
            var ge = P;
            return q(ge._context) + ".Provider";
          case c:
            return D(P, P.render, "ForwardRef");
          case f:
            var Ne = P.displayName || null;
            return Ne !== null ? Ne : L(P.type) || "Memo";
          case d: {
            var ft = P, bt = ft._payload, et = ft._init;
            try {
              return L(et(bt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var R = Object.assign, A = 0, F, H, V, I, g, j, W;
    function S() {
    }
    S.__reactDisabledLog = !0;
    function Z() {
      {
        if (A === 0) {
          F = console.log, H = console.info, V = console.warn, I = console.error, g = console.group, j = console.groupCollapsed, W = console.groupEnd;
          var P = {
            configurable: !0,
            enumerable: !0,
            value: S,
            writable: !0
          };
          Object.defineProperties(console, {
            info: P,
            log: P,
            warn: P,
            error: P,
            group: P,
            groupCollapsed: P,
            groupEnd: P
          });
        }
        A++;
      }
    }
    function Y() {
      {
        if (A--, A === 0) {
          var P = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: R({}, P, {
              value: F
            }),
            info: R({}, P, {
              value: H
            }),
            warn: R({}, P, {
              value: V
            }),
            error: R({}, P, {
              value: I
            }),
            group: R({}, P, {
              value: g
            }),
            groupCollapsed: R({}, P, {
              value: j
            }),
            groupEnd: R({}, P, {
              value: W
            })
          });
        }
        A < 0 && b("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var G = v.ReactCurrentDispatcher, X;
    function ie(P, se, ge) {
      {
        if (X === void 0)
          try {
            throw Error();
          } catch (ft) {
            var Ne = ft.stack.trim().match(/\n( *(at )?)/);
            X = Ne && Ne[1] || "";
          }
        return `
` + X + P;
      }
    }
    var ae = !1, J;
    {
      var Q = typeof WeakMap == "function" ? WeakMap : Map;
      J = new Q();
    }
    function K(P, se) {
      if (!P || ae)
        return "";
      {
        var ge = J.get(P);
        if (ge !== void 0)
          return ge;
      }
      var Ne;
      ae = !0;
      var ft = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var bt;
      bt = G.current, G.current = null, Z();
      try {
        if (se) {
          var et = function() {
            throw Error();
          };
          if (Object.defineProperty(et.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(et, []);
            } catch (_n) {
              Ne = _n;
            }
            Reflect.construct(P, [], et);
          } else {
            try {
              et.call();
            } catch (_n) {
              Ne = _n;
            }
            P.call(et.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (_n) {
            Ne = _n;
          }
          P();
        }
      } catch (_n) {
        if (_n && Ne && typeof _n.stack == "string") {
          for (var Je = _n.stack.split(`
`), bn = Ne.stack.split(`
`), Bt = Je.length - 1, qt = bn.length - 1; Bt >= 1 && qt >= 0 && Je[Bt] !== bn[qt]; )
            qt--;
          for (; Bt >= 1 && qt >= 0; Bt--, qt--)
            if (Je[Bt] !== bn[qt]) {
              if (Bt !== 1 || qt !== 1)
                do
                  if (Bt--, qt--, qt < 0 || Je[Bt] !== bn[qt]) {
                    var Wn = `
` + Je[Bt].replace(" at new ", " at ");
                    return P.displayName && Wn.includes("<anonymous>") && (Wn = Wn.replace("<anonymous>", P.displayName)), typeof P == "function" && J.set(P, Wn), Wn;
                  }
                while (Bt >= 1 && qt >= 0);
              break;
            }
        }
      } finally {
        ae = !1, G.current = bt, Y(), Error.prepareStackTrace = ft;
      }
      var ha = P ? P.displayName || P.name : "", Fi = ha ? ie(ha) : "";
      return typeof P == "function" && J.set(P, Fi), Fi;
    }
    function fe(P, se, ge) {
      return K(P, !1);
    }
    function ye(P) {
      var se = P.prototype;
      return !!(se && se.isReactComponent);
    }
    function $e(P, se, ge) {
      if (P == null)
        return "";
      if (typeof P == "function")
        return K(P, ye(P));
      if (typeof P == "string")
        return ie(P);
      switch (P) {
        case l:
          return ie("Suspense");
        case u:
          return ie("SuspenseList");
      }
      if (typeof P == "object")
        switch (P.$$typeof) {
          case c:
            return fe(P.render);
          case f:
            return $e(P.type, se, ge);
          case d: {
            var Ne = P, ft = Ne._payload, bt = Ne._init;
            try {
              return $e(bt(ft), se, ge);
            } catch {
            }
          }
        }
      return "";
    }
    var M = Object.prototype.hasOwnProperty, re = {}, le = v.ReactDebugCurrentFrame;
    function oe(P) {
      if (P) {
        var se = P._owner, ge = $e(P.type, P._source, se ? se.type : null);
        le.setExtraStackFrame(ge);
      } else
        le.setExtraStackFrame(null);
    }
    function Te(P, se, ge, Ne, ft) {
      {
        var bt = Function.call.bind(M);
        for (var et in P)
          if (bt(P, et)) {
            var Je = void 0;
            try {
              if (typeof P[et] != "function") {
                var bn = Error((Ne || "React class") + ": " + ge + " type `" + et + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof P[et] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw bn.name = "Invariant Violation", bn;
              }
              Je = P[et](se, et, Ne, ge, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Bt) {
              Je = Bt;
            }
            Je && !(Je instanceof Error) && (oe(ft), b("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ne || "React class", ge, et, typeof Je), oe(null)), Je instanceof Error && !(Je.message in re) && (re[Je.message] = !0, oe(ft), b("Failed %s type: %s", ge, Je.message), oe(null));
          }
      }
    }
    var Se = Array.isArray;
    function Re(P) {
      return Se(P);
    }
    function ze(P) {
      {
        var se = typeof Symbol == "function" && Symbol.toStringTag, ge = se && P[Symbol.toStringTag] || P.constructor.name || "Object";
        return ge;
      }
    }
    function ee(P) {
      try {
        return ue(P), !1;
      } catch {
        return !0;
      }
    }
    function ue(P) {
      return "" + P;
    }
    function z(P) {
      if (ee(P))
        return b("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ze(P)), ue(P);
    }
    var N = v.ReactCurrentOwner, te = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, de, be, Oe;
    Oe = {};
    function Ve(P) {
      if (M.call(P, "ref")) {
        var se = Object.getOwnPropertyDescriptor(P, "ref").get;
        if (se && se.isReactWarning)
          return !1;
      }
      return P.ref !== void 0;
    }
    function Qe(P) {
      if (M.call(P, "key")) {
        var se = Object.getOwnPropertyDescriptor(P, "key").get;
        if (se && se.isReactWarning)
          return !1;
      }
      return P.key !== void 0;
    }
    function Ct(P, se) {
      if (typeof P.ref == "string" && N.current && se && N.current.stateNode !== se) {
        var ge = L(N.current.type);
        Oe[ge] || (b('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', L(N.current.type), P.ref), Oe[ge] = !0);
      }
    }
    function _t(P, se) {
      {
        var ge = function() {
          de || (de = !0, b("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", se));
        };
        ge.isReactWarning = !0, Object.defineProperty(P, "key", {
          get: ge,
          configurable: !0
        });
      }
    }
    function Ue(P, se) {
      {
        var ge = function() {
          be || (be = !0, b("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", se));
        };
        ge.isReactWarning = !0, Object.defineProperty(P, "ref", {
          get: ge,
          configurable: !0
        });
      }
    }
    var kt = function(P, se, ge, Ne, ft, bt, et) {
      var Je = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: P,
        key: se,
        ref: ge,
        props: et,
        // Record the component responsible for creating this element.
        _owner: bt
      };
      return Je._store = {}, Object.defineProperty(Je._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Je, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ne
      }), Object.defineProperty(Je, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ft
      }), Object.freeze && (Object.freeze(Je.props), Object.freeze(Je)), Je;
    };
    function Ze(P, se, ge, Ne, ft) {
      {
        var bt, et = {}, Je = null, bn = null;
        ge !== void 0 && (z(ge), Je = "" + ge), Qe(se) && (z(se.key), Je = "" + se.key), Ve(se) && (bn = se.ref, Ct(se, ft));
        for (bt in se)
          M.call(se, bt) && !te.hasOwnProperty(bt) && (et[bt] = se[bt]);
        if (P && P.defaultProps) {
          var Bt = P.defaultProps;
          for (bt in Bt)
            et[bt] === void 0 && (et[bt] = Bt[bt]);
        }
        if (Je || bn) {
          var qt = typeof P == "function" ? P.displayName || P.name || "Unknown" : P;
          Je && _t(et, qt), bn && Ue(et, qt);
        }
        return kt(P, Je, bn, ft, Ne, N.current, et);
      }
    }
    var fn = v.ReactCurrentOwner, Dn = v.ReactDebugCurrentFrame;
    function Qn(P) {
      if (P) {
        var se = P._owner, ge = $e(P.type, P._source, se ? se.type : null);
        Dn.setExtraStackFrame(ge);
      } else
        Dn.setExtraStackFrame(null);
    }
    var Wr;
    Wr = !1;
    function gr(P) {
      return typeof P == "object" && P !== null && P.$$typeof === t;
    }
    function er() {
      {
        if (fn.current) {
          var P = L(fn.current.type);
          if (P)
            return `

Check the render method of \`` + P + "`.";
        }
        return "";
      }
    }
    function Vr(P) {
      return "";
    }
    var ht = {};
    function Ot(P) {
      {
        var se = er();
        if (!se) {
          var ge = typeof P == "string" ? P : P.displayName || P.name;
          ge && (se = `

Check the top-level render call using <` + ge + ">.");
        }
        return se;
      }
    }
    function Zt(P, se) {
      {
        if (!P._store || P._store.validated || P.key != null)
          return;
        P._store.validated = !0;
        var ge = Ot(se);
        if (ht[ge])
          return;
        ht[ge] = !0;
        var Ne = "";
        P && P._owner && P._owner !== fn.current && (Ne = " It was passed a child from " + L(P._owner.type) + "."), Qn(P), b('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ge, Ne), Qn(null);
      }
    }
    function Kt(P, se) {
      {
        if (typeof P != "object")
          return;
        if (Re(P))
          for (var ge = 0; ge < P.length; ge++) {
            var Ne = P[ge];
            gr(Ne) && Zt(Ne, se);
          }
        else if (gr(P))
          P._store && (P._store.validated = !0);
        else if (P) {
          var ft = y(P);
          if (typeof ft == "function" && ft !== P.entries)
            for (var bt = ft.call(P), et; !(et = bt.next()).done; )
              gr(et.value) && Zt(et.value, se);
        }
      }
    }
    function on(P) {
      {
        var se = P.type;
        if (se == null || typeof se == "string")
          return;
        var ge;
        if (typeof se == "function")
          ge = se.propTypes;
        else if (typeof se == "object" && (se.$$typeof === c || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        se.$$typeof === f))
          ge = se.propTypes;
        else
          return;
        if (ge) {
          var Ne = L(se);
          Te(ge, P.props, "prop", Ne, P);
        } else if (se.PropTypes !== void 0 && !Wr) {
          Wr = !0;
          var ft = L(se);
          b("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ft || "Unknown");
        }
        typeof se.getDefaultProps == "function" && !se.getDefaultProps.isReactClassApproved && b("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Gt(P) {
      {
        for (var se = Object.keys(P.props), ge = 0; ge < se.length; ge++) {
          var Ne = se[ge];
          if (Ne !== "children" && Ne !== "key") {
            Qn(P), b("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ne), Qn(null);
            break;
          }
        }
        P.ref !== null && (Qn(P), b("Invalid attribute `ref` supplied to `React.Fragment`."), Qn(null));
      }
    }
    var zn = {};
    function qn(P, se, ge, Ne, ft, bt) {
      {
        var et = k(P);
        if (!et) {
          var Je = "";
          (P === void 0 || typeof P == "object" && P !== null && Object.keys(P).length === 0) && (Je += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var bn = Vr();
          bn ? Je += bn : Je += er();
          var Bt;
          P === null ? Bt = "null" : Re(P) ? Bt = "array" : P !== void 0 && P.$$typeof === t ? (Bt = "<" + (L(P.type) || "Unknown") + " />", Je = " Did you accidentally export a JSX literal instead of a component?") : Bt = typeof P, b("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Bt, Je);
        }
        var qt = Ze(P, se, ge, ft, bt);
        if (qt == null)
          return qt;
        if (et) {
          var Wn = se.children;
          if (Wn !== void 0)
            if (Ne)
              if (Re(Wn)) {
                for (var ha = 0; ha < Wn.length; ha++)
                  Kt(Wn[ha], P);
                Object.freeze && Object.freeze(Wn);
              } else
                b("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Kt(Wn, P);
        }
        if (M.call(se, "key")) {
          var Fi = L(P), _n = Object.keys(se).filter(function(xR) {
            return xR !== "key";
          }), Vf = _n.length > 0 ? "{key: someKey, " + _n.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!zn[Fi + Vf]) {
            var wR = _n.length > 0 ? "{" + _n.join(": ..., ") + ": ...}" : "{}";
            b(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Vf, Fi, wR, Fi), zn[Fi + Vf] = !0;
          }
        }
        return P === r ? Gt(qt) : on(qt), qt;
      }
    }
    function li(P, se, ge) {
      return qn(P, se, ge, !0);
    }
    function yR(P, se, ge) {
      return qn(P, se, ge, !1);
    }
    var gR = yR, bR = li;
    Po.Fragment = r, Po.jsx = gR, Po.jsxs = bR;
  }()), Po;
}
process.env.NODE_ENV === "production" ? uh.exports = RR() : uh.exports = IR();
var O = uh.exports;
function AR(e, t = []) {
  let n = [];
  function r(a, o) {
    const s = x.createContext(o), c = n.length;
    n = [...n, o];
    function l(f) {
      const { scope: d, children: p, ...m } = f, h = (d == null ? void 0 : d[e][c]) || s, y = x.useMemo(() => m, Object.values(m));
      return /* @__PURE__ */ O.jsx(h.Provider, { value: y, children: p });
    }
    function u(f, d) {
      const p = (d == null ? void 0 : d[e][c]) || s, m = x.useContext(p);
      if (m) return m;
      if (o !== void 0) return o;
      throw new Error(`\`${f}\` must be used within \`${a}\``);
    }
    return l.displayName = a + "Provider", [l, u];
  }
  const i = () => {
    const a = n.map((o) => x.createContext(o));
    return function(s) {
      const c = (s == null ? void 0 : s[e]) || a;
      return x.useMemo(
        () => ({ [`__scope${e}`]: { ...s, [e]: c } }),
        [s, c]
      );
    };
  };
  return i.scopeName = e, [r, PR(i, ...t)];
}
function PR(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(a) {
      const o = r.reduce((s, { useScope: c, scopeName: l }) => {
        const f = c(a)[`__scope${l}`];
        return { ...s, ...f };
      }, {});
      return x.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function _i(e) {
  const t = x.useRef(e);
  return x.useEffect(() => {
    t.current = e;
  }), x.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
var Za = globalThis != null && globalThis.document ? x.useLayoutEffect : () => {
};
function DR(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function jR(...e) {
  return (t) => e.forEach((n) => DR(n, t));
}
var FS = x.forwardRef((e, t) => {
  const { children: n, ...r } = e, i = x.Children.toArray(n), a = i.find(MR);
  if (a) {
    const o = a.props.children, s = i.map((c) => c === a ? x.Children.count(o) > 1 ? x.Children.only(null) : x.isValidElement(o) ? o.props.children : null : c);
    return /* @__PURE__ */ O.jsx(fh, { ...r, ref: t, children: x.isValidElement(o) ? x.cloneElement(o, void 0, s) : null });
  }
  return /* @__PURE__ */ O.jsx(fh, { ...r, ref: t, children: n });
});
FS.displayName = "Slot";
var fh = x.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  if (x.isValidElement(n)) {
    const i = LR(n);
    return x.cloneElement(n, {
      ...FR(r, n.props),
      // @ts-ignore
      ref: t ? jR(t, i) : i
    });
  }
  return x.Children.count(n) > 1 ? x.Children.only(null) : null;
});
fh.displayName = "SlotClone";
var NR = ({ children: e }) => /* @__PURE__ */ O.jsx(O.Fragment, { children: e });
function MR(e) {
  return x.isValidElement(e) && e.type === NR;
}
function FR(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? i && a ? n[r] = (...s) => {
      a(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...a } : r === "className" && (n[r] = [i, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function LR(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var BR = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], Qm = BR.reduce((e, t) => {
  const n = x.forwardRef((r, i) => {
    const { asChild: a, ...o } = r, s = a ? FS : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ O.jsx(s, { ...o, ref: i });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {}), ev = "Avatar", [UR, Ffe] = AR(ev), [zR, LS] = UR(ev), tv = x.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, ...r } = e, [i, a] = x.useState("idle");
    return /* @__PURE__ */ O.jsx(
      zR,
      {
        scope: n,
        imageLoadingStatus: i,
        onImageLoadingStatusChange: a,
        children: /* @__PURE__ */ O.jsx(Qm.span, { ...r, ref: t })
      }
    );
  }
);
tv.displayName = ev;
var BS = "AvatarImage", nv = x.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, src: r, onLoadingStatusChange: i = () => {
    }, ...a } = e, o = LS(BS, n), s = qR(r), c = _i((l) => {
      i(l), o.onImageLoadingStatusChange(l);
    });
    return Za(() => {
      s !== "idle" && c(s);
    }, [s, c]), s === "loaded" ? /* @__PURE__ */ O.jsx(Qm.img, { ...a, ref: t, src: r }) : null;
  }
);
nv.displayName = BS;
var US = "AvatarFallback", rv = x.forwardRef(
  (e, t) => {
    const { __scopeAvatar: n, delayMs: r, ...i } = e, a = LS(US, n), [o, s] = x.useState(r === void 0);
    return x.useEffect(() => {
      if (r !== void 0) {
        const c = window.setTimeout(() => s(!0), r);
        return () => window.clearTimeout(c);
      }
    }, [r]), o && a.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ O.jsx(Qm.span, { ...i, ref: t }) : null;
  }
);
rv.displayName = US;
function qR(e) {
  const [t, n] = x.useState("idle");
  return Za(() => {
    if (!e) {
      n("error");
      return;
    }
    let r = !0;
    const i = new window.Image(), a = (o) => () => {
      r && n(o);
    };
    return n("loading"), i.onload = a("loaded"), i.onerror = a("error"), i.src = e, () => {
      r = !1;
    };
  }, [e]), t;
}
function dh(e) {
  if (!/^#?([a-fA-F\d]{6}|[a-fA-F\d]{3})$/.test(e))
    return { r: 0, g: 0, b: 0 };
  const n = e.replace(/^#/, "");
  let r = n;
  n.length === 3 && (r = n.split("").map((c) => c + c).join(""));
  const i = parseInt(r, 16), a = i >> 16 & 255, o = i >> 8 & 255, s = i & 255;
  return { r: a, g: o, b: s };
}
function WR(e) {
  return `#${((1 << 24) + (e.r << 16) + (e.g << 8) + e.b).toString(16).slice(1)}`;
}
const VR = (e, t = 30) => {
  const n = Math.min(e.r, e.g, e.b), r = Math.max(e.r, e.g, e.b, n + 1);
  return {
    r: Math.floor((e.r - n) / (r - n) * t * (1 - 0.299) + 120 - t / 2),
    g: Math.floor((e.g - n) / (r - n) * t * (1 - 0.587) + 120 - t / 2),
    b: Math.floor((e.b - n) / (r - n) * t * (1 - 0.114) + 120 - t / 2)
  };
};
function Cg(e) {
  return Object.entries(e).reduce((t, [n, r]) => {
    const i = n.replace(/(\d+)/, (a) => (1e3 - parseInt(a)).toString());
    return { ...t, [i]: r };
  }, {});
}
const HR = 2.4, ZR = 0.2126729, KR = 0.7151522, GR = 0.072175, YR = 0.56, JR = 0.57, XR = 0.62, QR = 0.65, Ml = 0.022, Og = 1.414, eI = 1.14, tI = 1.14, nI = 0.035991, rI = 0.035991, iI = 27.7847239587675, aI = 27.7847239587675, $g = 0.027, Rg = 0.027, Ig = 1e-3, oI = 5e-4;
function Ag(e) {
  const { r: t, g: n, b: r } = e, i = (a) => (a / 255) ** HR;
  return ZR * i(t) + KR * i(n) + GR * i(r);
}
function Pg(e, t) {
  if (!e || !t)
    return 0;
  let n = Ag(dh(e)), r = Ag(dh(t)), i = 0, a = 0;
  return n = n > Ml ? n : n + (Ml - n) ** Og, r = r > Ml ? r : r + (Ml - r) ** Og, Math.abs(r - n) < oI ? 0 : (r > n ? (i = (r ** YR - n ** JR) * eI, a = i < Ig ? 0 : i < nI ? i - i * iI * $g : i - $g) : (i = (r ** QR - n ** XR) * tI, a = i > -Ig ? 0 : i > -rI ? i - i * aI * Rg : i + Rg), Math.abs(a * 100));
}
let Wu = class {
  constructor() {
    Ee(this, "eventMap");
    this.eventMap = {};
  }
  on(t, n) {
    var r;
    return this.eventMap[t] || (this.eventMap[t] = /* @__PURE__ */ new Set()), (r = this.eventMap[t]) == null || r.add(n), () => {
      var i;
      (i = this.eventMap[t]) == null || i.delete(n);
    };
  }
  emit(t, n) {
    var r, i;
    (r = this.eventMap[t]) == null || r.forEach((a) => {
      a(n);
    }), (i = this.eventMap["*"]) == null || i.forEach((a) => {
      a({ type: t, payload: n });
    });
  }
};
const sI = new Wu();
function Dg(e, t) {
  let n = `${e} {`;
  for (const [r, i] of Object.entries(t))
    n += `${r}: ${i}; `;
  return n += "}", n;
}
function zS(e, t) {
  let n = 0;
  if (e.length == 0)
    return n;
  for (let r = 0; r < e.length; r++) {
    const i = e.charCodeAt(r);
    n = (n << 5) - n + i, n = n & n;
  }
  return Math.abs(n) % t;
}
var qS = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(yt, function() {
    var n = 1e3, r = 6e4, i = 36e5, a = "millisecond", o = "second", s = "minute", c = "hour", l = "day", u = "week", f = "month", d = "quarter", p = "year", m = "date", h = "Invalid Date", y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, v = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, b = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(R) {
      var A = ["th", "st", "nd", "rd"], F = R % 100;
      return "[" + R + (A[(F - 20) % 10] || A[F] || A[0]) + "]";
    } }, w = function(R, A, F) {
      var H = String(R);
      return !H || H.length >= A ? R : "" + Array(A + 1 - H.length).join(F) + R;
    }, T = { s: w, z: function(R) {
      var A = -R.utcOffset(), F = Math.abs(A), H = Math.floor(F / 60), V = F % 60;
      return (A <= 0 ? "+" : "-") + w(H, 2, "0") + ":" + w(V, 2, "0");
    }, m: function R(A, F) {
      if (A.date() < F.date()) return -R(F, A);
      var H = 12 * (F.year() - A.year()) + (F.month() - A.month()), V = A.clone().add(H, f), I = F - V < 0, g = A.clone().add(H + (I ? -1 : 1), f);
      return +(-(H + (F - V) / (I ? V - g : g - V)) || 0);
    }, a: function(R) {
      return R < 0 ? Math.ceil(R) || 0 : Math.floor(R);
    }, p: function(R) {
      return { M: f, y: p, w: u, d: l, D: m, h: c, m: s, s: o, ms: a, Q: d }[R] || String(R || "").toLowerCase().replace(/s$/, "");
    }, u: function(R) {
      return R === void 0;
    } }, E = "en", _ = {};
    _[E] = b;
    var $ = "$isDayjsObject", B = function(R) {
      return R instanceof q || !(!R || !R[$]);
    }, U = function R(A, F, H) {
      var V;
      if (!A) return E;
      if (typeof A == "string") {
        var I = A.toLowerCase();
        _[I] && (V = I), F && (_[I] = F, V = I);
        var g = A.split("-");
        if (!V && g.length > 1) return R(g[0]);
      } else {
        var j = A.name;
        _[j] = A, V = j;
      }
      return !H && V && (E = V), V || !H && E;
    }, k = function(R, A) {
      if (B(R)) return R.clone();
      var F = typeof A == "object" ? A : {};
      return F.date = R, F.args = arguments, new q(F);
    }, D = T;
    D.l = U, D.i = B, D.w = function(R, A) {
      return k(R, { locale: A.$L, utc: A.$u, x: A.$x, $offset: A.$offset });
    };
    var q = function() {
      function R(F) {
        this.$L = U(F.locale, null, !0), this.parse(F), this.$x = this.$x || F.x || {}, this[$] = !0;
      }
      var A = R.prototype;
      return A.parse = function(F) {
        this.$d = function(H) {
          var V = H.date, I = H.utc;
          if (V === null) return /* @__PURE__ */ new Date(NaN);
          if (D.u(V)) return /* @__PURE__ */ new Date();
          if (V instanceof Date) return new Date(V);
          if (typeof V == "string" && !/Z$/i.test(V)) {
            var g = V.match(y);
            if (g) {
              var j = g[2] - 1 || 0, W = (g[7] || "0").substring(0, 3);
              return I ? new Date(Date.UTC(g[1], j, g[3] || 1, g[4] || 0, g[5] || 0, g[6] || 0, W)) : new Date(g[1], j, g[3] || 1, g[4] || 0, g[5] || 0, g[6] || 0, W);
            }
          }
          return new Date(V);
        }(F), this.init();
      }, A.init = function() {
        var F = this.$d;
        this.$y = F.getFullYear(), this.$M = F.getMonth(), this.$D = F.getDate(), this.$W = F.getDay(), this.$H = F.getHours(), this.$m = F.getMinutes(), this.$s = F.getSeconds(), this.$ms = F.getMilliseconds();
      }, A.$utils = function() {
        return D;
      }, A.isValid = function() {
        return this.$d.toString() !== h;
      }, A.isSame = function(F, H) {
        var V = k(F);
        return this.startOf(H) <= V && V <= this.endOf(H);
      }, A.isAfter = function(F, H) {
        return k(F) < this.startOf(H);
      }, A.isBefore = function(F, H) {
        return this.endOf(H) < k(F);
      }, A.$g = function(F, H, V) {
        return D.u(F) ? this[H] : this.set(V, F);
      }, A.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, A.valueOf = function() {
        return this.$d.getTime();
      }, A.startOf = function(F, H) {
        var V = this, I = !!D.u(H) || H, g = D.p(F), j = function(ae, J) {
          var Q = D.w(V.$u ? Date.UTC(V.$y, J, ae) : new Date(V.$y, J, ae), V);
          return I ? Q : Q.endOf(l);
        }, W = function(ae, J) {
          return D.w(V.toDate()[ae].apply(V.toDate("s"), (I ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(J)), V);
        }, S = this.$W, Z = this.$M, Y = this.$D, G = "set" + (this.$u ? "UTC" : "");
        switch (g) {
          case p:
            return I ? j(1, 0) : j(31, 11);
          case f:
            return I ? j(1, Z) : j(0, Z + 1);
          case u:
            var X = this.$locale().weekStart || 0, ie = (S < X ? S + 7 : S) - X;
            return j(I ? Y - ie : Y + (6 - ie), Z);
          case l:
          case m:
            return W(G + "Hours", 0);
          case c:
            return W(G + "Minutes", 1);
          case s:
            return W(G + "Seconds", 2);
          case o:
            return W(G + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, A.endOf = function(F) {
        return this.startOf(F, !1);
      }, A.$set = function(F, H) {
        var V, I = D.p(F), g = "set" + (this.$u ? "UTC" : ""), j = (V = {}, V[l] = g + "Date", V[m] = g + "Date", V[f] = g + "Month", V[p] = g + "FullYear", V[c] = g + "Hours", V[s] = g + "Minutes", V[o] = g + "Seconds", V[a] = g + "Milliseconds", V)[I], W = I === l ? this.$D + (H - this.$W) : H;
        if (I === f || I === p) {
          var S = this.clone().set(m, 1);
          S.$d[j](W), S.init(), this.$d = S.set(m, Math.min(this.$D, S.daysInMonth())).$d;
        } else j && this.$d[j](W);
        return this.init(), this;
      }, A.set = function(F, H) {
        return this.clone().$set(F, H);
      }, A.get = function(F) {
        return this[D.p(F)]();
      }, A.add = function(F, H) {
        var V, I = this;
        F = Number(F);
        var g = D.p(H), j = function(Z) {
          var Y = k(I);
          return D.w(Y.date(Y.date() + Math.round(Z * F)), I);
        };
        if (g === f) return this.set(f, this.$M + F);
        if (g === p) return this.set(p, this.$y + F);
        if (g === l) return j(1);
        if (g === u) return j(7);
        var W = (V = {}, V[s] = r, V[c] = i, V[o] = n, V)[g] || 1, S = this.$d.getTime() + F * W;
        return D.w(S, this);
      }, A.subtract = function(F, H) {
        return this.add(-1 * F, H);
      }, A.format = function(F) {
        var H = this, V = this.$locale();
        if (!this.isValid()) return V.invalidDate || h;
        var I = F || "YYYY-MM-DDTHH:mm:ssZ", g = D.z(this), j = this.$H, W = this.$m, S = this.$M, Z = V.weekdays, Y = V.months, G = V.meridiem, X = function(J, Q, K, fe) {
          return J && (J[Q] || J(H, I)) || K[Q].slice(0, fe);
        }, ie = function(J) {
          return D.s(j % 12 || 12, J, "0");
        }, ae = G || function(J, Q, K) {
          var fe = J < 12 ? "AM" : "PM";
          return K ? fe.toLowerCase() : fe;
        };
        return I.replace(v, function(J, Q) {
          return Q || function(K) {
            switch (K) {
              case "YY":
                return String(H.$y).slice(-2);
              case "YYYY":
                return D.s(H.$y, 4, "0");
              case "M":
                return S + 1;
              case "MM":
                return D.s(S + 1, 2, "0");
              case "MMM":
                return X(V.monthsShort, S, Y, 3);
              case "MMMM":
                return X(Y, S);
              case "D":
                return H.$D;
              case "DD":
                return D.s(H.$D, 2, "0");
              case "d":
                return String(H.$W);
              case "dd":
                return X(V.weekdaysMin, H.$W, Z, 2);
              case "ddd":
                return X(V.weekdaysShort, H.$W, Z, 3);
              case "dddd":
                return Z[H.$W];
              case "H":
                return String(j);
              case "HH":
                return D.s(j, 2, "0");
              case "h":
                return ie(1);
              case "hh":
                return ie(2);
              case "a":
                return ae(j, W, !0);
              case "A":
                return ae(j, W, !1);
              case "m":
                return String(W);
              case "mm":
                return D.s(W, 2, "0");
              case "s":
                return String(H.$s);
              case "ss":
                return D.s(H.$s, 2, "0");
              case "SSS":
                return D.s(H.$ms, 3, "0");
              case "Z":
                return g;
            }
            return null;
          }(J) || g.replace(":", "");
        });
      }, A.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, A.diff = function(F, H, V) {
        var I, g = this, j = D.p(H), W = k(F), S = (W.utcOffset() - this.utcOffset()) * r, Z = this - W, Y = function() {
          return D.m(g, W);
        };
        switch (j) {
          case p:
            I = Y() / 12;
            break;
          case f:
            I = Y();
            break;
          case d:
            I = Y() / 3;
            break;
          case u:
            I = (Z - S) / 6048e5;
            break;
          case l:
            I = (Z - S) / 864e5;
            break;
          case c:
            I = Z / i;
            break;
          case s:
            I = Z / r;
            break;
          case o:
            I = Z / n;
            break;
          default:
            I = Z;
        }
        return V ? I : D.a(I);
      }, A.daysInMonth = function() {
        return this.endOf(f).$D;
      }, A.$locale = function() {
        return _[this.$L];
      }, A.locale = function(F, H) {
        if (!F) return this.$L;
        var V = this.clone(), I = U(F, H, !0);
        return I && (V.$L = I), V;
      }, A.clone = function() {
        return D.w(this.$d, this);
      }, A.toDate = function() {
        return new Date(this.valueOf());
      }, A.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, A.toISOString = function() {
        return this.$d.toISOString();
      }, A.toString = function() {
        return this.$d.toUTCString();
      }, R;
    }(), L = q.prototype;
    return k.prototype = L, [["$ms", a], ["$s", o], ["$m", s], ["$H", c], ["$W", l], ["$M", f], ["$y", p], ["$D", m]].forEach(function(R) {
      L[R[1]] = function(A) {
        return this.$g(A, R[0], R[1]);
      };
    }), k.extend = function(R, A) {
      return R.$i || (R(A, q, k), R.$i = !0), k;
    }, k.locale = U, k.isDayjs = B, k.unix = function(R) {
      return k(1e3 * R);
    }, k.en = _[E], k.Ls = _, k.p = {}, k;
  });
})(qS);
var lI = qS.exports;
const Vu = /* @__PURE__ */ Ye(lI);
var WS = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(yt, function() {
    return function(n, r, i) {
      r.prototype.isToday = function() {
        var a = "YYYY-MM-DD", o = i();
        return this.format(a) === o.format(a);
      };
    };
  });
})(WS);
var cI = WS.exports;
const uI = /* @__PURE__ */ Ye(cI);
var VS = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(yt, function() {
    return function(n, r, i) {
      r.prototype.isYesterday = function() {
        var a = "YYYY-MM-DD", o = i().subtract(1, "day");
        return this.format(a) === o.format(a);
      };
    };
  });
})(VS);
var fI = VS.exports;
const dI = /* @__PURE__ */ Ye(fI);
let Fl;
const pI = new Uint8Array(16);
function hI() {
  if (!Fl && (Fl = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Fl))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Fl(pI);
}
const sn = [];
for (let e = 0; e < 256; ++e)
  sn.push((e + 256).toString(16).slice(1));
function mI(e, t = 0) {
  return sn[e[t + 0]] + sn[e[t + 1]] + sn[e[t + 2]] + sn[e[t + 3]] + "-" + sn[e[t + 4]] + sn[e[t + 5]] + "-" + sn[e[t + 6]] + sn[e[t + 7]] + "-" + sn[e[t + 8]] + sn[e[t + 9]] + "-" + sn[e[t + 10]] + sn[e[t + 11]] + sn[e[t + 12]] + sn[e[t + 13]] + sn[e[t + 14]] + sn[e[t + 15]];
}
const vI = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), jg = {
  randomUUID: vI
};
function HS(e, t, n) {
  if (jg.randomUUID && !t && !e)
    return jg.randomUUID();
  e = e || {};
  const r = e.random || (e.rng || hI)();
  return r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, mI(r);
}
Vu.extend(uI);
Vu.extend(dI);
function yI(e, t = "day") {
  var r, i, a;
  if (!e || e.length === 0) return [];
  const n = [];
  (r = e[0]) != null && r.timestamp && n.push(Ng(e[0].timestamp));
  for (let o = 0; o < e.length; o++)
    if (e[o] && n.push(e[o]), o + 1 < e.length) {
      const s = (i = e[o]) == null ? void 0 : i.timestamp, c = (a = e[o + 1]) == null ? void 0 : a.timestamp;
      !Vu(s).isSame(c, t) && c && n.push(Ng(c));
    }
  return n;
}
function Ng(e) {
  return {
    id: HS(),
    direction: "system",
    sender: { name: "system" },
    timestamp: e,
    block: {
      type: "text",
      text: gI(e)
    }
  };
}
function gI(e, t = !1) {
  const n = Vu(e), r = "h:mma";
  return n.isToday() ? t ? `Today • ${n.format(r)}` : "Today" : n.isYesterday() ? t ? `Yesterday • ${n.format(r)}` : "Yesterday" : t ? n.format(`YYYY-MM-DD • ${r}`) : n.format("YYYY-MM-DD");
}
function bI(e = "") {
  if (typeof e != "string")
    throw new TypeError("Color should be string!");
  const t = /^#?([\da-f]{2})([\da-f]{2})([\da-f]{2})$/i.exec(e);
  if (t)
    return t.splice(1).map((r) => Number.parseInt(r, 16));
  const n = /^#?([\da-f])([\da-f])([\da-f])$/i.exec(e);
  if (n)
    return n.splice(1).map((r) => Number.parseInt(r + r, 16));
  if (e.includes(","))
    return e.split(",").map((r) => Number.parseInt(r));
  throw new Error("Invalid color format! Use #ABC or #AABBCC or r,g,b");
}
function wI(e) {
  return "#" + e.map((t) => `0${t.toString(16).toUpperCase()}`.slice(-2)).join("");
}
function xI(e, t) {
  return e.map((n) => Math.round(n + (255 - n) * t));
}
function SI(e, t) {
  return e.map((n) => Math.round(n * t));
}
const Do = (e) => (t) => xI(t, e), jo = (e) => (t) => SI(t, e), EI = {
  50: Do(0.95),
  100: Do(0.9),
  200: Do(0.75),
  300: Do(0.6),
  400: Do(0.3),
  500: (e) => e,
  600: jo(0.9),
  700: jo(0.6),
  800: jo(0.45),
  900: jo(0.3),
  950: jo(0.2)
};
function Mg(e, t = EI) {
  const n = {}, r = bI(e);
  for (const [i, a] of Object.entries(t))
    n[i] = wI(a(r));
  return n;
}
var st;
(function(e) {
  e.assertEqual = (i) => i;
  function t(i) {
  }
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (i) => {
    const a = {};
    for (const o of i)
      a[o] = o;
    return a;
  }, e.getValidEnumValues = (i) => {
    const a = e.objectKeys(i).filter((s) => typeof i[i[s]] != "number"), o = {};
    for (const s of a)
      o[s] = i[s];
    return e.objectValues(o);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(a) {
    return i[a];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const a = [];
    for (const o in i)
      Object.prototype.hasOwnProperty.call(i, o) && a.push(o);
    return a;
  }, e.find = (i, a) => {
    for (const o of i)
      if (a(o))
        return o;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function r(i, a = " | ") {
    return i.map((o) => typeof o == "string" ? `'${o}'` : o).join(a);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (i, a) => typeof a == "bigint" ? a.toString() : a;
})(st || (st = {}));
var ph;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(ph || (ph = {}));
const we = st.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), hi = (e) => {
  switch (typeof e) {
    case "undefined":
      return we.undefined;
    case "string":
      return we.string;
    case "number":
      return isNaN(e) ? we.nan : we.number;
    case "boolean":
      return we.boolean;
    case "function":
      return we.function;
    case "bigint":
      return we.bigint;
    case "symbol":
      return we.symbol;
    case "object":
      return Array.isArray(e) ? we.array : e === null ? we.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? we.promise : typeof Map < "u" && e instanceof Map ? we.map : typeof Set < "u" && e instanceof Set ? we.set : typeof Date < "u" && e instanceof Date ? we.date : we.object;
    default:
      return we.unknown;
  }
}, he = st.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), _I = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
let lr = class extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(a) {
      return a.message;
    }, r = { _errors: [] }, i = (a) => {
      for (const o of a.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(i);
        else if (o.code === "invalid_return_type")
          i(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          i(o.argumentsError);
        else if (o.path.length === 0)
          r._errors.push(n(o));
        else {
          let s = r, c = 0;
          for (; c < o.path.length; ) {
            const l = o.path[c];
            c === o.path.length - 1 ? (s[l] = s[l] || { _errors: [] }, s[l]._errors.push(n(o))) : s[l] = s[l] || { _errors: [] }, s = s[l], c++;
          }
        }
    };
    return i(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, st.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const i of this.issues)
      i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
};
lr.create = (e) => new lr(e);
const ds = (e, t) => {
  let n;
  switch (e.code) {
    case he.invalid_type:
      e.received === we.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case he.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, st.jsonStringifyReplacer)}`;
      break;
    case he.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${st.joinValues(e.keys, ", ")}`;
      break;
    case he.invalid_union:
      n = "Invalid input";
      break;
    case he.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${st.joinValues(e.options)}`;
      break;
    case he.invalid_enum_value:
      n = `Invalid enum value. Expected ${st.joinValues(e.options)}, received '${e.received}'`;
      break;
    case he.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case he.invalid_return_type:
      n = "Invalid function return type";
      break;
    case he.invalid_date:
      n = "Invalid date";
      break;
    case he.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : st.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case he.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case he.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case he.custom:
      n = "Invalid input";
      break;
    case he.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case he.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case he.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, st.assertNever(e);
  }
  return { message: n };
};
let ZS = ds;
function kI(e) {
  ZS = e;
}
function Vc() {
  return ZS;
}
const Hc = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: i } = e, a = [...n, ...i.path || []], o = {
    ...i,
    path: a
  };
  let s = "";
  const c = r.filter((l) => !!l).slice().reverse();
  for (const l of c)
    s = l(o, { data: t, defaultError: s }).message;
  return {
    ...i,
    path: a,
    message: i.message || s
  };
}, TI = [];
function ke(e, t) {
  const n = Hc({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      Vc(),
      ds
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(n);
}
let Rn = class KS {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const i of n) {
      if (i.status === "aborted")
        return Me;
      i.status === "dirty" && t.dirty(), r.push(i.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const i of n)
      r.push({
        key: await i.key,
        value: await i.value
      });
    return KS.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const i of n) {
      const { key: a, value: o } = i;
      if (a.status === "aborted" || o.status === "aborted")
        return Me;
      a.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), a.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (r[a.value] = o.value);
    }
    return { status: t.value, value: r };
  }
};
const Me = Object.freeze({
  status: "aborted"
}), GS = (e) => ({ status: "dirty", value: e }), Sn = (e) => ({ status: "valid", value: e }), hh = (e) => e.status === "aborted", mh = (e) => e.status === "dirty", ps = (e) => e.status === "valid", Zc = (e) => typeof Promise < "u" && e instanceof Promise;
var Ie;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(Ie || (Ie = {}));
let Dr = class {
  constructor(t, n, r, i) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
const Fg = (e, t) => {
  if (ps(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new lr(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function Le(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: i } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (o, s) => o.code !== "invalid_type" ? { message: s.defaultError } : typeof s.data > "u" ? { message: r ?? s.defaultError } : { message: n ?? s.defaultError }, description: i };
}
let qe = class {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return hi(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: hi(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Rn(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: hi(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (Zc(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const i = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: hi(t)
    }, a = this._parseSync({ data: t, path: i.path, parent: i });
    return Fg(i, a);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: hi(t)
    }, i = this._parse({ data: t, path: r.path, parent: r }), a = await (Zc(i) ? i : Promise.resolve(i));
    return Fg(r, a);
  }
  refine(t, n) {
    const r = (i) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(i) : n;
    return this._refinement((i, a) => {
      const o = t(i), s = () => a.addIssue({
        code: he.custom,
        ...r(i)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((c) => c ? !0 : (s(), !1)) : o ? !0 : (s(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, i) => t(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1));
  }
  _refinement(t) {
    return new fr({
      schema: this,
      typeName: Pe.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return Yr.create(this, this._def);
  }
  nullable() {
    return Qi.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return Xi.create(this, this._def);
  }
  promise() {
    return Ya.create(this, this._def);
  }
  or(t) {
    return ws.create([this, t], this._def);
  }
  and(t) {
    return xs.create(this, t, this._def);
  }
  transform(t) {
    return new fr({
      ...Le(this._def),
      schema: this,
      typeName: Pe.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new ks({
      ...Le(this._def),
      innerType: this,
      defaultValue: n,
      typeName: Pe.ZodDefault
    });
  }
  brand() {
    return new rE({
      typeName: Pe.ZodBranded,
      type: this,
      ...Le(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Xc({
      ...Le(this._def),
      innerType: this,
      catchValue: n,
      typeName: Pe.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return iv.create(this, t);
  }
  readonly() {
    return eu.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
const CI = /^c[^\s-]{8,}$/i, OI = /^[a-z][a-z0-9]*$/, $I = /^[0-9A-HJKMNP-TV-Z]{26}$/, RI = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, II = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, AI = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let Hf;
const PI = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, DI = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, jI = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function NI(e, t) {
  return !!((t === "v4" || !t) && PI.test(e) || (t === "v6" || !t) && DI.test(e));
}
let Ka = class Go extends qe {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== we.string) {
      const a = this._getOrReturnCtx(t);
      return ke(
        a,
        {
          code: he.invalid_type,
          expected: we.string,
          received: a.parsedType
        }
        //
      ), Me;
    }
    const r = new Rn();
    let i;
    for (const a of this._def.checks)
      if (a.kind === "min")
        t.data.length < a.value && (i = this._getOrReturnCtx(t, i), ke(i, {
          code: he.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "max")
        t.data.length > a.value && (i = this._getOrReturnCtx(t, i), ke(i, {
          code: he.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "length") {
        const o = t.data.length > a.value, s = t.data.length < a.value;
        (o || s) && (i = this._getOrReturnCtx(t, i), o ? ke(i, {
          code: he.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : s && ke(i, {
          code: he.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), r.dirty());
      } else if (a.kind === "email")
        II.test(t.data) || (i = this._getOrReturnCtx(t, i), ke(i, {
          validation: "email",
          code: he.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "emoji")
        Hf || (Hf = new RegExp(AI, "u")), Hf.test(t.data) || (i = this._getOrReturnCtx(t, i), ke(i, {
          validation: "emoji",
          code: he.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "uuid")
        RI.test(t.data) || (i = this._getOrReturnCtx(t, i), ke(i, {
          validation: "uuid",
          code: he.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid")
        CI.test(t.data) || (i = this._getOrReturnCtx(t, i), ke(i, {
          validation: "cuid",
          code: he.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid2")
        OI.test(t.data) || (i = this._getOrReturnCtx(t, i), ke(i, {
          validation: "cuid2",
          code: he.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "ulid")
        $I.test(t.data) || (i = this._getOrReturnCtx(t, i), ke(i, {
          validation: "ulid",
          code: he.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), ke(i, {
            validation: "url",
            code: he.invalid_string,
            message: a.message
          }), r.dirty();
        }
      else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), ke(i, {
        validation: "regex",
        code: he.invalid_string,
        message: a.message
      }), r.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (i = this._getOrReturnCtx(t, i), ke(i, {
        code: he.invalid_string,
        validation: { includes: a.value, position: a.position },
        message: a.message
      }), r.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (i = this._getOrReturnCtx(t, i), ke(i, {
        code: he.invalid_string,
        validation: { startsWith: a.value },
        message: a.message
      }), r.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (i = this._getOrReturnCtx(t, i), ke(i, {
        code: he.invalid_string,
        validation: { endsWith: a.value },
        message: a.message
      }), r.dirty()) : a.kind === "datetime" ? jI(a).test(t.data) || (i = this._getOrReturnCtx(t, i), ke(i, {
        code: he.invalid_string,
        validation: "datetime",
        message: a.message
      }), r.dirty()) : a.kind === "ip" ? NI(t.data, a.version) || (i = this._getOrReturnCtx(t, i), ke(i, {
        validation: "ip",
        code: he.invalid_string,
        message: a.message
      }), r.dirty()) : st.assertNever(a);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((i) => t.test(i), {
      validation: n,
      code: he.invalid_string,
      ...Ie.errToObj(r)
    });
  }
  _addCheck(t) {
    return new Go({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Ie.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Ie.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Ie.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Ie.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Ie.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Ie.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Ie.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Ie.errToObj(t) });
  }
  datetime(t) {
    var n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
      ...Ie.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...Ie.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...Ie.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...Ie.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...Ie.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...Ie.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...Ie.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...Ie.errToObj(n)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, Ie.errToObj(t));
  }
  trim() {
    return new Go({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new Go({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new Go({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
Ka.create = (e) => {
  var t;
  return new Ka({
    checks: [],
    typeName: Pe.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Le(e)
  });
};
function MI(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, i = n > r ? n : r, a = parseInt(e.toFixed(i).replace(".", "")), o = parseInt(t.toFixed(i).replace(".", ""));
  return a % o / Math.pow(10, i);
}
let hs = class vh extends qe {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== we.number) {
      const a = this._getOrReturnCtx(t);
      return ke(a, {
        code: he.invalid_type,
        expected: we.number,
        received: a.parsedType
      }), Me;
    }
    let r;
    const i = new Rn();
    for (const a of this._def.checks)
      a.kind === "int" ? st.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), ke(r, {
        code: he.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), i.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), ke(r, {
        code: he.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), ke(r, {
        code: he.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? MI(t.data, a.value) !== 0 && (r = this._getOrReturnCtx(t, r), ke(r, {
        code: he.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), ke(r, {
        code: he.not_finite,
        message: a.message
      }), i.dirty()) : st.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, Ie.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, Ie.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, Ie.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, Ie.toString(n));
  }
  setLimit(t, n, r, i) {
    return new vh({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: Ie.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new vh({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: Ie.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Ie.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Ie.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Ie.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Ie.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Ie.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: Ie.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Ie.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Ie.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && st.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
};
hs.create = (e) => new hs({
  checks: [],
  typeName: Pe.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Le(e)
});
let ms = class yh extends qe {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== we.bigint) {
      const a = this._getOrReturnCtx(t);
      return ke(a, {
        code: he.invalid_type,
        expected: we.bigint,
        received: a.parsedType
      }), Me;
    }
    let r;
    const i = new Rn();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), ke(r, {
        code: he.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), ke(r, {
        code: he.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), ke(r, {
        code: he.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : st.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, Ie.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, Ie.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, Ie.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, Ie.toString(n));
  }
  setLimit(t, n, r, i) {
    return new yh({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: Ie.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new yh({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Ie.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Ie.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Ie.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Ie.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Ie.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
ms.create = (e) => {
  var t;
  return new ms({
    checks: [],
    typeName: Pe.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Le(e)
  });
};
let vs = class extends qe {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== we.boolean) {
      const r = this._getOrReturnCtx(t);
      return ke(r, {
        code: he.invalid_type,
        expected: we.boolean,
        received: r.parsedType
      }), Me;
    }
    return Sn(t.data);
  }
};
vs.create = (e) => new vs({
  typeName: Pe.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Le(e)
});
let ys = class YS extends qe {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== we.date) {
      const a = this._getOrReturnCtx(t);
      return ke(a, {
        code: he.invalid_type,
        expected: we.date,
        received: a.parsedType
      }), Me;
    }
    if (isNaN(t.data.getTime())) {
      const a = this._getOrReturnCtx(t);
      return ke(a, {
        code: he.invalid_date
      }), Me;
    }
    const r = new Rn();
    let i;
    for (const a of this._def.checks)
      a.kind === "min" ? t.data.getTime() < a.value && (i = this._getOrReturnCtx(t, i), ke(i, {
        code: he.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), r.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (i = this._getOrReturnCtx(t, i), ke(i, {
        code: he.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), r.dirty()) : st.assertNever(a);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new YS({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Ie.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Ie.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
};
ys.create = (e) => new ys({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: Pe.ZodDate,
  ...Le(e)
});
let Kc = class extends qe {
  _parse(t) {
    if (this._getType(t) !== we.symbol) {
      const r = this._getOrReturnCtx(t);
      return ke(r, {
        code: he.invalid_type,
        expected: we.symbol,
        received: r.parsedType
      }), Me;
    }
    return Sn(t.data);
  }
};
Kc.create = (e) => new Kc({
  typeName: Pe.ZodSymbol,
  ...Le(e)
});
let gs = class extends qe {
  _parse(t) {
    if (this._getType(t) !== we.undefined) {
      const r = this._getOrReturnCtx(t);
      return ke(r, {
        code: he.invalid_type,
        expected: we.undefined,
        received: r.parsedType
      }), Me;
    }
    return Sn(t.data);
  }
};
gs.create = (e) => new gs({
  typeName: Pe.ZodUndefined,
  ...Le(e)
});
let bs = class extends qe {
  _parse(t) {
    if (this._getType(t) !== we.null) {
      const r = this._getOrReturnCtx(t);
      return ke(r, {
        code: he.invalid_type,
        expected: we.null,
        received: r.parsedType
      }), Me;
    }
    return Sn(t.data);
  }
};
bs.create = (e) => new bs({
  typeName: Pe.ZodNull,
  ...Le(e)
});
let Ga = class extends qe {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Sn(t.data);
  }
};
Ga.create = (e) => new Ga({
  typeName: Pe.ZodAny,
  ...Le(e)
});
let Hi = class extends qe {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Sn(t.data);
  }
};
Hi.create = (e) => new Hi({
  typeName: Pe.ZodUnknown,
  ...Le(e)
});
let ei = class extends qe {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return ke(n, {
      code: he.invalid_type,
      expected: we.never,
      received: n.parsedType
    }), Me;
  }
};
ei.create = (e) => new ei({
  typeName: Pe.ZodNever,
  ...Le(e)
});
let Gc = class extends qe {
  _parse(t) {
    if (this._getType(t) !== we.undefined) {
      const r = this._getOrReturnCtx(t);
      return ke(r, {
        code: he.invalid_type,
        expected: we.void,
        received: r.parsedType
      }), Me;
    }
    return Sn(t.data);
  }
};
Gc.create = (e) => new Gc({
  typeName: Pe.ZodVoid,
  ...Le(e)
});
let Xi = class gc extends qe {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), i = this._def;
    if (n.parsedType !== we.array)
      return ke(n, {
        code: he.invalid_type,
        expected: we.array,
        received: n.parsedType
      }), Me;
    if (i.exactLength !== null) {
      const o = n.data.length > i.exactLength.value, s = n.data.length < i.exactLength.value;
      (o || s) && (ke(n, {
        code: o ? he.too_big : he.too_small,
        minimum: s ? i.exactLength.value : void 0,
        maximum: o ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), r.dirty());
    }
    if (i.minLength !== null && n.data.length < i.minLength.value && (ke(n, {
      code: he.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), r.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (ke(n, {
      code: he.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((o, s) => i.type._parseAsync(new Dr(n, o, n.path, s)))).then((o) => Rn.mergeArray(r, o));
    const a = [...n.data].map((o, s) => i.type._parseSync(new Dr(n, o, n.path, s)));
    return Rn.mergeArray(r, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new gc({
      ...this._def,
      minLength: { value: t, message: Ie.toString(n) }
    });
  }
  max(t, n) {
    return new gc({
      ...this._def,
      maxLength: { value: t, message: Ie.toString(n) }
    });
  }
  length(t, n) {
    return new gc({
      ...this._def,
      exactLength: { value: t, message: Ie.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
Xi.create = (e, t) => new Xi({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: Pe.ZodArray,
  ...Le(t)
});
function Ca(e) {
  if (e instanceof Yn) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = Yr.create(Ca(r));
    }
    return new Yn({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof Xi ? new Xi({
    ...e._def,
    type: Ca(e.element)
  }) : e instanceof Yr ? Yr.create(Ca(e.unwrap())) : e instanceof Qi ? Qi.create(Ca(e.unwrap())) : e instanceof ki ? ki.create(e.items.map((t) => Ca(t))) : e;
}
let Yn = class tr extends qe {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = st.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== we.object) {
      const l = this._getOrReturnCtx(t);
      return ke(l, {
        code: he.invalid_type,
        expected: we.object,
        received: l.parsedType
      }), Me;
    }
    const { status: r, ctx: i } = this._processInputParams(t), { shape: a, keys: o } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof ei && this._def.unknownKeys === "strip"))
      for (const l in i.data)
        o.includes(l) || s.push(l);
    const c = [];
    for (const l of o) {
      const u = a[l], f = i.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: u._parse(new Dr(i, f, i.path, l)),
        alwaysSet: l in i.data
      });
    }
    if (this._def.catchall instanceof ei) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const u of s)
          c.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: i.data[u] }
          });
      else if (l === "strict")
        s.length > 0 && (ke(i, {
          code: he.unrecognized_keys,
          keys: s
        }), r.dirty());
      else if (l !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const u of s) {
        const f = i.data[u];
        c.push({
          key: { status: "valid", value: u },
          value: l._parse(
            new Dr(i, f, i.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const u of c) {
        const f = await u.key;
        l.push({
          key: f,
          value: await u.value,
          alwaysSet: u.alwaysSet
        });
      }
      return l;
    }).then((l) => Rn.mergeObjectSync(r, l)) : Rn.mergeObjectSync(r, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return Ie.errToObj, new tr({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var i, a, o, s;
          const c = (o = (a = (i = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(i, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (s = Ie.errToObj(t).message) !== null && s !== void 0 ? s : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new tr({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new tr({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new tr({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new tr({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: Pe.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new tr({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return st.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new tr({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return st.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new tr({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Ca(this);
  }
  partial(t) {
    const n = {};
    return st.objectKeys(this.shape).forEach((r) => {
      const i = this.shape[r];
      t && !t[r] ? n[r] = i : n[r] = i.optional();
    }), new tr({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return st.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let a = this.shape[r];
        for (; a instanceof Yr; )
          a = a._def.innerType;
        n[r] = a;
      }
    }), new tr({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return nE(st.objectKeys(this.shape));
  }
};
Yn.create = (e, t) => new Yn({
  shape: () => e,
  unknownKeys: "strip",
  catchall: ei.create(),
  typeName: Pe.ZodObject,
  ...Le(t)
});
Yn.strictCreate = (e, t) => new Yn({
  shape: () => e,
  unknownKeys: "strict",
  catchall: ei.create(),
  typeName: Pe.ZodObject,
  ...Le(t)
});
Yn.lazycreate = (e, t) => new Yn({
  shape: e,
  unknownKeys: "strip",
  catchall: ei.create(),
  typeName: Pe.ZodObject,
  ...Le(t)
});
let ws = class extends qe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function i(a) {
      for (const s of a)
        if (s.result.status === "valid")
          return s.result;
      for (const s of a)
        if (s.result.status === "dirty")
          return n.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((s) => new lr(s.ctx.common.issues));
      return ke(n, {
        code: he.invalid_union,
        unionErrors: o
      }), Me;
    }
    if (n.common.async)
      return Promise.all(r.map(async (a) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(i);
    {
      let a;
      const o = [];
      for (const c of r) {
        const l = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, u = c._parseSync({
          data: n.data,
          path: n.path,
          parent: l
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !a && (a = { result: u, ctx: l }), l.common.issues.length && o.push(l.common.issues);
      }
      if (a)
        return n.common.issues.push(...a.ctx.common.issues), a.result;
      const s = o.map((c) => new lr(c));
      return ke(n, {
        code: he.invalid_union,
        unionErrors: s
      }), Me;
    }
  }
  get options() {
    return this._def.options;
  }
};
ws.create = (e, t) => new ws({
  options: e,
  typeName: Pe.ZodUnion,
  ...Le(t)
});
const bc = (e) => e instanceof Ss ? bc(e.schema) : e instanceof fr ? bc(e.innerType()) : e instanceof Es ? [e.value] : e instanceof nl ? e.options : e instanceof _s ? Object.keys(e.enum) : e instanceof ks ? bc(e._def.innerType) : e instanceof gs ? [void 0] : e instanceof bs ? [null] : null;
let JS = class XS extends qe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== we.object)
      return ke(n, {
        code: he.invalid_type,
        expected: we.object,
        received: n.parsedType
      }), Me;
    const r = this.discriminator, i = n.data[r], a = this.optionsMap.get(i);
    return a ? n.common.async ? a._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : a._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (ke(n, {
      code: he.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), Me);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const i = /* @__PURE__ */ new Map();
    for (const a of n) {
      const o = bc(a.shape[t]);
      if (!o)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const s of o) {
        if (i.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        i.set(s, a);
      }
    }
    return new XS({
      typeName: Pe.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: i,
      ...Le(r)
    });
  }
};
function gh(e, t) {
  const n = hi(e), r = hi(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === we.object && r === we.object) {
    const i = st.objectKeys(t), a = st.objectKeys(e).filter((s) => i.indexOf(s) !== -1), o = { ...e, ...t };
    for (const s of a) {
      const c = gh(e[s], t[s]);
      if (!c.valid)
        return { valid: !1 };
      o[s] = c.data;
    }
    return { valid: !0, data: o };
  } else if (n === we.array && r === we.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let a = 0; a < e.length; a++) {
      const o = e[a], s = t[a], c = gh(o, s);
      if (!c.valid)
        return { valid: !1 };
      i.push(c.data);
    }
    return { valid: !0, data: i };
  } else return n === we.date && r === we.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
let xs = class extends qe {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = (a, o) => {
      if (hh(a) || hh(o))
        return Me;
      const s = gh(a.value, o.value);
      return s.valid ? ((mh(a) || mh(o)) && n.dirty(), { status: n.value, value: s.data }) : (ke(r, {
        code: he.invalid_intersection_types
      }), Me);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([a, o]) => i(a, o)) : i(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
};
xs.create = (e, t, n) => new xs({
  left: e,
  right: t,
  typeName: Pe.ZodIntersection,
  ...Le(n)
});
let ki = class QS extends qe {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== we.array)
      return ke(r, {
        code: he.invalid_type,
        expected: we.array,
        received: r.parsedType
      }), Me;
    if (r.data.length < this._def.items.length)
      return ke(r, {
        code: he.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Me;
    !this._def.rest && r.data.length > this._def.items.length && (ke(r, {
      code: he.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const a = [...r.data].map((o, s) => {
      const c = this._def.items[s] || this._def.rest;
      return c ? c._parse(new Dr(r, o, r.path, s)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(a).then((o) => Rn.mergeArray(n, o)) : Rn.mergeArray(n, a);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new QS({
      ...this._def,
      rest: t
    });
  }
};
ki.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ki({
    items: e,
    typeName: Pe.ZodTuple,
    rest: null,
    ...Le(t)
  });
};
let eE = class bh extends qe {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== we.object)
      return ke(r, {
        code: he.invalid_type,
        expected: we.object,
        received: r.parsedType
      }), Me;
    const i = [], a = this._def.keyType, o = this._def.valueType;
    for (const s in r.data)
      i.push({
        key: a._parse(new Dr(r, s, r.path, s)),
        value: o._parse(new Dr(r, r.data[s], r.path, s))
      });
    return r.common.async ? Rn.mergeObjectAsync(n, i) : Rn.mergeObjectSync(n, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof qe ? new bh({
      keyType: t,
      valueType: n,
      typeName: Pe.ZodRecord,
      ...Le(r)
    }) : new bh({
      keyType: Ka.create(),
      valueType: t,
      typeName: Pe.ZodRecord,
      ...Le(n)
    });
  }
}, Yc = class extends qe {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== we.map)
      return ke(r, {
        code: he.invalid_type,
        expected: we.map,
        received: r.parsedType
      }), Me;
    const i = this._def.keyType, a = this._def.valueType, o = [...r.data.entries()].map(([s, c], l) => ({
      key: i._parse(new Dr(r, s, r.path, [l, "key"])),
      value: a._parse(new Dr(r, c, r.path, [l, "value"]))
    }));
    if (r.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of o) {
          const l = await c.key, u = await c.value;
          if (l.status === "aborted" || u.status === "aborted")
            return Me;
          (l.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(l.value, u.value);
        }
        return { status: n.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const c of o) {
        const l = c.key, u = c.value;
        if (l.status === "aborted" || u.status === "aborted")
          return Me;
        (l.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(l.value, u.value);
      }
      return { status: n.value, value: s };
    }
  }
};
Yc.create = (e, t, n) => new Yc({
  valueType: t,
  keyType: e,
  typeName: Pe.ZodMap,
  ...Le(n)
});
let Jc = class wh extends qe {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== we.set)
      return ke(r, {
        code: he.invalid_type,
        expected: we.set,
        received: r.parsedType
      }), Me;
    const i = this._def;
    i.minSize !== null && r.data.size < i.minSize.value && (ke(r, {
      code: he.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), n.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (ke(r, {
      code: he.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), n.dirty());
    const a = this._def.valueType;
    function o(c) {
      const l = /* @__PURE__ */ new Set();
      for (const u of c) {
        if (u.status === "aborted")
          return Me;
        u.status === "dirty" && n.dirty(), l.add(u.value);
      }
      return { status: n.value, value: l };
    }
    const s = [...r.data.values()].map((c, l) => a._parse(new Dr(r, c, r.path, l)));
    return r.common.async ? Promise.all(s).then((c) => o(c)) : o(s);
  }
  min(t, n) {
    return new wh({
      ...this._def,
      minSize: { value: t, message: Ie.toString(n) }
    });
  }
  max(t, n) {
    return new wh({
      ...this._def,
      maxSize: { value: t, message: Ie.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
Jc.create = (e, t) => new Jc({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: Pe.ZodSet,
  ...Le(t)
});
let tE = class wc extends qe {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== we.function)
      return ke(n, {
        code: he.invalid_type,
        expected: we.function,
        received: n.parsedType
      }), Me;
    function r(s, c) {
      return Hc({
        data: s,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Vc(),
          ds
        ].filter((l) => !!l),
        issueData: {
          code: he.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function i(s, c) {
      return Hc({
        data: s,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Vc(),
          ds
        ].filter((l) => !!l),
        issueData: {
          code: he.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const a = { errorMap: n.common.contextualErrorMap }, o = n.data;
    if (this._def.returns instanceof Ya) {
      const s = this;
      return Sn(async function(...c) {
        const l = new lr([]), u = await s._def.args.parseAsync(c, a).catch((p) => {
          throw l.addIssue(r(c, p)), l;
        }), f = await Reflect.apply(o, this, u);
        return await s._def.returns._def.type.parseAsync(f, a).catch((p) => {
          throw l.addIssue(i(f, p)), l;
        });
      });
    } else {
      const s = this;
      return Sn(function(...c) {
        const l = s._def.args.safeParse(c, a);
        if (!l.success)
          throw new lr([r(c, l.error)]);
        const u = Reflect.apply(o, this, l.data), f = s._def.returns.safeParse(u, a);
        if (!f.success)
          throw new lr([i(u, f.error)]);
        return f.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new wc({
      ...this._def,
      args: ki.create(t).rest(Hi.create())
    });
  }
  returns(t) {
    return new wc({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new wc({
      args: t || ki.create([]).rest(Hi.create()),
      returns: n || Hi.create(),
      typeName: Pe.ZodFunction,
      ...Le(r)
    });
  }
}, Ss = class extends qe {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
};
Ss.create = (e, t) => new Ss({
  getter: e,
  typeName: Pe.ZodLazy,
  ...Le(t)
});
let Es = class extends qe {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return ke(n, {
        received: n.data,
        code: he.invalid_literal,
        expected: this._def.value
      }), Me;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
};
Es.create = (e, t) => new Es({
  value: e,
  typeName: Pe.ZodLiteral,
  ...Le(t)
});
function nE(e, t) {
  return new nl({
    values: e,
    typeName: Pe.ZodEnum,
    ...Le(t)
  });
}
let nl = class xh extends qe {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return ke(n, {
        expected: st.joinValues(r),
        received: n.parsedType,
        code: he.invalid_type
      }), Me;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return ke(n, {
        received: n.data,
        code: he.invalid_enum_value,
        options: r
      }), Me;
    }
    return Sn(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t) {
    return xh.create(t);
  }
  exclude(t) {
    return xh.create(this.options.filter((n) => !t.includes(n)));
  }
};
nl.create = nE;
let _s = class extends qe {
  _parse(t) {
    const n = st.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== we.string && r.parsedType !== we.number) {
      const i = st.objectValues(n);
      return ke(r, {
        expected: st.joinValues(i),
        received: r.parsedType,
        code: he.invalid_type
      }), Me;
    }
    if (n.indexOf(t.data) === -1) {
      const i = st.objectValues(n);
      return ke(r, {
        received: r.data,
        code: he.invalid_enum_value,
        options: i
      }), Me;
    }
    return Sn(t.data);
  }
  get enum() {
    return this._def.values;
  }
};
_s.create = (e, t) => new _s({
  values: e,
  typeName: Pe.ZodNativeEnum,
  ...Le(t)
});
let Ya = class extends qe {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== we.promise && n.common.async === !1)
      return ke(n, {
        code: he.invalid_type,
        expected: we.promise,
        received: n.parsedType
      }), Me;
    const r = n.parsedType === we.promise ? n.data : Promise.resolve(n.data);
    return Sn(r.then((i) => this._def.type.parseAsync(i, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
};
Ya.create = (e, t) => new Ya({
  type: e,
  typeName: Pe.ZodPromise,
  ...Le(t)
});
let fr = class extends qe {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Pe.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = this._def.effect || null, a = {
      addIssue: (o) => {
        ke(r, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), i.type === "preprocess") {
      const o = i.transform(r.data, a);
      return r.common.issues.length ? {
        status: "dirty",
        value: r.data
      } : r.common.async ? Promise.resolve(o).then((s) => this._def.schema._parseAsync({
        data: s,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: o,
        path: r.path,
        parent: r
      });
    }
    if (i.type === "refinement") {
      const o = (s) => {
        const c = i.refinement(s, a);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      };
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? Me : (s.status === "dirty" && n.dirty(), o(s.value), { status: n.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => s.status === "aborted" ? Me : (s.status === "dirty" && n.dirty(), o(s.value).then(() => ({ status: n.value, value: s.value }))));
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!ps(o))
          return o;
        const s = i.transform(o.value, a);
        if (s instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => ps(o) ? Promise.resolve(i.transform(o.value, a)).then((s) => ({ status: n.value, value: s })) : o);
    st.assertNever(i);
  }
};
fr.create = (e, t, n) => new fr({
  schema: e,
  typeName: Pe.ZodEffects,
  effect: t,
  ...Le(n)
});
fr.createWithPreprocess = (e, t, n) => new fr({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: Pe.ZodEffects,
  ...Le(n)
});
let Yr = class extends qe {
  _parse(t) {
    return this._getType(t) === we.undefined ? Sn(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Yr.create = (e, t) => new Yr({
  innerType: e,
  typeName: Pe.ZodOptional,
  ...Le(t)
});
let Qi = class extends qe {
  _parse(t) {
    return this._getType(t) === we.null ? Sn(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
Qi.create = (e, t) => new Qi({
  innerType: e,
  typeName: Pe.ZodNullable,
  ...Le(t)
});
let ks = class extends qe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === we.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ks.create = (e, t) => new ks({
  innerType: e,
  typeName: Pe.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...Le(t)
});
let Xc = class extends qe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return Zc(i) ? i.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new lr(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new lr(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
Xc.create = (e, t) => new Xc({
  innerType: e,
  typeName: Pe.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...Le(t)
});
let Qc = class extends qe {
  _parse(t) {
    if (this._getType(t) !== we.nan) {
      const r = this._getOrReturnCtx(t);
      return ke(r, {
        code: he.invalid_type,
        expected: we.nan,
        received: r.parsedType
      }), Me;
    }
    return { status: "valid", value: t.data };
  }
};
Qc.create = (e) => new Qc({
  typeName: Pe.ZodNaN,
  ...Le(e)
});
const FI = Symbol("zod_brand");
let rE = class extends qe {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}, iv = class iE extends qe {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? Me : a.status === "dirty" ? (n.dirty(), GS(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return i.status === "aborted" ? Me : i.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new iE({
      in: t,
      out: n,
      typeName: Pe.ZodPipeline
    });
  }
}, eu = class extends qe {
  _parse(t) {
    const n = this._def.innerType._parse(t);
    return ps(n) && (n.value = Object.freeze(n.value)), n;
  }
};
eu.create = (e, t) => new eu({
  innerType: e,
  typeName: Pe.ZodReadonly,
  ...Le(t)
});
const aE = (e, t = {}, n) => e ? Ga.create().superRefine((r, i) => {
  var a, o;
  if (!e(r)) {
    const s = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, c = (o = (a = s.fatal) !== null && a !== void 0 ? a : n) !== null && o !== void 0 ? o : !0, l = typeof s == "string" ? { message: s } : s;
    i.addIssue({ code: "custom", ...l, fatal: c });
  }
}) : Ga.create(), LI = {
  object: Yn.lazycreate
};
var Pe;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(Pe || (Pe = {}));
const BI = (e, t = {
  message: `Input not instance of ${e.name}`
}) => aE((n) => n instanceof e, t), oE = Ka.create, sE = hs.create, UI = Qc.create, zI = ms.create, lE = vs.create, qI = ys.create, WI = Kc.create, VI = gs.create, HI = bs.create, ZI = Ga.create, KI = Hi.create, GI = ei.create, YI = Gc.create, JI = Xi.create, XI = Yn.create, QI = Yn.strictCreate, eA = ws.create, tA = JS.create, nA = xs.create, rA = ki.create, iA = eE.create, aA = Yc.create, oA = Jc.create, sA = tE.create, lA = Ss.create, cA = Es.create, uA = nl.create, fA = _s.create, dA = Ya.create, Lg = fr.create, pA = Yr.create, hA = Qi.create, mA = fr.createWithPreprocess, vA = iv.create, yA = () => oE().optional(), gA = () => sE().optional(), bA = () => lE().optional(), wA = {
  string: (e) => Ka.create({ ...e, coerce: !0 }),
  number: (e) => hs.create({ ...e, coerce: !0 }),
  boolean: (e) => vs.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => ms.create({ ...e, coerce: !0 }),
  date: (e) => ys.create({ ...e, coerce: !0 })
}, xA = Me;
var _e = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: ds,
  setErrorMap: kI,
  getErrorMap: Vc,
  makeIssue: Hc,
  EMPTY_PATH: TI,
  addIssueToContext: ke,
  ParseStatus: Rn,
  INVALID: Me,
  DIRTY: GS,
  OK: Sn,
  isAborted: hh,
  isDirty: mh,
  isValid: ps,
  isAsync: Zc,
  get util() {
    return st;
  },
  get objectUtil() {
    return ph;
  },
  ZodParsedType: we,
  getParsedType: hi,
  ZodType: qe,
  ZodString: Ka,
  ZodNumber: hs,
  ZodBigInt: ms,
  ZodBoolean: vs,
  ZodDate: ys,
  ZodSymbol: Kc,
  ZodUndefined: gs,
  ZodNull: bs,
  ZodAny: Ga,
  ZodUnknown: Hi,
  ZodNever: ei,
  ZodVoid: Gc,
  ZodArray: Xi,
  ZodObject: Yn,
  ZodUnion: ws,
  ZodDiscriminatedUnion: JS,
  ZodIntersection: xs,
  ZodTuple: ki,
  ZodRecord: eE,
  ZodMap: Yc,
  ZodSet: Jc,
  ZodFunction: tE,
  ZodLazy: Ss,
  ZodLiteral: Es,
  ZodEnum: nl,
  ZodNativeEnum: _s,
  ZodPromise: Ya,
  ZodEffects: fr,
  ZodTransformer: fr,
  ZodOptional: Yr,
  ZodNullable: Qi,
  ZodDefault: ks,
  ZodCatch: Xc,
  ZodNaN: Qc,
  BRAND: FI,
  ZodBranded: rE,
  ZodPipeline: iv,
  ZodReadonly: eu,
  custom: aE,
  Schema: qe,
  ZodSchema: qe,
  late: LI,
  get ZodFirstPartyTypeKind() {
    return Pe;
  },
  coerce: wA,
  any: ZI,
  array: JI,
  bigint: zI,
  boolean: lE,
  date: qI,
  discriminatedUnion: tA,
  effect: Lg,
  enum: uA,
  function: sA,
  instanceof: BI,
  intersection: nA,
  lazy: lA,
  literal: cA,
  map: aA,
  nan: UI,
  nativeEnum: fA,
  never: GI,
  null: HI,
  nullable: hA,
  number: sE,
  object: XI,
  oboolean: bA,
  onumber: gA,
  optional: pA,
  ostring: yA,
  pipeline: vA,
  preprocess: mA,
  promise: dA,
  record: iA,
  set: oA,
  strictObject: QI,
  string: oE,
  symbol: WI,
  transformer: Lg,
  tuple: rA,
  undefined: VI,
  union: eA,
  unknown: KI,
  void: YI,
  NEVER: xA,
  ZodIssueCode: he,
  quotelessJson: _I,
  ZodError: lr
});
const No = _e.object({
  title: _e.string().optional(),
  link: _e.string().optional()
}), cE = _e.object({
  color: _e.string().optional(),
  variant: _e.enum(["soft", "solid"]).optional(),
  themeMode: _e.enum(["light", "dark"]).optional(),
  fontFamily: _e.enum(["rubik", "inter", "ibm", "fira"]).optional(),
  radius: _e.number().min(0.5).max(4).optional()
}), SA = _e.object({
  composerPlaceholder: _e.string().optional(),
  botName: _e.string().optional(),
  botAvatar: _e.string().optional(),
  botDescription: _e.string().optional(),
  website: No.optional(),
  email: No.optional(),
  phone: No.optional(),
  privacyPolicy: No.optional(),
  termsOfService: No.optional(),
  showPoweredBy: _e.boolean().optional(),
  storageLocation: _e.enum(["localStorage", "sessionStorage"]).optional()
}).merge(cE), EA = _e.enum([
  "heading1",
  "heading2",
  "heading3",
  "text",
  "horizontalRule",
  "link",
  "italic",
  "bold",
  "orderedList",
  "unorderedList",
  "listItem",
  "lineBreak",
  "pre"
]), _A = _e.object({}).passthrough().transform((e) => e), me = _e.object({
  className: _e.string().optional(),
  style: _A.optional()
}), Zf = _e.object({
  container: me.optional(),
  image: me.optional(),
  fallback: me.optional()
}), kA = _e.object({
  button: me.optional(),
  text: _e.record(EA, me.optional()),
  image: _e.object({
    image: me.optional(),
    placeholder: me.optional()
  }).optional(),
  audio: me.optional(),
  video: me.optional(),
  file: _e.object({
    container: me.optional(),
    title: me.optional(),
    icon: me.optional()
  }).optional(),
  location: _e.object({
    container: me.optional(),
    title: me.optional(),
    icon: me.optional()
  }).optional(),
  column: me.optional(),
  row: me.optional(),
  bubble: me.optional(),
  carousel: _e.object({
    container: me.optional(),
    slidesContainer: me.optional(),
    backButton: me.optional(),
    nextButton: me.optional()
  }).optional(),
  dropdown: _e.object({
    button: _e.object({
      container: me.optional(),
      icon: me.optional(),
      text: me.optional()
    }).optional(),
    content: _e.object({
      container: me.optional(),
      item: me.optional()
    }).optional()
  }).optional()
}), TA = _e.object({
  container: me.optional(),
  modal: _e.object({
    overlay: me.optional(),
    container: me.optional(),
    dialog: _e.object({
      container: me.optional(),
      title: _e.object({
        container: me.optional(),
        text: me.optional(),
        closeIcon: me.optional()
      }).optional(),
      content: me.optional(),
      newConversation: _e.object({
        text: me.optional(),
        button: me.optional()
      }).optional()
    }).optional()
  }).optional(),
  notification: _e.object({
    container: me.optional(),
    title: me.optional(),
    description: me.optional(),
    icon: me.optional(),
    closeIcon: me.optional()
  }).optional(),
  header: _e.object({
    container: me.optional(),
    content: _e.object({
      container: me.optional(),
      title: me.optional(),
      description: me.optional(),
      avatar: Zf.optional(),
      actions: _e.object({
        container: me.optional(),
        icons: me.optional()
      }).optional()
    }),
    expandedContent: _e.object({
      container: me.optional(),
      group: me.optional(),
      descriptionItems: _e.object({
        container: me.optional(),
        icon: me.optional(),
        text: me.optional(),
        link: me.optional(),
        poweredBy: me.optional()
      }).optional()
    }).optional(),
    description: _e.object({
      container: me.optional(),
      title: me.optional(),
      subtitle: me.optional()
    }).optional(),
    newConversationIcon: me.optional()
  }).optional(),
  composer: _e.object({
    container: me.optional(),
    input: me.optional(),
    uploadButton: _e.object({
      container: me.optional(),
      icon: me.optional()
    }).optional(),
    button: _e.object({
      container: me.optional(),
      icon: me.optional()
    }).optional()
  }).optional(),
  fab: _e.object({
    icon: me.optional(),
    container: me.optional()
  }).optional(),
  messageList: _e.object({
    scrollbar: _e.object({
      container: me.optional(),
      viewport: me.optional(),
      thumb: me.optional(),
      corner: me.optional(),
      background: me.optional()
    }).optional(),
    container: me.optional(),
    marquee: _e.object({
      content: me.optional(),
      title: me.optional(),
      description: me.optional(),
      avatar: Zf.optional(),
      container: me.optional()
    }).optional(),
    scrollDownButton: _e.object({
      container: me.optional(),
      button: me.optional(),
      icon: me.optional()
    }).optional()
  }).optional(),
  message: _e.object({
    container: me.optional(),
    avatar: Zf.optional(),
    blocks: kA.optional()
  }).optional(),
  loadingIndicator: _e.object({
    container: me.optional(),
    loader: me.optional()
  }).optional()
}), CA = _e.enum(["opened", "closed", "initial"]), OA = _e.object({
  name: _e.string().optional(),
  pictureUrl: _e.string().optional(),
  data: _e.record(_e.unknown()).optional(),
  userKey: _e.string().optional()
}), $A = _e.object({
  configuration: SA.optional().catch(void 0),
  theme: TA.optional().catch(void 0),
  style: _e.string().optional().catch(void 0),
  user: OA.optional().catch(void 0)
}), dde = $A.extend({
  clientId: _e.string(),
  botId: _e.string(),
  selector: _e.string().optional().catch(void 0),
  webchatScriptUrl: _e.string().optional().catch(void 0),
  fabScriptUrl: _e.string().optional().catch(void 0),
  pushpinUrl: _e.string().optional().catch(void 0),
  defaultState: CA.optional().catch(void 0)
});
function RA(e) {
  const { fontFamily: t, radius: n, themeMode: r, variant: i, color: a } = cE.parse(e);
  let o = {}, s = {};
  if (a) {
    const u = Mg(a), f = r === "dark" ? Cg(u) : u, d = Mg(WR(VR(dh(a)))), p = r === "dark" ? Cg(d) : d, m = r === "dark" ? "#101010" : "#fdfdfd";
    s = Object.entries({ ...f, 1: m }).reduce(
      (y, [v, b]) => ({ ...y, [`--bpPrimary-${v}`]: b }),
      {}
    );
    const h = Object.entries({ ...p, 1: m }).reduce(
      (y, [v, b]) => ({ ...y, [`--bpGray-${v}`]: b }),
      {}
    );
    o = {
      ...s,
      ...h
    };
  }
  n && (o = {
    ...o,
    "--bpRadius-scale": n.toString()
  });
  const c = s ? Pg(s["--bpPrimary-600"], s["--bpPrimary-50"]) > 40 ? "var(--bpPrimary-50)" : "var(--bpPrimary-900)" : "var(--bpPrimary-50)", l = i === "solid" ? {
    "--header-bg": "var(--bpPrimary-600)",
    "--header-bg-hover": "var(--bpPrimary-700)",
    "--header-hover-dark": "var(--bpPrimary-800)",
    "--header-title": c,
    "--header-description": c,
    "--header-description-icon": c,
    "--header-description-link": c,
    "--header-avatar-bg": "var(--bpPrimary-300)",
    "--header-avatar-text": "var(--bpPrimary-700)",
    "--message-bg": "var(--bpPrimary-600)",
    "--message-bg-hover": "var(--bpPrimary-700)",
    "--message-text": c,
    "--send-button-bg": "var(--bpPrimary-600)",
    "--send-button-bg-hover": "var(--bpPrimary-700)",
    "--send-button-text": "var(--bpPrimary-50)",
    "--button-bg": "var(--bpPrimary-50)",
    "--button-bg-hover": "var(--bpPrimary-100)",
    "--button-text": "var(--bpPrimary-800)",
    "--fab-bg": "var(--bpPrimary-600)",
    "--fab-bg-hover": "var(--bpPrimary-700)",
    "--fab-icon": c
  } : {
    "--header-bg": "var(--bpGray-50)",
    "--header-bg-hover": "var(--bpGray-100)",
    "--header-hover-dark": "var(--bpGray-200)",
    "--header-title": "var(--bpGray-900)",
    "--header-description": "var(--bpGray-800)",
    "--header-description-icon": "var(--bpPrimary-700)",
    "--header-description-link": "var(--bpPrimary-800)",
    "--header-avatar-bg": "var(--bpPrimary-600)",
    "--header-avatar-text": "var(--bpPrimary-50)",
    "--message-bg": "var(--bpPrimary-100)",
    "--message-bg-hover": "var(--bpPrimary-200)",
    "--message-text": "var(--bpPrimary-900)",
    "--send-button-bg": "var(--bpPrimary-600)",
    "--send-button-bg-hover": "var(--bpPrimary-700)",
    "--send-button-text": "var(--bpPrimary-50)",
    "--button-bg": "var(--bpPrimary-500)",
    "--button-bg-hover": "var(--bpPrimary-600)",
    "--button-text": s ? Pg(s["--bpPrimary-500"], s["--bpPrimary-50"]) > 40 ? "var(--bpPrimary-50)" : "var(--bpPrimary-900)" : "var(--bpPrimary-50)",
    "--fab-bg": "var(--bpPrimary-100)",
    "--fab-bg-hover": "var(--bpPrimary-200)",
    "--fab-icon": "var(--bpPrimary-700)"
  };
  return o = {
    ...o,
    ...l
  }, Dg(":root", o) + (t ? Dg(".bpFont", { "font-family": `var(--${t}-font)` }) : "");
}
const IA = (e, t = {}) => new Promise((n, r) => {
  if (typeof window > "u")
    return r("Window is not defined");
  if (!e)
    return r("Url is not defined");
  let i = null;
  const a = new Image();
  a.addEventListener("load", () => {
    i && clearTimeout(i), n({ width: a.naturalWidth, height: a.naturalHeight });
  }), a.addEventListener("error", (o) => {
    i && clearTimeout(i), r(`${o.type}: ${o.message}`);
  }), a.src = e, t.timeout && (i = setTimeout(() => r("Timeout"), t.timeout));
}), av = An(
  ({ userId: e, src: t, container: n, image: r, fallback: i, ...a }, o) => {
    const s = zS(e ?? "", 15);
    return /* @__PURE__ */ O.jsxs(tv, { ref: o, "data-color": s, ...n, ...a, children: [
      /* @__PURE__ */ O.jsx(nv, { src: t, ...r }),
      /* @__PURE__ */ O.jsx(rv, { ...i, children: typeof a.children == "string" ? a.children[0] : a.children })
    ] });
  }
);
av.displayName = "Avatar";
function AA(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const PA = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, DA = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, jA = {};
function Bg(e, t) {
  return (jA.jsx ? DA : PA).test(e);
}
const NA = /[ \t\n\f\r]/g;
function MA(e) {
  return typeof e == "object" ? e.type === "text" ? Ug(e.value) : !1 : Ug(e);
}
function Ug(e) {
  return e.replace(NA, "") === "";
}
class rl {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
rl.prototype.property = {};
rl.prototype.normal = {};
rl.prototype.space = null;
function uE(e, t) {
  const n = {}, r = {};
  let i = -1;
  for (; ++i < e.length; )
    Object.assign(n, e[i].property), Object.assign(r, e[i].normal);
  return new rl(n, r, t);
}
function Sh(e) {
  return e.toLowerCase();
}
class Jn {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
Jn.prototype.space = null;
Jn.prototype.boolean = !1;
Jn.prototype.booleanish = !1;
Jn.prototype.overloadedBoolean = !1;
Jn.prototype.number = !1;
Jn.prototype.commaSeparated = !1;
Jn.prototype.spaceSeparated = !1;
Jn.prototype.commaOrSpaceSeparated = !1;
Jn.prototype.mustUseProperty = !1;
Jn.prototype.defined = !1;
let FA = 0;
const Fe = la(), Wt = la(), fE = la(), pe = la(), St = la(), La = la(), jn = la();
function la() {
  return 2 ** ++FA;
}
const Eh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Fe,
  booleanish: Wt,
  commaOrSpaceSeparated: jn,
  commaSeparated: La,
  number: pe,
  overloadedBoolean: fE,
  spaceSeparated: St
}, Symbol.toStringTag, { value: "Module" })), Kf = Object.keys(Eh);
class ov extends Jn {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, i) {
    let a = -1;
    if (super(t, n), zg(this, "space", i), typeof r == "number")
      for (; ++a < Kf.length; ) {
        const o = Kf[a];
        zg(this, Kf[a], (r & Eh[o]) === Eh[o]);
      }
  }
}
ov.prototype.defined = !0;
function zg(e, t, n) {
  n && (e[t] = n);
}
const LA = {}.hasOwnProperty;
function vo(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (LA.call(e.properties, r)) {
      const i = e.properties[r], a = new ov(
        r,
        e.transform(e.attributes || {}, r),
        i,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[Sh(r)] = r, n[Sh(a.attribute)] = r;
    }
  return new rl(t, n, e.space);
}
const dE = vo({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), pE = vo({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function hE(e, t) {
  return t in e ? e[t] : t;
}
function mE(e, t) {
  return hE(e, t.toLowerCase());
}
const vE = vo({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: mE,
  properties: { xmlns: null, xmlnsXLink: null }
}), yE = vo({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Wt,
    ariaAutoComplete: null,
    ariaBusy: Wt,
    ariaChecked: Wt,
    ariaColCount: pe,
    ariaColIndex: pe,
    ariaColSpan: pe,
    ariaControls: St,
    ariaCurrent: null,
    ariaDescribedBy: St,
    ariaDetails: null,
    ariaDisabled: Wt,
    ariaDropEffect: St,
    ariaErrorMessage: null,
    ariaExpanded: Wt,
    ariaFlowTo: St,
    ariaGrabbed: Wt,
    ariaHasPopup: null,
    ariaHidden: Wt,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: St,
    ariaLevel: pe,
    ariaLive: null,
    ariaModal: Wt,
    ariaMultiLine: Wt,
    ariaMultiSelectable: Wt,
    ariaOrientation: null,
    ariaOwns: St,
    ariaPlaceholder: null,
    ariaPosInSet: pe,
    ariaPressed: Wt,
    ariaReadOnly: Wt,
    ariaRelevant: null,
    ariaRequired: Wt,
    ariaRoleDescription: St,
    ariaRowCount: pe,
    ariaRowIndex: pe,
    ariaRowSpan: pe,
    ariaSelected: Wt,
    ariaSetSize: pe,
    ariaSort: null,
    ariaValueMax: pe,
    ariaValueMin: pe,
    ariaValueNow: pe,
    ariaValueText: null,
    role: null
  }
}), BA = vo({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: mE,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: La,
    acceptCharset: St,
    accessKey: St,
    action: null,
    allow: null,
    allowFullScreen: Fe,
    allowPaymentRequest: Fe,
    allowUserMedia: Fe,
    alt: null,
    as: null,
    async: Fe,
    autoCapitalize: null,
    autoComplete: St,
    autoFocus: Fe,
    autoPlay: Fe,
    blocking: St,
    capture: null,
    charSet: null,
    checked: Fe,
    cite: null,
    className: St,
    cols: pe,
    colSpan: null,
    content: null,
    contentEditable: Wt,
    controls: Fe,
    controlsList: St,
    coords: pe | La,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Fe,
    defer: Fe,
    dir: null,
    dirName: null,
    disabled: Fe,
    download: fE,
    draggable: Wt,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Fe,
    formTarget: null,
    headers: St,
    height: pe,
    hidden: Fe,
    high: pe,
    href: null,
    hrefLang: null,
    htmlFor: St,
    httpEquiv: St,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Fe,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Fe,
    itemId: null,
    itemProp: St,
    itemRef: St,
    itemScope: Fe,
    itemType: St,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Fe,
    low: pe,
    manifest: null,
    max: null,
    maxLength: pe,
    media: null,
    method: null,
    min: null,
    minLength: pe,
    multiple: Fe,
    muted: Fe,
    name: null,
    nonce: null,
    noModule: Fe,
    noValidate: Fe,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Fe,
    optimum: pe,
    pattern: null,
    ping: St,
    placeholder: null,
    playsInline: Fe,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Fe,
    referrerPolicy: null,
    rel: St,
    required: Fe,
    reversed: Fe,
    rows: pe,
    rowSpan: pe,
    sandbox: St,
    scope: null,
    scoped: Fe,
    seamless: Fe,
    selected: Fe,
    shadowRootClonable: Fe,
    shadowRootDelegatesFocus: Fe,
    shadowRootMode: null,
    shape: null,
    size: pe,
    sizes: null,
    slot: null,
    span: pe,
    spellCheck: Wt,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: pe,
    step: null,
    style: null,
    tabIndex: pe,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Fe,
    useMap: null,
    value: Wt,
    width: pe,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: St,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: pe,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: pe,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Fe,
    // Lists. Use CSS to reduce space between items instead
    declare: Fe,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: pe,
    // `<img>` and `<object>`
    leftMargin: pe,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: pe,
    // `<body>`
    marginWidth: pe,
    // `<body>`
    noResize: Fe,
    // `<frame>`
    noHref: Fe,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Fe,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Fe,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: pe,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Wt,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: pe,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: pe,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Fe,
    disableRemotePlayback: Fe,
    prefix: null,
    property: null,
    results: pe,
    security: null,
    unselectable: null
  }
}), UA = vo({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: hE,
  properties: {
    about: jn,
    accentHeight: pe,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: pe,
    amplitude: pe,
    arabicForm: null,
    ascent: pe,
    attributeName: null,
    attributeType: null,
    azimuth: pe,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: pe,
    by: null,
    calcMode: null,
    capHeight: pe,
    className: St,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: pe,
    diffuseConstant: pe,
    direction: null,
    display: null,
    dur: null,
    divisor: pe,
    dominantBaseline: null,
    download: Fe,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: pe,
    enableBackground: null,
    end: null,
    event: null,
    exponent: pe,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: pe,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: La,
    g2: La,
    glyphName: La,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: pe,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: pe,
    horizOriginX: pe,
    horizOriginY: pe,
    id: null,
    ideographic: pe,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: pe,
    k: pe,
    k1: pe,
    k2: pe,
    k3: pe,
    k4: pe,
    kernelMatrix: jn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: pe,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: pe,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: pe,
    overlineThickness: pe,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: pe,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: St,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: pe,
    pointsAtY: pe,
    pointsAtZ: pe,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: jn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: jn,
    rev: jn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: jn,
    requiredFeatures: jn,
    requiredFonts: jn,
    requiredFormats: jn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: pe,
    specularExponent: pe,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: pe,
    strikethroughThickness: pe,
    string: null,
    stroke: null,
    strokeDashArray: jn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: pe,
    strokeOpacity: pe,
    strokeWidth: null,
    style: null,
    surfaceScale: pe,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: jn,
    tabIndex: pe,
    tableValues: null,
    target: null,
    targetX: pe,
    targetY: pe,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: jn,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: pe,
    underlineThickness: pe,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: pe,
    values: null,
    vAlphabetic: pe,
    vMathematical: pe,
    vectorEffect: null,
    vHanging: pe,
    vIdeographic: pe,
    version: null,
    vertAdvY: pe,
    vertOriginX: pe,
    vertOriginY: pe,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: pe,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), zA = /^data[-\w.:]+$/i, qg = /-[a-z]/g, qA = /[A-Z]/g;
function WA(e, t) {
  const n = Sh(t);
  let r = t, i = Jn;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && zA.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(qg, HA);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!qg.test(a)) {
        let o = a.replace(qA, VA);
        o.charAt(0) !== "-" && (o = "-" + o), t = "data" + o;
      }
    }
    i = ov;
  }
  return new i(r, t);
}
function VA(e) {
  return "-" + e.toLowerCase();
}
function HA(e) {
  return e.charAt(1).toUpperCase();
}
const ZA = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, KA = uE([pE, dE, vE, yE, BA], "html"), sv = uE([pE, dE, vE, yE, UA], "svg");
function GA(e) {
  return e.join(" ").trim();
}
var gE = {}, Wg = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, YA = /\n/g, JA = /^\s*/, XA = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, QA = /^:\s*/, eP = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, tP = /^[;\s]*/, nP = /^\s+|\s+$/g, rP = `
`, Vg = "/", Hg = "*", Ui = "", iP = "comment", aP = "declaration", oP = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function i(m) {
    var h = m.match(YA);
    h && (n += h.length);
    var y = m.lastIndexOf(rP);
    r = ~y ? m.length - y : r + m.length;
  }
  function a() {
    var m = { line: n, column: r };
    return function(h) {
      return h.position = new o(m), l(), h;
    };
  }
  function o(m) {
    this.start = m, this.end = { line: n, column: r }, this.source = t.source;
  }
  o.prototype.content = e;
  function s(m) {
    var h = new Error(
      t.source + ":" + n + ":" + r + ": " + m
    );
    if (h.reason = m, h.filename = t.source, h.line = n, h.column = r, h.source = e, !t.silent) throw h;
  }
  function c(m) {
    var h = m.exec(e);
    if (h) {
      var y = h[0];
      return i(y), e = e.slice(y.length), h;
    }
  }
  function l() {
    c(JA);
  }
  function u(m) {
    var h;
    for (m = m || []; h = f(); )
      h !== !1 && m.push(h);
    return m;
  }
  function f() {
    var m = a();
    if (!(Vg != e.charAt(0) || Hg != e.charAt(1))) {
      for (var h = 2; Ui != e.charAt(h) && (Hg != e.charAt(h) || Vg != e.charAt(h + 1)); )
        ++h;
      if (h += 2, Ui === e.charAt(h - 1))
        return s("End of comment missing");
      var y = e.slice(2, h - 2);
      return r += 2, i(y), e = e.slice(h), r += 2, m({
        type: iP,
        comment: y
      });
    }
  }
  function d() {
    var m = a(), h = c(XA);
    if (h) {
      if (f(), !c(QA)) return s("property missing ':'");
      var y = c(eP), v = m({
        type: aP,
        property: Zg(h[0].replace(Wg, Ui)),
        value: y ? Zg(y[0].replace(Wg, Ui)) : Ui
      });
      return c(tP), v;
    }
  }
  function p() {
    var m = [];
    u(m);
    for (var h; h = d(); )
      h !== !1 && (m.push(h), u(m));
    return m;
  }
  return l(), p();
};
function Zg(e) {
  return e ? e.replace(nP, Ui) : Ui;
}
var sP = yt && yt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(gE, "__esModule", { value: !0 });
var Kg = gE.default = cP, lP = sP(oP);
function cP(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, lP.default)(e), i = typeof t == "function";
  return r.forEach(function(a) {
    if (a.type === "declaration") {
      var o = a.property, s = a.value;
      i ? t(o, s, a) : s && (n = n || {}, n[o] = s);
    }
  }), n;
}
const uP = Kg.default || Kg, bE = wE("end"), lv = wE("start");
function wE(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function fP(e) {
  const t = lv(e), n = bE(e);
  if (t && n)
    return { start: t, end: n };
}
function ns(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Gg(e.position) : "start" in e || "end" in e ? Gg(e) : "line" in e || "column" in e ? _h(e) : "";
}
function _h(e) {
  return Yg(e && e.line) + ":" + Yg(e && e.column);
}
function Gg(e) {
  return _h(e && e.start) + "-" + _h(e && e.end);
}
function Yg(e) {
  return e && typeof e == "number" ? e : 1;
}
class yn extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", a = {}, o = !1;
    if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
      ancestors: [n],
      place: n.position
    } : a = { ...n }), typeof t == "string" ? i = t : !a.cause && t && (o = !0, i = t.message, a.cause = t), !a.ruleId && !a.source && typeof r == "string") {
      const c = r.indexOf(":");
      c === -1 ? a.ruleId = r : (a.source = r.slice(0, c), a.ruleId = r.slice(c + 1));
    }
    if (!a.place && a.ancestors && a.ancestors) {
      const c = a.ancestors[a.ancestors.length - 1];
      c && (a.place = c.position);
    }
    const s = a.place && "start" in a.place ? a.place.start : a.place;
    this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = s ? s.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = s ? s.line : void 0, this.name = ns(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = o && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
yn.prototype.file = "";
yn.prototype.name = "";
yn.prototype.reason = "";
yn.prototype.message = "";
yn.prototype.stack = "";
yn.prototype.column = void 0;
yn.prototype.line = void 0;
yn.prototype.ancestors = void 0;
yn.prototype.cause = void 0;
yn.prototype.fatal = void 0;
yn.prototype.place = void 0;
yn.prototype.ruleId = void 0;
yn.prototype.source = void 0;
const cv = {}.hasOwnProperty, dP = /* @__PURE__ */ new Map(), pP = /[A-Z]/g, hP = /-([a-z])/g, mP = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), vP = /* @__PURE__ */ new Set(["td", "th"]), xE = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function yP(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = kP(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = _P(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? sv : KA,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, a = SE(i, e, void 0);
  return a && typeof a != "string" ? a : i.create(
    e,
    i.Fragment,
    { children: a || void 0 },
    void 0
  );
}
function SE(e, t, n) {
  if (t.type === "element")
    return gP(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return bP(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return xP(e, t, n);
  if (t.type === "mdxjsEsm")
    return wP(e, t);
  if (t.type === "root")
    return SP(e, t, n);
  if (t.type === "text")
    return EP(e, t);
}
function gP(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = sv, e.schema = i), e.ancestors.push(t);
  const a = _E(e, t.tagName, !1), o = TP(e, t);
  let s = fv(e, t);
  return mP.has(t.tagName) && (s = s.filter(function(c) {
    return typeof c == "string" ? !MA(c) : !0;
  })), EE(e, o, a, t), uv(o, s), e.ancestors.pop(), e.schema = r, e.create(t, a, o, n);
}
function bP(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  Ts(e, t.position);
}
function wP(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Ts(e, t.position);
}
function xP(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = sv, e.schema = i), e.ancestors.push(t);
  const a = t.name === null ? e.Fragment : _E(e, t.name, !0), o = CP(e, t), s = fv(e, t);
  return EE(e, o, a, t), uv(o, s), e.ancestors.pop(), e.schema = r, e.create(t, a, o, n);
}
function SP(e, t, n) {
  const r = {};
  return uv(r, fv(e, t)), e.create(t, e.Fragment, r, n);
}
function EP(e, t) {
  return t.value;
}
function EE(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function uv(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function _P(e, t, n) {
  return r;
  function r(i, a, o, s) {
    const l = Array.isArray(o.children) ? n : t;
    return s ? l(a, o, s) : l(a, o);
  }
}
function kP(e, t) {
  return n;
  function n(r, i, a, o) {
    const s = Array.isArray(a.children), c = lv(r);
    return t(
      i,
      a,
      o,
      s,
      {
        columnNumber: c ? c.column - 1 : void 0,
        fileName: e,
        lineNumber: c ? c.line : void 0
      },
      void 0
    );
  }
}
function TP(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && cv.call(t.properties, i)) {
      const a = OP(e, i, t.properties[i]);
      if (a) {
        const [o, s] = a;
        e.tableCellAlignToStyle && o === "align" && typeof s == "string" && vP.has(t.tagName) ? r = s : n[o] = s;
      }
    }
  if (r) {
    const a = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function CP(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const a = r.data.estree.body[0];
        a.type;
        const o = a.expression;
        o.type;
        const s = o.properties[0];
        s.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(s.argument)
        );
      } else
        Ts(e, t.position);
    else {
      const i = r.name;
      let a;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const s = r.value.data.estree.body[0];
          s.type, a = e.evaluater.evaluateExpression(s.expression);
        } else
          Ts(e, t.position);
      else
        a = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      a;
    }
  return n;
}
function fv(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : dP;
  for (; ++r < t.children.length; ) {
    const a = t.children[r];
    let o;
    if (e.passKeys) {
      const c = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
      if (c) {
        const l = i.get(c) || 0;
        o = c + "-" + l, i.set(c, l + 1);
      }
    }
    const s = SE(e, a, o);
    s !== void 0 && n.push(s);
  }
  return n;
}
function OP(e, t, n) {
  const r = WA(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? AA(n) : GA(n)), r.property === "style") {
      let i = typeof n == "object" ? n : $P(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = RP(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? ZA[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function $P(e, t) {
  const n = {};
  try {
    uP(t, r);
  } catch (i) {
    if (!e.ignoreInvalidStyle) {
      const a = (
        /** @type {Error} */
        i
      ), o = new yn("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: a,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw o.file = e.filePath || void 0, o.url = xE + "#cannot-parse-style-attribute", o;
    }
  }
  return n;
  function r(i, a) {
    let o = i;
    o.slice(0, 2) !== "--" && (o.slice(0, 4) === "-ms-" && (o = "ms-" + o.slice(4)), o = o.replace(hP, AP)), n[o] = a;
  }
}
function _E(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let a = -1, o;
    for (; ++a < i.length; ) {
      const s = Bg(i[a]) ? { type: "Identifier", name: i[a] } : { type: "Literal", value: i[a] };
      o = o ? {
        type: "MemberExpression",
        object: o,
        property: s,
        computed: !!(a && s.type === "Literal"),
        optional: !1
      } : s;
    }
    r = o;
  } else
    r = Bg(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {keyof JSX.IntrinsicElements} */
      r.value
    );
    return cv.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Ts(e);
}
function Ts(e, t) {
  const n = new yn(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = xE + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function RP(e) {
  const t = {};
  let n;
  for (n in e)
    cv.call(e, n) && (t[IP(n)] = e[n]);
  return t;
}
function IP(e) {
  let t = e.replace(pP, PP);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function AP(e, t) {
  return t.toUpperCase();
}
function PP(e) {
  return "-" + e.toLowerCase();
}
const Gf = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, DP = {};
function dv(e, t) {
  const n = DP, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return kE(e, r, i);
}
function kE(e, t, n) {
  if (jP(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Jg(e.children, t, n);
  }
  return Array.isArray(e) ? Jg(e, t, n) : "";
}
function Jg(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = kE(e[i], t, n);
  return r.join("");
}
function jP(e) {
  return !!(e && typeof e == "object");
}
const Xg = document.createElement("i");
function pv(e) {
  const t = "&" + e + ";";
  Xg.innerHTML = t;
  const n = Xg.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function Kn(e, t, n, r) {
  const i = e.length;
  let a = 0, o;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(t, n), e.splice(...o);
  else
    for (n && e.splice(t, n); a < r.length; )
      o = r.slice(a, a + 1e4), o.unshift(t, 0), e.splice(...o), a += 1e4, t += 1e4;
}
function Vn(e, t) {
  return e.length > 0 ? (Kn(e, e.length, 0, t), e) : t;
}
const Qg = {}.hasOwnProperty;
function TE(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    NP(t, e[n]);
  return t;
}
function NP(e, t) {
  let n;
  for (n in t) {
    const i = (Qg.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let o;
    if (a)
      for (o in a) {
        Qg.call(i, o) || (i[o] = []);
        const s = a[o];
        MP(
          // @ts-expect-error Looks like a list.
          i[o],
          Array.isArray(s) ? s : s ? [s] : []
        );
      }
  }
}
function MP(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Kn(e, 0, 0, r);
}
function CE(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "�" : String.fromCodePoint(n)
  );
}
function cr(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const xn = Pi(/[A-Za-z]/), hn = Pi(/[\dA-Za-z]/), FP = Pi(/[#-'*+\--9=?A-Z^-~]/);
function tu(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const kh = Pi(/\d/), LP = Pi(/[\dA-Fa-f]/), BP = Pi(/[!-/:-@[-`{-~]/);
function Ae(e) {
  return e !== null && e < -2;
}
function xt(e) {
  return e !== null && (e < 0 || e === 32);
}
function Ge(e) {
  return e === -2 || e === -1 || e === 32;
}
const Hu = Pi(new RegExp("\\p{P}|\\p{S}", "u")), ea = Pi(/\s/);
function Pi(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function yo(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let o = "";
    if (a === 37 && hn(e.charCodeAt(n + 1)) && hn(e.charCodeAt(n + 2)))
      i = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (o = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const s = e.charCodeAt(n + 1);
      a < 56320 && s > 56319 && s < 57344 ? (o = String.fromCharCode(a, s), i = 1) : o = "�";
    } else
      o = String.fromCharCode(a);
    o && (t.push(e.slice(r, n), encodeURIComponent(o)), r = n + i + 1, o = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function rt(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return o;
  function o(c) {
    return Ge(c) ? (e.enter(n), s(c)) : t(c);
  }
  function s(c) {
    return Ge(c) && a++ < i ? (e.consume(c), s) : (e.exit(n), t(c));
  }
}
const UP = {
  tokenize: zP
};
function zP(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    i
  );
  let n;
  return t;
  function r(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), rt(e, t, "linePrefix");
  }
  function i(s) {
    return e.enter("paragraph"), a(s);
  }
  function a(s) {
    const c = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = c), n = c, o(s);
  }
  function o(s) {
    if (s === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(s);
      return;
    }
    return Ae(s) ? (e.consume(s), e.exit("chunkText"), a) : (e.consume(s), o);
  }
}
const qP = {
  tokenize: WP
}, eb = {
  tokenize: VP
};
function WP(e) {
  const t = this, n = [];
  let r = 0, i, a, o;
  return s;
  function s(w) {
    if (r < n.length) {
      const T = n[r];
      return t.containerState = T[1], e.attempt(
        T[0].continuation,
        c,
        l
      )(w);
    }
    return l(w);
  }
  function c(w) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && b();
      const T = t.events.length;
      let E = T, _;
      for (; E--; )
        if (t.events[E][0] === "exit" && t.events[E][1].type === "chunkFlow") {
          _ = t.events[E][1].end;
          break;
        }
      v(r);
      let $ = T;
      for (; $ < t.events.length; )
        t.events[$][1].end = Object.assign({}, _), $++;
      return Kn(
        t.events,
        E + 1,
        0,
        t.events.slice(T)
      ), t.events.length = $, l(w);
    }
    return s(w);
  }
  function l(w) {
    if (r === n.length) {
      if (!i)
        return d(w);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return m(w);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      eb,
      u,
      f
    )(w);
  }
  function u(w) {
    return i && b(), v(r), d(w);
  }
  function f(w) {
    return t.parser.lazy[t.now().line] = r !== n.length, o = t.now().offset, m(w);
  }
  function d(w) {
    return t.containerState = {}, e.attempt(
      eb,
      p,
      m
    )(w);
  }
  function p(w) {
    return r++, n.push([t.currentConstruct, t.containerState]), d(w);
  }
  function m(w) {
    if (w === null) {
      i && b(), v(0), e.consume(w);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: a,
      _tokenizer: i
    }), h(w);
  }
  function h(w) {
    if (w === null) {
      y(e.exit("chunkFlow"), !0), v(0), e.consume(w);
      return;
    }
    return Ae(w) ? (e.consume(w), y(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, s) : (e.consume(w), h);
  }
  function y(w, T) {
    const E = t.sliceStream(w);
    if (T && E.push(null), w.previous = a, a && (a.next = w), a = w, i.defineSkip(w.start), i.write(E), t.parser.lazy[w.start.line]) {
      let _ = i.events.length;
      for (; _--; )
        if (
          // The token starts before the line ending…
          i.events[_][1].start.offset < o && // …and either is not ended yet…
          (!i.events[_][1].end || // …or ends after it.
          i.events[_][1].end.offset > o)
        )
          return;
      const $ = t.events.length;
      let B = $, U, k;
      for (; B--; )
        if (t.events[B][0] === "exit" && t.events[B][1].type === "chunkFlow") {
          if (U) {
            k = t.events[B][1].end;
            break;
          }
          U = !0;
        }
      for (v(r), _ = $; _ < t.events.length; )
        t.events[_][1].end = Object.assign({}, k), _++;
      Kn(
        t.events,
        B + 1,
        0,
        t.events.slice($)
      ), t.events.length = _;
    }
  }
  function v(w) {
    let T = n.length;
    for (; T-- > w; ) {
      const E = n[T];
      t.containerState = E[1], E[0].exit.call(t, e);
    }
    n.length = w;
  }
  function b() {
    i.write([null]), a = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function VP(e, t, n) {
  return rt(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function nu(e) {
  if (e === null || xt(e) || ea(e))
    return 1;
  if (Hu(e))
    return 2;
}
function Zu(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const a = e[i].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const Th = {
  name: "attention",
  tokenize: ZP,
  resolveAll: HP
};
function HP(e, t) {
  let n = -1, r, i, a, o, s, c, l, u;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          c = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const f = Object.assign({}, e[r][1].end), d = Object.assign({}, e[n][1].start);
          tb(f, -c), tb(d, c), o = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: f,
            end: Object.assign({}, e[r][1].end)
          }, s = {
            type: c > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: d
          }, a = {
            type: c > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, i = {
            type: c > 1 ? "strong" : "emphasis",
            start: Object.assign({}, o.start),
            end: Object.assign({}, s.end)
          }, e[r][1].end = Object.assign({}, o.start), e[n][1].start = Object.assign({}, s.end), l = [], e[r][1].end.offset - e[r][1].start.offset && (l = Vn(l, [["enter", e[r][1], t], ["exit", e[r][1], t]])), l = Vn(l, [["enter", i, t], ["enter", o, t], ["exit", o, t], ["enter", a, t]]), l = Vn(l, Zu(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), l = Vn(l, [["exit", a, t], ["enter", s, t], ["exit", s, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (u = 2, l = Vn(l, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : u = 0, Kn(e, r - 1, n - r + 3, l), n = r + l.length - u - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function ZP(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = nu(r);
  let a;
  return o;
  function o(c) {
    return a = c, e.enter("attentionSequence"), s(c);
  }
  function s(c) {
    if (c === a)
      return e.consume(c), s;
    const l = e.exit("attentionSequence"), u = nu(c), f = !u || u === 2 && i || n.includes(c), d = !i || i === 2 && u || n.includes(r);
    return l._open = !!(a === 42 ? f : f && (i || !d)), l._close = !!(a === 42 ? d : d && (u || !f)), t(c);
  }
}
function tb(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const KP = {
  name: "autolink",
  tokenize: GP
};
function GP(e, t, n) {
  let r = 0;
  return i;
  function i(p) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(p), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(p) {
    return xn(p) ? (e.consume(p), o) : p === 64 ? n(p) : l(p);
  }
  function o(p) {
    return p === 43 || p === 45 || p === 46 || hn(p) ? (r = 1, s(p)) : l(p);
  }
  function s(p) {
    return p === 58 ? (e.consume(p), r = 0, c) : (p === 43 || p === 45 || p === 46 || hn(p)) && r++ < 32 ? (e.consume(p), s) : (r = 0, l(p));
  }
  function c(p) {
    return p === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(p), e.exit("autolinkMarker"), e.exit("autolink"), t) : p === null || p === 32 || p === 60 || tu(p) ? n(p) : (e.consume(p), c);
  }
  function l(p) {
    return p === 64 ? (e.consume(p), u) : FP(p) ? (e.consume(p), l) : n(p);
  }
  function u(p) {
    return hn(p) ? f(p) : n(p);
  }
  function f(p) {
    return p === 46 ? (e.consume(p), r = 0, u) : p === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(p), e.exit("autolinkMarker"), e.exit("autolink"), t) : d(p);
  }
  function d(p) {
    if ((p === 45 || hn(p)) && r++ < 63) {
      const m = p === 45 ? d : f;
      return e.consume(p), m;
    }
    return n(p);
  }
}
const il = {
  tokenize: YP,
  partial: !0
};
function YP(e, t, n) {
  return r;
  function r(a) {
    return Ge(a) ? rt(e, i, "linePrefix")(a) : i(a);
  }
  function i(a) {
    return a === null || Ae(a) ? t(a) : n(a);
  }
}
const OE = {
  name: "blockQuote",
  tokenize: JP,
  continuation: {
    tokenize: XP
  },
  exit: QP
};
function JP(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const s = r.containerState;
      return s.open || (e.enter("blockQuote", {
        _container: !0
      }), s.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(o), e.exit("blockQuoteMarker"), a;
    }
    return n(o);
  }
  function a(o) {
    return Ge(o) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(o), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(o));
  }
}
function XP(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return Ge(o) ? rt(e, a, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(o) : a(o);
  }
  function a(o) {
    return e.attempt(OE, t, n)(o);
  }
}
function QP(e) {
  e.exit("blockQuote");
}
const $E = {
  name: "characterEscape",
  tokenize: eD
};
function eD(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), i;
  }
  function i(a) {
    return BP(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const RE = {
  name: "characterReference",
  tokenize: tD
};
function tD(e, t, n) {
  const r = this;
  let i = 0, a, o;
  return s;
  function s(f) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), c;
  }
  function c(f) {
    return f === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(f), e.exit("characterReferenceMarkerNumeric"), l) : (e.enter("characterReferenceValue"), a = 31, o = hn, u(f));
  }
  function l(f) {
    return f === 88 || f === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(f), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, o = LP, u) : (e.enter("characterReferenceValue"), a = 7, o = kh, u(f));
  }
  function u(f) {
    if (f === 59 && i) {
      const d = e.exit("characterReferenceValue");
      return o === hn && !pv(r.sliceSerialize(d)) ? n(f) : (e.enter("characterReferenceMarker"), e.consume(f), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return o(f) && i++ < a ? (e.consume(f), u) : n(f);
  }
}
const nb = {
  tokenize: rD,
  partial: !0
}, rb = {
  name: "codeFenced",
  tokenize: nD,
  concrete: !0
};
function nD(e, t, n) {
  const r = this, i = {
    tokenize: E,
    partial: !0
  };
  let a = 0, o = 0, s;
  return c;
  function c(_) {
    return l(_);
  }
  function l(_) {
    const $ = r.events[r.events.length - 1];
    return a = $ && $[1].type === "linePrefix" ? $[2].sliceSerialize($[1], !0).length : 0, s = _, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), u(_);
  }
  function u(_) {
    return _ === s ? (o++, e.consume(_), u) : o < 3 ? n(_) : (e.exit("codeFencedFenceSequence"), Ge(_) ? rt(e, f, "whitespace")(_) : f(_));
  }
  function f(_) {
    return _ === null || Ae(_) ? (e.exit("codeFencedFence"), r.interrupt ? t(_) : e.check(nb, h, T)(_)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), d(_));
  }
  function d(_) {
    return _ === null || Ae(_) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), f(_)) : Ge(_) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), rt(e, p, "whitespace")(_)) : _ === 96 && _ === s ? n(_) : (e.consume(_), d);
  }
  function p(_) {
    return _ === null || Ae(_) ? f(_) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), m(_));
  }
  function m(_) {
    return _ === null || Ae(_) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), f(_)) : _ === 96 && _ === s ? n(_) : (e.consume(_), m);
  }
  function h(_) {
    return e.attempt(i, T, y)(_);
  }
  function y(_) {
    return e.enter("lineEnding"), e.consume(_), e.exit("lineEnding"), v;
  }
  function v(_) {
    return a > 0 && Ge(_) ? rt(e, b, "linePrefix", a + 1)(_) : b(_);
  }
  function b(_) {
    return _ === null || Ae(_) ? e.check(nb, h, T)(_) : (e.enter("codeFlowValue"), w(_));
  }
  function w(_) {
    return _ === null || Ae(_) ? (e.exit("codeFlowValue"), b(_)) : (e.consume(_), w);
  }
  function T(_) {
    return e.exit("codeFenced"), t(_);
  }
  function E(_, $, B) {
    let U = 0;
    return k;
    function k(A) {
      return _.enter("lineEnding"), _.consume(A), _.exit("lineEnding"), D;
    }
    function D(A) {
      return _.enter("codeFencedFence"), Ge(A) ? rt(_, q, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(A) : q(A);
    }
    function q(A) {
      return A === s ? (_.enter("codeFencedFenceSequence"), L(A)) : B(A);
    }
    function L(A) {
      return A === s ? (U++, _.consume(A), L) : U >= o ? (_.exit("codeFencedFenceSequence"), Ge(A) ? rt(_, R, "whitespace")(A) : R(A)) : B(A);
    }
    function R(A) {
      return A === null || Ae(A) ? (_.exit("codeFencedFence"), $(A)) : B(A);
    }
  }
}
function rD(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? n(o) : (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), a);
  }
  function a(o) {
    return r.parser.lazy[r.now().line] ? n(o) : t(o);
  }
}
const Yf = {
  name: "codeIndented",
  tokenize: aD
}, iD = {
  tokenize: oD,
  partial: !0
};
function aD(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return e.enter("codeIndented"), rt(e, a, "linePrefix", 5)(l);
  }
  function a(l) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? o(l) : n(l);
  }
  function o(l) {
    return l === null ? c(l) : Ae(l) ? e.attempt(iD, o, c)(l) : (e.enter("codeFlowValue"), s(l));
  }
  function s(l) {
    return l === null || Ae(l) ? (e.exit("codeFlowValue"), o(l)) : (e.consume(l), s);
  }
  function c(l) {
    return e.exit("codeIndented"), t(l);
  }
}
function oD(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? n(o) : Ae(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), i) : rt(e, a, "linePrefix", 5)(o);
  }
  function a(o) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(o) : Ae(o) ? i(o) : n(o);
  }
}
const sD = {
  name: "codeText",
  tokenize: uD,
  resolve: lD,
  previous: cD
};
function lD(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function cD(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function uD(e, t, n) {
  let r = 0, i, a;
  return o;
  function o(f) {
    return e.enter("codeText"), e.enter("codeTextSequence"), s(f);
  }
  function s(f) {
    return f === 96 ? (e.consume(f), r++, s) : (e.exit("codeTextSequence"), c(f));
  }
  function c(f) {
    return f === null ? n(f) : f === 32 ? (e.enter("space"), e.consume(f), e.exit("space"), c) : f === 96 ? (a = e.enter("codeTextSequence"), i = 0, u(f)) : Ae(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), c) : (e.enter("codeTextData"), l(f));
  }
  function l(f) {
    return f === null || f === 32 || f === 96 || Ae(f) ? (e.exit("codeTextData"), c(f)) : (e.consume(f), l);
  }
  function u(f) {
    return f === 96 ? (e.consume(f), i++, u) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(f)) : (a.type = "codeTextData", l(f));
  }
}
class fD {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, n) {
    const r = n ?? Number.POSITIVE_INFINITY;
    return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, n, r) {
    const i = n || 0;
    this.setCursor(Math.trunc(t));
    const a = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return r && Mo(this.left, r), a.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), Mo(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), Mo(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const n = this.left.splice(t, Number.POSITIVE_INFINITY);
        Mo(this.right, n.reverse());
      } else {
        const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        Mo(this.left, n.reverse());
      }
  }
}
function Mo(e, t) {
  let n = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; n < t.length; )
      e.push(...t.slice(n, n + 1e4)), n += 1e4;
}
function IE(e) {
  const t = {};
  let n = -1, r, i, a, o, s, c, l;
  const u = new fD(e);
  for (; ++n < u.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = u.get(n), n && r[1].type === "chunkFlow" && u.get(n - 1)[1].type === "listItemPrefix" && (c = r[1]._tokenizer.events, a = 0, a < c.length && c[a][1].type === "lineEndingBlank" && (a += 2), a < c.length && c[a][1].type === "content"))
      for (; ++a < c.length && c[a][1].type !== "content"; )
        c[a][1].type === "chunkText" && (c[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, dD(u, n)), n = t[n], l = !0);
    else if (r[1]._container) {
      for (a = n, i = void 0; a-- && (o = u.get(a), o[1].type === "lineEnding" || o[1].type === "lineEndingBlank"); )
        o[0] === "enter" && (i && (u.get(i)[1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = a);
      i && (r[1].end = Object.assign({}, u.get(i)[1].start), s = u.slice(i, n), s.unshift(r), u.splice(i, n - i + 1, s));
    }
  }
  return Kn(e, 0, Number.POSITIVE_INFINITY, u.slice(0)), !l;
}
function dD(e, t) {
  const n = e.get(t)[1], r = e.get(t)[2];
  let i = t - 1;
  const a = [], o = n._tokenizer || r.parser[n.contentType](n.start), s = o.events, c = [], l = {};
  let u, f, d = -1, p = n, m = 0, h = 0;
  const y = [h];
  for (; p; ) {
    for (; e.get(++i)[1] !== p; )
      ;
    a.push(i), p._tokenizer || (u = r.sliceStream(p), p.next || u.push(null), f && o.defineSkip(p.start), p._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), p._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), f = p, p = p.next;
  }
  for (p = n; ++d < s.length; )
    // Find a void token that includes a break.
    s[d][0] === "exit" && s[d - 1][0] === "enter" && s[d][1].type === s[d - 1][1].type && s[d][1].start.line !== s[d][1].end.line && (h = d + 1, y.push(h), p._tokenizer = void 0, p.previous = void 0, p = p.next);
  for (o.events = [], p ? (p._tokenizer = void 0, p.previous = void 0) : y.pop(), d = y.length; d--; ) {
    const v = s.slice(y[d], y[d + 1]), b = a.pop();
    c.push([b, b + v.length - 1]), e.splice(b, 2, v);
  }
  for (c.reverse(), d = -1; ++d < c.length; )
    l[m + c[d][0]] = m + c[d][1], m += c[d][1] - c[d][0] - 1;
  return l;
}
const pD = {
  tokenize: vD,
  resolve: mD
}, hD = {
  tokenize: yD,
  partial: !0
};
function mD(e) {
  return IE(e), e;
}
function vD(e, t) {
  let n;
  return r;
  function r(s) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(s);
  }
  function i(s) {
    return s === null ? a(s) : Ae(s) ? e.check(hD, o, a)(s) : (e.consume(s), i);
  }
  function a(s) {
    return e.exit("chunkContent"), e.exit("content"), t(s);
  }
  function o(s) {
    return e.consume(s), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function yD(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), rt(e, a, "linePrefix");
  }
  function a(o) {
    if (o === null || Ae(o))
      return n(o);
    const s = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(o) : e.interrupt(r.parser.constructs.flow, n, t)(o);
  }
}
function AE(e, t, n, r, i, a, o, s, c) {
  const l = c || Number.POSITIVE_INFINITY;
  let u = 0;
  return f;
  function f(v) {
    return v === 60 ? (e.enter(r), e.enter(i), e.enter(a), e.consume(v), e.exit(a), d) : v === null || v === 32 || v === 41 || tu(v) ? n(v) : (e.enter(r), e.enter(o), e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), h(v));
  }
  function d(v) {
    return v === 62 ? (e.enter(a), e.consume(v), e.exit(a), e.exit(i), e.exit(r), t) : (e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), p(v));
  }
  function p(v) {
    return v === 62 ? (e.exit("chunkString"), e.exit(s), d(v)) : v === null || v === 60 || Ae(v) ? n(v) : (e.consume(v), v === 92 ? m : p);
  }
  function m(v) {
    return v === 60 || v === 62 || v === 92 ? (e.consume(v), p) : p(v);
  }
  function h(v) {
    return !u && (v === null || v === 41 || xt(v)) ? (e.exit("chunkString"), e.exit(s), e.exit(o), e.exit(r), t(v)) : u < l && v === 40 ? (e.consume(v), u++, h) : v === 41 ? (e.consume(v), u--, h) : v === null || v === 32 || v === 40 || tu(v) ? n(v) : (e.consume(v), v === 92 ? y : h);
  }
  function y(v) {
    return v === 40 || v === 41 || v === 92 ? (e.consume(v), h) : h(v);
  }
}
function PE(e, t, n, r, i, a) {
  const o = this;
  let s = 0, c;
  return l;
  function l(p) {
    return e.enter(r), e.enter(i), e.consume(p), e.exit(i), e.enter(a), u;
  }
  function u(p) {
    return s > 999 || p === null || p === 91 || p === 93 && !c || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    p === 94 && !s && "_hiddenFootnoteSupport" in o.parser.constructs ? n(p) : p === 93 ? (e.exit(a), e.enter(i), e.consume(p), e.exit(i), e.exit(r), t) : Ae(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), u) : (e.enter("chunkString", {
      contentType: "string"
    }), f(p));
  }
  function f(p) {
    return p === null || p === 91 || p === 93 || Ae(p) || s++ > 999 ? (e.exit("chunkString"), u(p)) : (e.consume(p), c || (c = !Ge(p)), p === 92 ? d : f);
  }
  function d(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), s++, f) : f(p);
  }
}
function DE(e, t, n, r, i, a) {
  let o;
  return s;
  function s(d) {
    return d === 34 || d === 39 || d === 40 ? (e.enter(r), e.enter(i), e.consume(d), e.exit(i), o = d === 40 ? 41 : d, c) : n(d);
  }
  function c(d) {
    return d === o ? (e.enter(i), e.consume(d), e.exit(i), e.exit(r), t) : (e.enter(a), l(d));
  }
  function l(d) {
    return d === o ? (e.exit(a), c(o)) : d === null ? n(d) : Ae(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), rt(e, l, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), u(d));
  }
  function u(d) {
    return d === o || d === null || Ae(d) ? (e.exit("chunkString"), l(d)) : (e.consume(d), d === 92 ? f : u);
  }
  function f(d) {
    return d === o || d === 92 ? (e.consume(d), u) : u(d);
  }
}
function rs(e, t) {
  let n;
  return r;
  function r(i) {
    return Ae(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : Ge(i) ? rt(
      e,
      r,
      n ? "linePrefix" : "lineSuffix"
    )(i) : t(i);
  }
}
const gD = {
  name: "definition",
  tokenize: wD
}, bD = {
  tokenize: xD,
  partial: !0
};
function wD(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(p) {
    return e.enter("definition"), o(p);
  }
  function o(p) {
    return PE.call(
      r,
      e,
      s,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(p);
  }
  function s(p) {
    return i = cr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), p === 58 ? (e.enter("definitionMarker"), e.consume(p), e.exit("definitionMarker"), c) : n(p);
  }
  function c(p) {
    return xt(p) ? rs(e, l)(p) : l(p);
  }
  function l(p) {
    return AE(
      e,
      u,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(p);
  }
  function u(p) {
    return e.attempt(bD, f, f)(p);
  }
  function f(p) {
    return Ge(p) ? rt(e, d, "whitespace")(p) : d(p);
  }
  function d(p) {
    return p === null || Ae(p) ? (e.exit("definition"), r.parser.defined.push(i), t(p)) : n(p);
  }
}
function xD(e, t, n) {
  return r;
  function r(s) {
    return xt(s) ? rs(e, i)(s) : n(s);
  }
  function i(s) {
    return DE(e, a, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(s);
  }
  function a(s) {
    return Ge(s) ? rt(e, o, "whitespace")(s) : o(s);
  }
  function o(s) {
    return s === null || Ae(s) ? t(s) : n(s);
  }
}
const SD = {
  name: "hardBreakEscape",
  tokenize: ED
};
function ED(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), i;
  }
  function i(a) {
    return Ae(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const _D = {
  name: "headingAtx",
  tokenize: TD,
  resolve: kD
};
function kD(e, t) {
  let n = e.length - 2, r = 3, i, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Kn(e, r, n - r + 1, [["enter", i, t], ["enter", a, t], ["exit", a, t], ["exit", i, t]])), e;
}
function TD(e, t, n) {
  let r = 0;
  return i;
  function i(u) {
    return e.enter("atxHeading"), a(u);
  }
  function a(u) {
    return e.enter("atxHeadingSequence"), o(u);
  }
  function o(u) {
    return u === 35 && r++ < 6 ? (e.consume(u), o) : u === null || xt(u) ? (e.exit("atxHeadingSequence"), s(u)) : n(u);
  }
  function s(u) {
    return u === 35 ? (e.enter("atxHeadingSequence"), c(u)) : u === null || Ae(u) ? (e.exit("atxHeading"), t(u)) : Ge(u) ? rt(e, s, "whitespace")(u) : (e.enter("atxHeadingText"), l(u));
  }
  function c(u) {
    return u === 35 ? (e.consume(u), c) : (e.exit("atxHeadingSequence"), s(u));
  }
  function l(u) {
    return u === null || u === 35 || xt(u) ? (e.exit("atxHeadingText"), s(u)) : (e.consume(u), l);
  }
}
const CD = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], ib = ["pre", "script", "style", "textarea"], OD = {
  name: "htmlFlow",
  tokenize: AD,
  resolveTo: ID,
  concrete: !0
}, $D = {
  tokenize: DD,
  partial: !0
}, RD = {
  tokenize: PD,
  partial: !0
};
function ID(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function AD(e, t, n) {
  const r = this;
  let i, a, o, s, c;
  return l;
  function l(S) {
    return u(S);
  }
  function u(S) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(S), f;
  }
  function f(S) {
    return S === 33 ? (e.consume(S), d) : S === 47 ? (e.consume(S), a = !0, h) : S === 63 ? (e.consume(S), i = 3, r.interrupt ? t : g) : xn(S) ? (e.consume(S), o = String.fromCharCode(S), y) : n(S);
  }
  function d(S) {
    return S === 45 ? (e.consume(S), i = 2, p) : S === 91 ? (e.consume(S), i = 5, s = 0, m) : xn(S) ? (e.consume(S), i = 4, r.interrupt ? t : g) : n(S);
  }
  function p(S) {
    return S === 45 ? (e.consume(S), r.interrupt ? t : g) : n(S);
  }
  function m(S) {
    const Z = "CDATA[";
    return S === Z.charCodeAt(s++) ? (e.consume(S), s === Z.length ? r.interrupt ? t : q : m) : n(S);
  }
  function h(S) {
    return xn(S) ? (e.consume(S), o = String.fromCharCode(S), y) : n(S);
  }
  function y(S) {
    if (S === null || S === 47 || S === 62 || xt(S)) {
      const Z = S === 47, Y = o.toLowerCase();
      return !Z && !a && ib.includes(Y) ? (i = 1, r.interrupt ? t(S) : q(S)) : CD.includes(o.toLowerCase()) ? (i = 6, Z ? (e.consume(S), v) : r.interrupt ? t(S) : q(S)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(S) : a ? b(S) : w(S));
    }
    return S === 45 || hn(S) ? (e.consume(S), o += String.fromCharCode(S), y) : n(S);
  }
  function v(S) {
    return S === 62 ? (e.consume(S), r.interrupt ? t : q) : n(S);
  }
  function b(S) {
    return Ge(S) ? (e.consume(S), b) : k(S);
  }
  function w(S) {
    return S === 47 ? (e.consume(S), k) : S === 58 || S === 95 || xn(S) ? (e.consume(S), T) : Ge(S) ? (e.consume(S), w) : k(S);
  }
  function T(S) {
    return S === 45 || S === 46 || S === 58 || S === 95 || hn(S) ? (e.consume(S), T) : E(S);
  }
  function E(S) {
    return S === 61 ? (e.consume(S), _) : Ge(S) ? (e.consume(S), E) : w(S);
  }
  function _(S) {
    return S === null || S === 60 || S === 61 || S === 62 || S === 96 ? n(S) : S === 34 || S === 39 ? (e.consume(S), c = S, $) : Ge(S) ? (e.consume(S), _) : B(S);
  }
  function $(S) {
    return S === c ? (e.consume(S), c = null, U) : S === null || Ae(S) ? n(S) : (e.consume(S), $);
  }
  function B(S) {
    return S === null || S === 34 || S === 39 || S === 47 || S === 60 || S === 61 || S === 62 || S === 96 || xt(S) ? E(S) : (e.consume(S), B);
  }
  function U(S) {
    return S === 47 || S === 62 || Ge(S) ? w(S) : n(S);
  }
  function k(S) {
    return S === 62 ? (e.consume(S), D) : n(S);
  }
  function D(S) {
    return S === null || Ae(S) ? q(S) : Ge(S) ? (e.consume(S), D) : n(S);
  }
  function q(S) {
    return S === 45 && i === 2 ? (e.consume(S), F) : S === 60 && i === 1 ? (e.consume(S), H) : S === 62 && i === 4 ? (e.consume(S), j) : S === 63 && i === 3 ? (e.consume(S), g) : S === 93 && i === 5 ? (e.consume(S), I) : Ae(S) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check($D, W, L)(S)) : S === null || Ae(S) ? (e.exit("htmlFlowData"), L(S)) : (e.consume(S), q);
  }
  function L(S) {
    return e.check(RD, R, W)(S);
  }
  function R(S) {
    return e.enter("lineEnding"), e.consume(S), e.exit("lineEnding"), A;
  }
  function A(S) {
    return S === null || Ae(S) ? L(S) : (e.enter("htmlFlowData"), q(S));
  }
  function F(S) {
    return S === 45 ? (e.consume(S), g) : q(S);
  }
  function H(S) {
    return S === 47 ? (e.consume(S), o = "", V) : q(S);
  }
  function V(S) {
    if (S === 62) {
      const Z = o.toLowerCase();
      return ib.includes(Z) ? (e.consume(S), j) : q(S);
    }
    return xn(S) && o.length < 8 ? (e.consume(S), o += String.fromCharCode(S), V) : q(S);
  }
  function I(S) {
    return S === 93 ? (e.consume(S), g) : q(S);
  }
  function g(S) {
    return S === 62 ? (e.consume(S), j) : S === 45 && i === 2 ? (e.consume(S), g) : q(S);
  }
  function j(S) {
    return S === null || Ae(S) ? (e.exit("htmlFlowData"), W(S)) : (e.consume(S), j);
  }
  function W(S) {
    return e.exit("htmlFlow"), t(S);
  }
}
function PD(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return Ae(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), a) : n(o);
  }
  function a(o) {
    return r.parser.lazy[r.now().line] ? n(o) : t(o);
  }
}
function DD(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(il, t, n);
  }
}
const jD = {
  name: "htmlText",
  tokenize: ND
};
function ND(e, t, n) {
  const r = this;
  let i, a, o;
  return s;
  function s(g) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(g), c;
  }
  function c(g) {
    return g === 33 ? (e.consume(g), l) : g === 47 ? (e.consume(g), E) : g === 63 ? (e.consume(g), w) : xn(g) ? (e.consume(g), B) : n(g);
  }
  function l(g) {
    return g === 45 ? (e.consume(g), u) : g === 91 ? (e.consume(g), a = 0, m) : xn(g) ? (e.consume(g), b) : n(g);
  }
  function u(g) {
    return g === 45 ? (e.consume(g), p) : n(g);
  }
  function f(g) {
    return g === null ? n(g) : g === 45 ? (e.consume(g), d) : Ae(g) ? (o = f, H(g)) : (e.consume(g), f);
  }
  function d(g) {
    return g === 45 ? (e.consume(g), p) : f(g);
  }
  function p(g) {
    return g === 62 ? F(g) : g === 45 ? d(g) : f(g);
  }
  function m(g) {
    const j = "CDATA[";
    return g === j.charCodeAt(a++) ? (e.consume(g), a === j.length ? h : m) : n(g);
  }
  function h(g) {
    return g === null ? n(g) : g === 93 ? (e.consume(g), y) : Ae(g) ? (o = h, H(g)) : (e.consume(g), h);
  }
  function y(g) {
    return g === 93 ? (e.consume(g), v) : h(g);
  }
  function v(g) {
    return g === 62 ? F(g) : g === 93 ? (e.consume(g), v) : h(g);
  }
  function b(g) {
    return g === null || g === 62 ? F(g) : Ae(g) ? (o = b, H(g)) : (e.consume(g), b);
  }
  function w(g) {
    return g === null ? n(g) : g === 63 ? (e.consume(g), T) : Ae(g) ? (o = w, H(g)) : (e.consume(g), w);
  }
  function T(g) {
    return g === 62 ? F(g) : w(g);
  }
  function E(g) {
    return xn(g) ? (e.consume(g), _) : n(g);
  }
  function _(g) {
    return g === 45 || hn(g) ? (e.consume(g), _) : $(g);
  }
  function $(g) {
    return Ae(g) ? (o = $, H(g)) : Ge(g) ? (e.consume(g), $) : F(g);
  }
  function B(g) {
    return g === 45 || hn(g) ? (e.consume(g), B) : g === 47 || g === 62 || xt(g) ? U(g) : n(g);
  }
  function U(g) {
    return g === 47 ? (e.consume(g), F) : g === 58 || g === 95 || xn(g) ? (e.consume(g), k) : Ae(g) ? (o = U, H(g)) : Ge(g) ? (e.consume(g), U) : F(g);
  }
  function k(g) {
    return g === 45 || g === 46 || g === 58 || g === 95 || hn(g) ? (e.consume(g), k) : D(g);
  }
  function D(g) {
    return g === 61 ? (e.consume(g), q) : Ae(g) ? (o = D, H(g)) : Ge(g) ? (e.consume(g), D) : U(g);
  }
  function q(g) {
    return g === null || g === 60 || g === 61 || g === 62 || g === 96 ? n(g) : g === 34 || g === 39 ? (e.consume(g), i = g, L) : Ae(g) ? (o = q, H(g)) : Ge(g) ? (e.consume(g), q) : (e.consume(g), R);
  }
  function L(g) {
    return g === i ? (e.consume(g), i = void 0, A) : g === null ? n(g) : Ae(g) ? (o = L, H(g)) : (e.consume(g), L);
  }
  function R(g) {
    return g === null || g === 34 || g === 39 || g === 60 || g === 61 || g === 96 ? n(g) : g === 47 || g === 62 || xt(g) ? U(g) : (e.consume(g), R);
  }
  function A(g) {
    return g === 47 || g === 62 || xt(g) ? U(g) : n(g);
  }
  function F(g) {
    return g === 62 ? (e.consume(g), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(g);
  }
  function H(g) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(g), e.exit("lineEnding"), V;
  }
  function V(g) {
    return Ge(g) ? rt(e, I, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(g) : I(g);
  }
  function I(g) {
    return e.enter("htmlTextData"), o(g);
  }
}
const hv = {
  name: "labelEnd",
  tokenize: zD,
  resolveTo: UD,
  resolveAll: BD
}, MD = {
  tokenize: qD
}, FD = {
  tokenize: WD
}, LD = {
  tokenize: VD
};
function BD(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function UD(e, t) {
  let n = e.length, r = 0, i, a, o, s;
  for (; n--; )
    if (i = e[n][1], a) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (a = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else i.type === "labelEnd" && (o = n);
  const c = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, l = {
    type: "label",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[o][1].end)
  }, u = {
    type: "labelText",
    start: Object.assign({}, e[a + r + 2][1].end),
    end: Object.assign({}, e[o - 2][1].start)
  };
  return s = [["enter", c, t], ["enter", l, t]], s = Vn(s, e.slice(a + 1, a + r + 3)), s = Vn(s, [["enter", u, t]]), s = Vn(s, Zu(t.parser.constructs.insideSpan.null, e.slice(a + r + 4, o - 3), t)), s = Vn(s, [["exit", u, t], e[o - 2], e[o - 1], ["exit", l, t]]), s = Vn(s, e.slice(o + 1)), s = Vn(s, [["exit", c, t]]), Kn(e, a, e.length, s), e;
}
function zD(e, t, n) {
  const r = this;
  let i = r.events.length, a, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      a = r.events[i][1];
      break;
    }
  return s;
  function s(d) {
    return a ? a._inactive ? f(d) : (o = r.parser.defined.includes(cr(r.sliceSerialize({
      start: a.end,
      end: r.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(d), e.exit("labelMarker"), e.exit("labelEnd"), c) : n(d);
  }
  function c(d) {
    return d === 40 ? e.attempt(MD, u, o ? u : f)(d) : d === 91 ? e.attempt(FD, u, o ? l : f)(d) : o ? u(d) : f(d);
  }
  function l(d) {
    return e.attempt(LD, u, f)(d);
  }
  function u(d) {
    return t(d);
  }
  function f(d) {
    return a._balanced = !0, n(d);
  }
}
function qD(e, t, n) {
  return r;
  function r(f) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), i;
  }
  function i(f) {
    return xt(f) ? rs(e, a)(f) : a(f);
  }
  function a(f) {
    return f === 41 ? u(f) : AE(e, o, s, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(f);
  }
  function o(f) {
    return xt(f) ? rs(e, c)(f) : u(f);
  }
  function s(f) {
    return n(f);
  }
  function c(f) {
    return f === 34 || f === 39 || f === 40 ? DE(e, l, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(f) : u(f);
  }
  function l(f) {
    return xt(f) ? rs(e, u)(f) : u(f);
  }
  function u(f) {
    return f === 41 ? (e.enter("resourceMarker"), e.consume(f), e.exit("resourceMarker"), e.exit("resource"), t) : n(f);
  }
}
function WD(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return PE.call(r, e, a, o, "reference", "referenceMarker", "referenceString")(s);
  }
  function a(s) {
    return r.parser.defined.includes(cr(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(s) : n(s);
  }
  function o(s) {
    return n(s);
  }
}
function VD(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), i;
  }
  function i(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const HD = {
  name: "labelStartImage",
  tokenize: ZD,
  resolveAll: hv.resolveAll
};
function ZD(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(s), e.exit("labelImageMarker"), a;
  }
  function a(s) {
    return s === 91 ? (e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelImage"), o) : n(s);
  }
  function o(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const KD = {
  name: "labelStartLink",
  tokenize: GD,
  resolveAll: hv.resolveAll
};
function GD(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const Jf = {
  name: "lineEnding",
  tokenize: YD
};
function YD(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), rt(e, t, "linePrefix");
  }
}
const xc = {
  name: "thematicBreak",
  tokenize: JD
};
function JD(e, t, n) {
  let r = 0, i;
  return a;
  function a(l) {
    return e.enter("thematicBreak"), o(l);
  }
  function o(l) {
    return i = l, s(l);
  }
  function s(l) {
    return l === i ? (e.enter("thematicBreakSequence"), c(l)) : r >= 3 && (l === null || Ae(l)) ? (e.exit("thematicBreak"), t(l)) : n(l);
  }
  function c(l) {
    return l === i ? (e.consume(l), r++, c) : (e.exit("thematicBreakSequence"), Ge(l) ? rt(e, s, "whitespace")(l) : s(l));
  }
}
const Tn = {
  name: "list",
  tokenize: ej,
  continuation: {
    tokenize: tj
  },
  exit: rj
}, XD = {
  tokenize: ij,
  partial: !0
}, QD = {
  tokenize: nj,
  partial: !0
};
function ej(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let a = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return s;
  function s(p) {
    const m = r.containerState.type || (p === 42 || p === 43 || p === 45 ? "listUnordered" : "listOrdered");
    if (m === "listUnordered" ? !r.containerState.marker || p === r.containerState.marker : kh(p)) {
      if (r.containerState.type || (r.containerState.type = m, e.enter(m, {
        _container: !0
      })), m === "listUnordered")
        return e.enter("listItemPrefix"), p === 42 || p === 45 ? e.check(xc, n, l)(p) : l(p);
      if (!r.interrupt || p === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), c(p);
    }
    return n(p);
  }
  function c(p) {
    return kh(p) && ++o < 10 ? (e.consume(p), c) : (!r.interrupt || o < 2) && (r.containerState.marker ? p === r.containerState.marker : p === 41 || p === 46) ? (e.exit("listItemValue"), l(p)) : n(p);
  }
  function l(p) {
    return e.enter("listItemMarker"), e.consume(p), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || p, e.check(
      il,
      // Can’t be empty when interrupting.
      r.interrupt ? n : u,
      e.attempt(XD, d, f)
    );
  }
  function u(p) {
    return r.containerState.initialBlankLine = !0, a++, d(p);
  }
  function f(p) {
    return Ge(p) ? (e.enter("listItemPrefixWhitespace"), e.consume(p), e.exit("listItemPrefixWhitespace"), d) : n(p);
  }
  function d(p) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(p);
  }
}
function tj(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(il, i, a);
  function i(s) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, rt(e, t, "listItemIndent", r.containerState.size + 1)(s);
  }
  function a(s) {
    return r.containerState.furtherBlankLines || !Ge(s) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(s)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(QD, t, o)(s));
  }
  function o(s) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, rt(e, e.attempt(Tn, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s);
  }
}
function nj(e, t, n) {
  const r = this;
  return rt(e, i, "listItemIndent", r.containerState.size + 1);
  function i(a) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function rj(e) {
  e.exit(this.containerState.type);
}
function ij(e, t, n) {
  const r = this;
  return rt(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(a) {
    const o = r.events[r.events.length - 1];
    return !Ge(a) && o && o[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const ab = {
  name: "setextUnderline",
  tokenize: oj,
  resolveTo: aj
};
function aj(e, t) {
  let n = e.length, r, i, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const o = {
    type: "setextHeading",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[i][1].type = "setextHeadingText", a ? (e.splice(i, 0, ["enter", o, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[a][1].end)) : e[r][1] = o, e.push(["exit", o, t]), e;
}
function oj(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(l) {
    let u = r.events.length, f;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        f = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || f) ? (e.enter("setextHeadingLine"), i = l, o(l)) : n(l);
  }
  function o(l) {
    return e.enter("setextHeadingLineSequence"), s(l);
  }
  function s(l) {
    return l === i ? (e.consume(l), s) : (e.exit("setextHeadingLineSequence"), Ge(l) ? rt(e, c, "lineSuffix")(l) : c(l));
  }
  function c(l) {
    return l === null || Ae(l) ? (e.exit("setextHeadingLine"), t(l)) : n(l);
  }
}
const sj = {
  tokenize: lj
};
function lj(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    il,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      i,
      rt(
        e,
        e.attempt(
          this.parser.constructs.flow,
          i,
          e.attempt(pD, i)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const cj = {
  resolveAll: NE()
}, uj = jE("string"), fj = jE("text");
function jE(e) {
  return {
    tokenize: t,
    resolveAll: NE(
      e === "text" ? dj : void 0
    )
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], a = n.attempt(i, o, s);
    return o;
    function o(u) {
      return l(u) ? a(u) : s(u);
    }
    function s(u) {
      if (u === null) {
        n.consume(u);
        return;
      }
      return n.enter("data"), n.consume(u), c;
    }
    function c(u) {
      return l(u) ? (n.exit("data"), a(u)) : (n.consume(u), c);
    }
    function l(u) {
      if (u === null)
        return !0;
      const f = i[u];
      let d = -1;
      if (f)
        for (; ++d < f.length; ) {
          const p = f[d];
          if (!p.previous || p.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function NE(e) {
  return t;
  function t(n, r) {
    let i = -1, a;
    for (; ++i <= n.length; )
      a === void 0 ? n[i] && n[i][1].type === "data" && (a = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== a + 2 && (n[a][1].end = n[i - 1][1].end, n.splice(a + 2, i - a - 2), i = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function dj(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let a = i.length, o = -1, s = 0, c;
      for (; a--; ) {
        const l = i[a];
        if (typeof l == "string") {
          for (o = l.length; l.charCodeAt(o - 1) === 32; )
            s++, o--;
          if (o) break;
          o = -1;
        } else if (l === -2)
          c = !0, s++;
        else if (l !== -1) {
          a++;
          break;
        }
      }
      if (s) {
        const l = {
          type: n === e.length || c || s < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - s,
            offset: r.end.offset - s,
            _index: r.start._index + a,
            _bufferIndex: a ? o : r.start._bufferIndex + o
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, l.start), r.start.offset === r.end.offset ? Object.assign(r, l) : (e.splice(
          n,
          0,
          ["enter", l, t],
          ["exit", l, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function pj(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, a = [];
  let o = [], s = [];
  const c = {
    consume: b,
    enter: w,
    exit: T,
    attempt: $(E),
    check: $(_),
    interrupt: $(_, {
      interrupt: !0
    })
  }, l = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: p,
    sliceSerialize: d,
    now: m,
    defineSkip: h,
    write: f
  };
  let u = t.tokenize.call(l, c);
  return t.resolveAll && a.push(t), l;
  function f(D) {
    return o = Vn(o, D), y(), o[o.length - 1] !== null ? [] : (B(t, 0), l.events = Zu(a, l.events, l), l.events);
  }
  function d(D, q) {
    return mj(p(D), q);
  }
  function p(D) {
    return hj(o, D);
  }
  function m() {
    const { line: D, column: q, offset: L, _index: R, _bufferIndex: A } = r;
    return {
      line: D,
      column: q,
      offset: L,
      _index: R,
      _bufferIndex: A
    };
  }
  function h(D) {
    i[D.line] = D.column, k();
  }
  function y() {
    let D;
    for (; r._index < o.length; ) {
      const q = o[r._index];
      if (typeof q == "string")
        for (D = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === D && r._bufferIndex < q.length; )
          v(q.charCodeAt(r._bufferIndex));
      else
        v(q);
    }
  }
  function v(D) {
    u = u(D);
  }
  function b(D) {
    Ae(D) ? (r.line++, r.column = 1, r.offset += D === -3 ? 2 : 1, k()) : D !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), l.previous = D;
  }
  function w(D, q) {
    const L = q || {};
    return L.type = D, L.start = m(), l.events.push(["enter", L, l]), s.push(L), L;
  }
  function T(D) {
    const q = s.pop();
    return q.end = m(), l.events.push(["exit", q, l]), q;
  }
  function E(D, q) {
    B(D, q.from);
  }
  function _(D, q) {
    q.restore();
  }
  function $(D, q) {
    return L;
    function L(R, A, F) {
      let H, V, I, g;
      return Array.isArray(R) ? W(R) : "tokenize" in R ? (
        // @ts-expect-error Looks like a construct.
        W([R])
      ) : j(R);
      function j(G) {
        return X;
        function X(ie) {
          const ae = ie !== null && G[ie], J = ie !== null && G.null, Q = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ae) ? ae : ae ? [ae] : [],
            ...Array.isArray(J) ? J : J ? [J] : []
          ];
          return W(Q)(ie);
        }
      }
      function W(G) {
        return H = G, V = 0, G.length === 0 ? F : S(G[V]);
      }
      function S(G) {
        return X;
        function X(ie) {
          return g = U(), I = G, G.partial || (l.currentConstruct = G), G.name && l.parser.constructs.disable.null.includes(G.name) ? Y() : G.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            q ? Object.assign(Object.create(l), q) : l,
            c,
            Z,
            Y
          )(ie);
        }
      }
      function Z(G) {
        return D(I, g), A;
      }
      function Y(G) {
        return g.restore(), ++V < H.length ? S(H[V]) : F;
      }
    }
  }
  function B(D, q) {
    D.resolveAll && !a.includes(D) && a.push(D), D.resolve && Kn(
      l.events,
      q,
      l.events.length - q,
      D.resolve(l.events.slice(q), l)
    ), D.resolveTo && (l.events = D.resolveTo(l.events, l));
  }
  function U() {
    const D = m(), q = l.previous, L = l.currentConstruct, R = l.events.length, A = Array.from(s);
    return {
      restore: F,
      from: R
    };
    function F() {
      r = D, l.previous = q, l.currentConstruct = L, l.events.length = R, s = A, k();
    }
  }
  function k() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function hj(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, a = t.end._bufferIndex;
  let o;
  if (n === i)
    o = [e[n].slice(r, a)];
  else {
    if (o = e.slice(n, i), r > -1) {
      const s = o[0];
      typeof s == "string" ? o[0] = s.slice(r) : o.shift();
    }
    a > 0 && o.push(e[i].slice(0, a));
  }
  return o;
}
function mj(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const a = e[n];
    let o;
    if (typeof a == "string")
      o = a;
    else
      switch (a) {
        case -5: {
          o = "\r";
          break;
        }
        case -4: {
          o = `
`;
          break;
        }
        case -3: {
          o = `\r
`;
          break;
        }
        case -2: {
          o = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i) continue;
          o = " ";
          break;
        }
        default:
          o = String.fromCharCode(a);
      }
    i = a === -2, r.push(o);
  }
  return r.join("");
}
const vj = {
  42: Tn,
  43: Tn,
  45: Tn,
  48: Tn,
  49: Tn,
  50: Tn,
  51: Tn,
  52: Tn,
  53: Tn,
  54: Tn,
  55: Tn,
  56: Tn,
  57: Tn,
  62: OE
}, yj = {
  91: gD
}, gj = {
  [-2]: Yf,
  [-1]: Yf,
  32: Yf
}, bj = {
  35: _D,
  42: xc,
  45: [ab, xc],
  60: OD,
  61: ab,
  95: xc,
  96: rb,
  126: rb
}, wj = {
  38: RE,
  92: $E
}, xj = {
  [-5]: Jf,
  [-4]: Jf,
  [-3]: Jf,
  33: HD,
  38: RE,
  42: Th,
  60: [KP, jD],
  91: KD,
  92: [SD, $E],
  93: hv,
  95: Th,
  96: sD
}, Sj = {
  null: [Th, cj]
}, Ej = {
  null: [42, 95]
}, _j = {
  null: []
}, kj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Ej,
  contentInitial: yj,
  disable: _j,
  document: vj,
  flow: bj,
  flowInitial: gj,
  insideSpan: Sj,
  string: wj,
  text: xj
}, Symbol.toStringTag, { value: "Module" }));
function Tj(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    TE([kj, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: i(UP),
    document: i(qP),
    flow: i(sj),
    string: i(uj),
    text: i(fj)
  };
  return r;
  function i(a) {
    return o;
    function o(s) {
      return pj(r, a, s);
    }
  }
}
function Cj(e) {
  for (; !IE(e); )
    ;
  return e;
}
const ob = /[\0\t\n\r]/g;
function Oj() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(a, o, s) {
    const c = [];
    let l, u, f, d, p;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(o || void 0).decode(a)), f = 0, t = "", n && (a.charCodeAt(0) === 65279 && f++, n = void 0); f < a.length; ) {
      if (ob.lastIndex = f, l = ob.exec(a), d = l && l.index !== void 0 ? l.index : a.length, p = a.charCodeAt(d), !l) {
        t = a.slice(f);
        break;
      }
      if (p === 10 && f === d && r)
        c.push(-3), r = void 0;
      else
        switch (r && (c.push(-5), r = void 0), f < d && (c.push(a.slice(f, d)), e += d - f), p) {
          case 0: {
            c.push(65533), e++;
            break;
          }
          case 9: {
            for (u = Math.ceil(e / 4) * 4, c.push(-2); e++ < u; ) c.push(-1);
            break;
          }
          case 10: {
            c.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      f = d + 1;
    }
    return s && (r && c.push(-5), t && c.push(t), c.push(null)), c;
  }
}
const $j = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Rj(e) {
  return e.replace($j, Ij);
}
function Ij(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), a = i === 120 || i === 88;
    return CE(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return pv(n) || e;
}
const ME = {}.hasOwnProperty;
function Aj(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), Pj(n)(Cj(Tj(n).document().write(Oj()(e, t, !0))));
}
function Pj(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(oe),
      autolinkProtocol: U,
      autolinkEmail: U,
      atxHeading: a($e),
      blockQuote: a(J),
      characterEscape: U,
      characterReference: U,
      codeFenced: a(Q),
      codeFencedFenceInfo: o,
      codeFencedFenceMeta: o,
      codeIndented: a(Q, o),
      codeText: a(K, o),
      codeTextData: U,
      data: U,
      codeFlowValue: U,
      definition: a(fe),
      definitionDestinationString: o,
      definitionLabelString: o,
      definitionTitleString: o,
      emphasis: a(ye),
      hardBreakEscape: a(M),
      hardBreakTrailing: a(M),
      htmlFlow: a(re, o),
      htmlFlowData: U,
      htmlText: a(re, o),
      htmlTextData: U,
      image: a(le),
      label: o,
      link: a(oe),
      listItem: a(Se),
      listItemValue: d,
      listOrdered: a(Te, f),
      listUnordered: a(Te),
      paragraph: a(Re),
      reference: S,
      referenceString: o,
      resourceDestinationString: o,
      resourceTitleString: o,
      setextHeading: a($e),
      strong: a(ze),
      thematicBreak: a(ue)
    },
    exit: {
      atxHeading: c(),
      atxHeadingSequence: E,
      autolink: c(),
      autolinkEmail: ae,
      autolinkProtocol: ie,
      blockQuote: c(),
      characterEscapeValue: k,
      characterReferenceMarkerHexadecimal: Y,
      characterReferenceMarkerNumeric: Y,
      characterReferenceValue: G,
      characterReference: X,
      codeFenced: c(y),
      codeFencedFence: h,
      codeFencedFenceInfo: p,
      codeFencedFenceMeta: m,
      codeFlowValue: k,
      codeIndented: c(v),
      codeText: c(A),
      codeTextData: k,
      data: k,
      definition: c(),
      definitionDestinationString: T,
      definitionLabelString: b,
      definitionTitleString: w,
      emphasis: c(),
      hardBreakEscape: c(q),
      hardBreakTrailing: c(q),
      htmlFlow: c(L),
      htmlFlowData: k,
      htmlText: c(R),
      htmlTextData: k,
      image: c(H),
      label: I,
      labelText: V,
      lineEnding: D,
      link: c(F),
      listItem: c(),
      listOrdered: c(),
      listUnordered: c(),
      paragraph: c(),
      referenceString: Z,
      resourceDestinationString: g,
      resourceTitleString: j,
      resource: W,
      setextHeading: c(B),
      setextHeadingLineSequence: $,
      setextHeadingText: _,
      strong: c(),
      thematicBreak: c()
    }
  };
  FE(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(z) {
    let N = {
      type: "root",
      children: []
    };
    const te = {
      stack: [N],
      tokenStack: [],
      config: t,
      enter: s,
      exit: l,
      buffer: o,
      resume: u,
      data: n
    }, de = [];
    let be = -1;
    for (; ++be < z.length; )
      if (z[be][1].type === "listOrdered" || z[be][1].type === "listUnordered")
        if (z[be][0] === "enter")
          de.push(be);
        else {
          const Oe = de.pop();
          be = i(z, Oe, be);
        }
    for (be = -1; ++be < z.length; ) {
      const Oe = t[z[be][0]];
      ME.call(Oe, z[be][1].type) && Oe[z[be][1].type].call(Object.assign({
        sliceSerialize: z[be][2].sliceSerialize
      }, te), z[be][1]);
    }
    if (te.tokenStack.length > 0) {
      const Oe = te.tokenStack[te.tokenStack.length - 1];
      (Oe[1] || sb).call(te, void 0, Oe[0]);
    }
    for (N.position = {
      start: ci(z.length > 0 ? z[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: ci(z.length > 0 ? z[z.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, be = -1; ++be < t.transforms.length; )
      N = t.transforms[be](N) || N;
    return N;
  }
  function i(z, N, te) {
    let de = N - 1, be = -1, Oe = !1, Ve, Qe, Ct, _t;
    for (; ++de <= te; ) {
      const Ue = z[de];
      switch (Ue[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          Ue[0] === "enter" ? be++ : be--, _t = void 0;
          break;
        }
        case "lineEndingBlank": {
          Ue[0] === "enter" && (Ve && !_t && !be && !Ct && (Ct = de), _t = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          _t = void 0;
      }
      if (!be && Ue[0] === "enter" && Ue[1].type === "listItemPrefix" || be === -1 && Ue[0] === "exit" && (Ue[1].type === "listUnordered" || Ue[1].type === "listOrdered")) {
        if (Ve) {
          let kt = de;
          for (Qe = void 0; kt--; ) {
            const Ze = z[kt];
            if (Ze[1].type === "lineEnding" || Ze[1].type === "lineEndingBlank") {
              if (Ze[0] === "exit") continue;
              Qe && (z[Qe][1].type = "lineEndingBlank", Oe = !0), Ze[1].type = "lineEnding", Qe = kt;
            } else if (!(Ze[1].type === "linePrefix" || Ze[1].type === "blockQuotePrefix" || Ze[1].type === "blockQuotePrefixWhitespace" || Ze[1].type === "blockQuoteMarker" || Ze[1].type === "listItemIndent")) break;
          }
          Ct && (!Qe || Ct < Qe) && (Ve._spread = !0), Ve.end = Object.assign({}, Qe ? z[Qe][1].start : Ue[1].end), z.splice(Qe || de, 0, ["exit", Ve, Ue[2]]), de++, te++;
        }
        if (Ue[1].type === "listItemPrefix") {
          const kt = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, Ue[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          Ve = kt, z.splice(de, 0, ["enter", kt, Ue[2]]), de++, te++, Ct = void 0, _t = !0;
        }
      }
    }
    return z[N][1]._spread = Oe, te;
  }
  function a(z, N) {
    return te;
    function te(de) {
      s.call(this, z(de), de), N && N.call(this, de);
    }
  }
  function o() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function s(z, N, te) {
    this.stack[this.stack.length - 1].children.push(z), this.stack.push(z), this.tokenStack.push([N, te]), z.position = {
      start: ci(N.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function c(z) {
    return N;
    function N(te) {
      z && z.call(this, te), l.call(this, te);
    }
  }
  function l(z, N) {
    const te = this.stack.pop(), de = this.tokenStack.pop();
    if (de)
      de[0].type !== z.type && (N ? N.call(this, z, de[0]) : (de[1] || sb).call(this, z, de[0]));
    else throw new Error("Cannot close `" + z.type + "` (" + ns({
      start: z.start,
      end: z.end
    }) + "): it’s not open");
    te.position.end = ci(z.end);
  }
  function u() {
    return dv(this.stack.pop());
  }
  function f() {
    this.data.expectingFirstListItemValue = !0;
  }
  function d(z) {
    if (this.data.expectingFirstListItemValue) {
      const N = this.stack[this.stack.length - 2];
      N.start = Number.parseInt(this.sliceSerialize(z), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function p() {
    const z = this.resume(), N = this.stack[this.stack.length - 1];
    N.lang = z;
  }
  function m() {
    const z = this.resume(), N = this.stack[this.stack.length - 1];
    N.meta = z;
  }
  function h() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function y() {
    const z = this.resume(), N = this.stack[this.stack.length - 1];
    N.value = z.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function v() {
    const z = this.resume(), N = this.stack[this.stack.length - 1];
    N.value = z.replace(/(\r?\n|\r)$/g, "");
  }
  function b(z) {
    const N = this.resume(), te = this.stack[this.stack.length - 1];
    te.label = N, te.identifier = cr(this.sliceSerialize(z)).toLowerCase();
  }
  function w() {
    const z = this.resume(), N = this.stack[this.stack.length - 1];
    N.title = z;
  }
  function T() {
    const z = this.resume(), N = this.stack[this.stack.length - 1];
    N.url = z;
  }
  function E(z) {
    const N = this.stack[this.stack.length - 1];
    if (!N.depth) {
      const te = this.sliceSerialize(z).length;
      N.depth = te;
    }
  }
  function _() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function $(z) {
    const N = this.stack[this.stack.length - 1];
    N.depth = this.sliceSerialize(z).codePointAt(0) === 61 ? 1 : 2;
  }
  function B() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function U(z) {
    const te = this.stack[this.stack.length - 1].children;
    let de = te[te.length - 1];
    (!de || de.type !== "text") && (de = ee(), de.position = {
      start: ci(z.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, te.push(de)), this.stack.push(de);
  }
  function k(z) {
    const N = this.stack.pop();
    N.value += this.sliceSerialize(z), N.position.end = ci(z.end);
  }
  function D(z) {
    const N = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const te = N.children[N.children.length - 1];
      te.position.end = ci(z.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(N.type) && (U.call(this, z), k.call(this, z));
  }
  function q() {
    this.data.atHardBreak = !0;
  }
  function L() {
    const z = this.resume(), N = this.stack[this.stack.length - 1];
    N.value = z;
  }
  function R() {
    const z = this.resume(), N = this.stack[this.stack.length - 1];
    N.value = z;
  }
  function A() {
    const z = this.resume(), N = this.stack[this.stack.length - 1];
    N.value = z;
  }
  function F() {
    const z = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const N = this.data.referenceType || "shortcut";
      z.type += "Reference", z.referenceType = N, delete z.url, delete z.title;
    } else
      delete z.identifier, delete z.label;
    this.data.referenceType = void 0;
  }
  function H() {
    const z = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const N = this.data.referenceType || "shortcut";
      z.type += "Reference", z.referenceType = N, delete z.url, delete z.title;
    } else
      delete z.identifier, delete z.label;
    this.data.referenceType = void 0;
  }
  function V(z) {
    const N = this.sliceSerialize(z), te = this.stack[this.stack.length - 2];
    te.label = Rj(N), te.identifier = cr(N).toLowerCase();
  }
  function I() {
    const z = this.stack[this.stack.length - 1], N = this.resume(), te = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, te.type === "link") {
      const de = z.children;
      te.children = de;
    } else
      te.alt = N;
  }
  function g() {
    const z = this.resume(), N = this.stack[this.stack.length - 1];
    N.url = z;
  }
  function j() {
    const z = this.resume(), N = this.stack[this.stack.length - 1];
    N.title = z;
  }
  function W() {
    this.data.inReference = void 0;
  }
  function S() {
    this.data.referenceType = "collapsed";
  }
  function Z(z) {
    const N = this.resume(), te = this.stack[this.stack.length - 1];
    te.label = N, te.identifier = cr(this.sliceSerialize(z)).toLowerCase(), this.data.referenceType = "full";
  }
  function Y(z) {
    this.data.characterReferenceType = z.type;
  }
  function G(z) {
    const N = this.sliceSerialize(z), te = this.data.characterReferenceType;
    let de;
    te ? (de = CE(N, te === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : de = pv(N);
    const be = this.stack[this.stack.length - 1];
    be.value += de;
  }
  function X(z) {
    const N = this.stack.pop();
    N.position.end = ci(z.end);
  }
  function ie(z) {
    k.call(this, z);
    const N = this.stack[this.stack.length - 1];
    N.url = this.sliceSerialize(z);
  }
  function ae(z) {
    k.call(this, z);
    const N = this.stack[this.stack.length - 1];
    N.url = "mailto:" + this.sliceSerialize(z);
  }
  function J() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Q() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function K() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function fe() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function ye() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function $e() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function M() {
    return {
      type: "break"
    };
  }
  function re() {
    return {
      type: "html",
      value: ""
    };
  }
  function le() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function oe() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Te(z) {
    return {
      type: "list",
      ordered: z.type === "listOrdered",
      start: null,
      spread: z._spread,
      children: []
    };
  }
  function Se(z) {
    return {
      type: "listItem",
      spread: z._spread,
      checked: null,
      children: []
    };
  }
  function Re() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function ze() {
    return {
      type: "strong",
      children: []
    };
  }
  function ee() {
    return {
      type: "text",
      value: ""
    };
  }
  function ue() {
    return {
      type: "thematicBreak"
    };
  }
}
function ci(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function FE(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? FE(e, r) : Dj(e, r);
  }
}
function Dj(e, t) {
  let n;
  for (n in t)
    if (ME.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function sb(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + ns({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + ns({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + ns({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function jj(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return Aj(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function Nj(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Mj(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function Fj(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function Lj(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Bj(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Uj(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = yo(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let o, s = e.footnoteCounts.get(r);
  s === void 0 ? (s = 0, e.footnoteOrder.push(r), o = e.footnoteOrder.length) : o = a + 1, s += 1, e.footnoteCounts.set(r, s);
  const c = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (s > 1 ? "-" + s : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(o) }]
  };
  e.patch(t, c);
  const l = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [c]
  };
  return e.patch(t, l), e.applyData(t, l);
}
function zj(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function qj(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function LE(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), a = i[0];
  a && a.type === "text" ? a.value = "[" + a.value : i.unshift({ type: "text", value: "[" });
  const o = i[i.length - 1];
  return o && o.type === "text" ? o.value += r : i.push({ type: "text", value: r }), i;
}
function Wj(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return LE(e, t);
  const i = { src: yo(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function Vj(e, t) {
  const n = { src: yo(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function Hj(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Zj(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return LE(e, t);
  const i = { href: yo(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function Kj(e, t) {
  const n = { href: yo(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Gj(e, t, n) {
  const r = e.all(t), i = n ? Yj(n) : BE(t), a = {}, o = [];
  if (typeof t.checked == "boolean") {
    const u = r[0];
    let f;
    u && u.type === "element" && u.tagName === "p" ? f = u : (f = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(f)), f.children.length > 0 && f.children.unshift({ type: "text", value: " " }), f.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let s = -1;
  for (; ++s < r.length; ) {
    const u = r[s];
    (i || s !== 0 || u.type !== "element" || u.tagName !== "p") && o.push({ type: "text", value: `
` }), u.type === "element" && u.tagName === "p" && !i ? o.push(...u.children) : o.push(u);
  }
  const c = r[r.length - 1];
  c && (i || c.type !== "element" || c.tagName !== "p") && o.push({ type: "text", value: `
` });
  const l = { type: "element", tagName: "li", properties: a, children: o };
  return e.patch(t, l), e.applyData(t, l);
}
function Yj(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = BE(n[r]);
  }
  return t;
}
function BE(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function Jj(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const o = r[i];
    if (o.type === "element" && o.tagName === "li" && o.properties && Array.isArray(o.properties.className) && o.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function Xj(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Qj(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function e2(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function t2(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const o = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], o), i.push(o);
  }
  if (n.length > 0) {
    const o = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, s = lv(t.children[1]), c = bE(t.children[t.children.length - 1]);
    s && c && (o.position = { start: s, end: c }), i.push(o);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function n2(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", o = n && n.type === "table" ? n.align : void 0, s = o ? o.length : t.children.length;
  let c = -1;
  const l = [];
  for (; ++c < s; ) {
    const f = t.children[c], d = {}, p = o ? o[c] : void 0;
    p && (d.align = p);
    let m = { type: "element", tagName: a, properties: d, children: [] };
    f && (m.children = e.all(f), e.patch(f, m), m = e.applyData(f, m)), l.push(m);
  }
  const u = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(l, !0)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function r2(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const lb = 9, cb = 32;
function i2(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const a = [];
  for (; r; )
    a.push(
      ub(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return a.push(ub(t.slice(i), i > 0, !1)), a.join("");
}
function ub(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === lb || a === cb; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(i - 1);
    for (; a === lb || a === cb; )
      i--, a = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function a2(e, t) {
  const n = { type: "text", value: i2(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function o2(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const s2 = {
  blockquote: Nj,
  break: Mj,
  code: Fj,
  delete: Lj,
  emphasis: Bj,
  footnoteReference: Uj,
  heading: zj,
  html: qj,
  imageReference: Wj,
  image: Vj,
  inlineCode: Hj,
  linkReference: Zj,
  link: Kj,
  listItem: Gj,
  list: Jj,
  paragraph: Xj,
  // @ts-expect-error: root is different, but hard to type.
  root: Qj,
  strong: e2,
  table: t2,
  tableCell: r2,
  tableRow: n2,
  text: a2,
  thematicBreak: o2,
  toml: Ll,
  yaml: Ll,
  definition: Ll,
  footnoteDefinition: Ll
};
function Ll() {
}
const UE = -1, Ku = 0, ru = 1, iu = 2, mv = 3, vv = 4, yv = 5, gv = 6, zE = 7, qE = 8, fb = typeof self == "object" ? self : globalThis, l2 = (e, t) => {
  const n = (i, a) => (e.set(a, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [a, o] = t[i];
    switch (a) {
      case Ku:
      case UE:
        return n(o, i);
      case ru: {
        const s = n([], i);
        for (const c of o)
          s.push(r(c));
        return s;
      }
      case iu: {
        const s = n({}, i);
        for (const [c, l] of o)
          s[r(c)] = r(l);
        return s;
      }
      case mv:
        return n(new Date(o), i);
      case vv: {
        const { source: s, flags: c } = o;
        return n(new RegExp(s, c), i);
      }
      case yv: {
        const s = n(/* @__PURE__ */ new Map(), i);
        for (const [c, l] of o)
          s.set(r(c), r(l));
        return s;
      }
      case gv: {
        const s = n(/* @__PURE__ */ new Set(), i);
        for (const c of o)
          s.add(r(c));
        return s;
      }
      case zE: {
        const { name: s, message: c } = o;
        return n(new fb[s](c), i);
      }
      case qE:
        return n(BigInt(o), i);
      case "BigInt":
        return n(Object(BigInt(o)), i);
    }
    return n(new fb[a](o), i);
  };
  return r;
}, db = (e) => l2(/* @__PURE__ */ new Map(), e)(0), ma = "", { toString: c2 } = {}, { keys: u2 } = Object, Fo = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Ku, t];
  const n = c2.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [ru, ma];
    case "Object":
      return [iu, ma];
    case "Date":
      return [mv, ma];
    case "RegExp":
      return [vv, ma];
    case "Map":
      return [yv, ma];
    case "Set":
      return [gv, ma];
  }
  return n.includes("Array") ? [ru, n] : n.includes("Error") ? [zE, n] : [iu, n];
}, Bl = ([e, t]) => e === Ku && (t === "function" || t === "symbol"), f2 = (e, t, n, r) => {
  const i = (o, s) => {
    const c = r.push(o) - 1;
    return n.set(s, c), c;
  }, a = (o) => {
    if (n.has(o))
      return n.get(o);
    let [s, c] = Fo(o);
    switch (s) {
      case Ku: {
        let u = o;
        switch (c) {
          case "bigint":
            s = qE, u = o.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + c);
            u = null;
            break;
          case "undefined":
            return i([UE], o);
        }
        return i([s, u], o);
      }
      case ru: {
        if (c)
          return i([c, [...o]], o);
        const u = [], f = i([s, u], o);
        for (const d of o)
          u.push(a(d));
        return f;
      }
      case iu: {
        if (c)
          switch (c) {
            case "BigInt":
              return i([c, o.toString()], o);
            case "Boolean":
            case "Number":
            case "String":
              return i([c, o.valueOf()], o);
          }
        if (t && "toJSON" in o)
          return a(o.toJSON());
        const u = [], f = i([s, u], o);
        for (const d of u2(o))
          (e || !Bl(Fo(o[d]))) && u.push([a(d), a(o[d])]);
        return f;
      }
      case mv:
        return i([s, o.toISOString()], o);
      case vv: {
        const { source: u, flags: f } = o;
        return i([s, { source: u, flags: f }], o);
      }
      case yv: {
        const u = [], f = i([s, u], o);
        for (const [d, p] of o)
          (e || !(Bl(Fo(d)) || Bl(Fo(p)))) && u.push([a(d), a(p)]);
        return f;
      }
      case gv: {
        const u = [], f = i([s, u], o);
        for (const d of o)
          (e || !Bl(Fo(d))) && u.push(a(d));
        return f;
      }
    }
    const { message: l } = o;
    return i([s, { name: c, message: l }], o);
  };
  return a;
}, pb = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return f2(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, au = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? db(pb(e, t)) : structuredClone(e)
) : (e, t) => db(pb(e, t));
function d2(e, t) {
  const n = [{ type: "text", value: "↩" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function p2(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function h2(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || d2, r = e.options.footnoteBackLabel || p2, i = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", o = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, s = [];
  let c = -1;
  for (; ++c < e.footnoteOrder.length; ) {
    const l = e.footnoteById.get(
      e.footnoteOrder[c]
    );
    if (!l)
      continue;
    const u = e.all(l), f = String(l.identifier).toUpperCase(), d = yo(f.toLowerCase());
    let p = 0;
    const m = [], h = e.footnoteCounts.get(f);
    for (; h !== void 0 && ++p <= h; ) {
      m.length > 0 && m.push({ type: "text", value: " " });
      let b = typeof n == "string" ? n : n(c, p);
      typeof b == "string" && (b = { type: "text", value: b }), m.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + d + (p > 1 ? "-" + p : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(c, p),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(b) ? b : [b]
      });
    }
    const y = u[u.length - 1];
    if (y && y.type === "element" && y.tagName === "p") {
      const b = y.children[y.children.length - 1];
      b && b.type === "text" ? b.value += " " : y.children.push({ type: "text", value: " " }), y.children.push(...m);
    } else
      u.push(...m);
    const v = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + d },
      children: e.wrap(u, !0)
    };
    e.patch(l, v), s.push(v);
  }
  if (s.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...au(o),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(s, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Gu = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return g2;
    if (typeof e == "function")
      return Yu(e);
    if (typeof e == "object")
      return Array.isArray(e) ? m2(e) : v2(e);
    if (typeof e == "string")
      return y2(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function m2(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Gu(e[n]);
  return Yu(r);
  function r(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i)) return !0;
    return !1;
  }
}
function v2(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Yu(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let a;
    for (a in e)
      if (i[a] !== t[a]) return !1;
    return !0;
  }
}
function y2(e) {
  return Yu(t);
  function t(n) {
    return n && n.type === e;
  }
}
function Yu(e) {
  return t;
  function t(n, r, i) {
    return !!(b2(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function g2() {
  return !0;
}
function b2(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const WE = [], w2 = !0, Ch = !1, x2 = "skip";
function VE(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const a = Gu(i), o = r ? -1 : 1;
  s(e, void 0, [])();
  function s(c, l, u) {
    const f = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof f.type == "string") {
      const p = (
        // `hast`
        typeof f.tagName == "string" ? f.tagName : (
          // `xast`
          typeof f.name == "string" ? f.name : void 0
        )
      );
      Object.defineProperty(d, "name", {
        value: "node (" + (c.type + (p ? "<" + p + ">" : "")) + ")"
      });
    }
    return d;
    function d() {
      let p = WE, m, h, y;
      if ((!t || a(c, l, u[u.length - 1] || void 0)) && (p = S2(n(c, u)), p[0] === Ch))
        return p;
      if ("children" in c && c.children) {
        const v = (
          /** @type {UnistParent} */
          c
        );
        if (v.children && p[0] !== x2)
          for (h = (r ? v.children.length : -1) + o, y = u.concat(v); h > -1 && h < v.children.length; ) {
            const b = v.children[h];
            if (m = s(b, h, y)(), m[0] === Ch)
              return m;
            h = typeof m[1] == "number" ? m[1] : h + o;
          }
      }
      return p;
    }
  }
}
function S2(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [w2, e] : e == null ? WE : [e];
}
function bv(e, t, n, r) {
  let i, a, o;
  typeof t == "function" && typeof n != "function" ? (a = void 0, o = t, i = n) : (a = t, o = n, i = r), VE(e, a, s, i);
  function s(c, l) {
    const u = l[l.length - 1], f = u ? u.children.indexOf(c) : void 0;
    return o(c, f, u);
  }
}
const Oh = {}.hasOwnProperty, E2 = {};
function _2(e, t) {
  const n = t || E2, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), o = { ...s2, ...n.handlers }, s = {
    all: l,
    applyData: T2,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: o,
    one: c,
    options: n,
    patch: k2,
    wrap: O2
  };
  return bv(e, function(u) {
    if (u.type === "definition" || u.type === "footnoteDefinition") {
      const f = u.type === "definition" ? r : i, d = String(u.identifier).toUpperCase();
      f.has(d) || f.set(d, u);
    }
  }), s;
  function c(u, f) {
    const d = u.type, p = s.handlers[d];
    if (Oh.call(s.handlers, d) && p)
      return p(s, u, f);
    if (s.options.passThrough && s.options.passThrough.includes(d)) {
      if ("children" in u) {
        const { children: h, ...y } = u, v = au(y);
        return v.children = s.all(u), v;
      }
      return au(u);
    }
    return (s.options.unknownHandler || C2)(s, u, f);
  }
  function l(u) {
    const f = [];
    if ("children" in u) {
      const d = u.children;
      let p = -1;
      for (; ++p < d.length; ) {
        const m = s.one(d[p], u);
        if (m) {
          if (p && d[p - 1].type === "break" && (!Array.isArray(m) && m.type === "text" && (m.value = hb(m.value)), !Array.isArray(m) && m.type === "element")) {
            const h = m.children[0];
            h && h.type === "text" && (h.value = hb(h.value));
          }
          Array.isArray(m) ? f.push(...m) : f.push(m);
        }
      }
    }
    return f;
  }
}
function k2(e, t) {
  e.position && (t.position = fP(e));
}
function T2(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const o = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: o };
      }
    n.type === "element" && a && Object.assign(n.properties, au(a)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function C2(e, t) {
  const n = t.data || {}, r = "value" in t && !(Oh.call(n, "hProperties") || Oh.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function O2(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function hb(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function mb(e, t) {
  const n = _2(e, t), r = n.one(e, void 0), i = h2(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && a.children.push({ type: "text", value: `
` }, i), a;
}
function $2(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      mb(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      mb(n, { file: r, ...e || t })
    );
  };
}
function vb(e) {
  if (e)
    throw e;
}
var Sc = Object.prototype.hasOwnProperty, HE = Object.prototype.toString, yb = Object.defineProperty, gb = Object.getOwnPropertyDescriptor, bb = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : HE.call(t) === "[object Array]";
}, wb = function(t) {
  if (!t || HE.call(t) !== "[object Object]")
    return !1;
  var n = Sc.call(t, "constructor"), r = t.constructor && t.constructor.prototype && Sc.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || Sc.call(t, i);
}, xb = function(t, n) {
  yb && n.name === "__proto__" ? yb(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, Sb = function(t, n) {
  if (n === "__proto__")
    if (Sc.call(t, n)) {
      if (gb)
        return gb(t, n).value;
    } else return;
  return t[n];
}, R2 = function e() {
  var t, n, r, i, a, o, s = arguments[0], c = 1, l = arguments.length, u = !1;
  for (typeof s == "boolean" && (u = s, s = arguments[1] || {}, c = 2), (s == null || typeof s != "object" && typeof s != "function") && (s = {}); c < l; ++c)
    if (t = arguments[c], t != null)
      for (n in t)
        r = Sb(s, n), i = Sb(t, n), s !== i && (u && i && (wb(i) || (a = bb(i))) ? (a ? (a = !1, o = r && bb(r) ? r : []) : o = r && wb(r) ? r : {}, xb(s, { name: n, newValue: e(u, o, i) })) : typeof i < "u" && xb(s, { name: n, newValue: i }));
  return s;
};
const Xf = /* @__PURE__ */ Ye(R2);
function $h(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function I2() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let a = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    s(null, ...i);
    function s(c, ...l) {
      const u = e[++a];
      let f = -1;
      if (c) {
        o(c);
        return;
      }
      for (; ++f < i.length; )
        (l[f] === null || l[f] === void 0) && (l[f] = i[f]);
      i = l, u ? A2(u, s)(...l) : o(null, ...l);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function A2(e, t) {
  let n;
  return r;
  function r(...o) {
    const s = e.length > o.length;
    let c;
    s && o.push(i);
    try {
      c = e.apply(this, o);
    } catch (l) {
      const u = (
        /** @type {Error} */
        l
      );
      if (s && n)
        throw u;
      return i(u);
    }
    s || (c && c.then && typeof c.then == "function" ? c.then(a, i) : c instanceof Error ? i(c) : a(c));
  }
  function i(o, ...s) {
    n || (n = !0, t(o, ...s));
  }
  function a(o) {
    i(null, o);
  }
}
const kr = { basename: P2, dirname: D2, extname: j2, join: N2, sep: "/" };
function P2(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  al(e);
  let n = 0, r = -1, i = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (a) {
          n = i + 1;
          break;
        }
      } else r < 0 && (a = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let o = -1, s = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (a) {
        n = i + 1;
        break;
      }
    } else
      o < 0 && (a = !0, o = i + 1), s > -1 && (e.codePointAt(i) === t.codePointAt(s--) ? s < 0 && (r = i) : (s = -1, r = o));
  return n === r ? r = o : r < 0 && (r = e.length), e.slice(n, r);
}
function D2(e) {
  if (al(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function j2(e) {
  al(e);
  let t = e.length, n = -1, r = 0, i = -1, a = 0, o;
  for (; t--; ) {
    const s = e.codePointAt(t);
    if (s === 47) {
      if (o) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (o = !0, n = t + 1), s === 46 ? i < 0 ? i = t : a !== 1 && (a = 1) : i > -1 && (a = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function N2(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    al(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : M2(n);
}
function M2(e) {
  al(e);
  const t = e.codePointAt(0) === 47;
  let n = F2(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function F2(e, t) {
  let n = "", r = 0, i = -1, a = 0, o = -1, s, c;
  for (; ++o <= e.length; ) {
    if (o < e.length)
      s = e.codePointAt(o);
    else {
      if (s === 47)
        break;
      s = 47;
    }
    if (s === 47) {
      if (!(i === o - 1 || a === 1)) if (i !== o - 1 && a === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (c = n.lastIndexOf("/"), c !== n.length - 1) {
              c < 0 ? (n = "", r = 0) : (n = n.slice(0, c), r = n.length - 1 - n.lastIndexOf("/")), i = o, a = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, i = o, a = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(i + 1, o) : n = e.slice(i + 1, o), r = o - i - 1;
      i = o, a = 0;
    } else s === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function al(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const L2 = { cwd: B2 };
function B2() {
  return "/";
}
function Rh(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function U2(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!Rh(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return z2(e);
}
function z2(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const Qf = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class ZE {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? Rh(t) ? n = { path: t } : typeof t == "string" || q2(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : L2.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Qf.length; ) {
      const a = Qf[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let i;
    for (i in n)
      Qf.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? kr.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    td(t, "basename"), ed(t, "basename"), this.path = kr.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? kr.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Eb(this.basename, "dirname"), this.path = kr.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? kr.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (ed(t, "extname"), Eb(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = kr.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    Rh(t) && (t = U2(t)), td(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? kr.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    td(t, "stem"), ed(t, "stem"), this.path = kr.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new yn(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function ed(e, t) {
  if (e && e.includes(kr.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + kr.sep + "`"
    );
}
function td(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Eb(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function q2(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const W2 = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], a = function() {
      return i.apply(a, arguments);
    };
    return Object.setPrototypeOf(a, r), a;
  }
), V2 = {}.hasOwnProperty;
class wv extends W2 {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = I2();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new wv()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(Xf(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (id("data", this.frozen), this.namespace[t] = n, this) : V2.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (id("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Ul(t), r = this.parser || this.Parser;
    return nd("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), nd("process", this.parser || this.Parser), rd("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(a, o) {
      const s = Ul(t), c = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(s)
      );
      r.run(c, s, function(u, f, d) {
        if (u || !f || !d)
          return l(u);
        const p = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          f
        ), m = r.stringify(p, d);
        K2(m) ? d.value = m : d.result = m, l(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          d
        );
      });
      function l(u, f) {
        u || !f ? o(u) : a ? a(f) : n(void 0, f);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), nd("processSync", this.parser || this.Parser), rd("processSync", this.compiler || this.Compiler), this.process(t, i), kb("processSync", "process", n), r;
    function i(a, o) {
      n = !0, vb(a), r = o;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    _b(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(o, s) {
      const c = Ul(n);
      i.run(t, c, l);
      function l(u, f, d) {
        const p = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          f || t
        );
        u ? s(u) : o ? o(p) : r(void 0, p, d);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, a), kb("runSync", "run", r), i;
    function a(o, s) {
      vb(o), i = s, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Ul(n), i = this.compiler || this.Compiler;
    return rd("stringify", i), _b(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (id("use", this.frozen), t != null) if (typeof t == "function")
      c(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? s(t) : o(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(l) {
      if (typeof l == "function")
        c(l, []);
      else if (typeof l == "object")
        if (Array.isArray(l)) {
          const [u, ...f] = (
            /** @type {PluginTuple<Array<unknown>>} */
            l
          );
          c(u, f);
        } else
          o(l);
      else
        throw new TypeError("Expected usable value, not `" + l + "`");
    }
    function o(l) {
      if (!("plugins" in l) && !("settings" in l))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      s(l.plugins), l.settings && (i.settings = Xf(!0, i.settings, l.settings));
    }
    function s(l) {
      let u = -1;
      if (l != null) if (Array.isArray(l))
        for (; ++u < l.length; ) {
          const f = l[u];
          a(f);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + l + "`");
    }
    function c(l, u) {
      let f = -1, d = -1;
      for (; ++f < r.length; )
        if (r[f][0] === l) {
          d = f;
          break;
        }
      if (d === -1)
        r.push([l, ...u]);
      else if (u.length > 0) {
        let [p, ...m] = u;
        const h = r[d][1];
        $h(h) && $h(p) && (p = Xf(!0, h, p)), r[d] = [l, p, ...m];
      }
    }
  }
}
const H2 = new wv().freeze();
function nd(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function rd(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function id(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function _b(e) {
  if (!$h(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function kb(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Ul(e) {
  return Z2(e) ? e : new ZE(e);
}
function Z2(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function K2(e) {
  return typeof e == "string" || G2(e);
}
function G2(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const Y2 = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", Tb = [], Cb = { allowDangerousHtml: !0 }, J2 = /^(https?|ircs?|mailto|xmpp)$/i, X2 = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function Q2(e) {
  const t = e.allowedElements, n = e.allowElement, r = e.children || "", i = e.className, a = e.components, o = e.disallowedElements, s = e.rehypePlugins || Tb, c = e.remarkPlugins || Tb, l = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Cb } : Cb, u = e.skipHtml, f = e.unwrapDisallowed, d = e.urlTransform || KE, p = H2().use(jj).use(c).use($2, l).use(s), m = new ZE();
  typeof r == "string" && (m.value = r);
  for (const b of X2)
    Object.hasOwn(e, b.from) && ("" + b.from + (b.to ? "use `" + b.to + "` instead" : "remove it") + Y2 + b.id, void 0);
  const h = p.parse(m);
  let y = p.runSync(h, m);
  return i && (y = {
    type: "element",
    tagName: "div",
    properties: { className: i },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      y.type === "root" ? y.children : [y]
    )
  }), bv(y, v), yP(y, {
    Fragment: O.Fragment,
    components: a,
    ignoreInvalidStyle: !0,
    jsx: O.jsx,
    jsxs: O.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function v(b, w, T) {
    if (b.type === "raw" && T && typeof w == "number")
      return u ? T.children.splice(w, 1) : T.children[w] = { type: "text", value: b.value }, w;
    if (b.type === "element") {
      let E;
      for (E in Gf)
        if (Object.hasOwn(Gf, E) && Object.hasOwn(b.properties, E)) {
          const _ = b.properties[E], $ = Gf[E];
          ($ === null || $.includes(b.tagName)) && (b.properties[E] = d(String(_ || ""), E, b));
        }
    }
    if (b.type === "element") {
      let E = t ? !t.includes(b.tagName) : o ? o.includes(b.tagName) : !1;
      if (!E && n && typeof w == "number" && (E = !n(b, w, T)), E && T && typeof w == "number")
        return f && b.children ? T.children.splice(w, 1, ...b.children) : T.children.splice(w, 1), w;
    }
  }
}
function KE(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, it’s relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    i > -1 && t > i || n > -1 && t > n || r > -1 && t > r || // It is a protocol, it should be allowed.
    J2.test(e.slice(0, t)) ? e : ""
  );
}
function eN(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function GE(e, t, n) {
  const i = Gu((n || {}).ignore || []), a = tN(t);
  let o = -1;
  for (; ++o < a.length; )
    VE(e, "text", s);
  function s(l, u) {
    let f = -1, d;
    for (; ++f < u.length; ) {
      const p = u[f], m = d ? d.children : void 0;
      if (i(
        p,
        m ? m.indexOf(p) : void 0,
        d
      ))
        return;
      d = p;
    }
    if (d)
      return c(l, u);
  }
  function c(l, u) {
    const f = u[u.length - 1], d = a[o][0], p = a[o][1];
    let m = 0;
    const y = f.children.indexOf(l);
    let v = !1, b = [];
    d.lastIndex = 0;
    let w = d.exec(l.value);
    for (; w; ) {
      const T = w.index, E = {
        index: w.index,
        input: w.input,
        stack: [...u, l]
      };
      let _ = p(...w, E);
      if (typeof _ == "string" && (_ = _.length > 0 ? { type: "text", value: _ } : void 0), _ === !1 ? d.lastIndex = T + 1 : (m !== T && b.push({
        type: "text",
        value: l.value.slice(m, T)
      }), Array.isArray(_) ? b.push(..._) : _ && b.push(_), m = T + w[0].length, v = !0), !d.global)
        break;
      w = d.exec(l.value);
    }
    return v ? (m < l.value.length && b.push({ type: "text", value: l.value.slice(m) }), f.children.splice(y, 1, ...b)) : b = [l], y + b.length;
  }
}
function tN(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([nN(i[0]), rN(i[1])]);
  }
  return t;
}
function nN(e) {
  return typeof e == "string" ? new RegExp(eN(e), "g") : e;
}
function rN(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
function iN(e) {
  GE(e, [/\r?\n|\r/g, aN]);
}
function aN() {
  return { type: "break" };
}
function oN() {
  return function(e) {
    iN(e);
  };
}
function Ob(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
const ad = "phrasing", od = ["autolink", "link", "image", "label"];
function sN() {
  return {
    transforms: [hN],
    enter: {
      literalAutolink: cN,
      literalAutolinkEmail: sd,
      literalAutolinkHttp: sd,
      literalAutolinkWww: sd
    },
    exit: {
      literalAutolink: pN,
      literalAutolinkEmail: dN,
      literalAutolinkHttp: uN,
      literalAutolinkWww: fN
    }
  };
}
function lN() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: ad,
        notInConstruct: od
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: ad,
        notInConstruct: od
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: ad,
        notInConstruct: od
      }
    ]
  };
}
function cN(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function sd(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function uN(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function fN(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function dN(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function pN(e) {
  this.exit(e);
}
function hN(e) {
  GE(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, mN],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), vN]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function mN(e, t, n, r, i) {
  let a = "";
  if (!YE(i) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !yN(n)))
    return !1;
  const o = gN(n + r);
  if (!o[0]) return !1;
  const s = {
    type: "link",
    title: null,
    url: a + t + o[0],
    children: [{ type: "text", value: t + o[0] }]
  };
  return o[1] ? [s, { type: "text", value: o[1] }] : s;
}
function vN(e, t, n, r) {
  return (
    // Not an expected previous character.
    !YE(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function yN(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function gN(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = Ob(e, "(");
  let a = Ob(e, ")");
  for (; r !== -1 && i > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function YE(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || ea(n) || Hu(n)) && // If it’s an email, the previous character should not be a slash.
  (!t || n !== 47);
}
JE.peek = $N;
function bN() {
  return {
    enter: {
      gfmFootnoteDefinition: xN,
      gfmFootnoteDefinitionLabelString: SN,
      gfmFootnoteCall: kN,
      gfmFootnoteCallString: TN
    },
    exit: {
      gfmFootnoteDefinition: _N,
      gfmFootnoteDefinitionLabelString: EN,
      gfmFootnoteCall: ON,
      gfmFootnoteCallString: CN
    }
  };
}
function wN() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: RN, footnoteReference: JE }
  };
}
function xN(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function SN() {
  this.buffer();
}
function EN(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = cr(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function _N(e) {
  this.exit(e);
}
function kN(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function TN() {
  this.buffer();
}
function CN(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = cr(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function ON(e) {
  this.exit(e);
}
function JE(e, t, n, r) {
  const i = n.createTracker(r);
  let a = i.move("[^");
  const o = n.enter("footnoteReference"), s = n.enter("reference");
  return a += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: a,
      after: "]"
    })
  ), s(), o(), a += i.move("]"), a;
}
function $N() {
  return "[";
}
function RN(e, t, n, r) {
  const i = n.createTracker(r);
  let a = i.move("[^");
  const o = n.enter("footnoteDefinition"), s = n.enter("label");
  return a += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: a,
      after: "]"
    })
  ), s(), a += i.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), i.shift(4), a += i.move(
    n.indentLines(n.containerFlow(e, i.current()), IN)
  ), o(), a;
}
function IN(e, t, n) {
  return t === 0 ? e : (n ? "" : "    ") + e;
}
const AN = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
XE.peek = MN;
function PN() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: jN },
    exit: { strikethrough: NN }
  };
}
function DN() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: AN
      }
    ],
    handlers: { delete: XE }
  };
}
function jN(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function NN(e) {
  this.exit(e);
}
function XE(e, t, n, r) {
  const i = n.createTracker(r), a = n.enter("strikethrough");
  let o = i.move("~~");
  return o += n.containerPhrasing(e, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), a(), o;
}
function MN() {
  return "~";
}
function FN(e) {
  return e.length;
}
function LN(e, t) {
  const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || FN, a = [], o = [], s = [], c = [];
  let l = 0, u = -1;
  for (; ++u < e.length; ) {
    const h = [], y = [];
    let v = -1;
    for (e[u].length > l && (l = e[u].length); ++v < e[u].length; ) {
      const b = BN(e[u][v]);
      if (n.alignDelimiters !== !1) {
        const w = i(b);
        y[v] = w, (c[v] === void 0 || w > c[v]) && (c[v] = w);
      }
      h.push(b);
    }
    o[u] = h, s[u] = y;
  }
  let f = -1;
  if (typeof r == "object" && "length" in r)
    for (; ++f < l; )
      a[f] = $b(r[f]);
  else {
    const h = $b(r);
    for (; ++f < l; )
      a[f] = h;
  }
  f = -1;
  const d = [], p = [];
  for (; ++f < l; ) {
    const h = a[f];
    let y = "", v = "";
    h === 99 ? (y = ":", v = ":") : h === 108 ? y = ":" : h === 114 && (v = ":");
    let b = n.alignDelimiters === !1 ? 1 : Math.max(
      1,
      c[f] - y.length - v.length
    );
    const w = y + "-".repeat(b) + v;
    n.alignDelimiters !== !1 && (b = y.length + b + v.length, b > c[f] && (c[f] = b), p[f] = b), d[f] = w;
  }
  o.splice(1, 0, d), s.splice(1, 0, p), u = -1;
  const m = [];
  for (; ++u < o.length; ) {
    const h = o[u], y = s[u];
    f = -1;
    const v = [];
    for (; ++f < l; ) {
      const b = h[f] || "";
      let w = "", T = "";
      if (n.alignDelimiters !== !1) {
        const E = c[f] - (y[f] || 0), _ = a[f];
        _ === 114 ? w = " ".repeat(E) : _ === 99 ? E % 2 ? (w = " ".repeat(E / 2 + 0.5), T = " ".repeat(E / 2 - 0.5)) : (w = " ".repeat(E / 2), T = w) : T = " ".repeat(E);
      }
      n.delimiterStart !== !1 && !f && v.push("|"), n.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(n.alignDelimiters === !1 && b === "") && (n.delimiterStart !== !1 || f) && v.push(" "), n.alignDelimiters !== !1 && v.push(w), v.push(b), n.alignDelimiters !== !1 && v.push(T), n.padding !== !1 && v.push(" "), (n.delimiterEnd !== !1 || f !== l - 1) && v.push("|");
    }
    m.push(
      n.delimiterEnd === !1 ? v.join("").replace(/ +$/, "") : v.join("")
    );
  }
  return m.join(`
`);
}
function BN(e) {
  return e == null ? "" : String(e);
}
function $b(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function UN(e, t, n, r) {
  const i = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const o = n.indentLines(
    n.containerFlow(e, a.current()),
    zN
  );
  return i(), o;
}
function zN(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function qN(e, t) {
  return Rb(e, t.inConstruct, !0) && !Rb(e, t.notInConstruct, !1);
}
function Rb(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function Ib(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && qN(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function WN(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, a = 0, o = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++a > o && (o = a) : a = 1, i = r + t.length, r = n.indexOf(t, i);
  return o;
}
function VN(e, t) {
  return !!(t.options.fences === !1 && e.value && // If there’s no info…
  !e.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(e.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function HN(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function ZN(e, t, n, r) {
  const i = HN(n), a = e.value || "", o = i === "`" ? "GraveAccent" : "Tilde";
  if (VN(e, n)) {
    const f = n.enter("codeIndented"), d = n.indentLines(a, KN);
    return f(), d;
  }
  const s = n.createTracker(r), c = i.repeat(Math.max(WN(a, i) + 1, 3)), l = n.enter("codeFenced");
  let u = s.move(c);
  if (e.lang) {
    const f = n.enter(`codeFencedLang${o}`);
    u += s.move(
      n.safe(e.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...s.current()
      })
    ), f();
  }
  if (e.lang && e.meta) {
    const f = n.enter(`codeFencedMeta${o}`);
    u += s.move(" "), u += s.move(
      n.safe(e.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...s.current()
      })
    ), f();
  }
  return u += s.move(`
`), a && (u += s.move(a + `
`)), u += s.move(c), l(), u;
}
function KN(e, t, n) {
  return (n ? "" : "    ") + e;
}
function xv(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function GN(e, t, n, r) {
  const i = xv(n), a = i === '"' ? "Quote" : "Apostrophe", o = n.enter("definition");
  let s = n.enter("label");
  const c = n.createTracker(r);
  let l = c.move("[");
  return l += c.move(
    n.safe(n.associationId(e), {
      before: l,
      after: "]",
      ...c.current()
    })
  ), l += c.move("]: "), s(), // If there’s no url, or…
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), l += c.move("<"), l += c.move(
    n.safe(e.url, { before: l, after: ">", ...c.current() })
  ), l += c.move(">")) : (s = n.enter("destinationRaw"), l += c.move(
    n.safe(e.url, {
      before: l,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), s(), e.title && (s = n.enter(`title${a}`), l += c.move(" " + i), l += c.move(
    n.safe(e.title, {
      before: l,
      after: i,
      ...c.current()
    })
  ), l += c.move(i), s()), o(), l;
}
function YN(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
QE.peek = JN;
function QE(e, t, n, r) {
  const i = YN(n), a = n.enter("emphasis"), o = n.createTracker(r);
  let s = o.move(i);
  return s += o.move(
    n.containerPhrasing(e, {
      before: s,
      after: i,
      ...o.current()
    })
  ), s += o.move(i), a(), s;
}
function JN(e, t, n) {
  return n.options.emphasis || "*";
}
function XN(e, t) {
  let n = !1;
  return bv(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, Ch;
  }), !!((!e.depth || e.depth < 3) && dv(e) && (t.options.setext || n));
}
function QN(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (XN(e, n)) {
    const u = n.enter("headingSetext"), f = n.enter("phrasing"), d = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return f(), u(), d + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      d.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(d.lastIndexOf("\r"), d.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(i), s = n.enter("headingAtx"), c = n.enter("phrasing");
  a.move(o + " ");
  let l = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(l) && (l = "&#x" + l.charCodeAt(0).toString(16).toUpperCase() + ";" + l.slice(1)), l = l ? o + " " + l : o, n.options.closeAtx && (l += " " + o), c(), s(), l;
}
e_.peek = eM;
function e_(e) {
  return e.value || "";
}
function eM() {
  return "<";
}
t_.peek = tM;
function t_(e, t, n, r) {
  const i = xv(n), a = i === '"' ? "Quote" : "Apostrophe", o = n.enter("image");
  let s = n.enter("label");
  const c = n.createTracker(r);
  let l = c.move("![");
  return l += c.move(
    n.safe(e.alt, { before: l, after: "]", ...c.current() })
  ), l += c.move("]("), s(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), l += c.move("<"), l += c.move(
    n.safe(e.url, { before: l, after: ">", ...c.current() })
  ), l += c.move(">")) : (s = n.enter("destinationRaw"), l += c.move(
    n.safe(e.url, {
      before: l,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), s(), e.title && (s = n.enter(`title${a}`), l += c.move(" " + i), l += c.move(
    n.safe(e.title, {
      before: l,
      after: i,
      ...c.current()
    })
  ), l += c.move(i), s()), l += c.move(")"), o(), l;
}
function tM() {
  return "!";
}
n_.peek = nM;
function n_(e, t, n, r) {
  const i = e.referenceType, a = n.enter("imageReference");
  let o = n.enter("label");
  const s = n.createTracker(r);
  let c = s.move("![");
  const l = n.safe(e.alt, {
    before: c,
    after: "]",
    ...s.current()
  });
  c += s.move(l + "]["), o();
  const u = n.stack;
  n.stack = [], o = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...s.current()
  });
  return o(), n.stack = u, a(), i === "full" || !l || l !== f ? c += s.move(f + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += s.move("]"), c;
}
function nM() {
  return "!";
}
r_.peek = rM;
function r_(e, t, n) {
  let r = e.value || "", i = "`", a = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const o = n.unsafe[a], s = n.compilePattern(o);
    let c;
    if (o.atBreak)
      for (; c = s.exec(r); ) {
        let l = c.index;
        r.charCodeAt(l) === 10 && r.charCodeAt(l - 1) === 13 && l--, r = r.slice(0, l) + " " + r.slice(c.index + 1);
      }
  }
  return i + r + i;
}
function rM() {
  return "`";
}
function i_(e, t) {
  const n = dv(e);
  return !!(!t.options.resourceLink && // If there’s a url…
  e.url && // And there’s a no title…
  !e.title && // And the content of `node` is a single text node…
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content…
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(e.url));
}
a_.peek = iM;
function a_(e, t, n, r) {
  const i = xv(n), a = i === '"' ? "Quote" : "Apostrophe", o = n.createTracker(r);
  let s, c;
  if (i_(e, n)) {
    const u = n.stack;
    n.stack = [], s = n.enter("autolink");
    let f = o.move("<");
    return f += o.move(
      n.containerPhrasing(e, {
        before: f,
        after: ">",
        ...o.current()
      })
    ), f += o.move(">"), s(), n.stack = u, f;
  }
  s = n.enter("link"), c = n.enter("label");
  let l = o.move("[");
  return l += o.move(
    n.containerPhrasing(e, {
      before: l,
      after: "](",
      ...o.current()
    })
  ), l += o.move("]("), c(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = n.enter("destinationLiteral"), l += o.move("<"), l += o.move(
    n.safe(e.url, { before: l, after: ">", ...o.current() })
  ), l += o.move(">")) : (c = n.enter("destinationRaw"), l += o.move(
    n.safe(e.url, {
      before: l,
      after: e.title ? " " : ")",
      ...o.current()
    })
  )), c(), e.title && (c = n.enter(`title${a}`), l += o.move(" " + i), l += o.move(
    n.safe(e.title, {
      before: l,
      after: i,
      ...o.current()
    })
  ), l += o.move(i), c()), l += o.move(")"), s(), l;
}
function iM(e, t, n) {
  return i_(e, n) ? "<" : "[";
}
o_.peek = aM;
function o_(e, t, n, r) {
  const i = e.referenceType, a = n.enter("linkReference");
  let o = n.enter("label");
  const s = n.createTracker(r);
  let c = s.move("[");
  const l = n.containerPhrasing(e, {
    before: c,
    after: "]",
    ...s.current()
  });
  c += s.move(l + "]["), o();
  const u = n.stack;
  n.stack = [], o = n.enter("reference");
  const f = n.safe(n.associationId(e), {
    before: c,
    after: "]",
    ...s.current()
  });
  return o(), n.stack = u, a(), i === "full" || !l || l !== f ? c += s.move(f + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += s.move("]"), c;
}
function aM() {
  return "[";
}
function Sv(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function oM(e) {
  const t = Sv(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function sM(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function s_(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function lM(e, t, n, r) {
  const i = n.enter("list"), a = n.bulletCurrent;
  let o = e.ordered ? sM(n) : Sv(n);
  const s = e.ordered ? o === "." ? ")" : "." : oM(n);
  let c = t && n.bulletLastUsed ? o === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const u = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (c = !0), s_(n) === o && u
    ) {
      let f = -1;
      for (; ++f < e.children.length; ) {
        const d = e.children[f];
        if (d && d.type === "listItem" && d.children && d.children[0] && d.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (o = s), n.bulletCurrent = o;
  const l = n.containerFlow(e, r);
  return n.bulletLastUsed = o, n.bulletCurrent = a, i(), l;
}
function cM(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function uM(e, t, n, r) {
  const i = cM(n);
  let a = n.bulletCurrent || Sv(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let o = a.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (o = Math.ceil(o / 4) * 4);
  const s = n.createTracker(r);
  s.move(a + " ".repeat(o - a.length)), s.shift(o);
  const c = n.enter("listItem"), l = n.indentLines(
    n.containerFlow(e, s.current()),
    u
  );
  return c(), l;
  function u(f, d, p) {
    return d ? (p ? "" : " ".repeat(o)) + f : (p ? a : a + " ".repeat(o - a.length)) + f;
  }
}
function fM(e, t, n, r) {
  const i = n.enter("paragraph"), a = n.enter("phrasing"), o = n.containerPhrasing(e, r);
  return a(), i(), o;
}
const dM = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Gu([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function pM(e, t, n, r) {
  return (e.children.some(function(o) {
    return dM(o);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function hM(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
l_.peek = mM;
function l_(e, t, n, r) {
  const i = hM(n), a = n.enter("strong"), o = n.createTracker(r);
  let s = o.move(i + i);
  return s += o.move(
    n.containerPhrasing(e, {
      before: s,
      after: i,
      ...o.current()
    })
  ), s += o.move(i + i), a(), s;
}
function mM(e, t, n) {
  return n.options.strong || "*";
}
function vM(e, t, n, r) {
  return n.safe(e.value, r);
}
function yM(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function gM(e, t, n) {
  const r = (s_(n) + (n.options.ruleSpaces ? " " : "")).repeat(yM(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const c_ = {
  blockquote: UN,
  break: Ib,
  code: ZN,
  definition: GN,
  emphasis: QE,
  hardBreak: Ib,
  heading: QN,
  html: e_,
  image: t_,
  imageReference: n_,
  inlineCode: r_,
  link: a_,
  linkReference: o_,
  list: lM,
  listItem: uM,
  paragraph: fM,
  root: pM,
  strong: l_,
  text: vM,
  thematicBreak: gM
};
function bM() {
  return {
    enter: {
      table: wM,
      tableData: Ab,
      tableHeader: Ab,
      tableRow: SM
    },
    exit: {
      codeText: EM,
      table: xM,
      tableData: ld,
      tableHeader: ld,
      tableRow: ld
    }
  };
}
function wM(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function xM(e) {
  this.exit(e), this.data.inTable = void 0;
}
function SM(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function ld(e) {
  this.exit(e);
}
function Ab(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function EM(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, _M));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function _M(e, t) {
  return t === "|" ? t : e;
}
function kM(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: d,
      table: o,
      tableCell: c,
      tableRow: s
    }
  };
  function o(p, m, h, y) {
    return l(u(p, h, y), p.align);
  }
  function s(p, m, h, y) {
    const v = f(p, h, y), b = l([v]);
    return b.slice(0, b.indexOf(`
`));
  }
  function c(p, m, h, y) {
    const v = h.enter("tableCell"), b = h.enter("phrasing"), w = h.containerPhrasing(p, {
      ...y,
      before: a,
      after: a
    });
    return b(), v(), w;
  }
  function l(p, m) {
    return LN(p, {
      align: m,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function u(p, m, h) {
    const y = p.children;
    let v = -1;
    const b = [], w = m.enter("table");
    for (; ++v < y.length; )
      b[v] = f(y[v], m, h);
    return w(), b;
  }
  function f(p, m, h) {
    const y = p.children;
    let v = -1;
    const b = [], w = m.enter("tableRow");
    for (; ++v < y.length; )
      b[v] = c(y[v], p, m, h);
    return w(), b;
  }
  function d(p, m, h) {
    let y = c_.inlineCode(p, m, h);
    return h.stack.includes("tableCell") && (y = y.replace(/\|/g, "\\$&")), y;
  }
}
function TM() {
  return {
    exit: {
      taskListCheckValueChecked: Pb,
      taskListCheckValueUnchecked: Pb,
      paragraph: OM
    }
  };
}
function CM() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: $M }
  };
}
function Pb(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function OM(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let a = -1, o;
      for (; ++a < i.length; ) {
        const s = i[a];
        if (s.type === "paragraph") {
          o = s;
          break;
        }
      }
      o === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function $M(e, t, n, r) {
  const i = e.children[0], a = typeof e.checked == "boolean" && i && i.type === "paragraph", o = "[" + (e.checked ? "x" : " ") + "] ", s = n.createTracker(r);
  a && s.move(o);
  let c = c_.listItem(e, t, n, {
    ...r,
    ...s.current()
  });
  return a && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, l)), c;
  function l(u) {
    return u + o;
  }
}
function RM() {
  return [
    sN(),
    bN(),
    PN(),
    bM(),
    TM()
  ];
}
function IM(e) {
  return {
    extensions: [
      lN(),
      wN(),
      DN(),
      kM(e),
      CM()
    ]
  };
}
const AM = {
  tokenize: FM,
  partial: !0
}, u_ = {
  tokenize: LM,
  partial: !0
}, f_ = {
  tokenize: BM,
  partial: !0
}, d_ = {
  tokenize: UM,
  partial: !0
}, PM = {
  tokenize: zM,
  partial: !0
}, p_ = {
  name: "wwwAutolink",
  tokenize: NM,
  previous: m_
}, h_ = {
  name: "protocolAutolink",
  tokenize: MM,
  previous: v_
}, ri = {
  name: "emailAutolink",
  tokenize: jM,
  previous: y_
}, Fr = {};
function DM() {
  return {
    text: Fr
  };
}
let Li = 48;
for (; Li < 123; )
  Fr[Li] = ri, Li++, Li === 58 ? Li = 65 : Li === 91 && (Li = 97);
Fr[43] = ri;
Fr[45] = ri;
Fr[46] = ri;
Fr[95] = ri;
Fr[72] = [ri, h_];
Fr[104] = [ri, h_];
Fr[87] = [ri, p_];
Fr[119] = [ri, p_];
function jM(e, t, n) {
  const r = this;
  let i, a;
  return o;
  function o(f) {
    return !Ih(f) || !y_.call(r, r.previous) || Ev(r.events) ? n(f) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), s(f));
  }
  function s(f) {
    return Ih(f) ? (e.consume(f), s) : f === 64 ? (e.consume(f), c) : n(f);
  }
  function c(f) {
    return f === 46 ? e.check(PM, u, l)(f) : f === 45 || f === 95 || hn(f) ? (a = !0, e.consume(f), c) : u(f);
  }
  function l(f) {
    return e.consume(f), i = !0, c;
  }
  function u(f) {
    return a && i && xn(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(f)) : n(f);
  }
}
function NM(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return o !== 87 && o !== 119 || !m_.call(r, r.previous) || Ev(r.events) ? n(o) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(AM, e.attempt(u_, e.attempt(f_, a), n), n)(o));
  }
  function a(o) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(o);
  }
}
function MM(e, t, n) {
  const r = this;
  let i = "", a = !1;
  return o;
  function o(f) {
    return (f === 72 || f === 104) && v_.call(r, r.previous) && !Ev(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(f), e.consume(f), s) : n(f);
  }
  function s(f) {
    if (xn(f) && i.length < 5)
      return i += String.fromCodePoint(f), e.consume(f), s;
    if (f === 58) {
      const d = i.toLowerCase();
      if (d === "http" || d === "https")
        return e.consume(f), c;
    }
    return n(f);
  }
  function c(f) {
    return f === 47 ? (e.consume(f), a ? l : (a = !0, c)) : n(f);
  }
  function l(f) {
    return f === null || tu(f) || xt(f) || ea(f) || Hu(f) ? n(f) : e.attempt(u_, e.attempt(f_, u), n)(f);
  }
  function u(f) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(f);
  }
}
function FM(e, t, n) {
  let r = 0;
  return i;
  function i(o) {
    return (o === 87 || o === 119) && r < 3 ? (r++, e.consume(o), i) : o === 46 && r === 3 ? (e.consume(o), a) : n(o);
  }
  function a(o) {
    return o === null ? n(o) : t(o);
  }
}
function LM(e, t, n) {
  let r, i, a;
  return o;
  function o(l) {
    return l === 46 || l === 95 ? e.check(d_, c, s)(l) : l === null || xt(l) || ea(l) || l !== 45 && Hu(l) ? c(l) : (a = !0, e.consume(l), o);
  }
  function s(l) {
    return l === 95 ? r = !0 : (i = r, r = void 0), e.consume(l), o;
  }
  function c(l) {
    return i || r || !a ? n(l) : t(l);
  }
}
function BM(e, t) {
  let n = 0, r = 0;
  return i;
  function i(o) {
    return o === 40 ? (n++, e.consume(o), i) : o === 41 && r < n ? a(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? e.check(d_, t, a)(o) : o === null || xt(o) || ea(o) ? t(o) : (e.consume(o), i);
  }
  function a(o) {
    return o === 41 && r++, e.consume(o), i;
  }
}
function UM(e, t, n) {
  return r;
  function r(s) {
    return s === 33 || s === 34 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 63 || s === 95 || s === 126 ? (e.consume(s), r) : s === 38 ? (e.consume(s), a) : s === 93 ? (e.consume(s), i) : (
      // `<` is an end.
      s === 60 || // So is whitespace.
      s === null || xt(s) || ea(s) ? t(s) : n(s)
    );
  }
  function i(s) {
    return s === null || s === 40 || s === 91 || xt(s) || ea(s) ? t(s) : r(s);
  }
  function a(s) {
    return xn(s) ? o(s) : n(s);
  }
  function o(s) {
    return s === 59 ? (e.consume(s), r) : xn(s) ? (e.consume(s), o) : n(s);
  }
}
function zM(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), i;
  }
  function i(a) {
    return hn(a) ? n(a) : t(a);
  }
}
function m_(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || xt(e);
}
function v_(e) {
  return !xn(e);
}
function y_(e) {
  return !(e === 47 || Ih(e));
}
function Ih(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || hn(e);
}
function Ev(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const qM = {
  tokenize: JM,
  partial: !0
};
function WM() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: KM,
        continuation: {
          tokenize: GM
        },
        exit: YM
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: ZM
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: VM,
        resolveTo: HM
      }
    }
  };
}
function VM(e, t, n) {
  const r = this;
  let i = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o;
  for (; i--; ) {
    const c = r.events[i][1];
    if (c.type === "labelImage") {
      o = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return s;
  function s(c) {
    if (!o || !o._balanced)
      return n(c);
    const l = cr(r.sliceSerialize({
      start: o.end,
      end: r.now()
    }));
    return l.codePointAt(0) !== 94 || !a.includes(l.slice(1)) ? n(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function HM(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, o = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, s = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", o, t],
    ["exit", o, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...s), e;
}
function ZM(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, o;
  return s;
  function s(f) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(f) {
    return f !== 94 ? n(f) : (e.enter("gfmFootnoteCallMarker"), e.consume(f), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", l);
  }
  function l(f) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      f === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || xt(f)
    )
      return n(f);
    if (f === 93) {
      e.exit("chunkString");
      const d = e.exit("gfmFootnoteCallString");
      return i.includes(cr(r.sliceSerialize(d))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(f), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(f);
    }
    return xt(f) || (o = !0), a++, e.consume(f), f === 92 ? u : l;
  }
  function u(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), a++, l) : l(f);
  }
}
function KM(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, o = 0, s;
  return c;
  function c(m) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(m), e.exit("gfmFootnoteDefinitionLabelMarker"), l;
  }
  function l(m) {
    return m === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(m), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", u) : n(m);
  }
  function u(m) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      m === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      m === null || m === 91 || xt(m)
    )
      return n(m);
    if (m === 93) {
      e.exit("chunkString");
      const h = e.exit("gfmFootnoteDefinitionLabelString");
      return a = cr(r.sliceSerialize(h)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(m), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), d;
    }
    return xt(m) || (s = !0), o++, e.consume(m), m === 92 ? f : u;
  }
  function f(m) {
    return m === 91 || m === 92 || m === 93 ? (e.consume(m), o++, u) : u(m);
  }
  function d(m) {
    return m === 58 ? (e.enter("definitionMarker"), e.consume(m), e.exit("definitionMarker"), i.includes(a) || i.push(a), rt(e, p, "gfmFootnoteDefinitionWhitespace")) : n(m);
  }
  function p(m) {
    return t(m);
  }
}
function GM(e, t, n) {
  return e.check(il, t, e.attempt(qM, t, n));
}
function YM(e) {
  e.exit("gfmFootnoteDefinition");
}
function JM(e, t, n) {
  const r = this;
  return rt(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(a) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? t(a) : n(a);
  }
}
function XM(e) {
  let n = (e || {}).singleTilde;
  const r = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(o, s) {
    let c = -1;
    for (; ++c < o.length; )
      if (o[c][0] === "enter" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._close) {
        let l = c;
        for (; l--; )
          if (o[l][0] === "exit" && o[l][1].type === "strikethroughSequenceTemporary" && o[l][1]._open && // If the sizes are the same:
          o[c][1].end.offset - o[c][1].start.offset === o[l][1].end.offset - o[l][1].start.offset) {
            o[c][1].type = "strikethroughSequence", o[l][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, o[l][1].start),
              end: Object.assign({}, o[c][1].end)
            }, f = {
              type: "strikethroughText",
              start: Object.assign({}, o[l][1].end),
              end: Object.assign({}, o[c][1].start)
            }, d = [["enter", u, s], ["enter", o[l][1], s], ["exit", o[l][1], s], ["enter", f, s]], p = s.parser.constructs.insideSpan.null;
            p && Kn(d, d.length, 0, Zu(p, o.slice(l + 1, c), s)), Kn(d, d.length, 0, [["exit", f, s], ["enter", o[c][1], s], ["exit", o[c][1], s], ["exit", u, s]]), Kn(o, l - 1, c - l + 3, d), c = l + d.length - 2;
            break;
          }
      }
    for (c = -1; ++c < o.length; )
      o[c][1].type === "strikethroughSequenceTemporary" && (o[c][1].type = "data");
    return o;
  }
  function a(o, s, c) {
    const l = this.previous, u = this.events;
    let f = 0;
    return d;
    function d(m) {
      return l === 126 && u[u.length - 1][1].type !== "characterEscape" ? c(m) : (o.enter("strikethroughSequenceTemporary"), p(m));
    }
    function p(m) {
      const h = nu(l);
      if (m === 126)
        return f > 1 ? c(m) : (o.consume(m), f++, p);
      if (f < 2 && !n) return c(m);
      const y = o.exit("strikethroughSequenceTemporary"), v = nu(m);
      return y._open = !v || v === 2 && !!h, y._close = !h || h === 2 && !!v, s(m);
    }
  }
}
class QM {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    eF(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, o) {
      return a[0] - o[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0];
    r.push([...t]), t.length = 0;
    let i = r.pop();
    for (; i; )
      t.push(...i), i = r.pop();
    this.map.length = 0;
  }
}
function eF(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function tF(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function nF() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: rF,
        resolveAll: iF
      }
    }
  };
}
function rF(e, t, n) {
  const r = this;
  let i = 0, a = 0, o;
  return s;
  function s(k) {
    let D = r.events.length - 1;
    for (; D > -1; ) {
      const R = r.events[D][1].type;
      if (R === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      R === "linePrefix") D--;
      else break;
    }
    const q = D > -1 ? r.events[D][1].type : null, L = q === "tableHead" || q === "tableRow" ? _ : c;
    return L === _ && r.parser.lazy[r.now().line] ? n(k) : L(k);
  }
  function c(k) {
    return e.enter("tableHead"), e.enter("tableRow"), l(k);
  }
  function l(k) {
    return k === 124 || (o = !0, a += 1), u(k);
  }
  function u(k) {
    return k === null ? n(k) : Ae(k) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(k), e.exit("lineEnding"), p) : n(k) : Ge(k) ? rt(e, u, "whitespace")(k) : (a += 1, o && (o = !1, i += 1), k === 124 ? (e.enter("tableCellDivider"), e.consume(k), e.exit("tableCellDivider"), o = !0, u) : (e.enter("data"), f(k)));
  }
  function f(k) {
    return k === null || k === 124 || xt(k) ? (e.exit("data"), u(k)) : (e.consume(k), k === 92 ? d : f);
  }
  function d(k) {
    return k === 92 || k === 124 ? (e.consume(k), f) : f(k);
  }
  function p(k) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(k) : (e.enter("tableDelimiterRow"), o = !1, Ge(k) ? rt(e, m, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(k) : m(k));
  }
  function m(k) {
    return k === 45 || k === 58 ? y(k) : k === 124 ? (o = !0, e.enter("tableCellDivider"), e.consume(k), e.exit("tableCellDivider"), h) : E(k);
  }
  function h(k) {
    return Ge(k) ? rt(e, y, "whitespace")(k) : y(k);
  }
  function y(k) {
    return k === 58 ? (a += 1, o = !0, e.enter("tableDelimiterMarker"), e.consume(k), e.exit("tableDelimiterMarker"), v) : k === 45 ? (a += 1, v(k)) : k === null || Ae(k) ? T(k) : E(k);
  }
  function v(k) {
    return k === 45 ? (e.enter("tableDelimiterFiller"), b(k)) : E(k);
  }
  function b(k) {
    return k === 45 ? (e.consume(k), b) : k === 58 ? (o = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(k), e.exit("tableDelimiterMarker"), w) : (e.exit("tableDelimiterFiller"), w(k));
  }
  function w(k) {
    return Ge(k) ? rt(e, T, "whitespace")(k) : T(k);
  }
  function T(k) {
    return k === 124 ? m(k) : k === null || Ae(k) ? !o || i !== a ? E(k) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(k)) : E(k);
  }
  function E(k) {
    return n(k);
  }
  function _(k) {
    return e.enter("tableRow"), $(k);
  }
  function $(k) {
    return k === 124 ? (e.enter("tableCellDivider"), e.consume(k), e.exit("tableCellDivider"), $) : k === null || Ae(k) ? (e.exit("tableRow"), t(k)) : Ge(k) ? rt(e, $, "whitespace")(k) : (e.enter("data"), B(k));
  }
  function B(k) {
    return k === null || k === 124 || xt(k) ? (e.exit("data"), $(k)) : (e.consume(k), k === 92 ? U : B);
  }
  function U(k) {
    return k === 92 || k === 124 ? (e.consume(k), B) : B(k);
  }
}
function iF(e, t) {
  let n = -1, r = !0, i = 0, a = [0, 0, 0, 0], o = [0, 0, 0, 0], s = !1, c = 0, l, u, f;
  const d = new QM();
  for (; ++n < e.length; ) {
    const p = e[n], m = p[1];
    p[0] === "enter" ? m.type === "tableHead" ? (s = !1, c !== 0 && (Db(d, t, c, l, u), u = void 0, c = 0), l = {
      type: "table",
      start: Object.assign({}, m.start),
      // Note: correct end is set later.
      end: Object.assign({}, m.end)
    }, d.add(n, 0, [["enter", l, t]])) : m.type === "tableRow" || m.type === "tableDelimiterRow" ? (r = !0, f = void 0, a = [0, 0, 0, 0], o = [0, n + 1, 0, 0], s && (s = !1, u = {
      type: "tableBody",
      start: Object.assign({}, m.start),
      // Note: correct end is set later.
      end: Object.assign({}, m.end)
    }, d.add(n, 0, [["enter", u, t]])), i = m.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : i && (m.type === "data" || m.type === "tableDelimiterMarker" || m.type === "tableDelimiterFiller") ? (r = !1, o[2] === 0 && (a[1] !== 0 && (o[0] = o[1], f = zl(d, t, a, i, void 0, f), a = [0, 0, 0, 0]), o[2] = n)) : m.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (o[0] = o[1], f = zl(d, t, a, i, void 0, f)), a = o, o = [a[1], n, 0, 0])) : m.type === "tableHead" ? (s = !0, c = n) : m.type === "tableRow" || m.type === "tableDelimiterRow" ? (c = n, a[1] !== 0 ? (o[0] = o[1], f = zl(d, t, a, i, n, f)) : o[1] !== 0 && (f = zl(d, t, o, i, n, f)), i = 0) : i && (m.type === "data" || m.type === "tableDelimiterMarker" || m.type === "tableDelimiterFiller") && (o[3] = n);
  }
  for (c !== 0 && Db(d, t, c, l, u), d.consume(t.events), n = -1; ++n < t.events.length; ) {
    const p = t.events[n];
    p[0] === "enter" && p[1].type === "table" && (p[1]._align = tF(t.events, n));
  }
  return e;
}
function zl(e, t, n, r, i, a) {
  const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", s = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, Oa(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const c = Oa(t.events, n[1]);
  if (a = {
    type: o,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const l = Oa(t.events, n[2]), u = Oa(t.events, n[3]), f = {
      type: s,
      start: Object.assign({}, l),
      end: Object.assign({}, u)
    };
    if (e.add(n[2], 0, [["enter", f, t]]), r !== 2) {
      const d = t.events[n[2]], p = t.events[n[3]];
      if (d[1].end = Object.assign({}, p[1].end), d[1].type = "chunkText", d[1].contentType = "text", n[3] > n[2] + 1) {
        const m = n[2] + 1, h = n[3] - n[2] - 1;
        e.add(m, h, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", f, t]]);
  }
  return i !== void 0 && (a.end = Object.assign({}, Oa(t.events, i)), e.add(i, 0, [["exit", a, t]]), a = void 0), a;
}
function Db(e, t, n, r, i) {
  const a = [], o = Oa(t.events, n);
  i && (i.end = Object.assign({}, o), a.push(["exit", i, t])), r.end = Object.assign({}, o), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function Oa(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const aF = {
  name: "tasklistCheck",
  tokenize: sF
};
function oF() {
  return {
    text: {
      91: aF
    }
  };
}
function sF(e, t, n) {
  const r = this;
  return i;
  function i(c) {
    return (
      // Exit if there’s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(c) {
    return xt(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), o) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), o) : n(c);
  }
  function o(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), s) : n(c);
  }
  function s(c) {
    return Ae(c) ? t(c) : Ge(c) ? e.check({
      tokenize: lF
    }, t, n)(c) : n(c);
  }
}
function lF(e, t, n) {
  return rt(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function cF(e) {
  return TE([
    DM(),
    WM(),
    XM(e),
    nF(),
    oF()
  ]);
}
const uF = {};
function fF(e) {
  const t = (
    /** @type {Processor} */
    this
  ), n = e || uF, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(cF(n)), a.push(RM()), o.push(IM(n));
}
const ut = {
  container: {
    className: "bpReset bpContainer bpFont",
    dropzone: {
      overlay: {
        className: "bpDropzoneOverlay"
      },
      container: {
        className: "bpDropzoneContainer"
      }
    }
  },
  loader: {
    className: "bpReset bpLoader"
  },
  modal: {
    container: {
      className: "bpReset bpModalContainer"
    },
    overlay: {
      className: "bpModalOverlay"
    },
    dialog: {
      container: {
        className: "bpReset bpModalDialogContainer"
      },
      title: {
        container: {
          className: "bpReset bpModalDialogTitleContainer"
        },
        text: {
          className: "bpModalDialogTitleText"
        },
        closeIcon: {
          className: "bpModalDialogTitleCloseIcon"
        }
      },
      content: {
        className: "bpModalDialogContent"
      },
      newConversation: {
        button: {
          className: "bpModalDialogNewConversationButton"
        },
        text: {
          className: "bpModalDialogNewConversationText"
        }
      }
    }
  },
  fab: {
    container: {
      className: "bpReset bpFabContainer"
    },
    icon: {
      className: "bpFabIcon"
    }
  },
  notification: {
    container: {
      className: "bpReset bpNotificationContainer"
    },
    title: {
      className: "bpNotificationTitle"
    },
    description: {
      className: "bpNotificationDescription"
    },
    icon: {
      className: "bpNotificationIcon"
    },
    closeIcon: {
      className: "bpNotificationCloseIcon"
    }
  },
  header: {
    container: {
      className: "bpReset bpHeaderContainer bpFont"
    },
    content: {
      container: {
        className: "bpReset bpHeaderContentContainer"
      },
      title: {
        className: "bpHeaderContentTitle"
      },
      description: {
        className: "bpHeaderContentDescription"
      },
      avatar: {
        container: {
          className: "bpReset bpHeaderContentAvatarContainer"
        },
        image: {
          className: "bpHeaderContentAvatarImage"
        },
        fallback: {
          className: "bpHeaderContentAvatarFallback"
        }
      },
      actions: {
        container: {
          className: "bpReset bpHeaderContentActionsContainer"
        },
        icons: {
          className: "bpHeaderContentActionsIcons"
        }
      }
    },
    expandedContent: {
      container: {
        className: "bpReset bpHeaderExpandedContentContainer"
      },
      descriptionItems: {
        container: {
          className: "bpReset bpHeaderExpandedContentDescriptionItemsContainer"
        },
        icon: {
          className: "bpHeaderExpandedContentDescriptionItemsIcon"
        },
        text: {
          className: "bpHeaderExpandedContentDescriptionItemsText"
        },
        link: {
          className: "bpHeaderExpandedContentDescriptionItemsLink"
        }
      },
      group: {
        className: "bpHeaderExpandedContentGroup"
      }
    },
    newConversationIcon: {
      className: "bpHeaderNewConversationIcon"
    }
  },
  composer: {
    container: {
      className: "bpReset bpComposerContainer bpFont"
    },
    poweredBy: {
      className: "bpComposerPoweredBy"
    },
    inputContainer: {
      className: "bpComposerInputContainer"
    },
    input: {
      className: "bpComposerInput"
    },
    button: {
      container: {
        className: "bpReset bpComposerButtonContainer"
      },
      icon: {
        className: "bpComposerButtonIcon"
      }
    },
    uploadButton: {
      icon: {
        className: "bpComposerUploadButtonIcon"
      },
      container: {
        className: "bpReset bpComposerUploadButtonContainer"
      }
    },
    voiceButton: {
      icon: {
        className: "bpComposerVoiceButtonIcon"
      },
      container: {
        className: "bpReset bpComposerVoiceButtonContainer"
      }
    },
    fileContainer: {
      className: "bpComposerFileContainer"
    },
    fileWidget: {
      container: {
        className: "bpComposerFileAttachement"
      },
      loader: {
        className: "bpComposerFileLoader"
      },
      fileIcon: {
        container: {
          className: "bpComposerFileIconWrapper"
        },
        icon: {
          className: "bpComposerFileIcon"
        }
      },
      metadata: {
        container: {
          className: "bpComposerFileMetadata"
        },
        name: {
          className: "bpComposerFileName"
        },
        type: {
          className: "bpComposerFileExtension"
        }
      },
      removeIcon: {
        className: "bpComposerFileRemoveIcon"
      },
      errorIcon: {
        className: "bpComposerFileErrorIcon"
      },
      previewImage: {
        className: "bpComposerFilePreviewImage"
      }
    }
  },
  messageList: {
    scrollDownButton: {
      container: {
        className: "bpReset bpMessageListScrollDownButtonContainer"
      },
      button: {
        className: "bpMessageListScrollDownButtonButton"
      },
      icon: {
        className: "bpMessageListScrollDownButtonIcon"
      }
    },
    container: {
      className: "bpReset bpMessageListContainer bpFont"
    },
    viewPort: {
      className: "bpMessageListViewport"
    },
    marquee: {
      container: {
        className: "bpReset bpMessageListMarqueeContainer"
      },
      content: {
        className: "bpMessageListMarqueeContent"
      },
      title: {
        className: "bpMessageListMarqueeTitle"
      },
      description: {
        className: "bpMessageListMarqueeDescription"
      },
      avatar: {
        container: {
          className: "bpReset bpMessageListMarqueeAvatarContainer"
        },
        image: {
          className: "bpMessageListMarqueeAvatarImage"
        },
        fallback: {
          className: "bpMessageListMarqueeAvatarFallback"
        }
      }
    },
    headerMessage: {
      className: "bpMessageListHeaderMessage"
    }
  },
  message: {
    container: {
      className: "bpReset bpMessageContainer"
    },
    avatar: {
      container: {
        className: "bpReset bpMessageAvatarContainer"
      },
      image: {
        className: "bpMessageAvatarImage"
      },
      fallback: {
        className: "bpMessageAvatarFallback"
      }
    },
    blocks: {
      text: {
        heading1: {
          className: "bpMessageBlocksTextHeading1"
        },
        heading2: {
          className: "bpMessageBlocksTextHeading2"
        },
        heading3: {
          className: "bpMessageBlocksTextHeading3"
        },
        heading4: {
          className: "bpMessageBlocksTextHeading4"
        },
        unorderedList: {
          className: "bpMessageBlocksTextUnorderedList"
        },
        orderedList: {
          className: "bpMessageBlocksTextOrderedList"
        },
        listItem: {
          className: "bpMessageBlocksTextListItem"
        },
        link: {
          className: "bpMessageBlocksTextLink"
        },
        italic: {
          className: "bpMessageBlocksTextItalic"
        },
        bold: {
          className: "bpMessageBlocksTextBold"
        },
        text: {
          className: "bpMessageBlocksTextText"
        },
        image: {
          className: "bpMessageBlocksTextImage"
        },
        horizontalRule: {
          className: "bpMessageBlocksTextHorizontalRule"
        },
        lineBreak: {
          className: "bpMessageBlocksTextLineBreak"
        },
        input: {
          className: "bpMessageBlocksTextInput"
        },
        codeBlockContainer: {
          className: "bpMessageBlocksTextCodeBlockContainer"
        },
        codeBlockTitle: {
          className: "bpMessageBlocksTextCodeBlockTitle"
        },
        codeBlockCopyIcon: {
          className: "bpMessageBlocksTextCodeBlockCopyIcon"
        },
        codeBlock: {
          className: "bpMessageBlocksTextCodeBlock"
        },
        code: {
          className: "bpMessageBlocksTextCode"
        },
        tableContainer: {
          className: "bpMessageBlocksTextTableContainer"
        },
        table: {
          className: "bpMessageBlocksTextTable"
        },
        tableHeader: {
          className: "bpMessageBlocksTextTableHeader"
        },
        tableData: {
          className: "bpMessageBlocksTextTableData"
        },
        tableRow: {
          className: "bpMessageBlocksTextTableRow"
        }
      },
      audio: {
        className: "bpMessageBlocksAudio"
      },
      image: {
        image: {
          className: "bpMessageBlocksImageImage"
        },
        placeholder: {
          className: "bpMessageBlocksImagePlaceholder"
        }
      },
      video: {
        className: "bpMessageBlocksVideo"
      },
      location: {
        container: {
          className: "bpMessageBlocksLocationContainer"
        },
        title: {
          className: "bpMessageBlocksLocationTitle"
        },
        icon: {
          className: "bpMessageBlocksLocationIcon"
        }
      },
      file: {
        container: {
          className: "bpMessageBlocksFileContainer"
        },
        title: {
          className: "bpMessageBlocksFileTitle"
        },
        icon: {
          className: "bpMessageBlocksFileIcon"
        }
      },
      row: {
        className: "bpMessageBlocksRow"
      },
      column: {
        className: "bpMessageBlocksColumn"
      },
      bubble: {
        className: "bpMessageBlocksBubble"
      },
      carousel: {
        container: {
          className: "bpMessageBlocksCarouselContainer"
        },
        slidesContainer: {
          className: "bpMessageBlocksCarouselSlidesContainer"
        },
        backButton: {
          className: "bpMessageBlocksCarouselBackButton"
        },
        nextButton: {
          className: "bpMessageBlocksCarouselNextButton"
        }
      },
      dropdown: {
        button: {
          container: {
            className: "bpMessageBlocksDropdownButtonContainer"
          },
          text: {
            className: "bpMessageBlocksDropdownButtonText"
          },
          icon: {
            className: "bpMessageBlocksDropdownButtonIcon"
          }
        },
        content: {
          container: {
            className: "bpMessageBlocksDropdownContentContainer"
          },
          item: {
            className: "bpMessageBlocksDropdownContentItem"
          }
        }
      },
      button: {
        className: "bpMessageBlocksButton"
      }
    }
  },
  typingIndicator: {
    container: {
      className: "bpTypingIndicatorContainer"
    },
    loader: {
      className: "bpTypingIndicatorLoader"
    }
  }
};
function dF({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m4.5 12.75 6 6 9-13.5"
  }));
}
const pF = /* @__PURE__ */ x.forwardRef(dF);
function hF({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M15.75 17.25v3.375c0 .621-.504 1.125-1.125 1.125h-9.75a1.125 1.125 0 0 1-1.125-1.125V7.875c0-.621.504-1.125 1.125-1.125H6.75a9.06 9.06 0 0 1 1.5.124m7.5 10.376h3.375c.621 0 1.125-.504 1.125-1.125V11.25c0-4.46-3.243-8.161-7.5-8.876a9.06 9.06 0 0 0-1.5-.124H9.375c-.621 0-1.125.504-1.125 1.125v3.5m7.5 10.375H9.375a1.125 1.125 0 0 1-1.125-1.125v-9.25m12 6.625v-1.875a3.375 3.375 0 0 0-3.375-3.375h-1.5a1.125 1.125 0 0 1-1.125-1.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H9.75"
  }));
}
const mF = /* @__PURE__ */ x.forwardRef(hF);
function vF({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z"
  }));
}
const yF = /* @__PURE__ */ x.forwardRef(vF);
function gF({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m2.25 15.75 5.159-5.159a2.25 2.25 0 0 1 3.182 0l5.159 5.159m-1.5-1.5 1.409-1.409a2.25 2.25 0 0 1 3.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 0 0 1.5-1.5V6a1.5 1.5 0 0 0-1.5-1.5H3.75A1.5 1.5 0 0 0 2.25 6v12a1.5 1.5 0 0 0 1.5 1.5Zm10.5-11.25h.008v.008h-.008V8.25Zm.375 0a.375.375 0 1 1-.75 0 .375.375 0 0 1 .75 0Z"
  }));
}
const bF = /* @__PURE__ */ x.forwardRef(gF);
function wF({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z"
  }));
}
const xF = /* @__PURE__ */ x.forwardRef(wF);
function SF({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "m15.75 10.5 4.72-4.72a.75.75 0 0 1 1.28.53v11.38a.75.75 0 0 1-1.28.53l-4.72-4.72M4.5 18.75h9a2.25 2.25 0 0 0 2.25-2.25v-9a2.25 2.25 0 0 0-2.25-2.25h-9A2.25 2.25 0 0 0 2.25 7.5v9a2.25 2.25 0 0 0 2.25 2.25Z"
  }));
}
const EF = /* @__PURE__ */ x.forwardRef(SF);
function _F({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M6 18 18 6M6 6l12 12"
  }));
}
const g_ = /* @__PURE__ */ x.forwardRef(_F), kF = ({ text: e }) => {
  const {
    message: {
      blocks: { text: t }
    }
  } = ut, n = {
    h1: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("h1", { ...i, ...t.heading1 }),
    h2: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("h2", { ...i, ...t.heading2 }),
    h3: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("h3", { ...i, ...t.heading3 }),
    h4: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("h4", { ...i, ...t.heading4 }),
    h5: "h4",
    h6: "h4",
    em: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("em", { ...i, ...t.italic }),
    strong: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("strong", { ...i, ...t.bold }),
    p: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("p", { ...i, ...t.text }),
    hr: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("hr", { ...i, ...t.horizontalRule }),
    a: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("a", { ...i, ...t.link, target: "_blank" }),
    img: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("img", { ...i, ...t.image }),
    ol: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("ol", { ...i, ...t.orderedList }),
    ul: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("ul", { ...i, ...t.unorderedList }),
    li: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("li", { ...i, ...t.listItem }),
    br: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("br", { ...i, ...t.lineBreak }),
    pre: ({ node: r, ...i }) => {
      var f, d;
      const a = r == null ? void 0 : r.children[0], o = TF(((d = (f = a == null ? void 0 : a.properties) == null ? void 0 : f.className) == null ? void 0 : d[0]) || ""), [s, c] = He(!1), l = Tt(null), u = () => {
        if (!l.current) return;
        const p = l.current.textContent || "";
        navigator.clipboard.writeText(p).then(() => {
          c(!0), setTimeout(() => {
            c(!1);
          }, 1500);
        }).catch((m) => {
          console.error("Failed to copy code to clipboard:", m);
        });
      };
      return /* @__PURE__ */ O.jsxs("div", { ...t.codeBlockContainer, children: [
        /* @__PURE__ */ O.jsxs("div", { ...t.codeBlockTitle, children: [
          o ? /* @__PURE__ */ O.jsx("span", { children: o }) : "Code",
          s ? /* @__PURE__ */ O.jsx(pF, { ...t.codeBlockCopyIcon }) : /* @__PURE__ */ O.jsx(
            mF,
            {
              ...t.codeBlockCopyIcon,
              onClick: u
            }
          )
        ] }),
        /* @__PURE__ */ O.jsx("pre", { ref: l, ...i, ...t.codeBlock })
      ] });
    },
    input: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("input", { ...i, ...t.input, disabled: !1 }),
    code: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("code", { ...i, ...t.code }),
    table: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("div", { ...t.tableContainer, children: /* @__PURE__ */ O.jsx("table", { ...i, ...t.table }) }),
    th: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("th", { ...i, ...t.tableHeader }),
    tr: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("tr", { ...i, ...t.tableRow }),
    td: ({ node: r, ...i }) => /* @__PURE__ */ O.jsx("td", { ...i, ...t.tableData })
  };
  return /* @__PURE__ */ O.jsx(
    Q2,
    {
      urlTransform: (r) => r.startsWith("tel:") ? r : KE(r),
      components: n,
      remarkPlugins: [fF, oN],
      children: e
    }
  );
}, TF = (e) => {
  if (!e) return "";
  const t = e.match(/language-(\w+)/);
  return t ? t[1] : "";
}, CF = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, jb = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (u, f) => {
    const d = typeof u == "function" ? u(t) : u;
    if (!Object.is(d, t)) {
      const p = t;
      t = f ?? (typeof d != "object" || d === null) ? d : Object.assign({}, t, d), n.forEach((m) => m(t, p));
    }
  }, i = () => t, c = { setState: r, getState: i, getInitialState: () => l, subscribe: (u) => (n.add(u), () => n.delete(u)), destroy: () => {
    (CF ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, l = t = e(r, i, c);
  return c;
}, OF = (e) => e ? jb(e) : jb;
var Ah = { exports: {} }, cd = {}, ql = { exports: {} }, ud = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Nb;
function $F() {
  if (Nb) return ud;
  Nb = 1;
  var e = vt;
  function t(f, d) {
    return f === d && (f !== 0 || 1 / f === 1 / d) || f !== f && d !== d;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, a = e.useLayoutEffect, o = e.useDebugValue;
  function s(f, d) {
    var p = d(), m = r({ inst: { value: p, getSnapshot: d } }), h = m[0].inst, y = m[1];
    return a(function() {
      h.value = p, h.getSnapshot = d, c(h) && y({ inst: h });
    }, [f, p, d]), i(function() {
      return c(h) && y({ inst: h }), f(function() {
        c(h) && y({ inst: h });
      });
    }, [f]), o(p), p;
  }
  function c(f) {
    var d = f.getSnapshot;
    f = f.value;
    try {
      var p = d();
      return !n(f, p);
    } catch {
      return !0;
    }
  }
  function l(f, d) {
    return d();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? l : s;
  return ud.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u, ud;
}
var fd = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Mb;
function RF() {
  return Mb || (Mb = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = vt, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(w) {
      {
        for (var T = arguments.length, E = new Array(T > 1 ? T - 1 : 0), _ = 1; _ < T; _++)
          E[_ - 1] = arguments[_];
        r("error", w, E);
      }
    }
    function r(w, T, E) {
      {
        var _ = t.ReactDebugCurrentFrame, $ = _.getStackAddendum();
        $ !== "" && (T += "%s", E = E.concat([$]));
        var B = E.map(function(U) {
          return String(U);
        });
        B.unshift("Warning: " + T), Function.prototype.apply.call(console[w], console, B);
      }
    }
    function i(w, T) {
      return w === T && (w !== 0 || 1 / w === 1 / T) || w !== w && T !== T;
    }
    var a = typeof Object.is == "function" ? Object.is : i, o = e.useState, s = e.useEffect, c = e.useLayoutEffect, l = e.useDebugValue, u = !1, f = !1;
    function d(w, T, E) {
      u || e.startTransition !== void 0 && (u = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var _ = T();
      if (!f) {
        var $ = T();
        a(_, $) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), f = !0);
      }
      var B = o({
        inst: {
          value: _,
          getSnapshot: T
        }
      }), U = B[0].inst, k = B[1];
      return c(function() {
        U.value = _, U.getSnapshot = T, p(U) && k({
          inst: U
        });
      }, [w, _, T]), s(function() {
        p(U) && k({
          inst: U
        });
        var D = function() {
          p(U) && k({
            inst: U
          });
        };
        return w(D);
      }, [w]), l(_), _;
    }
    function p(w) {
      var T = w.getSnapshot, E = w.value;
      try {
        var _ = T();
        return !a(E, _);
      } catch {
        return !0;
      }
    }
    function m(w, T, E) {
      return T();
    }
    var h = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", y = !h, v = y ? m : d, b = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : v;
    fd.useSyncExternalStore = b, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), fd;
}
var Fb;
function b_() {
  return Fb || (Fb = 1, process.env.NODE_ENV === "production" ? ql.exports = $F() : ql.exports = RF()), ql.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lb;
function IF() {
  if (Lb) return cd;
  Lb = 1;
  var e = vt, t = b_();
  function n(l, u) {
    return l === u && (l !== 0 || 1 / l === 1 / u) || l !== l && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, a = e.useRef, o = e.useEffect, s = e.useMemo, c = e.useDebugValue;
  return cd.useSyncExternalStoreWithSelector = function(l, u, f, d, p) {
    var m = a(null);
    if (m.current === null) {
      var h = { hasValue: !1, value: null };
      m.current = h;
    } else h = m.current;
    m = s(function() {
      function v(_) {
        if (!b) {
          if (b = !0, w = _, _ = d(_), p !== void 0 && h.hasValue) {
            var $ = h.value;
            if (p($, _)) return T = $;
          }
          return T = _;
        }
        if ($ = T, r(w, _)) return $;
        var B = d(_);
        return p !== void 0 && p($, B) ? $ : (w = _, T = B);
      }
      var b = !1, w, T, E = f === void 0 ? null : f;
      return [function() {
        return v(u());
      }, E === null ? void 0 : function() {
        return v(E());
      }];
    }, [u, f, d, p]);
    var y = i(l, m[0], m[1]);
    return o(function() {
      h.hasValue = !0, h.value = y;
    }, [y]), c(y), y;
  }, cd;
}
var dd = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Bb;
function AF() {
  return Bb || (Bb = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = vt, t = b_();
    function n(u, f) {
      return u === f && (u !== 0 || 1 / u === 1 / f) || u !== u && f !== f;
    }
    var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, a = e.useRef, o = e.useEffect, s = e.useMemo, c = e.useDebugValue;
    function l(u, f, d, p, m) {
      var h = a(null), y;
      h.current === null ? (y = {
        hasValue: !1,
        value: null
      }, h.current = y) : y = h.current;
      var v = s(function() {
        var E = !1, _, $, B = function(q) {
          if (!E) {
            E = !0, _ = q;
            var L = p(q);
            if (m !== void 0 && y.hasValue) {
              var R = y.value;
              if (m(R, L))
                return $ = R, R;
            }
            return $ = L, L;
          }
          var A = _, F = $;
          if (r(A, q))
            return F;
          var H = p(q);
          return m !== void 0 && m(F, H) ? F : (_ = q, $ = H, H);
        }, U = d === void 0 ? null : d, k = function() {
          return B(f());
        }, D = U === null ? void 0 : function() {
          return B(U());
        };
        return [k, D];
      }, [f, d, p, m]), b = v[0], w = v[1], T = i(u, b, w);
      return o(function() {
        y.hasValue = !0, y.value = T;
      }, [T]), c(T), T;
    }
    dd.useSyncExternalStoreWithSelector = l, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), dd;
}
process.env.NODE_ENV === "production" ? Ah.exports = IF() : Ah.exports = AF();
var PF = Ah.exports;
const DF = /* @__PURE__ */ Ye(PF), w_ = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, { useDebugValue: jF } = vt, { useSyncExternalStoreWithSelector: NF } = DF;
let Ub = !1;
const MF = (e) => e;
function FF(e, t = MF, n) {
  (w_ ? "production" : void 0) !== "production" && n && !Ub && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), Ub = !0);
  const r = NF(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return jF(r), r;
}
const LF = (e) => {
  (w_ ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? OF(e) : e, n = (r, i) => FF(t, r, i);
  return Object.assign(n, t), n;
}, go = (e) => LF, Ec = { BASE_URL: "/", DEV: !1, MODE: "production", PROD: !0, SSR: !1 }, Ph = /* @__PURE__ */ new Map(), Wl = (e) => {
  const t = Ph.get(e);
  return t ? Object.fromEntries(
    Object.entries(t.stores).map(([n, r]) => [n, r.getState()])
  ) : {};
}, BF = (e, t, n) => {
  if (e === void 0)
    return {
      type: "untracked",
      connection: t.connect(n)
    };
  const r = Ph.get(n.name);
  if (r)
    return { type: "tracked", store: e, ...r };
  const i = {
    connection: t.connect(n),
    stores: {}
  };
  return Ph.set(n.name, i), { type: "tracked", store: e, ...i };
}, UF = (e, t = {}) => (n, r, i) => {
  const { enabled: a, anonymousActionType: o, store: s, ...c } = t;
  let l;
  try {
    l = (a ?? (Ec ? "production" : void 0) !== "production") && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!l)
    return (Ec ? "production" : void 0) !== "production" && a && console.warn(
      "[zustand devtools middleware] Please install/enable Redux devtools extension"
    ), e(n, r, i);
  const { connection: u, ...f } = BF(s, l, c);
  let d = !0;
  i.setState = (h, y, v) => {
    const b = n(h, y);
    if (!d) return b;
    const w = v === void 0 ? { type: o || "anonymous" } : typeof v == "string" ? { type: v } : v;
    return s === void 0 ? (u == null || u.send(w, r()), b) : (u == null || u.send(
      {
        ...w,
        type: `${s}/${w.type}`
      },
      {
        ...Wl(c.name),
        [s]: i.getState()
      }
    ), b);
  };
  const p = (...h) => {
    const y = d;
    d = !1, n(...h), d = y;
  }, m = e(i.setState, r, i);
  if (f.type === "untracked" ? u == null || u.init(m) : (f.stores[f.store] = i, u == null || u.init(
    Object.fromEntries(
      Object.entries(f.stores).map(([h, y]) => [
        h,
        h === f.store ? m : y.getState()
      ])
    )
  )), i.dispatchFromDevtools && typeof i.dispatch == "function") {
    let h = !1;
    const y = i.dispatch;
    i.dispatch = (...v) => {
      (Ec ? "production" : void 0) !== "production" && v[0].type === "__setState" && !h && (console.warn(
        '[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'
      ), h = !0), y(...v);
    };
  }
  return u.subscribe((h) => {
    var y;
    switch (h.type) {
      case "ACTION":
        if (typeof h.payload != "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return pd(
          h.payload,
          (v) => {
            if (v.type === "__setState") {
              if (s === void 0) {
                p(v.state);
                return;
              }
              Object.keys(v.state).length !== 1 && console.error(
                `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
              );
              const b = v.state[s];
              if (b == null)
                return;
              JSON.stringify(i.getState()) !== JSON.stringify(b) && p(b);
              return;
            }
            i.dispatchFromDevtools && typeof i.dispatch == "function" && i.dispatch(v);
          }
        );
      case "DISPATCH":
        switch (h.payload.type) {
          case "RESET":
            return p(m), s === void 0 ? u == null ? void 0 : u.init(i.getState()) : u == null ? void 0 : u.init(Wl(c.name));
          case "COMMIT":
            if (s === void 0) {
              u == null || u.init(i.getState());
              return;
            }
            return u == null ? void 0 : u.init(Wl(c.name));
          case "ROLLBACK":
            return pd(h.state, (v) => {
              if (s === void 0) {
                p(v), u == null || u.init(i.getState());
                return;
              }
              p(v[s]), u == null || u.init(Wl(c.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return pd(h.state, (v) => {
              if (s === void 0) {
                p(v);
                return;
              }
              JSON.stringify(i.getState()) !== JSON.stringify(v[s]) && p(v[s]);
            });
          case "IMPORT_STATE": {
            const { nextLiftedState: v } = h.payload, b = (y = v.computedStates.slice(-1)[0]) == null ? void 0 : y.state;
            if (!b) return;
            p(s === void 0 ? b : b[s]), u == null || u.send(
              null,
              // FIXME no-any
              v
            );
            return;
          }
          case "PAUSE_RECORDING":
            return d = !d;
        }
        return;
    }
  }), m;
}, Ju = UF, pd = (e, t) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      r
    );
  }
  n !== void 0 && t(n);
};
function x_(e, t) {
  let n;
  try {
    n = e();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var a;
      const o = (c) => c === null ? null : JSON.parse(c, void 0), s = (a = n.getItem(i)) != null ? a : null;
      return s instanceof Promise ? s.then(o) : o(s);
    },
    setItem: (i, a) => n.setItem(
      i,
      JSON.stringify(a, void 0)
    ),
    removeItem: (i) => n.removeItem(i)
  };
}
const Cs = (e) => (t) => {
  try {
    const n = e(t);
    return n instanceof Promise ? n : {
      then(r) {
        return Cs(r)(n);
      },
      catch(r) {
        return this;
      }
    };
  } catch (n) {
    return {
      then(r) {
        return this;
      },
      catch(r) {
        return Cs(r)(n);
      }
    };
  }
}, zF = (e, t) => (n, r, i) => {
  let a = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (y) => y,
    version: 0,
    merge: (y, v) => ({
      ...v,
      ...y
    }),
    ...t
  }, o = !1;
  const s = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  let l;
  try {
    l = a.getStorage();
  } catch {
  }
  if (!l)
    return e(
      (...y) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${a.name}', the given storage is currently unavailable.`
        ), n(...y);
      },
      r,
      i
    );
  const u = Cs(a.serialize), f = () => {
    const y = a.partialize({ ...r() });
    let v;
    const b = u({ state: y, version: a.version }).then(
      (w) => l.setItem(a.name, w)
    ).catch((w) => {
      v = w;
    });
    if (v)
      throw v;
    return b;
  }, d = i.setState;
  i.setState = (y, v) => {
    d(y, v), f();
  };
  const p = e(
    (...y) => {
      n(...y), f();
    },
    r,
    i
  );
  let m;
  const h = () => {
    var y;
    if (!l) return;
    o = !1, s.forEach((b) => b(r()));
    const v = ((y = a.onRehydrateStorage) == null ? void 0 : y.call(a, r())) || void 0;
    return Cs(l.getItem.bind(l))(a.name).then((b) => {
      if (b)
        return a.deserialize(b);
    }).then((b) => {
      if (b)
        if (typeof b.version == "number" && b.version !== a.version) {
          if (a.migrate)
            return a.migrate(
              b.state,
              b.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return b.state;
    }).then((b) => {
      var w;
      return m = a.merge(
        b,
        (w = r()) != null ? w : p
      ), n(m, !0), f();
    }).then(() => {
      v == null || v(m, void 0), o = !0, c.forEach((b) => b(m));
    }).catch((b) => {
      v == null || v(void 0, b);
    });
  };
  return i.persist = {
    setOptions: (y) => {
      a = {
        ...a,
        ...y
      }, y.getStorage && (l = y.getStorage());
    },
    clearStorage: () => {
      l == null || l.removeItem(a.name);
    },
    getOptions: () => a,
    rehydrate: () => h(),
    hasHydrated: () => o,
    onHydrate: (y) => (s.add(y), () => {
      s.delete(y);
    }),
    onFinishHydration: (y) => (c.add(y), () => {
      c.delete(y);
    })
  }, h(), m || p;
}, qF = (e, t) => (n, r, i) => {
  let a = {
    storage: x_(() => localStorage),
    partialize: (h) => h,
    version: 0,
    merge: (h, y) => ({
      ...y,
      ...h
    }),
    ...t
  }, o = !1;
  const s = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
  let l = a.storage;
  if (!l)
    return e(
      (...h) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${a.name}', the given storage is currently unavailable.`
        ), n(...h);
      },
      r,
      i
    );
  const u = () => {
    const h = a.partialize({ ...r() });
    return l.setItem(a.name, {
      state: h,
      version: a.version
    });
  }, f = i.setState;
  i.setState = (h, y) => {
    f(h, y), u();
  };
  const d = e(
    (...h) => {
      n(...h), u();
    },
    r,
    i
  );
  i.getInitialState = () => d;
  let p;
  const m = () => {
    var h, y;
    if (!l) return;
    o = !1, s.forEach((b) => {
      var w;
      return b((w = r()) != null ? w : d);
    });
    const v = ((y = a.onRehydrateStorage) == null ? void 0 : y.call(a, (h = r()) != null ? h : d)) || void 0;
    return Cs(l.getItem.bind(l))(a.name).then((b) => {
      if (b)
        if (typeof b.version == "number" && b.version !== a.version) {
          if (a.migrate)
            return [
              !0,
              a.migrate(
                b.state,
                b.version
              )
            ];
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [!1, b.state];
      return [!1, void 0];
    }).then((b) => {
      var w;
      const [T, E] = b;
      if (p = a.merge(
        E,
        (w = r()) != null ? w : d
      ), n(p, !0), T)
        return u();
    }).then(() => {
      v == null || v(p, void 0), p = r(), o = !0, c.forEach((b) => b(p));
    }).catch((b) => {
      v == null || v(void 0, b);
    });
  };
  return i.persist = {
    setOptions: (h) => {
      a = {
        ...a,
        ...h
      }, h.storage && (l = h.storage);
    },
    clearStorage: () => {
      l == null || l.removeItem(a.name);
    },
    getOptions: () => a,
    rehydrate: () => m(),
    hasHydrated: () => o,
    onHydrate: (h) => (s.add(h), () => {
      s.delete(h);
    }),
    onFinishHydration: (h) => (c.add(h), () => {
      c.delete(h);
    })
  }, a.skipHydration || m(), p || d;
}, WF = (e, t) => "getStorage" in t || "serialize" in t || "deserialize" in t ? ((Ec ? "production" : void 0) !== "production" && console.warn(
  "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
), zF(e, t)) : qF(e, t), S_ = WF, E_ = go()(
  Ju(
    S_(
      (e) => ({
        messageHistory: [],
        addMessageToHistory: (t) => e((n) => ({
          ...n,
          messageHistory: [t, ...(n.messageHistory ?? []).slice(0, 100)]
        }))
      }),
      {
        name: "botpress-message-history"
        // Dynamically set the store name
      }
    )
  )
);
function Vi(e) {
  const { metadata: t, conversationId: n, userId: r } = e, { payload: i, disableInput: a } = __(e.payload);
  return {
    id: e.id,
    conversationId: n,
    authorId: r,
    timestamp: new Date(e.createdAt),
    block: i,
    disableInput: a,
    metadata: t
  };
}
const __ = (e) => {
  switch (e.type) {
    case "audio":
      return k_(e);
    case "card":
      return VF(e);
    case "carousel":
      return HF(e);
    case "choice":
      return ZF(e);
    case "dropdown":
      return KF(e);
    case "file":
      return T_(e);
    case "image":
      return C_(e);
    case "location":
      return O_(e);
    case "markdown":
      return $_(e);
    case "text":
      return R_(e);
    case "video":
      return I_(e);
    case "bloc":
      return GF(e);
    case "custom":
      return { payload: e };
    case "reaction":
      return { payload: { type: "text", text: "Unsupported message type" } };
    default: {
      const t = e;
      throw new Error(`Unsuported message type ${t}`);
    }
  }
}, ol = (e) => ({
  block: e,
  type: "bubble"
}), k_ = (e) => ({
  payload: { type: "audio", url: e.audioUrl }
}), VF = (e) => ({
  payload: ol(A_(e))
}), HF = (e) => ({
  payload: {
    type: "carousel",
    blocks: e.items.map((t) => A_({ type: "card", ...t }))
  }
}), ZF = (e) => {
  const t = e.options.map((a) => ({ title: a.label, value: a.value })), n = e.text, r = HS(), i = ol({
    type: "text",
    text: n
  });
  return t.length === 0 ? {
    disableInput: e.disableFreeText,
    payload: i
  } : {
    disableInput: e.disableFreeText,
    payload: {
      type: "column",
      blocks: [
        i,
        {
          type: "row",
          blocks: t.map(({ title: a, value: o }) => ({
            type: "button",
            variant: "action",
            text: a,
            buttonValue: o,
            groupId: r
          }))
        }
      ]
    }
  };
}, KF = (e) => {
  const t = e.options.map((i) => ({ label: i.label, value: i.value })), n = e.text, r = [
    {
      type: "dropdown",
      label: n ?? "Select an option",
      options: t
    }
  ];
  return n && r.unshift({
    type: "text",
    text: n
  }), {
    disableInput: !0,
    payload: ol({
      type: "column",
      blocks: r
    })
  };
}, T_ = (e) => ({
  payload: {
    type: "file",
    url: e.fileUrl,
    title: e.title
  }
}), C_ = (e) => ({
  payload: { type: "image", url: e.imageUrl }
}), O_ = (e) => ({
  payload: {
    type: "location",
    latitude: e.latitude,
    longitude: e.longitude,
    title: e.title ?? e.address ?? "View on map"
  }
}), $_ = (e) => ({
  payload: ol({ type: "text", text: e.markdown })
}), R_ = (e) => ({
  payload: ol({ type: "text", text: e.text, value: e.value })
}), I_ = (e) => ({
  payload: { type: "video", url: e.videoUrl }
}), GF = (e) => ({ payload: {
  type: "column",
  blocks: e.items.map((n) => {
    switch (n.type) {
      case "audio":
        return k_({ ...n.payload, type: n.type }).payload;
      case "file":
        return T_({ ...n.payload, type: n.type }).payload;
      case "image":
        return C_({ ...n.payload, type: n.type }).payload;
      case "location":
        return O_({ ...n.payload, type: n.type }).payload;
      case "markdown":
        return $_({ ...n.payload, type: n.type }).payload;
      case "text":
        return R_({ ...n.payload, type: n.type }).payload;
      case "video":
        return I_({ ...n.payload, type: n.type }).payload;
      default:
        throw new Error("Unsuported message type");
    }
  })
} }), A_ = (e) => {
  const t = e.title, n = e.subtitle, r = e.imageUrl, i = e.actions.map((o) => {
    switch (o.action) {
      case "postback":
        return {
          type: "button",
          variant: "action",
          text: o.label,
          buttonValue: o.value,
          reusable: !0
        };
      case "url":
        return {
          type: "button",
          variant: "link",
          text: o.label,
          buttonValue: o.value,
          reusable: !0
        };
      case "say":
        return {
          type: "button",
          variant: "action",
          text: o.label,
          buttonValue: o.value,
          reusable: !0
        };
      default:
        throw new Error(`Unknown action type ${o.action}`);
    }
  }), a = [];
  return r && a.push({
    type: "image",
    url: r
  }), t && a.push({
    type: "text",
    text: `#### ${t}`
  }), n && a.push({
    type: "text",
    text: n
  }), i.length > 0 && a.push({
    type: "row",
    blocks: i
  }), {
    type: "column",
    horizontalAlignment: "center",
    blocks: [...a]
  };
};
function Dh(e) {
  const { metadata: t, conversationId: n, userId: r } = e;
  return e.payload.type === "reaction" ? {
    id: e.id,
    conversationId: n,
    authorId: r,
    timestamp: new Date(e.createdAt),
    block: { type: "text", text: e.payload.reaction },
    metadata: t
  } : Vi(e);
}
const Rr = go()(
  Ju(
    (e) => ({
      messages: [],
      isFetching: !1,
      setMessages: (t) => e({ messages: t }),
      addMessage: (t) => e(({ messages: n }) => {
        var i;
        const r = (i = t.metadata) == null ? void 0 : i.clientMessageId;
        if (r) {
          const a = n.findIndex((o) => {
            var s;
            return ((s = o.metadata) == null ? void 0 : s.clientMessageId) === r;
          });
          if (a !== -1)
            return {
              messages: [...n.slice(0, a), t, ...n.slice(a + 1)]
            };
        }
        return { messages: [...n.filter((a) => a.id !== t.id), t] };
      }),
      updateMessage: (t, n) => e(({ messages: r }) => ({
        messages: r.map((i) => i.id === t ? { ...i, ...n } : i)
      })),
      clearMessages: () => e({ messages: [] }),
      fetchMessages: async ({ client: t, conversationId: n }) => {
        const r = [];
        e({ isFetching: !0 });
        let i;
        do {
          const { messages: a, meta: o } = await t.listConversationMessages({ conversationId: n, nextToken: i });
          r.push(...a), i = o.nextToken;
        } while (i);
        return e({ isFetching: !1 }), r.reverse().map(Dh).filter(Boolean);
      },
      /**
       * @deprecated This method is deprecated and will be removed in a future release.
       * Please use the new API instead.
       */
      fetchMessagesLegacy: async ({ client: t, userKey: n, conversationId: r }) => {
        const i = [];
        e({ isFetching: !0 });
        let a;
        do {
          const o = await t.listConversationMessages({ id: r, "x-user-key": n, nextToken: a });
          i.push(...o.messages), a = o.meta.nextToken;
        } while (a);
        return e({ isFetching: !1 }), i.reverse();
      }
    }),
    { name: "messagesStore" }
  )
), YF = (e, t) => go()(
  Ju(
    S_(
      (n) => ({
        setUser: (r) => n((i) => ({
          ...i,
          user: r
        })),
        setConversationId: (r) => n((i) => ({
          ...i,
          conversationId: r
        })),
        clearAll: () => {
          n((r) => ({
            ...r,
            messageHistory: {},
            user: void 0,
            conversationId: void 0
          }));
        }
      }),
      {
        name: e,
        // Dynamically set the store name
        storage: x_(() => t === "sessionStorage" ? sessionStorage : localStorage)
      }
    )
  )
), Fa = class Fa {
  constructor() {
  }
  static getInstance(t = "bp-webchat", n) {
    return Fa._instances[t] || (Fa._instances[t] = YF(t, n)), Fa._instances[t];
  }
};
Ee(Fa, "_instances", {});
let jh = Fa;
const P_ = jh.getInstance, _v = go()(
  Ju(
    (e) => ({
      eventEmitter: sI,
      messageContainerRef: { current: null },
      setMessageContainerRef: (t) => e({ messageContainerRef: t })
    }),
    { name: "webchatStore" }
  )
), JF = 8, Yo = go()((e, t) => ({
  files: [],
  setFiles: (n) => e({ files: n }),
  upsertFile: (n) => e(({ files: r }) => ({ files: r.some((o) => o.name === n.name) ? r.map((o) => o.name === n.name ? { ...o, ...n } : o) : [...r, { ...n }] })),
  uploadFile: async (n, r) => {
    const i = t().files.some((o) => o.name === n.name), a = t().files.length === JF;
    if (!(!i && a)) {
      t().upsertFile({
        name: n.name,
        type: "file",
        instance: n,
        status: "loading"
      });
      try {
        const { fileUrl: o, type: s } = await r(n);
        t().upsertFile({
          name: n.name,
          type: s,
          url: o,
          instance: n,
          status: "uploaded"
        });
      } catch (o) {
        console.error("Error sending file:", o), t().upsertFile({
          name: n.name,
          type: "file",
          instance: n,
          status: "error"
        });
      }
    }
  },
  deleteFile: (n) => e(({ files: r }) => ({ files: r.filter((i) => i.name != n) }))
})), XF = ({ text: e, buttonValue: t, variant: n, groupId: r, reusable: i, sendMessage: a, isReadOnly: o, ...s }) => {
  const c = _v((w) => w.eventEmitter), [l, u] = He(!1), [f, d] = He(!1), [p, m] = He(!1), {
    message: {
      blocks: { button: h }
    }
  } = ut;
  Pt(() => {
    if (r)
      return c.on(`button-group-${r}-click`, () => {
        d(!0), i || m(!0);
      });
  }, [c, r, i]);
  const v = {
    ...s,
    onClick: (w) => {
      if ((p || o) && n === "link") {
        w.preventDefault();
        return;
      }
      u(!0), i || m(!0), r && c.emit(`button-group-${r}-click`), n !== "link" && a && (a == null || a({ type: "text", text: e, value: t }));
    },
    "data-activated": l ? "" : void 0,
    "data-group-activated": f ? "" : void 0,
    "data-type": n,
    ...h
  }, b = p || o;
  return n === "link" ? /* @__PURE__ */ O.jsx(
    "a",
    {
      ...v,
      style: o ? { pointerEvents: "none" } : void 0,
      href: t,
      target: "_blank",
      rel: "noopener noreferrer",
      children: e
    }
  ) : /* @__PURE__ */ O.jsx("button", { ...v, style: o ? { pointerEvents: "none" } : void 0, disabled: b, children: e });
}, D_ = An(
  ({ block: e, direction: t, timestamp: n, sender: r, metadata: i, sendMessage: a, messageId: o, isReadOnly: s, ...c }, l) => {
    const {
      message: {
        blocks: { bubble: u }
      }
    } = ut;
    return /* @__PURE__ */ O.jsx("div", { "data-direction": t, ...c, ...u, ref: l, children: /* @__PURE__ */ O.jsx(
      dl,
      {
        block: { ...e, direction: t, timestamp: n, sender: r, messageId: o, sendMessage: a, isReadOnly: s },
        direction: t,
        timestamp: n,
        sender: r,
        metadata: i,
        sendMessage: a,
        messageId: o,
        isReadOnly: s
      }
    ) });
  }
);
D_.displayName = "Bubble";
const j_ = NS(null);
function QF() {
  const e = ho(j_);
  if (!e)
    throw new Error("useMessageContext must be used within a Message");
  return e;
}
const N_ = NS(null);
function M_() {
  const e = ho(N_);
  if (!e)
    throw new Error("useModalContext must be used within a ModalProvider");
  return e;
}
var Zn = function() {
  return Zn = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var a in n) Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
    }
    return t;
  }, Zn.apply(this, arguments);
};
function F_(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function bo(e, t, n, r) {
  function i(a) {
    return a instanceof n ? a : new n(function(o) {
      o(a);
    });
  }
  return new (n || (n = Promise))(function(a, o) {
    function s(u) {
      try {
        l(r.next(u));
      } catch (f) {
        o(f);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (f) {
        o(f);
      }
    }
    function l(u) {
      u.done ? a(u.value) : i(u.value).then(s, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
}
function wo(e, t) {
  var n = { label: 0, sent: function() {
    if (a[0] & 1) throw a[1];
    return a[1];
  }, trys: [], ops: [] }, r, i, a, o = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return o.next = s(0), o.throw = s(1), o.return = s(2), typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; o && (o = 0, l[0] && (n = 0)), n; ) try {
      if (r = 1, i && (a = l[0] & 2 ? i.return : l[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, l[1])).done) return a;
      switch (i = 0, a && (l = [l[0] & 2, a.value]), l[0]) {
        case 0:
        case 1:
          a = l;
          break;
        case 4:
          return n.label++, { value: l[1], done: !1 };
        case 5:
          n.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (a = n.trys, !(a = a.length > 0 && a[a.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            n = 0;
            continue;
          }
          if (l[0] === 3 && (!a || l[1] > a[0] && l[1] < a[3])) {
            n.label = l[1];
            break;
          }
          if (l[0] === 6 && n.label < a[1]) {
            n.label = a[1], a = l;
            break;
          }
          if (a && n.label < a[2]) {
            n.label = a[2], n.ops.push(l);
            break;
          }
          a[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      l = t.call(e, n);
    } catch (u) {
      l = [6, u], i = 0;
    } finally {
      r = a = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
}
function zb(e, t) {
  var n = typeof Symbol == "function" && e[Symbol.iterator];
  if (!n) return e;
  var r = n.call(e), i, a = [], o;
  try {
    for (; (t === void 0 || t-- > 0) && !(i = r.next()).done; ) a.push(i.value);
  } catch (s) {
    o = { error: s };
  } finally {
    try {
      i && !i.done && (n = r.return) && n.call(r);
    } finally {
      if (o) throw o.error;
    }
  }
  return a;
}
function Nh(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, i = t.length, a; r < i; r++)
    (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
function eL() {
  var e = Tt(!1), t = ot(function() {
    return e.current;
  }, []);
  return Pt(function() {
    return e.current = !0, function() {
      e.current = !1;
    };
  }, []), t;
}
function tL(e, t, n) {
  t === void 0 && (t = []), n === void 0 && (n = { loading: !1 });
  var r = Tt(0), i = eL(), a = He(n), o = a[0], s = a[1], c = ot(function() {
    for (var l = [], u = 0; u < arguments.length; u++)
      l[u] = arguments[u];
    var f = ++r.current;
    return o.loading || s(function(d) {
      return Zn(Zn({}, d), { loading: !0 });
    }), e.apply(void 0, l).then(function(d) {
      return i() && f === r.current && s({ value: d, loading: !1 }), d;
    }, function(d) {
      return i() && f === r.current && s({ error: d, loading: !1 }), d;
    });
  }, t);
  return [o, c];
}
function nL(e, t) {
  t === void 0 && (t = []);
  var n = tL(e, t, {
    loading: !0
  }), r = n[0], i = n[1];
  return Pt(function() {
    i();
  }, [i]), r;
}
const L_ = An(({ url: e, type: t, orientation: n = "auto", ...r }, i) => {
  const a = _R(), { setIsLoading: o } = QF(), [s, c] = He(n), [l, u] = He(!1), {
    message: {
      blocks: { image: f }
    }
  } = ut;
  return mo(() => {
    o((d) => [...d, a]);
  }, []), nL(async () => {
    if (e) {
      try {
        const { width: d, height: p } = await IA(e);
        s === "auto" && c(rL(d, p));
      } catch (d) {
        c("square"), console.error(d);
      }
      o((d) => d.filter((p) => p !== a));
    }
  }, [e]), /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
    l ? null : /* @__PURE__ */ O.jsx("div", { "data-orientation": s, ...f.placeholder }),
    /* @__PURE__ */ O.jsx(
      "img",
      {
        "data-orientation": s,
        "data-loaded": l,
        ...r,
        ...f.image,
        src: e,
        alt: "",
        ref: i,
        loading: "lazy",
        onLoad: () => {
          u(!0);
        }
      }
    )
  ] });
});
L_.displayName = "Image";
function rL(e, t) {
  const n = {
    square: 1,
    portrait: 0.75,
    landscape: 1.3333333333333333
  }, r = e / t;
  return Object.keys(n).reduce((a, o) => Math.abs(n[o] - r) < Math.abs(n[a] - r) ? o : a);
}
const B_ = An(({ url: e, isReadOnly: t, ...n }, r) => {
  const {
    message: {
      blocks: { video: i }
    }
  } = ut;
  return /* @__PURE__ */ O.jsx("div", { children: /* @__PURE__ */ O.jsx(
    "video",
    {
      ...n,
      "data-chromatic": "ignore",
      style: t ? { pointerEvents: "none" } : void 0,
      controls: !0,
      src: e,
      ...i,
      ref: r
    }
  ) });
});
B_.displayName = "Video";
const U_ = An(({ url: e, isReadOnly: t, ...n }, r) => {
  const {
    message: {
      blocks: { audio: i }
    }
  } = ut;
  return /* @__PURE__ */ O.jsx("div", { children: /* @__PURE__ */ O.jsx(
    "audio",
    {
      ...n,
      controls: !0,
      style: t ? { pointerEvents: "none" } : void 0,
      src: e,
      ...i,
      ref: r
    }
  ) });
});
U_.displayName = "Audio";
function iL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M15.312 11.424a5.5 5.5 0 0 1-9.201 2.466l-.312-.311h2.433a.75.75 0 0 0 0-1.5H3.989a.75.75 0 0 0-.75.75v4.242a.75.75 0 0 0 1.5 0v-2.43l.31.31a7 7 0 0 0 11.712-3.138.75.75 0 0 0-1.449-.39Zm1.23-3.723a.75.75 0 0 0 .219-.53V2.929a.75.75 0 0 0-1.5 0V5.36l-.31-.31A7 7 0 0 0 3.239 8.188a.75.75 0 1 0 1.448.389A5.5 5.5 0 0 1 13.89 6.11l.311.31h-2.432a.75.75 0 0 0 0 1.5h4.243a.75.75 0 0 0 .53-.219Z",
    clipRule: "evenodd"
  }));
}
const aL = /* @__PURE__ */ x.forwardRef(iL);
function oL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M5.22 8.22a.75.75 0 0 1 1.06 0L10 11.94l3.72-3.72a.75.75 0 1 1 1.06 1.06l-4.25 4.25a.75.75 0 0 1-1.06 0L5.22 9.28a.75.75 0 0 1 0-1.06Z",
    clipRule: "evenodd"
  }));
}
const sL = /* @__PURE__ */ x.forwardRef(oL);
function lL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M4.5 2A1.5 1.5 0 0 0 3 3.5v13A1.5 1.5 0 0 0 4.5 18h11a1.5 1.5 0 0 0 1.5-1.5V7.621a1.5 1.5 0 0 0-.44-1.06l-4.12-4.122A1.5 1.5 0 0 0 11.378 2H4.5Zm4.75 6.75a.75.75 0 0 1 1.5 0v2.546l.943-1.048a.75.75 0 0 1 1.114 1.004l-2.25 2.5a.75.75 0 0 1-1.114 0l-2.25-2.5a.75.75 0 1 1 1.114-1.004l.943 1.048V8.75Z",
    clipRule: "evenodd"
  }));
}
const cL = /* @__PURE__ */ x.forwardRef(lL);
function uL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z",
    clipRule: "evenodd"
  }));
}
const fL = /* @__PURE__ */ x.forwardRef(uL);
function dL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "m9.69 18.933.003.001C9.89 19.02 10 19 10 19s.11.02.308-.066l.002-.001.006-.003.018-.008a5.741 5.741 0 0 0 .281-.14c.186-.096.446-.24.757-.433.62-.384 1.445-.966 2.274-1.765C15.302 14.988 17 12.493 17 9A7 7 0 1 0 3 9c0 3.492 1.698 5.988 3.355 7.584a13.731 13.731 0 0 0 2.273 1.765 11.842 11.842 0 0 0 .976.544l.062.029.018.008.006.003ZM10 11.25a2.25 2.25 0 1 0 0-4.5 2.25 2.25 0 0 0 0 4.5Z",
    clipRule: "evenodd"
  }));
}
const pL = /* @__PURE__ */ x.forwardRef(dL);
function hL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 1 0 0-16 8 8 0 0 0 0 16ZM8.28 7.22a.75.75 0 0 0-1.06 1.06L8.94 10l-1.72 1.72a.75.75 0 1 0 1.06 1.06L10 11.06l1.72 1.72a.75.75 0 1 0 1.06-1.06L11.06 10l1.72-1.72a.75.75 0 0 0-1.06-1.06L10 8.94 8.28 7.22Z",
    clipRule: "evenodd"
  }));
}
const hd = /* @__PURE__ */ x.forwardRef(hL), z_ = An(
  ({ latitude: e, longitude: t, title: n, isReadOnly: r, ...i }, a) => {
    const o = `https://www.google.com/maps/search/?api=1&query=${e},${t}`, {
      message: {
        blocks: { location: s }
      }
    } = ut;
    return /* @__PURE__ */ O.jsxs(
      "a",
      {
        ...i,
        ...s.container,
        style: r ? { pointerEvents: "none" } : void 0,
        href: o,
        type: "_blank",
        rel: "noopener",
        ref: a,
        children: [
          /* @__PURE__ */ O.jsx("p", { ...s.title, children: n }),
          /* @__PURE__ */ O.jsx(pL, { ...s.icon })
        ]
      }
    );
  }
);
z_.displayName = "Location";
const q_ = An(
  ({
    blocks: e,
    horizontalAlignment: t,
    verticalAlignment: n,
    direction: r,
    sender: i,
    timestamp: a,
    metadata: o,
    messageId: s,
    sendMessage: c,
    isReadOnly: l,
    ...u
  }, f) => {
    const {
      message: {
        blocks: { column: d }
      }
    } = ut;
    return /* @__PURE__ */ O.jsx("div", { "data-horizontal": t, "data-vertical": n, ...u, ...d, ref: f, children: e.map((p, m) => /* @__PURE__ */ O.jsx(
      dl,
      {
        block: { ...p, direction: r, timestamp: a, sender: i, messageId: s, sendMessage: c, isReadOnly: l },
        direction: r,
        timestamp: a,
        sender: i,
        metadata: o,
        sendMessage: c,
        messageId: s,
        isReadOnly: l
      },
      m
    )) });
  }
);
q_.displayName = "Column";
const W_ = An(
  ({
    blocks: e,
    horizontalAlignment: t,
    verticalAlignment: n,
    direction: r,
    sender: i,
    timestamp: a,
    metadata: o,
    sendMessage: s,
    messageId: c,
    isReadOnly: l,
    ...u
  }, f) => {
    const {
      message: {
        blocks: { row: d }
      }
    } = ut;
    return /* @__PURE__ */ O.jsx("div", { "data-horizontal": t, "data-vertical": n, ...u, ...d, ref: f, children: e.map((p, m) => /* @__PURE__ */ O.jsx(
      dl,
      {
        block: { ...p, direction: r, timestamp: a, sender: i, messageId: c, sendMessage: s, isReadOnly: l },
        direction: r,
        sender: i,
        timestamp: a,
        metadata: o,
        sendMessage: s,
        messageId: c,
        isReadOnly: l
      },
      m
    )) });
  }
);
W_.displayName = "Row";
function mL(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function qb(e) {
  return mL(e) || Array.isArray(e);
}
function vL() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function kv(e, t) {
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length) return !1;
  const i = JSON.stringify(Object.keys(e.breakpoints || {})), a = JSON.stringify(Object.keys(t.breakpoints || {}));
  return i !== a ? !1 : n.every((o) => {
    const s = e[o], c = t[o];
    return typeof s == "function" ? `${s}` == `${c}` : !qb(s) || !qb(c) ? s === c : kv(s, c);
  });
}
function Wb(e) {
  return e.concat().sort((t, n) => t.name > n.name ? 1 : -1).map((t) => t.options);
}
function yL(e, t) {
  if (e.length !== t.length) return !1;
  const n = Wb(e), r = Wb(t);
  return n.every((i, a) => {
    const o = r[a];
    return kv(i, o);
  });
}
function Tv(e) {
  return typeof e == "number";
}
function Vb(e) {
  return typeof e == "string";
}
function Cv(e) {
  return typeof e == "boolean";
}
function Hb(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ft(e) {
  return Math.abs(e);
}
function Ov(e) {
  return Math.sign(e);
}
function _c(e, t) {
  return Ft(e - t);
}
function gL(e, t) {
  if (e === 0 || t === 0 || Ft(e) <= Ft(t)) return 0;
  const n = _c(Ft(e), Ft(t));
  return Ft(n / e);
}
function Os(e) {
  return ou(e).map(Number);
}
function Jr(e) {
  return e[Xu(e)];
}
function Xu(e) {
  return Math.max(0, e.length - 1);
}
function ou(e) {
  return Object.keys(e);
}
function V_(e, t) {
  return [e, t].reduce((n, r) => (ou(r).forEach((i) => {
    const a = n[i], o = r[i], s = Hb(a) && Hb(o);
    n[i] = s ? V_(a, o) : o;
  }), n), {});
}
function H_(e, t) {
  return typeof t.MouseEvent < "u" && e instanceof t.MouseEvent;
}
function bL(e, t) {
  const n = {
    start: r,
    center: i,
    end: a
  };
  function r() {
    return 0;
  }
  function i(l) {
    return a(l) / 2;
  }
  function a(l) {
    return t - l;
  }
  function o() {
    return t * Number(e);
  }
  function s(l) {
    return Tv(e) ? o() : n[e](l);
  }
  return {
    measure: s
  };
}
function wL(e, t) {
  const n = e === "y" ? "y" : "x", r = e === "y" ? "x" : "y", i = s(), a = c();
  function o(u) {
    const {
      width: f,
      height: d
    } = u;
    return n === "x" ? f : d;
  }
  function s() {
    return n === "y" ? "top" : t === "rtl" ? "right" : "left";
  }
  function c() {
    return n === "y" ? "bottom" : t === "rtl" ? "left" : "right";
  }
  return {
    scroll: n,
    cross: r,
    startEdge: i,
    endEdge: a,
    measureSize: o
  };
}
function Ti(e, t) {
  const n = Ft(e - t);
  function r(l) {
    return l < e;
  }
  function i(l) {
    return l > t;
  }
  function a(l) {
    return r(l) || i(l);
  }
  function o(l) {
    return a(l) ? r(l) ? e : t : l;
  }
  function s(l) {
    return n ? l - n * Math.ceil((l - t) / n) : l;
  }
  return {
    length: n,
    max: t,
    min: e,
    constrain: o,
    reachedAny: a,
    reachedMax: i,
    reachedMin: r,
    removeOffset: s
  };
}
function Z_(e, t, n) {
  const {
    constrain: r
  } = Ti(0, e), i = e + 1;
  let a = o(t);
  function o(d) {
    return n ? Ft((i + d) % i) : r(d);
  }
  function s() {
    return a;
  }
  function c(d) {
    return a = o(d), f;
  }
  function l(d) {
    return u().set(s() + d);
  }
  function u() {
    return Z_(e, s(), n);
  }
  const f = {
    get: s,
    set: c,
    add: l,
    clone: u
  };
  return f;
}
function xL(e) {
  const t = e === "rtl" ? -1 : 1;
  function n(i) {
    return i * t;
  }
  return {
    apply: n
  };
}
function $s() {
  let e = [];
  function t(i, a, o, s = {
    passive: !0
  }) {
    return i.addEventListener(a, o, s), e.push(() => i.removeEventListener(a, o, s)), r;
  }
  function n() {
    e = e.filter((i) => i());
  }
  const r = {
    add: t,
    clear: n
  };
  return r;
}
function SL(e, t, n, r, i, a, o, s, c, l, u, f, d, p, m, h, y, v, b) {
  const {
    cross: w
  } = e, T = ["INPUT", "SELECT", "TEXTAREA"], E = {
    passive: !1
  }, _ = $s(), $ = $s(), B = Ti(50, 225).constrain(m.measure(20)), U = {
    mouse: 300,
    touch: 400
  }, k = {
    mouse: 500,
    touch: 600
  }, D = h ? 43 : 25;
  let q = !1, L = 0, R = 0, A = !1, F = !1, H = !1, V = !1;
  function I(Q, K) {
    if (!K) return;
    function fe($e) {
      (Cv(K) || K(Q, $e)) && Y($e);
    }
    const ye = n;
    _.add(ye, "dragstart", ($e) => $e.preventDefault(), E).add(ye, "touchmove", () => {
    }, E).add(ye, "touchend", () => {
    }).add(ye, "touchstart", fe).add(ye, "mousedown", fe).add(ye, "touchcancel", X).add(ye, "contextmenu", X).add(ye, "click", ie, !0);
  }
  function g() {
    _.clear(), $.clear();
  }
  function j() {
    const Q = V ? r : n;
    $.add(Q, "touchmove", G, E).add(Q, "touchend", X).add(Q, "mousemove", G, E).add(Q, "mouseup", X);
  }
  function W(Q) {
    const K = Q.nodeName || "";
    return T.includes(K);
  }
  function S() {
    return (h ? k : U)[V ? "mouse" : "touch"];
  }
  function Z(Q, K) {
    const fe = d.add(Ov(Q) * -1), ye = f.byDistance(Q, !h).distance;
    return h || Ft(Q) < B ? ye : v && K ? ye * 0.5 : f.byIndex(fe.get(), 0).distance;
  }
  function Y(Q) {
    const K = H_(Q, i);
    V = K, !(K && Q.button !== 0) && (W(Q.target) || (H = h && K && !Q.buttons && q, q = _c(a.get(), s.get()) >= 2, A = !0, o.pointerDown(Q), u.useFriction(0).useDuration(0), a.set(s), j(), L = o.readPoint(Q), R = o.readPoint(Q, w), p.emit("pointerDown")));
  }
  function G(Q) {
    const K = o.readPoint(Q), fe = o.readPoint(Q, w), ye = _c(K, L), $e = _c(fe, R);
    if (!F && !V && (!Q.cancelable || (F = ye > $e, !F)))
      return X(Q);
    const M = o.pointerMove(Q);
    ye > y && (H = !0), u.useFriction(0.3).useDuration(1), c.start(), a.add(t.apply(M)), Q.preventDefault();
  }
  function X(Q) {
    const fe = f.byDistance(0, !1).index !== d.get(), ye = o.pointerUp(Q) * S(), $e = Z(t.apply(ye), fe), M = gL(ye, $e), re = D - 10 * M, le = b + M / 50;
    F = !1, A = !1, $.clear(), u.useDuration(re).useFriction(le), l.distance($e, !h), V = !1, p.emit("pointerUp");
  }
  function ie(Q) {
    H && (Q.stopPropagation(), Q.preventDefault());
  }
  function ae() {
    return A;
  }
  return {
    init: I,
    pointerDown: ae,
    destroy: g
  };
}
function EL(e, t) {
  let r, i;
  function a(f) {
    return f.timeStamp;
  }
  function o(f, d) {
    const m = `client${(d || e.scroll) === "x" ? "X" : "Y"}`;
    return (H_(f, t) ? f : f.touches[0])[m];
  }
  function s(f) {
    return r = f, i = f, o(f);
  }
  function c(f) {
    const d = o(f) - o(i), p = a(f) - a(r) > 170;
    return i = f, p && (r = f), d;
  }
  function l(f) {
    if (!r || !i) return 0;
    const d = o(i) - o(r), p = a(f) - a(r), m = a(f) - a(i) > 170, h = d / p;
    return p && !m && Ft(h) > 0.1 ? h : 0;
  }
  return {
    pointerDown: s,
    pointerMove: c,
    pointerUp: l,
    readPoint: o
  };
}
function _L(e) {
  function t(r) {
    return e * (r / 100);
  }
  return {
    measure: t
  };
}
function kL(e, t, n, r, i) {
  let a, o, s = [], c = !1;
  function l(p) {
    return i.measureSize(p.getBoundingClientRect());
  }
  function u(p, m) {
    if (!m) return;
    o = l(e), s = r.map(l);
    function h(v) {
      for (const b of v) {
        const w = b.target === e, T = r.indexOf(b.target), E = w ? o : s[T], _ = l(w ? e : r[T]);
        if (E !== _) {
          n.requestAnimationFrame(() => {
            p.reInit(), t.emit("resize");
          });
          break;
        }
      }
    }
    a = new ResizeObserver((v) => {
      c || (Cv(m) || m(p, v)) && h(v);
    }), [e].concat(r).forEach((v) => a.observe(v));
  }
  function f() {
    a && a.disconnect(), c = !0;
  }
  return {
    init: u,
    destroy: f
  };
}
function TL(e, t, n, r) {
  let i = !0, a = 0, o = 0, s = n, c = r, l = e.get(), u = 0;
  function f() {
    const E = t.get() - e.get(), _ = !s;
    let $ = 0;
    return _ ? (a = 0, e.set(t), $ = E) : (a += E / s, a *= c, l += a, e.add(a), $ = l - u), o = Ov($), u = l, i = Ft(E) < 1e-3, T;
  }
  function d() {
    return i;
  }
  function p() {
    return s;
  }
  function m() {
    return o;
  }
  function h() {
    return a;
  }
  function y() {
    return b(n);
  }
  function v() {
    return w(r);
  }
  function b(E) {
    return s = E, T;
  }
  function w(E) {
    return c = E, T;
  }
  const T = {
    direction: m,
    duration: p,
    velocity: h,
    seek: f,
    settled: d,
    useBaseFriction: v,
    useBaseDuration: y,
    useFriction: w,
    useDuration: b
  };
  return T;
}
function CL(e, t, n, r, i) {
  const a = i.measure(10), o = i.measure(50), s = Ti(0.1, 0.99);
  let c = !1;
  function l() {
    return !(c || !e.reachedAny(n.get()) || !e.reachedAny(t.get()));
  }
  function u(p) {
    if (!l()) return;
    const m = e.reachedMin(t.get()) ? "min" : "max", h = Ft(e[m] - t.get()), y = n.get() - t.get(), v = s.constrain(h / o);
    n.subtract(y * v), !p && Ft(y) < a && (n.set(e.constrain(n.get())), r.useDuration(25).useBaseFriction());
  }
  function f(p) {
    c = !p;
  }
  return {
    constrain: u,
    toggleActive: f
  };
}
function OL(e, t, n, r) {
  const i = Ti(-t + e, n[0]), a = c(), o = l();
  function s() {
    const f = a[0], d = Jr(a), p = a.lastIndexOf(f), m = a.indexOf(d) + 1;
    return Ti(p, m);
  }
  function c() {
    return n.map(i.constrain).map((f) => parseFloat(f.toFixed(3)));
  }
  function l() {
    if (t <= e) return [i.max];
    if (r === "keepSnaps") return a;
    const {
      min: f,
      max: d
    } = s();
    return a.slice(f, d);
  }
  return {
    snapsContained: o
  };
}
function $L(e, t, n) {
  const r = t[0], i = n ? r - e : Jr(t);
  return {
    limit: Ti(i, r)
  };
}
function RL(e, t, n, r) {
  const a = t.min + 0.1, o = t.max + 0.1, {
    reachedMin: s,
    reachedMax: c
  } = Ti(a, o);
  function l(d) {
    return d === 1 ? c(n.get()) : d === -1 ? s(n.get()) : !1;
  }
  function u(d) {
    if (!l(d)) return;
    const p = e * (d * -1);
    r.forEach((m) => m.add(p));
  }
  return {
    loop: u
  };
}
function IL(e) {
  const {
    max: t,
    length: n
  } = e;
  function r(a) {
    return (a - t) / -n;
  }
  return {
    get: r
  };
}
function AL(e, t, n, r, i, a, o) {
  const {
    startEdge: s,
    endEdge: c
  } = e, {
    groupSlides: l
  } = a, u = p().map(t.measure), f = m(), d = h();
  function p() {
    return l(r).map((v) => Jr(v)[c] - v[0][s]).map(Ft);
  }
  function m() {
    return r.map((v) => n[s] - v[s]).map((v) => -Ft(v));
  }
  function h() {
    const b = Jr(f) - Jr(i);
    return l(f).map((w) => w[0]).map((w, T, E) => {
      const _ = !T, $ = T === Xu(E);
      return o && _ ? 0 : o && $ ? b : w + u[T];
    });
  }
  return {
    snaps: f,
    snapsAligned: d
  };
}
function PL(e, t, n, r, i) {
  const {
    reachedAny: a,
    removeOffset: o,
    constrain: s
  } = r;
  function c(m) {
    return m.concat().sort((h, y) => Ft(h) - Ft(y))[0];
  }
  function l(m) {
    const h = e ? o(m) : s(m), y = t.map((b) => b - h).map((b) => u(b, 0)).map((b, w) => ({
      diff: b,
      index: w
    })).sort((b, w) => Ft(b.diff) - Ft(w.diff)), {
      index: v
    } = y[0];
    return {
      index: v,
      distance: h
    };
  }
  function u(m, h) {
    const y = [m, m + n, m - n];
    if (!e) return y[0];
    if (!h) return c(y);
    const v = y.filter((b) => Ov(b) === h);
    return c(v);
  }
  function f(m, h) {
    const y = t[m] - i.get(), v = u(y, h);
    return {
      index: m,
      distance: v
    };
  }
  function d(m, h) {
    const y = i.get() + m, {
      index: v,
      distance: b
    } = l(y), w = !e && a(y);
    if (!h || w) return {
      index: v,
      distance: m
    };
    const T = t[v] - b, E = m + u(T, 0);
    return {
      index: v,
      distance: E
    };
  }
  return {
    byDistance: d,
    byIndex: f,
    shortcut: u
  };
}
function DL(e, t, n, r, i, a, o) {
  function s(f) {
    const d = f.distance, p = f.index !== t.get();
    a.add(d), d && (i.duration() ? e.start() : (e.update(), e.render(1), e.update())), p && (n.set(t.get()), t.set(f.index), o.emit("select"));
  }
  function c(f, d) {
    const p = r.byDistance(f, d);
    s(p);
  }
  function l(f, d) {
    const p = t.clone().set(f), m = r.byIndex(p.get(), d);
    s(m);
  }
  return {
    distance: c,
    index: l
  };
}
function kc(e) {
  let t = e;
  function n() {
    return t;
  }
  function r(c) {
    t = o(c);
  }
  function i(c) {
    t += o(c);
  }
  function a(c) {
    t -= o(c);
  }
  function o(c) {
    return Tv(c) ? c : c.get();
  }
  return {
    get: n,
    set: r,
    add: i,
    subtract: a
  };
}
function K_(e, t, n) {
  const r = e.scroll === "x" ? o : s, i = n.style;
  let a = !1;
  function o(d) {
    return `translate3d(${d}px,0px,0px)`;
  }
  function s(d) {
    return `translate3d(0px,${d}px,0px)`;
  }
  function c(d) {
    a || (i.transform = r(t.apply(d)));
  }
  function l(d) {
    a = !d;
  }
  function u() {
    a || (i.transform = "", n.getAttribute("style") || n.removeAttribute("style"));
  }
  return {
    clear: u,
    to: c,
    toggleActive: l
  };
}
function jL(e, t, n, r, i, a, o, s, c) {
  const l = Os(i), u = Os(i).reverse(), f = h().concat(y());
  function d(E, _) {
    return E.reduce(($, B) => $ - i[B], _);
  }
  function p(E, _) {
    return E.reduce(($, B) => d($, _) > 0 ? $.concat([B]) : $, []);
  }
  function m(E, _) {
    const $ = _ === "start", B = $ ? -r : r, U = o.findSlideBounds([B]);
    return E.map((k) => {
      const D = $ ? 0 : -r, q = $ ? r : 0, R = U.filter((A) => A.index === k)[0][$ ? "end" : "start"];
      return {
        index: k,
        slideLocation: kc(-1),
        translate: K_(e, t, c[k]),
        target: () => s.get() > R ? D : q
      };
    });
  }
  function h() {
    const E = a[0] - 1, _ = p(u, E);
    return m(_, "end");
  }
  function y() {
    const E = n - a[0] - 1, _ = p(l, E);
    return m(_, "start");
  }
  function v() {
    return f.every(({
      index: E
    }) => {
      const _ = l.filter(($) => $ !== E);
      return d(_, n) <= 0.1;
    });
  }
  function b() {
    f.forEach((E) => {
      const {
        target: _,
        translate: $,
        slideLocation: B
      } = E, U = _();
      U !== B.get() && ($.to(U), B.set(U));
    });
  }
  function w() {
    f.forEach((E) => E.translate.clear());
  }
  return {
    canLoop: v,
    clear: w,
    loop: b,
    loopPoints: f
  };
}
function NL(e, t) {
  let n, r = !1;
  function i(s, c) {
    if (!c) return;
    function l(u) {
      for (const f of u)
        if (f.type === "childList") {
          s.reInit(), t.emit("slidesChanged");
          break;
        }
    }
    n = new MutationObserver((u) => {
      r || (Cv(c) || c(s, u)) && l(u);
    }), n.observe(e, {
      childList: !0
    });
  }
  function a() {
    n && n.disconnect(), r = !0;
  }
  return {
    init: i,
    destroy: a
  };
}
function ML(e, t, n, r, i, a, o) {
  const {
    removeOffset: s,
    constrain: c
  } = i, l = 0.5, u = a ? [0, t, -t] : [0], f = p(u, o);
  function d(y) {
    const v = y || 0;
    return n.map((b) => Ti(l, b - l).constrain(b * v));
  }
  function p(y, v) {
    const b = y || u, w = d(v);
    return b.reduce((T, E) => {
      const _ = r.map(($, B) => ({
        start: $ - n[B] + w[B] + E,
        end: $ + e - w[B] + E,
        index: B
      }));
      return T.concat(_);
    }, []);
  }
  function m(y, v) {
    const b = a ? s(y) : c(y);
    return (v || f).reduce((T, E) => {
      const {
        index: _,
        start: $,
        end: B
      } = E, U = T.includes(_), k = $ < b && B > b;
      return !U && k ? T.concat([_]) : T;
    }, []);
  }
  return {
    check: m,
    findSlideBounds: p
  };
}
function FL(e, t, n, r, i, a) {
  const {
    measureSize: o,
    startEdge: s,
    endEdge: c
  } = e, l = n[0] && i, u = m(), f = h(), d = n.map(o), p = y();
  function m() {
    if (!l) return 0;
    const b = n[0];
    return Ft(t[s] - b[s]);
  }
  function h() {
    if (!l) return 0;
    const b = a.getComputedStyle(Jr(r));
    return parseFloat(b.getPropertyValue(`margin-${c}`));
  }
  function y() {
    return n.map((b, w, T) => {
      const E = !w, _ = w === Xu(T);
      return E ? d[w] + u : _ ? d[w] + f : T[w + 1][s] - b[s];
    }).map(Ft);
  }
  return {
    slideSizes: d,
    slideSizesWithGaps: p
  };
}
function LL(e, t, n) {
  const r = Tv(n);
  function i(c, l) {
    return Os(c).filter((u) => u % l === 0).map((u) => c.slice(u, u + l));
  }
  function a(c) {
    return Os(c).reduce((l, u) => {
      const d = t.slice(Jr(l), u + 1).reduce((p, m) => p + m, 0);
      return !u || d > e ? l.concat(u) : l;
    }, []).map((l, u, f) => c.slice(l, f[u + 1]));
  }
  function o(c) {
    return r ? i(c, n) : a(c);
  }
  return {
    groupSlides: o
  };
}
function BL(e, t, n, r, i, a, o, s) {
  const {
    align: c,
    axis: l,
    direction: u,
    startIndex: f,
    inViewThreshold: d,
    loop: p,
    duration: m,
    dragFree: h,
    dragThreshold: y,
    slidesToScroll: v,
    skipSnaps: b,
    containScroll: w
  } = a, T = t.getBoundingClientRect(), E = n.map((le) => le.getBoundingClientRect()), _ = xL(u), $ = wL(l, u), B = $.measureSize(T), U = _L(B), k = bL(c, B), D = !p && !!w, q = p || !!w, {
    slideSizes: L,
    slideSizesWithGaps: R
  } = FL($, T, E, n, q, i), A = LL(B, R, v), {
    snaps: F,
    snapsAligned: H
  } = AL($, k, T, E, R, A, D), V = -Jr(F) + Jr(R), {
    snapsContained: I
  } = OL(B, V, H, w), g = D ? I : H, {
    limit: j
  } = $L(V, g, p), W = Z_(Xu(g), f, p), S = W.clone(), Z = Os(n), Y = ({
    dragHandler: le,
    scrollBody: oe,
    scrollBounds: Te,
    eventHandler: Se,
    animation: Re,
    options: {
      loop: ze
    }
  }) => {
    const ee = le.pointerDown();
    ze || Te.constrain(ee);
    const ue = oe.seek().settled();
    ue && !ee && (Re.stop(), Se.emit("settle")), ue || Se.emit("scroll");
  }, G = ({
    scrollBody: le,
    translate: oe,
    location: Te,
    offsetLocation: Se,
    scrollLooper: Re,
    slideLooper: ze,
    options: {
      loop: ee
    }
  }, ue) => {
    const z = le.velocity();
    Se.set(Te.get() - z + z * ue), ee && (Re.loop(le.direction()), ze.loop()), oe.to(Se.get());
  }, X = {
    start: () => s.start(re),
    stop: () => s.stop(re),
    update: () => Y(re),
    render: (le) => G(re, le)
  }, ie = 0.68, ae = g[W.get()], J = kc(ae), Q = kc(ae), K = kc(ae), fe = TL(J, K, m, ie), ye = PL(p, g, V, j, K), $e = DL(X, W, S, ye, fe, K, o), M = ML(B, V, L, F, j, p, d), re = {
    ownerDocument: r,
    ownerWindow: i,
    eventHandler: o,
    containerRect: T,
    slideRects: E,
    animation: X,
    axis: $,
    direction: _,
    dragHandler: SL($, _, e, r, i, K, EL($, i), J, X, $e, fe, ye, W, o, U, h, y, b, ie),
    eventStore: $s(),
    percentOfView: U,
    index: W,
    indexPrevious: S,
    limit: j,
    location: J,
    offsetLocation: Q,
    options: a,
    resizeHandler: kL(t, o, i, n, $),
    scrollBody: fe,
    scrollBounds: CL(j, J, K, fe, U),
    scrollLooper: RL(V, j, Q, [J, Q, K]),
    scrollProgress: IL(j),
    scrollSnaps: g,
    scrollTarget: ye,
    scrollTo: $e,
    slideLooper: jL($, _, B, V, R, g, M, Q, n),
    slidesHandler: NL(t, o),
    slidesInView: M,
    slideIndexes: Z,
    slidesToScroll: A,
    target: K,
    translate: K_($, _, t)
  };
  return re;
}
function UL(e) {
  const t = 16.666666666666668;
  let n = [], r = null, i = 0, a = 0;
  function o(f) {
    r || (r = f);
    const d = f - r;
    for (r = f, i += d; i >= t; )
      n.forEach(({
        animation: m
      }) => m.update()), i -= t;
    const p = Ft(i / t);
    n.forEach(({
      animation: m
    }) => m.render(p)), a && e.requestAnimationFrame(o);
  }
  function s(f) {
    n.includes(f) || n.push(f), !a && (a = e.requestAnimationFrame(o));
  }
  function c(f) {
    n = n.filter((d) => d !== f), !n.length && (e.cancelAnimationFrame(a), r = null, i = 0, a = 0);
  }
  function l() {
    r = null, i = 0;
  }
  return {
    start: s,
    stop: c,
    reset: l,
    window: e
  };
}
function zL() {
  const e = {};
  let t;
  function n(c) {
    t = c;
  }
  function r(c) {
    return e[c] || [];
  }
  function i(c) {
    return r(c).forEach((l) => l(t, c)), s;
  }
  function a(c, l) {
    return e[c] = r(c).concat([l]), s;
  }
  function o(c, l) {
    return e[c] = r(c).filter((u) => u !== l), s;
  }
  const s = {
    init: n,
    emit: i,
    off: o,
    on: a
  };
  return s;
}
const qL = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  inViewThreshold: 0,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0
};
function WL(e) {
  function t(a, o) {
    return V_(a, o || {});
  }
  function n(a) {
    const o = a.breakpoints || {}, s = ou(o).filter((c) => e.matchMedia(c).matches).map((c) => o[c]).reduce((c, l) => t(c, l), {});
    return t(a, s);
  }
  function r(a) {
    return a.map((o) => ou(o.breakpoints || {})).reduce((o, s) => o.concat(s), []).map(e.matchMedia);
  }
  return {
    mergeOptions: t,
    optionsAtMedia: n,
    optionsMediaQueries: r
  };
}
function VL(e) {
  let t = [];
  function n(a, o) {
    return t = a.filter(({
      options: s
    }) => e.optionsAtMedia(s).active !== !1), t.forEach((s) => s.init(o, e)), a.reduce((s, c) => Object.assign(s, {
      [c.name]: c
    }), {});
  }
  function r() {
    t = t.filter((a) => a.destroy());
  }
  return {
    init: n,
    destroy: r
  };
}
function Ja(e, t, n) {
  const r = e.ownerDocument, i = r.defaultView, a = WL(i), o = VL(a), s = $s(), c = $s(), l = zL(), {
    animationRealms: u
  } = Ja, {
    mergeOptions: f,
    optionsAtMedia: d,
    optionsMediaQueries: p
  } = a, {
    on: m,
    off: h,
    emit: y
  } = l, v = L;
  let b = !1, w, T = f(qL, Ja.globalOptions), E = f(T), _ = [], $, B, U;
  function k() {
    const {
      container: fe,
      slides: ye
    } = E;
    B = (Vb(fe) ? e.querySelector(fe) : fe) || e.children[0];
    const M = Vb(ye) ? B.querySelectorAll(ye) : ye;
    U = [].slice.call(M || B.children);
  }
  function D(fe, ye) {
    const $e = BL(e, B, U, r, i, fe, l, ye);
    if (fe.loop && !$e.slideLooper.canLoop()) {
      const M = Object.assign({}, fe, {
        loop: !1
      });
      return D(M, ye);
    }
    return $e;
  }
  function q(fe, ye) {
    if (b) return;
    const $e = u.find((re) => re.window === i), M = $e || UL(i);
    $e || u.push(M), T = f(T, fe), E = d(T), _ = ye || _, k(), w = D(E, M), p([T, ..._.map(({
      options: re
    }) => re)]).forEach((re) => s.add(re, "change", L)), E.active && (w.translate.to(w.location.get()), w.eventHandler.init(K), w.resizeHandler.init(K, E.watchResize), w.slidesHandler.init(K, E.watchSlides), c.add(r, "visibilitychange", () => {
      r.hidden && M.reset();
    }), w.options.loop && w.slideLooper.loop(), B.offsetParent && U.length && w.dragHandler.init(K, E.watchDrag), $ = o.init(_, K));
  }
  function L(fe, ye) {
    const $e = Y();
    R(), q(f({
      startIndex: $e
    }, fe), ye), l.emit("reInit");
  }
  function R() {
    w.dragHandler.destroy(), w.animation.stop(), w.eventStore.clear(), w.translate.clear(), w.slideLooper.clear(), w.resizeHandler.destroy(), w.slidesHandler.destroy(), o.destroy(), s.clear(), c.clear();
  }
  function A() {
    b || (b = !0, s.clear(), R(), l.emit("destroy"));
  }
  function F(fe) {
    const ye = w[fe ? "target" : "location"].get(), $e = E.loop ? "removeOffset" : "constrain";
    return w.slidesInView.check(w.limit[$e](ye));
  }
  function H(fe) {
    const ye = F(fe);
    return w.slideIndexes.filter(($e) => !ye.includes($e));
  }
  function V(fe, ye, $e) {
    !E.active || b || (w.scrollBody.useBaseFriction().useDuration(ye ? 0 : E.duration), w.scrollTo.index(fe, $e || 0));
  }
  function I(fe) {
    const ye = w.index.add(1).get();
    V(ye, fe === !0, -1);
  }
  function g(fe) {
    const ye = w.index.add(-1).get();
    V(ye, fe === !0, 1);
  }
  function j() {
    return w.index.add(1).get() !== Y();
  }
  function W() {
    return w.index.add(-1).get() !== Y();
  }
  function S() {
    return w.scrollSnaps.map(w.scrollProgress.get);
  }
  function Z() {
    return w.scrollProgress.get(w.location.get());
  }
  function Y() {
    return w.index.get();
  }
  function G() {
    return w.indexPrevious.get();
  }
  function X() {
    return $;
  }
  function ie() {
    return w;
  }
  function ae() {
    return e;
  }
  function J() {
    return B;
  }
  function Q() {
    return U;
  }
  const K = {
    canScrollNext: j,
    canScrollPrev: W,
    containerNode: J,
    internalEngine: ie,
    destroy: A,
    off: h,
    on: m,
    emit: y,
    plugins: X,
    previousScrollSnap: G,
    reInit: v,
    rootNode: ae,
    scrollNext: I,
    scrollPrev: g,
    scrollProgress: Z,
    scrollSnapList: S,
    scrollTo: V,
    selectedScrollSnap: Y,
    slideNodes: Q,
    slidesInView: F,
    slidesNotInView: H
  };
  return q(t, n), setTimeout(() => l.emit("init"), 0), K;
}
Ja.animationRealms = [];
Ja.globalOptions = void 0;
function $v(e = {}, t = []) {
  const n = Tt(e), r = Tt(t), [i, a] = He(), [o, s] = He(), c = ot(() => {
    i && i.reInit(n.current, r.current);
  }, [i]);
  return Pt(() => {
    if (vL() && o) {
      Ja.globalOptions = $v.globalOptions;
      const l = Ja(o, n.current, r.current);
      return a(l), () => l.destroy();
    } else
      a(void 0);
  }, [o, a]), Pt(() => {
    kv(n.current, e) || (n.current = e, c());
  }, [e, c]), Pt(() => {
    yL(r.current, t) || (r.current = t, c());
  }, [t, c]), [s, i];
}
$v.globalOptions = void 0;
function HL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M15.75 2.25H21a.75.75 0 0 1 .75.75v5.25a.75.75 0 0 1-1.5 0V4.81L8.03 17.03a.75.75 0 0 1-1.06-1.06L19.19 3.75h-3.44a.75.75 0 0 1 0-1.5Zm-10.5 4.5a1.5 1.5 0 0 0-1.5 1.5v10.5a1.5 1.5 0 0 0 1.5 1.5h10.5a1.5 1.5 0 0 0 1.5-1.5V10.5a.75.75 0 0 1 1.5 0v8.25a3 3 0 0 1-3 3H5.25a3 3 0 0 1-3-3V8.25a3 3 0 0 1 3-3h8.25a.75.75 0 0 1 0 1.5H5.25Z",
    clipRule: "evenodd"
  }));
}
const ZL = /* @__PURE__ */ x.forwardRef(HL);
function KL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M7.72 12.53a.75.75 0 0 1 0-1.06l7.5-7.5a.75.75 0 1 1 1.06 1.06L9.31 12l6.97 6.97a.75.75 0 1 1-1.06 1.06l-7.5-7.5Z",
    clipRule: "evenodd"
  }));
}
const GL = /* @__PURE__ */ x.forwardRef(KL);
function YL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z",
    clipRule: "evenodd"
  }));
}
const JL = /* @__PURE__ */ x.forwardRef(YL);
function XL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M10.5 3.75a6 6 0 0 0-5.98 6.496A5.25 5.25 0 0 0 6.75 20.25H18a4.5 4.5 0 0 0 2.206-8.423 3.75 3.75 0 0 0-4.133-4.303A6.001 6.001 0 0 0 10.5 3.75Zm2.03 5.47a.75.75 0 0 0-1.06 0l-3 3a.75.75 0 1 0 1.06 1.06l1.72-1.72v4.94a.75.75 0 0 0 1.5 0v-4.94l1.72 1.72a.75.75 0 1 0 1.06-1.06l-3-3Z",
    clipRule: "evenodd"
  }));
}
const QL = /* @__PURE__ */ x.forwardRef(XL);
function e5({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M5.625 1.5c-1.036 0-1.875.84-1.875 1.875v17.25c0 1.035.84 1.875 1.875 1.875h12.75c1.035 0 1.875-.84 1.875-1.875V12.75A3.75 3.75 0 0 0 16.5 9h-1.875a1.875 1.875 0 0 1-1.875-1.875V5.25A3.75 3.75 0 0 0 9 1.5H5.625ZM7.5 15a.75.75 0 0 1 .75-.75h7.5a.75.75 0 0 1 0 1.5h-7.5A.75.75 0 0 1 7.5 15Zm.75 2.25a.75.75 0 0 0 0 1.5H12a.75.75 0 0 0 0-1.5H8.25Z",
    clipRule: "evenodd"
  }), /* @__PURE__ */ x.createElement("path", {
    d: "M12.971 1.816A5.23 5.23 0 0 1 14.25 5.25v1.875c0 .207.168.375.375.375H16.5a5.23 5.23 0 0 1 3.434 1.279 9.768 9.768 0 0 0-6.963-6.963Z"
  }));
}
const t5 = /* @__PURE__ */ x.forwardRef(e5);
function n5({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    d: "M1.5 8.67v8.58a3 3 0 0 0 3 3h15a3 3 0 0 0 3-3V8.67l-8.928 5.493a3 3 0 0 1-3.144 0L1.5 8.67Z"
  }), /* @__PURE__ */ x.createElement("path", {
    d: "M22.5 6.908V6.75a3 3 0 0 0-3-3h-15a3 3 0 0 0-3 3v.158l9.714 5.978a1.5 1.5 0 0 0 1.572 0L22.5 6.908Z"
  }));
}
const r5 = /* @__PURE__ */ x.forwardRef(n5);
function i5({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    d: "M21.721 12.752a9.711 9.711 0 0 0-.945-5.003 12.754 12.754 0 0 1-4.339 2.708 18.991 18.991 0 0 1-.214 4.772 17.165 17.165 0 0 0 5.498-2.477ZM14.634 15.55a17.324 17.324 0 0 0 .332-4.647c-.952.227-1.945.347-2.966.347-1.021 0-2.014-.12-2.966-.347a17.515 17.515 0 0 0 .332 4.647 17.385 17.385 0 0 0 5.268 0ZM9.772 17.119a18.963 18.963 0 0 0 4.456 0A17.182 17.182 0 0 1 12 21.724a17.18 17.18 0 0 1-2.228-4.605ZM7.777 15.23a18.87 18.87 0 0 1-.214-4.774 12.753 12.753 0 0 1-4.34-2.708 9.711 9.711 0 0 0-.944 5.004 17.165 17.165 0 0 0 5.498 2.477ZM21.356 14.752a9.765 9.765 0 0 1-7.478 6.817 18.64 18.64 0 0 0 1.988-4.718 18.627 18.627 0 0 0 5.49-2.098ZM2.644 14.752c1.682.971 3.53 1.688 5.49 2.099a18.64 18.64 0 0 0 1.988 4.718 9.765 9.765 0 0 1-7.478-6.816ZM13.878 2.43a9.755 9.755 0 0 1 6.116 3.986 11.267 11.267 0 0 1-3.746 2.504 18.63 18.63 0 0 0-2.37-6.49ZM12 2.276a17.152 17.152 0 0 1 2.805 7.121c-.897.23-1.837.353-2.805.353-.968 0-1.908-.122-2.805-.353A17.151 17.151 0 0 1 12 2.276ZM10.122 2.43a18.629 18.629 0 0 0-2.37 6.49 11.266 11.266 0 0 1-3.746-2.504 9.754 9.754 0 0 1 6.116-3.985Z"
  }));
}
const a5 = /* @__PURE__ */ x.forwardRef(i5);
function o5({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M12 1.5a5.25 5.25 0 0 0-5.25 5.25v3a3 3 0 0 0-3 3v6.75a3 3 0 0 0 3 3h10.5a3 3 0 0 0 3-3v-6.75a3 3 0 0 0-3-3v-3c0-2.9-2.35-5.25-5.25-5.25Zm3.75 8.25v-3a3.75 3.75 0 1 0-7.5 0v3h7.5Z",
    clipRule: "evenodd"
  }));
}
const s5 = /* @__PURE__ */ x.forwardRef(o5);
function l5({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M1.5 4.5a3 3 0 0 1 3-3h1.372c.86 0 1.61.586 1.819 1.42l1.105 4.423a1.875 1.875 0 0 1-.694 1.955l-1.293.97c-.135.101-.164.249-.126.352a11.285 11.285 0 0 0 6.697 6.697c.103.038.25.009.352-.126l.97-1.293a1.875 1.875 0 0 1 1.955-.694l4.423 1.105c.834.209 1.42.959 1.42 1.82V19.5a3 3 0 0 1-3 3h-2.25C8.552 22.5 1.5 15.448 1.5 6.75V4.5Z",
    clipRule: "evenodd"
  }));
}
const c5 = /* @__PURE__ */ x.forwardRef(l5);
function u5({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M12 3.75a.75.75 0 0 1 .75.75v6.75h6.75a.75.75 0 0 1 0 1.5h-6.75v6.75a.75.75 0 0 1-1.5 0v-6.75H4.5a.75.75 0 0 1 0-1.5h6.75V4.5a.75.75 0 0 1 .75-.75Z",
    clipRule: "evenodd"
  }));
}
const f5 = /* @__PURE__ */ x.forwardRef(u5), G_ = An(
  ({ blocks: e, direction: t, sender: n, timestamp: r, metadata: i, sendMessage: a, messageId: o, isReadOnly: s }, c) => {
    const [l, u] = $v({ skipSnaps: !0, loop: !0 }), [f, d] = He(!0), [p, m] = He(!0), h = ot(() => u == null ? void 0 : u.scrollPrev(), [u]), y = ot(() => u == null ? void 0 : u.scrollNext(), [u]), {
      message: {
        blocks: { carousel: v }
      }
    } = ut, b = ot((w) => {
      d(!w.canScrollPrev()), m(!w.canScrollNext());
    }, []);
    return Pt(() => {
      u && (b(u), u.on("reInit", b), u.on("select", b));
    }, [u, b]), /* @__PURE__ */ O.jsxs("div", { ...v == null ? void 0 : v.container, "data-container": "carousel", ref: l, children: [
      /* @__PURE__ */ O.jsx("div", { ref: c, ...v == null ? void 0 : v.slidesContainer, children: e.map((w, T) => /* @__PURE__ */ O.jsx(
        dl,
        {
          block: { ...w, direction: t, timestamp: r, sender: n, messageId: o, sendMessage: a, isReadOnly: s },
          direction: t,
          sender: n,
          timestamp: r,
          metadata: i,
          sendMessage: a,
          messageId: o,
          isReadOnly: s
        },
        T
      )) }),
      e.length > 1 && /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
        /* @__PURE__ */ O.jsx(
          GL,
          {
            ...v == null ? void 0 : v.backButton,
            "data-disabled": f ? "" : void 0,
            onClick: h
          }
        ),
        /* @__PURE__ */ O.jsx(
          JL,
          {
            ...v == null ? void 0 : v.nextButton,
            "data-disabled": p ? "" : void 0,
            onClick: y
          }
        )
      ] })
    ] });
  }
);
G_.displayName = "Carousel";
const Zb = Math.floor;
function Y_(e) {
  return J_(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function sl(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function d5(e) {
  var t;
  return (t = (J_(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function J_(e) {
  return e instanceof Node || e instanceof sl(e).Node;
}
function Hn(e) {
  return e instanceof Element || e instanceof sl(e).Element;
}
function Xa(e) {
  return e instanceof HTMLElement || e instanceof sl(e).HTMLElement;
}
function Mh(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof sl(e).ShadowRoot;
}
function p5(e) {
  return ["html", "body", "#document"].includes(Y_(e));
}
function h5(e) {
  return sl(e).getComputedStyle(e);
}
function m5(e) {
  if (Y_(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Mh(e) && e.host || // Fallback.
    d5(e)
  );
  return Mh(t) ? t.host : t;
}
function mi(e) {
  let t = e.activeElement;
  for (; ((n = t) == null || (r = n.shadowRoot) == null ? void 0 : r.activeElement) != null; ) {
    var n, r;
    t = t.shadowRoot.activeElement;
  }
  return t;
}
function Cn(e, t) {
  if (!e || !t)
    return !1;
  const n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && Mh(n)) {
    let r = t;
    for (; r; ) {
      if (e === r)
        return !0;
      r = r.parentNode || r.host;
    }
  }
  return !1;
}
function X_() {
  const e = navigator.userAgentData;
  return e != null && e.platform ? e.platform : navigator.platform;
}
function v5() {
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? e.brands.map((t) => {
    let {
      brand: n,
      version: r
    } = t;
    return n + "/" + r;
  }).join(" ") : navigator.userAgent;
}
function Q_(e) {
  if (e.mozInputSource === 0 && e.isTrusted)
    return !0;
  const t = /Android/i;
  return (t.test(X_()) || t.test(v5())) && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType;
}
function ek(e) {
  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType !== "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  e.width < 1 && e.height < 1 && e.pressure === 0 && e.detail === 0;
}
function tk() {
  return /apple/i.test(navigator.vendor);
}
function y5() {
  return X_().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function Kb(e, t) {
  return ["mouse", "pen"].includes(e);
}
function g5(e) {
  return "nativeEvent" in e;
}
function b5(e) {
  return e.matches("html,body");
}
function ar(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function md(e, t) {
  if (t == null)
    return !1;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
function nk(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
const w5 = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function rk(e) {
  return Xa(e) && e.matches(w5);
}
function ln(e) {
  e.preventDefault(), e.stopPropagation();
}
const Qa = Math.min, Nn = Math.max, su = Math.round, Vl = Math.floor, Ci = (e) => ({
  x: e,
  y: e
});
function Gb(e, t, n) {
  return Nn(e, Qa(t, n));
}
function Qu(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ll(e) {
  return e.split("-")[0];
}
function Rv(e) {
  return e.split("-")[1];
}
function ik(e) {
  return e === "x" ? "y" : "x";
}
function x5(e) {
  return e === "y" ? "height" : "width";
}
function cl(e) {
  return ["top", "bottom"].includes(ll(e)) ? "y" : "x";
}
function S5(e) {
  return ik(cl(e));
}
function E5(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function _5(e) {
  return typeof e != "number" ? E5(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function lu(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: i
  } = e;
  return {
    width: r,
    height: i,
    top: n,
    left: t,
    right: t + r,
    bottom: n + i,
    x: t,
    y: n
  };
}
function Yb(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const a = cl(t), o = S5(t), s = x5(o), c = ll(t), l = a === "y", u = r.x + r.width / 2 - i.width / 2, f = r.y + r.height / 2 - i.height / 2, d = r[s] / 2 - i[s] / 2;
  let p;
  switch (c) {
    case "top":
      p = {
        x: u,
        y: r.y - i.height
      };
      break;
    case "bottom":
      p = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      p = {
        x: r.x + r.width,
        y: f
      };
      break;
    case "left":
      p = {
        x: r.x - i.width,
        y: f
      };
      break;
    default:
      p = {
        x: r.x,
        y: r.y
      };
  }
  switch (Rv(t)) {
    case "start":
      p[o] -= d * (n && l ? -1 : 1);
      break;
    case "end":
      p[o] += d * (n && l ? -1 : 1);
      break;
  }
  return p;
}
const k5 = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: a = [],
    platform: o
  } = n, s = a.filter(Boolean), c = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let l = await o.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: u,
    y: f
  } = Yb(l, r, c), d = r, p = {}, m = 0;
  for (let h = 0; h < s.length; h++) {
    const {
      name: y,
      fn: v
    } = s[h], {
      x: b,
      y: w,
      data: T,
      reset: E
    } = await v({
      x: u,
      y: f,
      initialPlacement: r,
      placement: d,
      strategy: i,
      middlewareData: p,
      rects: l,
      platform: o,
      elements: {
        reference: e,
        floating: t
      }
    });
    u = b ?? u, f = w ?? f, p = {
      ...p,
      [y]: {
        ...p[y],
        ...T
      }
    }, E && m <= 50 && (m++, typeof E == "object" && (E.placement && (d = E.placement), E.rects && (l = E.rects === !0 ? await o.getElementRects({
      reference: e,
      floating: t,
      strategy: i
    }) : E.rects), {
      x: u,
      y: f
    } = Yb(l, d, c)), h = -1);
  }
  return {
    x: u,
    y: f,
    placement: d,
    strategy: i,
    middlewareData: p
  };
};
async function ak(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: a,
    rects: o,
    elements: s,
    strategy: c
  } = e, {
    boundary: l = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: f = "floating",
    altBoundary: d = !1,
    padding: p = 0
  } = Qu(t, e), m = _5(p), y = s[d ? f === "floating" ? "reference" : "floating" : f], v = lu(await a.getClippingRect({
    element: (n = await (a.isElement == null ? void 0 : a.isElement(y))) == null || n ? y : y.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(s.floating)),
    boundary: l,
    rootBoundary: u,
    strategy: c
  })), b = f === "floating" ? {
    x: r,
    y: i,
    width: o.floating.width,
    height: o.floating.height
  } : o.reference, w = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(s.floating)), T = await (a.isElement == null ? void 0 : a.isElement(w)) ? await (a.getScale == null ? void 0 : a.getScale(w)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, E = lu(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: s,
    rect: b,
    offsetParent: w,
    strategy: c
  }) : b);
  return {
    top: (v.top - E.top + m.top) / T.y,
    bottom: (E.bottom - v.bottom + m.bottom) / T.y,
    left: (v.left - E.left + m.left) / T.x,
    right: (E.right - v.right + m.right) / T.x
  };
}
async function T5(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, a = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = ll(n), s = Rv(n), c = cl(n) === "y", l = ["left", "top"].includes(o) ? -1 : 1, u = a && c ? -1 : 1, f = Qu(t, e);
  let {
    mainAxis: d,
    crossAxis: p,
    alignmentAxis: m
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return s && typeof m == "number" && (p = s === "end" ? m * -1 : m), c ? {
    x: p * u,
    y: d * l
  } : {
    x: d * l,
    y: p * u
  };
}
const C5 = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: i,
        y: a,
        placement: o,
        middlewareData: s
      } = t, c = await T5(t, e);
      return o === ((n = s.offset) == null ? void 0 : n.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : {
        x: i + c.x,
        y: a + c.y,
        data: {
          ...c,
          placement: o
        }
      };
    }
  };
}, O5 = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i
      } = t, {
        mainAxis: a = !0,
        crossAxis: o = !1,
        limiter: s = {
          fn: (y) => {
            let {
              x: v,
              y: b
            } = y;
            return {
              x: v,
              y: b
            };
          }
        },
        ...c
      } = Qu(e, t), l = {
        x: n,
        y: r
      }, u = await ak(t, c), f = cl(ll(i)), d = ik(f);
      let p = l[d], m = l[f];
      if (a) {
        const y = d === "y" ? "top" : "left", v = d === "y" ? "bottom" : "right", b = p + u[y], w = p - u[v];
        p = Gb(b, p, w);
      }
      if (o) {
        const y = f === "y" ? "top" : "left", v = f === "y" ? "bottom" : "right", b = m + u[y], w = m - u[v];
        m = Gb(b, m, w);
      }
      const h = s.fn({
        ...t,
        [d]: p,
        [f]: m
      });
      return {
        ...h,
        data: {
          x: h.x - n,
          y: h.y - r,
          enabled: {
            [d]: a,
            [f]: o
          }
        }
      };
    }
  };
}, $5 = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: i,
        rects: a,
        platform: o,
        elements: s
      } = t, {
        apply: c = () => {
        },
        ...l
      } = Qu(e, t), u = await ak(t, l), f = ll(i), d = Rv(i), p = cl(i) === "y", {
        width: m,
        height: h
      } = a.floating;
      let y, v;
      f === "top" || f === "bottom" ? (y = f, v = d === (await (o.isRTL == null ? void 0 : o.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (v = f, y = d === "end" ? "top" : "bottom");
      const b = h - u.top - u.bottom, w = m - u.left - u.right, T = Qa(h - u[y], b), E = Qa(m - u[v], w), _ = !t.middlewareData.shift;
      let $ = T, B = E;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (B = w), (r = t.middlewareData.shift) != null && r.enabled.y && ($ = b), _ && !d) {
        const k = Nn(u.left, 0), D = Nn(u.right, 0), q = Nn(u.top, 0), L = Nn(u.bottom, 0);
        p ? B = m - 2 * (k !== 0 || D !== 0 ? k + D : Nn(u.left, u.right)) : $ = h - 2 * (q !== 0 || L !== 0 ? q + L : Nn(u.top, u.bottom));
      }
      await c({
        ...t,
        availableWidth: B,
        availableHeight: $
      });
      const U = await o.getDimensions(s.floating);
      return m !== U.width || h !== U.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function ef() {
  return typeof window < "u";
}
function xo(e) {
  return ok(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Mn(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Lr(e) {
  var t;
  return (t = (ok(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function ok(e) {
  return ef() ? e instanceof Node || e instanceof Mn(e).Node : !1;
}
function dr(e) {
  return ef() ? e instanceof Element || e instanceof Mn(e).Element : !1;
}
function jr(e) {
  return ef() ? e instanceof HTMLElement || e instanceof Mn(e).HTMLElement : !1;
}
function Jb(e) {
  return !ef() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Mn(e).ShadowRoot;
}
function ul(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = pr(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function R5(e) {
  return ["table", "td", "th"].includes(xo(e));
}
function tf(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Iv(e) {
  const t = Av(), n = dr(e) ? pr(e) : e;
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function I5(e) {
  let t = Oi(e);
  for (; jr(t) && !eo(t); ) {
    if (Iv(t))
      return t;
    if (tf(t))
      return null;
    t = Oi(t);
  }
  return null;
}
function Av() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function eo(e) {
  return ["html", "body", "#document"].includes(xo(e));
}
function pr(e) {
  return Mn(e).getComputedStyle(e);
}
function nf(e) {
  return dr(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Oi(e) {
  if (xo(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Jb(e) && e.host || // Fallback.
    Lr(e)
  );
  return Jb(t) ? t.host : t;
}
function sk(e) {
  const t = Oi(e);
  return eo(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : jr(t) && ul(t) ? t : sk(t);
}
function bi(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = sk(e), a = i === ((r = e.ownerDocument) == null ? void 0 : r.body), o = Mn(i);
  if (a) {
    const s = Fh(o);
    return t.concat(o, o.visualViewport || [], ul(i) ? i : [], s && n ? bi(s) : []);
  }
  return t.concat(i, bi(i, [], n));
}
function Fh(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function lk(e) {
  const t = pr(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = jr(e), a = i ? e.offsetWidth : n, o = i ? e.offsetHeight : r, s = su(n) !== a || su(r) !== o;
  return s && (n = a, r = o), {
    width: n,
    height: r,
    $: s
  };
}
function Pv(e) {
  return dr(e) ? e : e.contextElement;
}
function Ba(e) {
  const t = Pv(e);
  if (!jr(t))
    return Ci(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: a
  } = lk(t);
  let o = (a ? su(n.width) : n.width) / r, s = (a ? su(n.height) : n.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: o,
    y: s
  };
}
const A5 = /* @__PURE__ */ Ci(0);
function ck(e) {
  const t = Mn(e);
  return !Av() || !t.visualViewport ? A5 : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function P5(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Mn(e) ? !1 : t;
}
function ta(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), a = Pv(e);
  let o = Ci(1);
  t && (r ? dr(r) && (o = Ba(r)) : o = Ba(e));
  const s = P5(a, n, r) ? ck(a) : Ci(0);
  let c = (i.left + s.x) / o.x, l = (i.top + s.y) / o.y, u = i.width / o.x, f = i.height / o.y;
  if (a) {
    const d = Mn(a), p = r && dr(r) ? Mn(r) : r;
    let m = d, h = Fh(m);
    for (; h && r && p !== m; ) {
      const y = Ba(h), v = h.getBoundingClientRect(), b = pr(h), w = v.left + (h.clientLeft + parseFloat(b.paddingLeft)) * y.x, T = v.top + (h.clientTop + parseFloat(b.paddingTop)) * y.y;
      c *= y.x, l *= y.y, u *= y.x, f *= y.y, c += w, l += T, m = Mn(h), h = Fh(m);
    }
  }
  return lu({
    width: u,
    height: f,
    x: c,
    y: l
  });
}
function D5(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: i
  } = e;
  const a = i === "fixed", o = Lr(r), s = t ? tf(t.floating) : !1;
  if (r === o || s && a)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = Ci(1);
  const u = Ci(0), f = jr(r);
  if ((f || !f && !a) && ((xo(r) !== "body" || ul(o)) && (c = nf(r)), jr(r))) {
    const d = ta(r);
    l = Ba(r), u.x = d.x + r.clientLeft, u.y = d.y + r.clientTop;
  }
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - c.scrollLeft * l.x + u.x,
    y: n.y * l.y - c.scrollTop * l.y + u.y
  };
}
function j5(e) {
  return Array.from(e.getClientRects());
}
function Lh(e, t) {
  const n = nf(e).scrollLeft;
  return t ? t.left + n : ta(Lr(e)).left + n;
}
function N5(e) {
  const t = Lr(e), n = nf(e), r = e.ownerDocument.body, i = Nn(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), a = Nn(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -n.scrollLeft + Lh(e);
  const s = -n.scrollTop;
  return pr(r).direction === "rtl" && (o += Nn(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: a,
    x: o,
    y: s
  };
}
function M5(e, t) {
  const n = Mn(e), r = Lr(e), i = n.visualViewport;
  let a = r.clientWidth, o = r.clientHeight, s = 0, c = 0;
  if (i) {
    a = i.width, o = i.height;
    const l = Av();
    (!l || l && t === "fixed") && (s = i.offsetLeft, c = i.offsetTop);
  }
  return {
    width: a,
    height: o,
    x: s,
    y: c
  };
}
function F5(e, t) {
  const n = ta(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, a = jr(e) ? Ba(e) : Ci(1), o = e.clientWidth * a.x, s = e.clientHeight * a.y, c = i * a.x, l = r * a.y;
  return {
    width: o,
    height: s,
    x: c,
    y: l
  };
}
function Xb(e, t, n) {
  let r;
  if (t === "viewport")
    r = M5(e, n);
  else if (t === "document")
    r = N5(Lr(e));
  else if (dr(t))
    r = F5(t, n);
  else {
    const i = ck(e);
    r = {
      ...t,
      x: t.x - i.x,
      y: t.y - i.y
    };
  }
  return lu(r);
}
function uk(e, t) {
  const n = Oi(e);
  return n === t || !dr(n) || eo(n) ? !1 : pr(n).position === "fixed" || uk(n, t);
}
function L5(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = bi(e, [], !1).filter((s) => dr(s) && xo(s) !== "body"), i = null;
  const a = pr(e).position === "fixed";
  let o = a ? Oi(e) : e;
  for (; dr(o) && !eo(o); ) {
    const s = pr(o), c = Iv(o);
    !c && s.position === "fixed" && (i = null), (a ? !c && !i : !c && s.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || ul(o) && !c && uk(e, o)) ? r = r.filter((u) => u !== o) : i = s, o = Oi(o);
  }
  return t.set(e, r), r;
}
function B5(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const o = [...n === "clippingAncestors" ? tf(t) ? [] : L5(t, this._c) : [].concat(n), r], s = o[0], c = o.reduce((l, u) => {
    const f = Xb(t, u, i);
    return l.top = Nn(f.top, l.top), l.right = Qa(f.right, l.right), l.bottom = Qa(f.bottom, l.bottom), l.left = Nn(f.left, l.left), l;
  }, Xb(t, s, i));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function U5(e) {
  const {
    width: t,
    height: n
  } = lk(e);
  return {
    width: t,
    height: n
  };
}
function z5(e, t, n) {
  const r = jr(t), i = Lr(t), a = n === "fixed", o = ta(e, !0, a, t);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = Ci(0);
  if (r || !r && !a)
    if ((xo(t) !== "body" || ul(i)) && (s = nf(t)), r) {
      const p = ta(t, !0, a, t);
      c.x = p.x + t.clientLeft, c.y = p.y + t.clientTop;
    } else i && (c.x = Lh(i));
  let l = 0, u = 0;
  if (i && !r && !a) {
    const p = i.getBoundingClientRect();
    u = p.top + s.scrollTop, l = p.left + s.scrollLeft - // RTL <body> scrollbar.
    Lh(i, p);
  }
  const f = o.left + s.scrollLeft - c.x - l, d = o.top + s.scrollTop - c.y - u;
  return {
    x: f,
    y: d,
    width: o.width,
    height: o.height
  };
}
function vd(e) {
  return pr(e).position === "static";
}
function Qb(e, t) {
  if (!jr(e) || pr(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Lr(e) === n && (n = n.ownerDocument.body), n;
}
function fk(e, t) {
  const n = Mn(e);
  if (tf(e))
    return n;
  if (!jr(e)) {
    let i = Oi(e);
    for (; i && !eo(i); ) {
      if (dr(i) && !vd(i))
        return i;
      i = Oi(i);
    }
    return n;
  }
  let r = Qb(e, t);
  for (; r && R5(r) && vd(r); )
    r = Qb(r, t);
  return r && eo(r) && vd(r) && !Iv(r) ? n : r || I5(e) || n;
}
const q5 = async function(e) {
  const t = this.getOffsetParent || fk, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: z5(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function W5(e) {
  return pr(e).direction === "rtl";
}
const V5 = {
  convertOffsetParentRelativeRectToViewportRelativeRect: D5,
  getDocumentElement: Lr,
  getClippingRect: B5,
  getOffsetParent: fk,
  getElementRects: q5,
  getClientRects: j5,
  getDimensions: U5,
  getScale: Ba,
  isElement: dr,
  isRTL: W5
};
function H5(e, t) {
  let n = null, r;
  const i = Lr(e);
  function a() {
    var s;
    clearTimeout(r), (s = n) == null || s.disconnect(), n = null;
  }
  function o(s, c) {
    s === void 0 && (s = !1), c === void 0 && (c = 1), a();
    const {
      left: l,
      top: u,
      width: f,
      height: d
    } = e.getBoundingClientRect();
    if (s || t(), !f || !d)
      return;
    const p = Vl(u), m = Vl(i.clientWidth - (l + f)), h = Vl(i.clientHeight - (u + d)), y = Vl(l), b = {
      rootMargin: -p + "px " + -m + "px " + -h + "px " + -y + "px",
      threshold: Nn(0, Qa(1, c)) || 1
    };
    let w = !0;
    function T(E) {
      const _ = E[0].intersectionRatio;
      if (_ !== c) {
        if (!w)
          return o();
        _ ? o(!1, _) : r = setTimeout(() => {
          o(!1, 1e-7);
        }, 1e3);
      }
      w = !1;
    }
    try {
      n = new IntersectionObserver(T, {
        ...b,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(T, b);
    }
    n.observe(e);
  }
  return o(!0), a;
}
function Z5(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: a = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = r, l = Pv(e), u = i || a ? [...l ? bi(l) : [], ...bi(t)] : [];
  u.forEach((v) => {
    i && v.addEventListener("scroll", n, {
      passive: !0
    }), a && v.addEventListener("resize", n);
  });
  const f = l && s ? H5(l, n) : null;
  let d = -1, p = null;
  o && (p = new ResizeObserver((v) => {
    let [b] = v;
    b && b.target === l && p && (p.unobserve(t), cancelAnimationFrame(d), d = requestAnimationFrame(() => {
      var w;
      (w = p) == null || w.observe(t);
    })), n();
  }), l && !c && p.observe(l), p.observe(t));
  let m, h = c ? ta(e) : null;
  c && y();
  function y() {
    const v = ta(e);
    h && (v.x !== h.x || v.y !== h.y || v.width !== h.width || v.height !== h.height) && n(), h = v, m = requestAnimationFrame(y);
  }
  return n(), () => {
    var v;
    u.forEach((b) => {
      i && b.removeEventListener("scroll", n), a && b.removeEventListener("resize", n);
    }), f == null || f(), (v = p) == null || v.disconnect(), p = null, c && cancelAnimationFrame(m);
  };
}
const K5 = C5, G5 = O5, Y5 = $5, J5 = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: V5,
    ...n
  }, a = {
    ...i.platform,
    _c: r
  };
  return k5(e, t, {
    ...i,
    platform: a
  });
};
var Tc = typeof document < "u" ? mo : Pt;
function cu(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!cu(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const a = i[r];
      if (!(a === "_owner" && e.$$typeof) && !cu(e[a], t[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function dk(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function ew(e, t) {
  const n = dk(e);
  return Math.round(t * n) / n;
}
function yd(e) {
  const t = x.useRef(e);
  return Tc(() => {
    t.current = e;
  }), t;
}
function X5(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: a,
      floating: o
    } = {},
    transform: s = !0,
    whileElementsMounted: c,
    open: l
  } = e, [u, f] = x.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [d, p] = x.useState(r);
  cu(d, r) || p(r);
  const [m, h] = x.useState(null), [y, v] = x.useState(null), b = x.useCallback((V) => {
    V !== _.current && (_.current = V, h(V));
  }, []), w = x.useCallback((V) => {
    V !== $.current && ($.current = V, v(V));
  }, []), T = a || m, E = o || y, _ = x.useRef(null), $ = x.useRef(null), B = x.useRef(u), U = c != null, k = yd(c), D = yd(i), q = yd(l), L = x.useCallback(() => {
    if (!_.current || !$.current)
      return;
    const V = {
      placement: t,
      strategy: n,
      middleware: d
    };
    D.current && (V.platform = D.current), J5(_.current, $.current, V).then((I) => {
      const g = {
        ...I,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: q.current !== !1
      };
      R.current && !cu(B.current, g) && (B.current = g, MS.flushSync(() => {
        f(g);
      }));
    });
  }, [d, t, n, D, q]);
  Tc(() => {
    l === !1 && B.current.isPositioned && (B.current.isPositioned = !1, f((V) => ({
      ...V,
      isPositioned: !1
    })));
  }, [l]);
  const R = x.useRef(!1);
  Tc(() => (R.current = !0, () => {
    R.current = !1;
  }), []), Tc(() => {
    if (T && (_.current = T), E && ($.current = E), T && E) {
      if (k.current)
        return k.current(T, E, L);
      L();
    }
  }, [T, E, L, k, U]);
  const A = x.useMemo(() => ({
    reference: _,
    floating: $,
    setReference: b,
    setFloating: w
  }), [b, w]), F = x.useMemo(() => ({
    reference: T,
    floating: E
  }), [T, E]), H = x.useMemo(() => {
    const V = {
      position: n,
      left: 0,
      top: 0
    };
    if (!F.floating)
      return V;
    const I = ew(F.floating, u.x), g = ew(F.floating, u.y);
    return s ? {
      ...V,
      transform: "translate(" + I + "px, " + g + "px)",
      ...dk(F.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: I,
      top: g
    };
  }, [n, s, F.floating, u.x, u.y]);
  return x.useMemo(() => ({
    ...u,
    update: L,
    refs: A,
    elements: F,
    floatingStyles: H
  }), [u, L, A, F, H]);
}
const Q5 = (e, t) => ({
  ...K5(e),
  options: [e, t]
}), e4 = (e, t) => ({
  ...G5(e),
  options: [e, t]
}), t4 = (e, t) => ({
  ...Y5(e),
  options: [e, t]
});
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var n4 = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], Bh = /* @__PURE__ */ n4.join(","), pk = typeof Element > "u", Rs = pk ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, uu = !pk && Element.prototype.getRootNode ? function(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
} : function(e) {
  return e == null ? void 0 : e.ownerDocument;
}, fu = function e(t, n) {
  var r;
  n === void 0 && (n = !0);
  var i = t == null || (r = t.getAttribute) === null || r === void 0 ? void 0 : r.call(t, "inert"), a = i === "" || i === "true", o = a || n && t && e(t.parentNode);
  return o;
}, r4 = function(t) {
  var n, r = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "contenteditable");
  return r === "" || r === "true";
}, i4 = function(t, n, r) {
  if (fu(t))
    return [];
  var i = Array.prototype.slice.apply(t.querySelectorAll(Bh));
  return n && Rs.call(t, Bh) && i.unshift(t), i = i.filter(r), i;
}, a4 = function e(t, n, r) {
  for (var i = [], a = Array.from(t); a.length; ) {
    var o = a.shift();
    if (!fu(o, !1))
      if (o.tagName === "SLOT") {
        var s = o.assignedElements(), c = s.length ? s : o.children, l = e(c, !0, r);
        r.flatten ? i.push.apply(i, l) : i.push({
          scopeParent: o,
          candidates: l
        });
      } else {
        var u = Rs.call(o, Bh);
        u && r.filter(o) && (n || !t.includes(o)) && i.push(o);
        var f = o.shadowRoot || // check for an undisclosed shadow
        typeof r.getShadowRoot == "function" && r.getShadowRoot(o), d = !fu(f, !1) && (!r.shadowRootFilter || r.shadowRootFilter(o));
        if (f && d) {
          var p = e(f === !0 ? o.children : f.children, !0, r);
          r.flatten ? i.push.apply(i, p) : i.push({
            scopeParent: o,
            candidates: p
          });
        } else
          a.unshift.apply(a, o.children);
      }
  }
  return i;
}, hk = function(t) {
  return !isNaN(parseInt(t.getAttribute("tabindex"), 10));
}, mk = function(t) {
  if (!t)
    throw new Error("No node provided");
  return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || r4(t)) && !hk(t) ? 0 : t.tabIndex;
}, o4 = function(t, n) {
  var r = mk(t);
  return r < 0 && n && !hk(t) ? 0 : r;
}, s4 = function(t, n) {
  return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex;
}, vk = function(t) {
  return t.tagName === "INPUT";
}, l4 = function(t) {
  return vk(t) && t.type === "hidden";
}, c4 = function(t) {
  var n = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(r) {
    return r.tagName === "SUMMARY";
  });
  return n;
}, u4 = function(t, n) {
  for (var r = 0; r < t.length; r++)
    if (t[r].checked && t[r].form === n)
      return t[r];
}, f4 = function(t) {
  if (!t.name)
    return !0;
  var n = t.form || uu(t), r = function(s) {
    return n.querySelectorAll('input[type="radio"][name="' + s + '"]');
  }, i;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    i = r(window.CSS.escape(t.name));
  else
    try {
      i = r(t.name);
    } catch (o) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", o.message), !1;
    }
  var a = u4(i, t.form);
  return !a || a === t;
}, d4 = function(t) {
  return vk(t) && t.type === "radio";
}, p4 = function(t) {
  return d4(t) && !f4(t);
}, h4 = function(t) {
  var n, r = t && uu(t), i = (n = r) === null || n === void 0 ? void 0 : n.host, a = !1;
  if (r && r !== t) {
    var o, s, c;
    for (a = !!((o = i) !== null && o !== void 0 && (s = o.ownerDocument) !== null && s !== void 0 && s.contains(i) || t != null && (c = t.ownerDocument) !== null && c !== void 0 && c.contains(t)); !a && i; ) {
      var l, u, f;
      r = uu(i), i = (l = r) === null || l === void 0 ? void 0 : l.host, a = !!((u = i) !== null && u !== void 0 && (f = u.ownerDocument) !== null && f !== void 0 && f.contains(i));
    }
  }
  return a;
}, tw = function(t) {
  var n = t.getBoundingClientRect(), r = n.width, i = n.height;
  return r === 0 && i === 0;
}, m4 = function(t, n) {
  var r = n.displayCheck, i = n.getShadowRoot;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  var a = Rs.call(t, "details>summary:first-of-type"), o = a ? t.parentElement : t;
  if (Rs.call(o, "details:not([open]) *"))
    return !0;
  if (!r || r === "full" || r === "legacy-full") {
    if (typeof i == "function") {
      for (var s = t; t; ) {
        var c = t.parentElement, l = uu(t);
        if (c && !c.shadowRoot && i(c) === !0)
          return tw(t);
        t.assignedSlot ? t = t.assignedSlot : !c && l !== t.ownerDocument ? t = l.host : t = c;
      }
      t = s;
    }
    if (h4(t))
      return !t.getClientRects().length;
    if (r !== "legacy-full")
      return !0;
  } else if (r === "non-zero-area")
    return tw(t);
  return !1;
}, v4 = function(t) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
    for (var n = t.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var r = 0; r < n.children.length; r++) {
          var i = n.children.item(r);
          if (i.tagName === "LEGEND")
            return Rs.call(n, "fieldset[disabled] *") ? !0 : !i.contains(t);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, y4 = function(t, n) {
  return !(n.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  fu(n) || l4(n) || m4(n, t) || // For a details element with a summary, the summary element gets the focus
  c4(n) || v4(n));
}, nw = function(t, n) {
  return !(p4(n) || mk(n) < 0 || !y4(t, n));
}, g4 = function(t) {
  var n = parseInt(t.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, b4 = function e(t) {
  var n = [], r = [];
  return t.forEach(function(i, a) {
    var o = !!i.scopeParent, s = o ? i.scopeParent : i, c = o4(s, o), l = o ? e(i.candidates) : s;
    c === 0 ? o ? n.push.apply(n, l) : n.push(s) : r.push({
      documentOrder: a,
      tabIndex: c,
      item: i,
      isScope: o,
      content: l
    });
  }), r.sort(s4).reduce(function(i, a) {
    return a.isScope ? i.push.apply(i, a.content) : i.push(a.content), i;
  }, []).concat(n);
}, Dv = function(t, n) {
  n = n || {};
  var r;
  return n.getShadowRoot ? r = a4([t], n.includeContainer, {
    filter: nw.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: g4
  }) : r = i4(t, n.includeContainer, nw.bind(null, n)), b4(r);
};
const jv = "ArrowUp", rf = "ArrowDown", to = "ArrowLeft", fl = "ArrowRight";
function Hl(e, t, n) {
  return Math.floor(e / t) !== n;
}
function is(e, t) {
  return t < 0 || t >= e.current.length;
}
function gd(e, t) {
  return pn(e, {
    disabledIndices: t
  });
}
function rw(e, t) {
  return pn(e, {
    decrement: !0,
    startingIndex: e.current.length,
    disabledIndices: t
  });
}
function pn(e, t) {
  let {
    startingIndex: n = -1,
    decrement: r = !1,
    disabledIndices: i,
    amount: a = 1
  } = t === void 0 ? {} : t;
  const o = e.current;
  let s = n;
  do {
    var c, l;
    s = s + (r ? -a : a);
  } while (s >= 0 && s <= o.length - 1 && (i ? i.includes(s) : o[s] == null || (c = o[s]) != null && c.hasAttribute("disabled") || ((l = o[s]) == null ? void 0 : l.getAttribute("aria-disabled")) === "true"));
  return s;
}
function w4(e, t) {
  let {
    event: n,
    orientation: r,
    loop: i,
    cols: a,
    disabledIndices: o,
    minIndex: s,
    maxIndex: c,
    prevIndex: l,
    stopEvent: u = !1
  } = t, f = l;
  if (n.key === jv) {
    if (u && ln(n), l === -1)
      f = c;
    else if (f = pn(e, {
      startingIndex: f,
      amount: a,
      decrement: !0,
      disabledIndices: o
    }), i && (l - a < s || f < 0)) {
      const d = l % a, p = c % a, m = c - (p - d);
      p === d ? f = c : f = p > d ? m : m - a;
    }
    is(e, f) && (f = l);
  }
  if (n.key === rf && (u && ln(n), l === -1 ? f = s : (f = pn(e, {
    startingIndex: l,
    amount: a,
    disabledIndices: o
  }), i && l + a > c && (f = pn(e, {
    startingIndex: l % a - a,
    amount: a,
    disabledIndices: o
  }))), is(e, f) && (f = l)), r === "both") {
    const d = Zb(l / a);
    n.key === fl && (u && ln(n), l % a !== a - 1 ? (f = pn(e, {
      startingIndex: l,
      disabledIndices: o
    }), i && Hl(f, a, d) && (f = pn(e, {
      startingIndex: l - l % a - 1,
      disabledIndices: o
    }))) : i && (f = pn(e, {
      startingIndex: l - l % a - 1,
      disabledIndices: o
    })), Hl(f, a, d) && (f = l)), n.key === to && (u && ln(n), l % a !== 0 ? (f = pn(e, {
      startingIndex: l,
      disabledIndices: o,
      decrement: !0
    }), i && Hl(f, a, d) && (f = pn(e, {
      startingIndex: l + (a - l % a),
      decrement: !0,
      disabledIndices: o
    }))) : i && (f = pn(e, {
      startingIndex: l + (a - l % a),
      decrement: !0,
      disabledIndices: o
    })), Hl(f, a, d) && (f = l));
    const p = Zb(c / a) === d;
    is(e, f) && (i && p ? f = n.key === to ? c : pn(e, {
      startingIndex: l - l % a - 1,
      disabledIndices: o
    }) : f = l);
  }
  return f;
}
let iw = 0;
function Kr(e, t) {
  t === void 0 && (t = {});
  const {
    preventScroll: n = !1,
    cancelPrevious: r = !0,
    sync: i = !1
  } = t;
  r && cancelAnimationFrame(iw);
  const a = () => e == null ? void 0 : e.focus({
    preventScroll: n
  });
  i ? a() : iw = requestAnimationFrame(a);
}
var Xt = typeof document < "u" ? mo : Pt;
function du() {
  return du = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, du.apply(this, arguments);
}
let bd = !1, x4 = 0;
const aw = () => "floating-ui-" + x4++;
function S4() {
  const [e, t] = x.useState(() => bd ? aw() : void 0);
  return Xt(() => {
    e == null && t(aw());
  }, []), x.useEffect(() => {
    bd || (bd = !0);
  }, []), e;
}
const E4 = x.useId, Nv = E4 || S4;
function _4() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, n) {
      var r;
      (r = e.get(t)) == null || r.forEach((i) => i(n));
    },
    on(t, n) {
      e.set(t, [...e.get(t) || [], n]);
    },
    off(t, n) {
      var r;
      e.set(t, ((r = e.get(t)) == null ? void 0 : r.filter((i) => i !== n)) || []);
    }
  };
}
const k4 = /* @__PURE__ */ x.createContext(null), T4 = /* @__PURE__ */ x.createContext(null), yk = () => {
  var e;
  return ((e = x.useContext(k4)) == null ? void 0 : e.id) || null;
}, af = () => x.useContext(T4);
function Is(e) {
  return "data-floating-ui-" + e;
}
function wi(e) {
  const t = Tt(e);
  return Xt(() => {
    t.current = e;
  }), t;
}
function C4(e, t) {
  var n;
  let r = [], i = (n = e.find((a) => a.id === t)) == null ? void 0 : n.parentId;
  for (; i; ) {
    const a = e.find((o) => o.id === i);
    i = a == null ? void 0 : a.parentId, a && (r = r.concat(a));
  }
  return r;
}
function Ua(e, t) {
  let n = e.filter((i) => {
    var a;
    return i.parentId === t && ((a = i.context) == null ? void 0 : a.open);
  }), r = n;
  for (; r.length; )
    r = e.filter((i) => {
      var a;
      return (a = r) == null ? void 0 : a.some((o) => {
        var s;
        return i.parentId === o.id && ((s = i.context) == null ? void 0 : s.open);
      });
    }), n = n.concat(r);
  return n;
}
function O4(e, t) {
  let n, r = -1;
  function i(a, o) {
    o > r && (n = a, r = o), Ua(e, a).forEach((c) => {
      i(c.id, o + 1);
    });
  }
  return i(t, 0), e.find((a) => a.id === n);
}
let va = /* @__PURE__ */ new WeakMap(), Zl = /* @__PURE__ */ new WeakSet(), Kl = {}, wd = 0;
const $4 = () => typeof HTMLElement < "u" && "inert" in HTMLElement.prototype, gk = (e) => e && (e.host || gk(e.parentNode)), R4 = (e, t) => t.map((n) => {
  if (e.contains(n))
    return n;
  const r = gk(n);
  return e.contains(r) ? r : null;
}).filter((n) => n != null);
function I4(e, t, n, r) {
  const i = "data-floating-ui-inert", a = r ? "inert" : n ? "aria-hidden" : null, o = R4(t, e), s = /* @__PURE__ */ new Set(), c = new Set(o), l = [];
  Kl[i] || (Kl[i] = /* @__PURE__ */ new WeakMap());
  const u = Kl[i];
  o.forEach(f), d(t), s.clear();
  function f(p) {
    !p || s.has(p) || (s.add(p), p.parentNode && f(p.parentNode));
  }
  function d(p) {
    !p || c.has(p) || Array.prototype.forEach.call(p.children, (m) => {
      if (s.has(m))
        d(m);
      else {
        const h = a ? m.getAttribute(a) : null, y = h !== null && h !== "false", v = (va.get(m) || 0) + 1, b = (u.get(m) || 0) + 1;
        va.set(m, v), u.set(m, b), l.push(m), v === 1 && y && Zl.add(m), b === 1 && m.setAttribute(i, ""), !y && a && m.setAttribute(a, "true");
      }
    });
  }
  return wd++, () => {
    l.forEach((p) => {
      const m = (va.get(p) || 0) - 1, h = (u.get(p) || 0) - 1;
      va.set(p, m), u.set(p, h), m || (!Zl.has(p) && a && p.removeAttribute(a), Zl.delete(p)), h || p.removeAttribute(i);
    }), wd--, wd || (va = /* @__PURE__ */ new WeakMap(), va = /* @__PURE__ */ new WeakMap(), Zl = /* @__PURE__ */ new WeakSet(), Kl = {});
  };
}
function ow(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = ar(e[0]).body;
  return I4(e.concat(Array.from(r.querySelectorAll("[aria-live]"))), r, t, n);
}
const Mv = () => ({
  getShadowRoot: !0,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function bk(e, t) {
  const n = Dv(e, Mv());
  t === "prev" && n.reverse();
  const r = n.indexOf(mi(ar(e)));
  return n.slice(r + 1)[0];
}
function wk() {
  return bk(document.body, "next");
}
function xk() {
  return bk(document.body, "prev");
}
function as(e, t) {
  const n = t || e.currentTarget, r = e.relatedTarget;
  return !r || !Cn(n, r);
}
function A4(e) {
  Dv(e, Mv()).forEach((n) => {
    n.dataset.tabindex = n.getAttribute("tabindex") || "", n.setAttribute("tabindex", "-1");
  });
}
function P4(e) {
  e.querySelectorAll("[data-tabindex]").forEach((n) => {
    const r = n.dataset.tabindex;
    delete n.dataset.tabindex, r ? n.setAttribute("tabindex", r) : n.removeAttribute("tabindex");
  });
}
const Fv = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
let D4;
function sw(e) {
  e.key === "Tab" && (e.target, clearTimeout(D4));
}
const pu = /* @__PURE__ */ x.forwardRef(function(t, n) {
  const [r, i] = x.useState();
  Xt(() => (tk() && i("button"), document.addEventListener("keydown", sw), () => {
    document.removeEventListener("keydown", sw);
  }), []);
  const a = {
    ref: n,
    tabIndex: 0,
    // Role is only for VoiceOver
    role: r,
    "aria-hidden": r ? void 0 : !0,
    [Is("focus-guard")]: "",
    style: Fv
  };
  return /* @__PURE__ */ x.createElement("span", du({}, t, a));
}), Sk = /* @__PURE__ */ x.createContext(null);
function j4(e) {
  let {
    id: t,
    root: n
  } = e === void 0 ? {} : e;
  const [r, i] = x.useState(null), a = Nv(), o = Ek(), s = x.useMemo(() => ({
    id: t,
    root: n,
    portalContext: o,
    uniqueId: a
  }), [t, n, o, a]), c = x.useRef();
  return Xt(() => () => {
    r == null || r.remove();
  }, [r, s]), Xt(() => {
    if (c.current === s) return;
    c.current = s;
    const {
      id: l,
      root: u,
      portalContext: f,
      uniqueId: d
    } = s, p = l ? document.getElementById(l) : null, m = Is("portal");
    if (p) {
      const h = document.createElement("div");
      h.id = d, h.setAttribute(m, ""), p.appendChild(h), i(h);
    } else {
      let h = u || (f == null ? void 0 : f.portalNode);
      h && !Hn(h) && (h = h.current), h = h || document.body;
      let y = null;
      l && (y = document.createElement("div"), y.id = l, h.appendChild(y));
      const v = document.createElement("div");
      v.id = d, v.setAttribute(m, ""), h = y || h, h.appendChild(v), i(v);
    }
  }, [s]), r;
}
function N4(e) {
  let {
    children: t,
    id: n,
    root: r = null,
    preserveTabOrder: i = !0
  } = e;
  const a = j4({
    id: n,
    root: r
  }), [o, s] = x.useState(null), c = x.useRef(null), l = x.useRef(null), u = x.useRef(null), f = x.useRef(null), d = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!o && // Guards are only for non-modal focus management.
    !o.modal && // Don't render if unmount is transitioning.
    o.open && i && !!(r || a)
  );
  return x.useEffect(() => {
    if (!a || !i || o != null && o.modal)
      return;
    function p(m) {
      a && as(m) && (m.type === "focusin" ? P4 : A4)(a);
    }
    return a.addEventListener("focusin", p, !0), a.addEventListener("focusout", p, !0), () => {
      a.removeEventListener("focusin", p, !0), a.removeEventListener("focusout", p, !0);
    };
  }, [a, i, o == null ? void 0 : o.modal]), /* @__PURE__ */ x.createElement(Sk.Provider, {
    value: x.useMemo(() => ({
      preserveTabOrder: i,
      beforeOutsideRef: c,
      afterOutsideRef: l,
      beforeInsideRef: u,
      afterInsideRef: f,
      portalNode: a,
      setFocusManagerState: s
    }), [i, a])
  }, d && a && /* @__PURE__ */ x.createElement(pu, {
    "data-type": "outside",
    ref: c,
    onFocus: (p) => {
      if (as(p, a)) {
        var m;
        (m = u.current) == null || m.focus();
      } else {
        const h = xk() || (o == null ? void 0 : o.refs.domReference.current);
        h == null || h.focus();
      }
    }
  }), d && a && /* @__PURE__ */ x.createElement("span", {
    "aria-owns": a.id,
    style: Fv
  }), a && /* @__PURE__ */ OR(t, a), d && a && /* @__PURE__ */ x.createElement(pu, {
    "data-type": "outside",
    ref: l,
    onFocus: (p) => {
      if (as(p, a)) {
        var m;
        (m = f.current) == null || m.focus();
      } else {
        const h = wk() || (o == null ? void 0 : o.refs.domReference.current);
        h == null || h.focus(), o != null && o.closeOnFocusOut && (o == null || o.onOpenChange(!1, p.nativeEvent));
      }
    }
  }));
}
const Ek = () => x.useContext(Sk), M4 = /* @__PURE__ */ x.forwardRef(function(t, n) {
  return /* @__PURE__ */ x.createElement("button", du({}, t, {
    type: "button",
    ref: n,
    tabIndex: -1,
    style: Fv
  }));
});
function F4(e) {
  const {
    context: t,
    children: n,
    disabled: r = !1,
    order: i = ["content"],
    guards: a = !0,
    initialFocus: o = 0,
    returnFocus: s = !0,
    modal: c = !0,
    visuallyHiddenDismiss: l = !1,
    closeOnFocusOut: u = !0
  } = e, {
    open: f,
    refs: d,
    nodeId: p,
    onOpenChange: m,
    events: h,
    dataRef: y,
    elements: {
      domReference: v,
      floating: b
    }
  } = t, w = $4() ? a : !0, T = wi(i), E = wi(o), _ = wi(s), $ = af(), B = Ek(), U = typeof o == "number" && o < 0, k = x.useRef(null), D = x.useRef(null), q = x.useRef(!1), L = x.useRef(null), R = x.useRef(!1), A = B != null, F = v && v.getAttribute("role") === "combobox" && rk(v) && U, H = x.useCallback(function(j) {
    return j === void 0 && (j = b), j ? Dv(j, Mv()) : [];
  }, [b]), V = x.useCallback((j) => {
    const W = H(j);
    return T.current.map((S) => v && S === "reference" ? v : b && S === "floating" ? b : W).filter(Boolean).flat();
  }, [v, b, T, H]);
  x.useEffect(() => {
    if (r || !c) return;
    function j(S) {
      if (S.key === "Tab") {
        Cn(b, mi(ar(b))) && H().length === 0 && !F && ln(S);
        const Z = V(), Y = nk(S);
        T.current[0] === "reference" && Y === v && (ln(S), S.shiftKey ? Kr(Z[Z.length - 1]) : Kr(Z[1])), T.current[1] === "floating" && Y === b && S.shiftKey && (ln(S), Kr(Z[0]));
      }
    }
    const W = ar(b);
    return W.addEventListener("keydown", j), () => {
      W.removeEventListener("keydown", j);
    };
  }, [r, v, b, c, T, d, F, H, V]), x.useEffect(() => {
    if (r || !u) return;
    function j() {
      R.current = !0, setTimeout(() => {
        R.current = !1;
      });
    }
    function W(S) {
      const Z = S.relatedTarget;
      queueMicrotask(() => {
        const Y = !(Cn(v, Z) || Cn(b, Z) || Cn(Z, b) || Cn(B == null ? void 0 : B.portalNode, Z) || Z != null && Z.hasAttribute(Is("focus-guard")) || $ && (Ua($.nodesRef.current, p).find((G) => {
          var X, ie;
          return Cn((X = G.context) == null ? void 0 : X.elements.floating, Z) || Cn((ie = G.context) == null ? void 0 : ie.elements.domReference, Z);
        }) || C4($.nodesRef.current, p).find((G) => {
          var X, ie;
          return ((X = G.context) == null ? void 0 : X.elements.floating) === Z || ((ie = G.context) == null ? void 0 : ie.elements.domReference) === Z;
        })));
        Z && Y && !R.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        Z !== L.current && (q.current = !0, m(!1, S));
      });
    }
    if (b && Xa(v))
      return v.addEventListener("focusout", W), v.addEventListener("pointerdown", j), !c && b.addEventListener("focusout", W), () => {
        v.removeEventListener("focusout", W), v.removeEventListener("pointerdown", j), !c && b.removeEventListener("focusout", W);
      };
  }, [r, v, b, c, p, $, B, m, u]), x.useEffect(() => {
    var j;
    if (r) return;
    const W = Array.from((B == null || (j = B.portalNode) == null ? void 0 : j.querySelectorAll("[" + Is("portal") + "]")) || []);
    if (b) {
      const S = [b, ...W, k.current, D.current, T.current.includes("reference") || F ? v : null].filter((Y) => Y != null), Z = c ? ow(S, w, !w) : ow(S);
      return () => {
        Z();
      };
    }
  }, [r, v, b, c, T, B, F, w]), Xt(() => {
    if (r || !b) return;
    const j = ar(b), W = mi(j);
    queueMicrotask(() => {
      const S = V(b), Z = E.current, Y = (typeof Z == "number" ? S[Z] : Z.current) || b, G = Cn(b, W);
      !U && !G && f && Kr(Y, {
        preventScroll: Y === b
      });
    });
  }, [r, f, b, U, V, E]), Xt(() => {
    if (r || !b) return;
    let j = !1;
    const W = ar(b), S = mi(W), Z = y.current;
    L.current = S;
    function Y(G) {
      if (G.type === "escapeKey" && d.domReference.current && (L.current = d.domReference.current), ["referencePress", "escapeKey"].includes(G.type))
        return;
      const X = G.data.returnFocus;
      typeof X == "object" ? (q.current = !1, j = X.preventScroll) : q.current = !X;
    }
    return h.on("dismiss", Y), () => {
      h.off("dismiss", Y);
      const G = mi(W);
      (Cn(b, G) || $ && Ua($.nodesRef.current, p).some((ie) => {
        var ae;
        return Cn((ae = ie.context) == null ? void 0 : ae.elements.floating, G);
      }) || Z.openEvent && ["click", "mousedown"].includes(Z.openEvent.type)) && d.domReference.current && (L.current = d.domReference.current), // eslint-disable-next-line react-hooks/exhaustive-deps
      _.current && Xa(L.current) && !q.current && Kr(L.current, {
        // When dismissing nested floating elements, by the time the rAF has
        // executed, the menus will all have been unmounted. When they try
        // to get focused, the calls get ignored — leaving the root
        // reference focused as desired.
        cancelPrevious: !1,
        preventScroll: j
      });
    };
  }, [r, b, _, y, d, h, $, p]), Xt(() => {
    if (!(r || !B))
      return B.setFocusManagerState({
        modal: c,
        closeOnFocusOut: u,
        open: f,
        onOpenChange: m,
        refs: d
      }), () => {
        B.setFocusManagerState(null);
      };
  }, [r, B, c, f, m, d, u]), Xt(() => {
    if (!r && b && typeof MutationObserver == "function" && !U) {
      const j = () => {
        const S = b.getAttribute("tabindex");
        T.current.includes("floating") || mi(ar(b)) !== d.domReference.current && H().length === 0 ? S !== "0" && b.setAttribute("tabindex", "0") : S !== "-1" && b.setAttribute("tabindex", "-1");
      };
      j();
      const W = new MutationObserver(j);
      return W.observe(b, {
        childList: !0,
        subtree: !0,
        attributes: !0
      }), () => {
        W.disconnect();
      };
    }
  }, [r, b, d, T, H, U]);
  function I(j) {
    return r || !l || !c ? null : /* @__PURE__ */ x.createElement(M4, {
      ref: j === "start" ? k : D,
      onClick: (W) => m(!1, W.nativeEvent)
    }, typeof l == "string" ? l : "Dismiss");
  }
  const g = !r && w && !F && (A || c);
  return /* @__PURE__ */ x.createElement(x.Fragment, null, g && /* @__PURE__ */ x.createElement(pu, {
    "data-type": "inside",
    ref: B == null ? void 0 : B.beforeInsideRef,
    onFocus: (j) => {
      if (c) {
        const S = V();
        Kr(i[0] === "reference" ? S[0] : S[S.length - 1]);
      } else if (B != null && B.preserveTabOrder && B.portalNode)
        if (q.current = !1, as(j, B.portalNode)) {
          const S = wk() || v;
          S == null || S.focus();
        } else {
          var W;
          (W = B.beforeOutsideRef.current) == null || W.focus();
        }
    }
  }), !F && I("start"), n, I("end"), g && /* @__PURE__ */ x.createElement(pu, {
    "data-type": "inside",
    ref: B == null ? void 0 : B.afterInsideRef,
    onFocus: (j) => {
      if (c)
        Kr(V()[0]);
      else if (B != null && B.preserveTabOrder && B.portalNode)
        if (u && (q.current = !0), as(j, B.portalNode)) {
          const S = xk() || v;
          S == null || S.focus();
        } else {
          var W;
          (W = B.afterOutsideRef.current) == null || W.focus();
        }
    }
  }));
}
function lw(e) {
  return Xa(e.target) && e.target.tagName === "BUTTON";
}
function cw(e) {
  return rk(e);
}
function L4(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    dataRef: i,
    elements: {
      domReference: a
    }
  } = e, {
    enabled: o = !0,
    event: s = "click",
    toggle: c = !0,
    ignoreMouse: l = !1,
    keyboardHandlers: u = !0
  } = t, f = x.useRef(), d = x.useRef(!1);
  return x.useMemo(() => o ? {
    reference: {
      onPointerDown(p) {
        f.current = p.pointerType;
      },
      onMouseDown(p) {
        p.button === 0 && (Kb(f.current) && l || s !== "click" && (n && c && (!i.current.openEvent || i.current.openEvent.type === "mousedown") ? r(!1, p.nativeEvent) : (p.preventDefault(), r(!0, p.nativeEvent))));
      },
      onClick(p) {
        if (s === "mousedown" && f.current) {
          f.current = void 0;
          return;
        }
        Kb(f.current) && l || (n && c && (!i.current.openEvent || i.current.openEvent.type === "click") ? r(!1, p.nativeEvent) : r(!0, p.nativeEvent));
      },
      onKeyDown(p) {
        f.current = void 0, !(p.defaultPrevented || !u || lw(p)) && (p.key === " " && !cw(a) && (p.preventDefault(), d.current = !0), p.key === "Enter" && r(!(n && c), p.nativeEvent));
      },
      onKeyUp(p) {
        p.defaultPrevented || !u || lw(p) || cw(a) || p.key === " " && d.current && (d.current = !1, r(!(n && c), p.nativeEvent));
      }
    }
  } : {}, [o, i, s, l, u, a, c, n, r]);
}
const B4 = x.useInsertionEffect, U4 = B4 || ((e) => e());
function xi(e) {
  const t = x.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return U4(() => {
    t.current = e;
  }), x.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
      r[i] = arguments[i];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
const z4 = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, q4 = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, W4 = (e) => {
  var t, n;
  return {
    escapeKeyBubbles: typeof e == "boolean" ? e : (t = e == null ? void 0 : e.escapeKey) != null ? t : !1,
    outsidePressBubbles: typeof e == "boolean" ? e : (n = e == null ? void 0 : e.outsidePress) != null ? n : !0
  };
};
function V4(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    events: i,
    nodeId: a,
    elements: {
      reference: o,
      domReference: s,
      floating: c
    },
    dataRef: l
  } = e, {
    enabled: u = !0,
    escapeKey: f = !0,
    outsidePress: d = !0,
    outsidePressEvent: p = "pointerdown",
    referencePress: m = !1,
    referencePressEvent: h = "pointerdown",
    ancestorScroll: y = !1,
    bubbles: v
  } = t, b = af(), w = yk() != null, T = xi(typeof d == "function" ? d : () => !1), E = typeof d == "function" ? T : d, _ = x.useRef(!1), {
    escapeKeyBubbles: $,
    outsidePressBubbles: B
  } = W4(v), U = xi((D) => {
    if (!n || !u || !f || D.key !== "Escape")
      return;
    const q = b ? Ua(b.nodesRef.current, a) : [];
    if (!$ && (D.stopPropagation(), q.length > 0)) {
      let L = !0;
      if (q.forEach((R) => {
        var A;
        if ((A = R.context) != null && A.open && !R.context.dataRef.current.__escapeKeyBubbles) {
          L = !1;
          return;
        }
      }), !L)
        return;
    }
    i.emit("dismiss", {
      type: "escapeKey",
      data: {
        returnFocus: {
          preventScroll: !1
        }
      }
    }), r(!1, g5(D) ? D.nativeEvent : D);
  }), k = xi((D) => {
    const q = _.current;
    if (_.current = !1, q || typeof E == "function" && !E(D))
      return;
    const L = nk(D), R = "[" + Is("inert") + "]", A = ar(c).querySelectorAll(R);
    let F = Hn(L) ? L : null;
    for (; F && !p5(F); ) {
      const I = m5(F);
      if (I === ar(c).body || !Hn(I))
        break;
      F = I;
    }
    if (A.length && Hn(L) && !b5(L) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !Cn(L, c) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(A).every((I) => !Cn(F, I)))
      return;
    if (Xa(L) && c) {
      const I = L.clientWidth > 0 && L.scrollWidth > L.clientWidth, g = L.clientHeight > 0 && L.scrollHeight > L.clientHeight;
      let j = g && D.offsetX > L.clientWidth;
      if (g && h5(L).direction === "rtl" && (j = D.offsetX <= L.offsetWidth - L.clientWidth), j || I && D.offsetY > L.clientHeight)
        return;
    }
    const H = b && Ua(b.nodesRef.current, a).some((I) => {
      var g;
      return md(D, (g = I.context) == null ? void 0 : g.elements.floating);
    });
    if (md(D, c) || md(D, s) || H)
      return;
    const V = b ? Ua(b.nodesRef.current, a) : [];
    if (V.length > 0) {
      let I = !0;
      if (V.forEach((g) => {
        var j;
        if ((j = g.context) != null && j.open && !g.context.dataRef.current.__outsidePressBubbles) {
          I = !1;
          return;
        }
      }), !I)
        return;
    }
    i.emit("dismiss", {
      type: "outsidePress",
      data: {
        returnFocus: w ? {
          preventScroll: !0
        } : Q_(D) || ek(D)
      }
    }), r(!1, D);
  });
  return x.useEffect(() => {
    if (!n || !u)
      return;
    l.current.__escapeKeyBubbles = $, l.current.__outsidePressBubbles = B;
    function D(R) {
      r(!1, R);
    }
    const q = ar(c);
    f && q.addEventListener("keydown", U), E && q.addEventListener(p, k);
    let L = [];
    return y && (Hn(s) && (L = bi(s)), Hn(c) && (L = L.concat(bi(c))), !Hn(o) && o && o.contextElement && (L = L.concat(bi(o.contextElement)))), L = L.filter((R) => {
      var A;
      return R !== ((A = q.defaultView) == null ? void 0 : A.visualViewport);
    }), L.forEach((R) => {
      R.addEventListener("scroll", D, {
        passive: !0
      });
    }), () => {
      f && q.removeEventListener("keydown", U), E && q.removeEventListener(p, k), L.forEach((R) => {
        R.removeEventListener("scroll", D);
      });
    };
  }, [l, c, s, o, f, E, p, n, r, y, u, $, B, U, k]), x.useEffect(() => {
    _.current = !1;
  }, [E, p]), x.useMemo(() => u ? {
    reference: {
      onKeyDown: U,
      [z4[h]]: (D) => {
        m && (i.emit("dismiss", {
          type: "referencePress",
          data: {
            returnFocus: !1
          }
        }), r(!1, D.nativeEvent));
      }
    },
    floating: {
      onKeyDown: U,
      [q4[p]]: () => {
        _.current = !0;
      }
    }
  } : {}, [u, i, m, p, h, r, U]);
}
let Uh;
process.env.NODE_ENV !== "production" && (Uh = /* @__PURE__ */ new Set());
function H4(e) {
  var t;
  e === void 0 && (e = {});
  const {
    open: n = !1,
    onOpenChange: r,
    nodeId: i
  } = e;
  if (process.env.NODE_ENV !== "production") {
    var a;
    const $ = "Floating UI: Cannot pass a virtual element to the `elements.reference` option, as it must be a real DOM element. Use `refs.setPositionReference` instead.";
    if ((a = e.elements) != null && a.reference && !Hn(e.elements.reference)) {
      var o;
      if (!((o = Uh) != null && o.has($))) {
        var s;
        (s = Uh) == null || s.add($), console.error($);
      }
    }
  }
  const [c, l] = x.useState(null), u = ((t = e.elements) == null ? void 0 : t.reference) || c, f = X5(e), d = af(), p = xi(($, B) => {
    $ && (h.current.openEvent = B), r == null || r($, B);
  }), m = x.useRef(null), h = x.useRef({}), y = x.useState(() => _4())[0], v = Nv(), b = x.useCallback(($) => {
    const B = Hn($) ? {
      getBoundingClientRect: () => $.getBoundingClientRect(),
      contextElement: $
    } : $;
    f.refs.setReference(B);
  }, [f.refs]), w = x.useCallback(($) => {
    (Hn($) || $ === null) && (m.current = $, l($)), (Hn(f.refs.reference.current) || f.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    $ !== null && !Hn($)) && f.refs.setReference($);
  }, [f.refs]), T = x.useMemo(() => ({
    ...f.refs,
    setReference: w,
    setPositionReference: b,
    domReference: m
  }), [f.refs, w, b]), E = x.useMemo(() => ({
    ...f.elements,
    domReference: u
  }), [f.elements, u]), _ = x.useMemo(() => ({
    ...f,
    refs: T,
    elements: E,
    dataRef: h,
    nodeId: i,
    floatingId: v,
    events: y,
    open: n,
    onOpenChange: p
  }), [f, i, v, y, n, p, T, E]);
  return Xt(() => {
    const $ = d == null ? void 0 : d.nodesRef.current.find((B) => B.id === i);
    $ && ($.context = _);
  }), x.useMemo(() => ({
    ...f,
    context: _,
    refs: T,
    elements: E
  }), [f, T, E, _]);
}
function xd(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  return {
    ...n === "floating" && {
      tabIndex: -1
    },
    ...e,
    ...t.map((i) => i ? i[n] : null).concat(e).reduce((i, a) => (a && Object.entries(a).forEach((o) => {
      let [s, c] = o;
      if (s.indexOf("on") === 0) {
        if (r.has(s) || r.set(s, []), typeof c == "function") {
          var l;
          (l = r.get(s)) == null || l.push(c), i[s] = function() {
            for (var u, f = arguments.length, d = new Array(f), p = 0; p < f; p++)
              d[p] = arguments[p];
            return (u = r.get(s)) == null ? void 0 : u.map((m) => m(...d)).find((m) => m !== void 0);
          };
        }
      } else
        i[s] = c;
    }), i), {})
  };
}
function Z4(e) {
  e === void 0 && (e = []);
  const t = e, n = x.useCallback(
    (a) => xd(a, e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), r = x.useCallback(
    (a) => xd(a, e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), i = x.useCallback(
    (a) => xd(a, e, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e.map((a) => a == null ? void 0 : a.item)
  );
  return x.useMemo(() => ({
    getReferenceProps: n,
    getFloatingProps: r,
    getItemProps: i
  }), [n, r, i]);
}
let uw = !1;
function of(e, t, n) {
  switch (e) {
    case "vertical":
      return t;
    case "horizontal":
      return n;
    default:
      return t || n;
  }
}
function fw(e, t) {
  return of(t, e === jv || e === rf, e === to || e === fl);
}
function Sd(e, t, n) {
  return of(t, e === rf, n ? e === to : e === fl) || e === "Enter" || e == " " || e === "";
}
function K4(e, t, n) {
  return of(t, n ? e === to : e === fl, e === rf);
}
function dw(e, t, n) {
  return of(t, n ? e === fl : e === to, e === jv);
}
function G4(e, t) {
  const {
    open: n,
    onOpenChange: r,
    refs: i,
    elements: {
      domReference: a,
      floating: o
    }
  } = e, {
    listRef: s,
    activeIndex: c,
    onNavigate: l = () => {
    },
    enabled: u = !0,
    selectedIndex: f = null,
    allowEscape: d = !1,
    loop: p = !1,
    nested: m = !1,
    rtl: h = !1,
    virtual: y = !1,
    focusItemOnOpen: v = "auto",
    focusItemOnHover: b = !0,
    openOnArrowKeyDown: w = !0,
    disabledIndices: T = void 0,
    orientation: E = "vertical",
    cols: _ = 1,
    scrollItemIntoView: $ = !0,
    virtualItemRef: B
  } = t;
  process.env.NODE_ENV !== "production" && (d && (p || console.warn(["Floating UI: `useListNavigation` looping must be enabled to allow", "escaping."].join(" ")), y || console.warn(["Floating UI: `useListNavigation` must be virtual to allow", "escaping."].join(" "))), E === "vertical" && _ > 1 && console.warn(["Floating UI: In grid list navigation mode (`cols` > 1), the", '`orientation` should be either "horizontal" or "both".'].join(" ")));
  const U = yk(), k = af(), D = xi(l), q = x.useRef(v), L = x.useRef(f ?? -1), R = x.useRef(null), A = x.useRef(!0), F = x.useRef(D), H = x.useRef(!!o), V = x.useRef(!1), I = x.useRef(!1), g = wi(T), j = wi(n), W = wi($), [S, Z] = x.useState(), [Y, G] = x.useState(), X = xi(function(J, Q, K) {
    K === void 0 && (K = !1);
    const fe = J.current[Q.current];
    fe && (y ? (Z(fe.id), k == null || k.events.emit("virtualfocus", fe), B && (B.current = fe)) : Kr(fe, {
      preventScroll: !0,
      // Mac Safari does not move the virtual cursor unless the focus call
      // is sync. However, for the very first focus call, we need to wait
      // for the position to be ready in order to prevent unwanted
      // scrolling. This means the virtual cursor will not move to the first
      // item when first opening the floating element, but will on
      // subsequent calls. `preventScroll` is supported in modern Safari,
      // so we can use that instead.
      // iOS Safari must be async or the first item will not be focused.
      sync: y5() && tk() ? uw || V.current : !1
    }), requestAnimationFrame(() => {
      const ye = W.current;
      ye && fe && (K || !A.current) && (fe.scrollIntoView == null || fe.scrollIntoView(typeof ye == "boolean" ? {
        block: "nearest",
        inline: "nearest"
      } : ye));
    }));
  });
  Xt(() => {
    document.createElement("div").focus({
      get preventScroll() {
        return uw = !0, !1;
      }
    });
  }, []), Xt(() => {
    u && (n && o ? q.current && f != null && (I.current = !0, D(f)) : H.current && (L.current = -1, F.current(null)));
  }, [u, n, o, f, D]), Xt(() => {
    if (u && n && o)
      if (c == null) {
        if (V.current = !1, f != null)
          return;
        if (H.current && (L.current = -1, X(s, L)), !H.current && q.current && (R.current != null || q.current === !0 && R.current == null)) {
          let J = 0;
          const Q = () => {
            s.current[0] == null ? (J < 2 && (J ? requestAnimationFrame : queueMicrotask)(Q), J++) : (L.current = R.current == null || Sd(R.current, E, h) || m ? gd(s, g.current) : rw(s, g.current), R.current = null, D(L.current));
          };
          Q();
        }
      } else is(s, c) || (L.current = c, X(s, L, I.current), I.current = !1);
  }, [u, n, o, c, f, m, s, E, h, D, X, g]), Xt(() => {
    var J, Q;
    if (!u || o || !k || y || !H.current)
      return;
    const K = k.nodesRef.current, fe = (J = K.find((M) => M.id === U)) == null || (Q = J.context) == null ? void 0 : Q.elements.floating, ye = mi(ar(o)), $e = K.some((M) => M.context && Cn(M.context.elements.floating, ye));
    fe && !$e && A.current && fe.focus({
      preventScroll: !0
    });
  }, [u, o, k, U, y]), Xt(() => {
    if (!u || !k || !y || U) return;
    function J(Q) {
      G(Q.id), B && (B.current = Q);
    }
    return k.events.on("virtualfocus", J), () => {
      k.events.off("virtualfocus", J);
    };
  }, [u, k, y, U, B]), Xt(() => {
    F.current = D, H.current = !!o;
  }), Xt(() => {
    n || (R.current = null);
  }, [n]);
  const ie = c != null, ae = x.useMemo(() => {
    function J(K) {
      if (!n) return;
      const fe = s.current.indexOf(K);
      fe !== -1 && D(fe);
    }
    return {
      onFocus(K) {
        let {
          currentTarget: fe
        } = K;
        J(fe);
      },
      onClick: (K) => {
        let {
          currentTarget: fe
        } = K;
        return fe.focus({
          preventScroll: !0
        });
      },
      // Safari
      ...b && {
        onMouseMove(K) {
          let {
            currentTarget: fe
          } = K;
          J(fe);
        },
        onPointerLeave(K) {
          let {
            pointerType: fe
          } = K;
          !A.current || fe === "touch" || (L.current = -1, X(s, L), D(null), y || Kr(i.floating.current, {
            preventScroll: !0
          }));
        }
      }
    };
  }, [n, i, X, b, s, D, y]);
  return x.useMemo(() => {
    if (!u)
      return {};
    const J = g.current;
    function Q(M) {
      if (A.current = !1, V.current = !0, !j.current && M.currentTarget === i.floating.current)
        return;
      if (m && dw(M.key, E, h)) {
        ln(M), r(!1, M.nativeEvent), Xa(a) && !y && a.focus();
        return;
      }
      const re = L.current, le = gd(s, J), oe = rw(s, J);
      if (M.key === "Home" && (ln(M), L.current = le, D(L.current)), M.key === "End" && (ln(M), L.current = oe, D(L.current)), !(_ > 1 && (L.current = w4(s, {
        event: M,
        orientation: E,
        loop: p,
        cols: _,
        disabledIndices: J,
        minIndex: le,
        maxIndex: oe,
        prevIndex: L.current,
        stopEvent: !0
      }), D(L.current), E === "both")) && fw(M.key, E)) {
        if (ln(M), n && !y && mi(M.currentTarget.ownerDocument) === M.currentTarget) {
          L.current = Sd(M.key, E, h) ? le : oe, D(L.current);
          return;
        }
        Sd(M.key, E, h) ? p ? L.current = re >= oe ? d && re !== s.current.length ? -1 : le : pn(s, {
          startingIndex: re,
          disabledIndices: J
        }) : L.current = Math.min(oe, pn(s, {
          startingIndex: re,
          disabledIndices: J
        })) : p ? L.current = re <= le ? d && re !== -1 ? s.current.length : oe : pn(s, {
          startingIndex: re,
          decrement: !0,
          disabledIndices: J
        }) : L.current = Math.max(le, pn(s, {
          startingIndex: re,
          decrement: !0,
          disabledIndices: J
        })), is(s, L.current) ? D(null) : D(L.current);
      }
    }
    function K(M) {
      v === "auto" && Q_(M.nativeEvent) && (q.current = !0);
    }
    function fe(M) {
      q.current = v, v === "auto" && ek(M.nativeEvent) && (q.current = !0);
    }
    const ye = y && n && ie && {
      "aria-activedescendant": Y || S
    }, $e = s.current.find((M) => (M == null ? void 0 : M.id) === S);
    return {
      reference: {
        ...ye,
        onKeyDown(M) {
          A.current = !1;
          const re = M.key.indexOf("Arrow") === 0, le = K4(M.key, E, h), oe = dw(M.key, E, h), Te = fw(M.key, E), Se = (m ? le : Te) || M.key === "Enter" || M.key.trim() === "";
          if (y && n) {
            const ue = k == null ? void 0 : k.nodesRef.current.find((N) => N.parentId == null), z = k && ue ? O4(k.nodesRef.current, ue.id) : null;
            if (re && z && B) {
              const N = new KeyboardEvent("keydown", {
                key: M.key,
                bubbles: !0
              });
              if (le || oe) {
                var Re, ze;
                const te = ((Re = z.context) == null ? void 0 : Re.elements.domReference) === M.currentTarget, de = oe && !te ? (ze = z.context) == null ? void 0 : ze.elements.domReference : le ? $e : null;
                de && (ln(M), de.dispatchEvent(N), G(void 0));
              }
              if (Te && z.context && z.context.open && z.parentId && M.currentTarget !== z.context.elements.domReference) {
                var ee;
                ln(M), (ee = z.context.elements.domReference) == null || ee.dispatchEvent(N);
                return;
              }
            }
            return Q(M);
          }
          if (!(!n && !w && re)) {
            if (Se && (R.current = m && Te ? null : M.key), m) {
              le && (ln(M), n ? (L.current = gd(s, J), D(L.current)) : r(!0, M.nativeEvent));
              return;
            }
            Te && (f != null && (L.current = f), ln(M), !n && w ? r(!0, M.nativeEvent) : Q(M), n && D(L.current));
          }
        },
        onFocus() {
          n && D(null);
        },
        onPointerDown: fe,
        onMouseDown: K,
        onClick: K
      },
      floating: {
        "aria-orientation": E === "both" ? void 0 : E,
        ...ye,
        onKeyDown: Q,
        onPointerMove() {
          A.current = !0;
        }
      },
      item: ae
    };
  }, [a, i, S, Y, g, j, s, u, E, h, y, n, ie, m, f, w, d, _, p, v, D, r, ae, k, B]);
}
function Y4(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    floatingId: r
  } = e, {
    enabled: i = !0,
    role: a = "dialog"
  } = t, o = Nv();
  return x.useMemo(() => {
    const s = {
      id: r,
      role: a
    };
    return i ? a === "tooltip" ? {
      reference: {
        "aria-describedby": n ? r : void 0
      },
      floating: s
    } : {
      reference: {
        "aria-expanded": n ? "true" : "false",
        "aria-haspopup": a === "alertdialog" ? "dialog" : a,
        "aria-controls": n ? r : void 0,
        ...a === "listbox" && {
          role: "combobox"
        },
        ...a === "menu" && {
          id: o
        }
      },
      floating: {
        ...s,
        ...a === "menu" && {
          "aria-labelledby": o
        }
      }
    } : {};
  }, [i, a, n, r, o]);
}
function J4(e, t) {
  var n;
  const {
    open: r,
    dataRef: i
  } = e, {
    listRef: a,
    activeIndex: o,
    onMatch: s,
    onTypingChange: c,
    enabled: l = !0,
    findMatch: u = null,
    resetMs: f = 750,
    ignoreKeys: d = [],
    selectedIndex: p = null
  } = t, m = x.useRef(), h = x.useRef(""), y = x.useRef((n = p ?? o) != null ? n : -1), v = x.useRef(null), b = xi(s), w = xi(c), T = wi(u), E = wi(d);
  return Xt(() => {
    r && (clearTimeout(m.current), v.current = null, h.current = "");
  }, [r]), Xt(() => {
    if (r && h.current === "") {
      var _;
      y.current = (_ = p ?? o) != null ? _ : -1;
    }
  }, [r, p, o]), x.useMemo(() => {
    if (!l)
      return {};
    function _(U) {
      U ? i.current.typing || (i.current.typing = U, w(U)) : i.current.typing && (i.current.typing = U, w(U));
    }
    function $(U, k, D) {
      const q = T.current ? T.current(k, D) : k.find((L) => (L == null ? void 0 : L.toLocaleLowerCase().indexOf(D.toLocaleLowerCase())) === 0);
      return q ? U.indexOf(q) : -1;
    }
    function B(U) {
      const k = a.current;
      if (h.current.length > 0 && h.current[0] !== " " && ($(k, k, h.current) === -1 ? _(!1) : U.key === " " && ln(U)), k == null || E.current.includes(U.key) || // Character key.
      U.key.length !== 1 || // Modifier key.
      U.ctrlKey || U.metaKey || U.altKey)
        return;
      r && U.key !== " " && (ln(U), _(!0)), k.every((R) => {
        var A, F;
        return R ? ((A = R[0]) == null ? void 0 : A.toLocaleLowerCase()) !== ((F = R[1]) == null ? void 0 : F.toLocaleLowerCase()) : !0;
      }) && h.current === U.key && (h.current = "", y.current = v.current), h.current += U.key, clearTimeout(m.current), m.current = setTimeout(() => {
        h.current = "", y.current = v.current, _(!1);
      }, f);
      const q = y.current, L = $(k, [...k.slice((q || 0) + 1), ...k.slice(0, (q || 0) + 1)], h.current);
      L !== -1 ? (b(L), v.current = L) : U.key !== " " && (h.current = "", _(!1));
    }
    return {
      reference: {
        onKeyDown: B
      },
      floating: {
        onKeyDown: B,
        onKeyUp(U) {
          U.key === " " && _(!1);
        }
      }
    };
  }, [l, r, i, a, f, E, T, b, w]);
}
const X4 = ({ options: e, reusable: t, sendMessage: n, isReadOnly: r }) => {
  var R, A, F, H, V;
  const i = _v((I) => I.messageContainerRef), [a, o] = x.useState(!1), [s, c] = x.useState(null), [l, u] = x.useState(null), {
    message: {
      blocks: { dropdown: f }
    }
  } = ut, d = e.reduce(
    (I, g) => (I[g.label] = g.value, I),
    {}
  ), p = d ? Object.keys(d) : [], m = (I) => {
    o(l !== null && !t ? !1 : I);
  }, { refs: h, floatingStyles: y, context: v } = H4({
    placement: "bottom-start",
    open: a,
    onOpenChange: m,
    whileElementsMounted: Z5,
    middleware: [
      Q5(5),
      e4({
        padding: 10,
        boundary: (i == null ? void 0 : i.current) ?? void 0,
        crossAxis: !0
      }),
      t4({
        apply({ rects: I, elements: g, availableHeight: j }) {
          Object.assign(g.floating.style, {
            maxHeight: `${j}px`,
            minWidth: `${I.reference.width}px`
          });
        },
        padding: 10
      })
    ]
  }), b = x.useRef([]), w = x.useRef(p), T = x.useRef(!1), E = L4(v, { event: "mousedown" }), _ = V4(v), $ = Y4(v, { role: "listbox" }), B = G4(v, {
    listRef: b,
    activeIndex: s,
    selectedIndex: l,
    onNavigate: c,
    // This is a large list, allow looping.
    loop: !0
  }), U = J4(v, {
    listRef: w,
    activeIndex: s,
    selectedIndex: l,
    onMatch: a ? c : u,
    onTypingChange(I) {
      T.current = I;
    }
  }), { getReferenceProps: k, getFloatingProps: D, getItemProps: q } = Z4([
    _,
    $,
    B,
    U,
    E
  ]), L = (I) => {
    u(I), p[I] !== void 0 && (n == null || n({
      type: "text",
      text: p[I] ?? "",
      value: d[p[I]] ?? ""
    })), o(!1);
  };
  return /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
    /* @__PURE__ */ O.jsxs(
      "div",
      {
        tabIndex: 0,
        ref: h.setReference,
        "aria-labelledby": "select-label",
        "aria-autocomplete": "none",
        "data-disabled": l !== null && !t ? "" : void 0,
        style: r ? { pointerEvents: "none" } : void 0,
        ...(R = f.button) == null ? void 0 : R.container,
        ...k(),
        children: [
          /* @__PURE__ */ O.jsx("span", { ...(A = f.button) == null ? void 0 : A.text, children: "Select..." }),
          /* @__PURE__ */ O.jsx(sL, { ...(F = f.button) == null ? void 0 : F.icon })
        ]
      }
    ),
    a && /* @__PURE__ */ O.jsx(N4, { children: /* @__PURE__ */ O.jsx(F4, { context: v, modal: !1, children: /* @__PURE__ */ O.jsx(
      "div",
      {
        ref: h.setFloating,
        className: (V = (H = f.content) == null ? void 0 : H.container) == null ? void 0 : V.className,
        style: { ...y },
        ...D(),
        children: p.map((I, g) => {
          var j;
          return /* @__PURE__ */ O.jsx(
            "div",
            {
              ref: (W) => {
                b.current[g] = W;
              },
              role: "option",
              tabIndex: g === s ? 0 : -1,
              "aria-selected": g === l && g === s,
              "data-active": g === s ? "" : void 0,
              ...(j = f.content) == null ? void 0 : j.item,
              ...q({
                onClick() {
                  L(g);
                },
                onKeyDown(W) {
                  W.key === "Enter" && (W.preventDefault(), L(g)), W.key === " " && !T.current && (W.preventDefault(), L(g));
                }
              }),
              children: I
            },
            I
          );
        })
      }
    ) }) })
  ] });
}, _k = An(({ title: e, url: t, isReadOnly: n, ...r }, i) => {
  const {
    message: {
      blocks: { file: a }
    }
  } = ut;
  return /* @__PURE__ */ O.jsxs(
    "a",
    {
      ...r,
      ...a.container,
      href: t,
      style: n ? { pointerEvents: "none" } : void 0,
      download: !0,
      ref: i,
      target: "_blank",
      rel: "noreferrer",
      children: [
        /* @__PURE__ */ O.jsx("p", { ...a.title, children: e || t }),
        /* @__PURE__ */ O.jsx(cL, { ...a.icon })
      ]
    }
  );
});
_k.displayName = "File";
const Q4 = go()((e, t) => ({
  components: {},
  getCustomComponent: async (n) => {
    const r = t().components[n];
    if (r)
      return r;
    const i = await fetch(n).then((l) => l.text()), a = new Blob([i], { type: "application/javascript" }), s = await import(URL.createObjectURL(a)), c = () => s.default;
    return e((l) => ({ components: { ...l.components, [n]: c } })), c;
  }
}));
globalThis.React = vt;
const eB = ({ url: e, name: t, data: n, ...r }) => {
  const i = Q4((l) => l.getCustomComponent), [a, o] = He(null), [s, c] = He(null);
  return Pt(() => {
    i(e).then(o).catch((l) => {
      c(l.message);
    });
  }, [e]), s ? /* @__PURE__ */ O.jsx("div", { style: { color: "red" }, children: s }) : a ? /* @__PURE__ */ O.jsx(a, { ...n, ...r }) : null;
}, tB = {
  audio: U_,
  bubble: D_,
  button: XF,
  carousel: G_,
  column: q_,
  dropdown: X4,
  file: _k,
  image: L_,
  location: z_,
  row: W_,
  text: kF,
  video: B_,
  custom: eB
}, dl = ({ block: e, renderers: t, ...n }) => {
  const r = (t == null ? void 0 : t[e.type]) ?? tB[e.type], i = { ...n, ...e };
  return /* @__PURE__ */ O.jsx(r, { ...i });
};
function nB({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    fillRule: "evenodd",
    d: "M8 14a.75.75 0 0 1-.75-.75V4.56L4.03 7.78a.75.75 0 0 1-1.06-1.06l4.5-4.5a.75.75 0 0 1 1.06 0l4.5 4.5a.75.75 0 0 1-1.06 1.06L8.75 4.56v8.69A.75.75 0 0 1 8 14Z",
    clipRule: "evenodd"
  }));
}
const rB = /* @__PURE__ */ x.forwardRef(nB);
function iB({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ x.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 16 16",
    fill: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ x.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ x.createElement("path", {
    d: "M8 1a2 2 0 0 0-2 2v4a2 2 0 1 0 4 0V3a2 2 0 0 0-2-2Z"
  }), /* @__PURE__ */ x.createElement("path", {
    d: "M4.5 7A.75.75 0 0 0 3 7a5.001 5.001 0 0 0 4.25 4.944V13.5h-1.5a.75.75 0 0 0 0 1.5h4.5a.75.75 0 0 0 0-1.5h-1.5v-1.556A5.001 5.001 0 0 0 13 7a.75.75 0 0 0-1.5 0 3.5 3.5 0 1 1-7 0Z"
  }));
}
const aB = /* @__PURE__ */ x.forwardRef(iB);
function kk(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (n = kk(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function As() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++) (e = arguments[n]) && (t = kk(e)) && (r && (r += " "), r += t);
  return r;
}
const oB = ({ disabled: e, onFileSelected: t }) => {
  const n = Tt(null), { container: r, icon: i } = ut.composer.uploadButton, a = () => {
    n.current && n.current.click();
  }, o = (s) => {
    const c = s.target.files;
    c && c.length > 0 && Array.from(c).forEach((l) => {
      t(l);
    });
  };
  return /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
    /* @__PURE__ */ O.jsx("button", { type: "button", disabled: e, ...r, children: /* @__PURE__ */ O.jsx(f5, { ...i, "data-disabled": e, onClick: a }) }),
    /* @__PURE__ */ O.jsx(
      "input",
      {
        value: "",
        multiple: !0,
        type: "file",
        ref: n,
        style: { display: "none" },
        onChange: o
      }
    )
  ] });
}, sB = ({ name: e, type: t, instance: n, status: r, removeFile: i }) => {
  const { loader: a, fileIcon: o, removeIcon: s, errorIcon: c, previewImage: l } = ut.composer.fileWidget, u = ["PNG", "JPEG", "JPG"].includes(Yl(e)), f = zt(() => u ? URL.createObjectURL(n) : "", [n]);
  return r === "loading" ? /* @__PURE__ */ O.jsx(Gl, { name: e, status: r, removeButton: /* @__PURE__ */ O.jsx("div", { ...a }), extension: Yl(e), children: /* @__PURE__ */ O.jsx("div", { ...o.container, children: /* @__PURE__ */ O.jsx(Ed, { type: t, ...o.icon }) }) }) : r === "error" ? /* @__PURE__ */ O.jsx(
    Gl,
    {
      name: e,
      status: r,
      removeButton: /* @__PURE__ */ O.jsx(hd, { onClick: () => i(e), ...s }),
      extension: "Upload Error",
      children: /* @__PURE__ */ O.jsxs("div", { ...o.container, children: [
        /* @__PURE__ */ O.jsx(fL, { ...c }),
        /* @__PURE__ */ O.jsx(Ed, { type: t, ...o.icon })
      ] })
    }
  ) : r == "uploaded" && u ? /* @__PURE__ */ O.jsx(
    Gl,
    {
      name: e,
      status: r,
      removeButton: /* @__PURE__ */ O.jsx(hd, { onClick: () => i(e), ...s }),
      extension: Yl(e),
      children: /* @__PURE__ */ O.jsx("div", { ...o.container, children: /* @__PURE__ */ O.jsx("img", { src: f, alt: e, ...l }) })
    }
  ) : /* @__PURE__ */ O.jsx(
    Gl,
    {
      name: e,
      status: r,
      removeButton: /* @__PURE__ */ O.jsx(hd, { onClick: () => i(e), ...s }),
      extension: Yl(e),
      children: /* @__PURE__ */ O.jsx("div", { ...o.container, children: /* @__PURE__ */ O.jsx(Ed, { type: t, ...o.icon }) })
    }
  );
}, Gl = ({ name: e, status: t, removeButton: n, children: r, extension: i }) => {
  const { container: a, metadata: o } = ut.composer.fileWidget;
  return /* @__PURE__ */ O.jsxs("div", { "data-status": t, title: e, ...a, children: [
    n,
    r,
    /* @__PURE__ */ O.jsxs("div", { ...o.container, children: [
      /* @__PURE__ */ O.jsx("div", { ...o.name, children: e }),
      /* @__PURE__ */ O.jsx("div", { ...o.type, children: i })
    ] })
  ] });
}, Ed = ({ type: e, ...t }) => e === "image" ? /* @__PURE__ */ O.jsx(bF, { ...t }) : e === "video" ? /* @__PURE__ */ O.jsx(EF, { ...t }) : e === "audio" ? /* @__PURE__ */ O.jsx(xF, { ...t }) : /* @__PURE__ */ O.jsx(yF, { ...t }), Yl = (e) => {
  const t = e.split(".").pop();
  return t ? t.toUpperCase() : "File";
};
function zh() {
  return zh = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n) ({}).hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, zh.apply(null, arguments);
}
function lB(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
var cB = mo, uB = function(t) {
  var n = x.useRef(t);
  return cB(function() {
    n.current = t;
  }), n;
}, pw = function(t, n) {
  if (typeof t == "function") {
    t(n);
    return;
  }
  t.current = n;
}, fB = function(t, n) {
  var r = Tt();
  return ot(function(i) {
    t.current = i, r.current && pw(r.current, null), r.current = n, n && pw(n, i);
  }, [n]);
}, hw = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0",
  display: "block"
}, dB = function(t) {
  Object.keys(hw).forEach(function(n) {
    t.style.setProperty(n, hw[n], "important");
  });
}, mw = dB, wn = null, vw = function(t, n) {
  var r = t.scrollHeight;
  return n.sizingStyle.boxSizing === "border-box" ? r + n.borderSize : r - n.paddingSize;
};
function pB(e, t, n, r) {
  n === void 0 && (n = 1), r === void 0 && (r = 1 / 0), wn || (wn = document.createElement("textarea"), wn.setAttribute("tabindex", "-1"), wn.setAttribute("aria-hidden", "true"), mw(wn)), wn.parentNode === null && document.body.appendChild(wn);
  var i = e.paddingSize, a = e.borderSize, o = e.sizingStyle, s = o.boxSizing;
  Object.keys(o).forEach(function(d) {
    var p = d;
    wn.style[p] = o[p];
  }), mw(wn), wn.value = t;
  var c = vw(wn, e);
  wn.value = t, c = vw(wn, e), wn.value = "x";
  var l = wn.scrollHeight - i, u = l * n;
  s === "border-box" && (u = u + i + a), c = Math.max(u, c);
  var f = l * r;
  return s === "border-box" && (f = f + i + a), c = Math.min(f, c), [c, l];
}
var yw = function() {
}, hB = function(t, n) {
  return t.reduce(function(r, i) {
    return r[i] = n[i], r;
  }, {});
}, mB = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width",
  "wordBreak"
], vB = !!document.documentElement.currentStyle, yB = function(t) {
  var n = window.getComputedStyle(t);
  if (n === null)
    return null;
  var r = hB(mB, n), i = r.boxSizing;
  if (i === "")
    return null;
  vB && i === "border-box" && (r.width = parseFloat(r.width) + parseFloat(r.borderRightWidth) + parseFloat(r.borderLeftWidth) + parseFloat(r.paddingRight) + parseFloat(r.paddingLeft) + "px");
  var a = parseFloat(r.paddingBottom) + parseFloat(r.paddingTop), o = parseFloat(r.borderBottomWidth) + parseFloat(r.borderTopWidth);
  return {
    sizingStyle: r,
    paddingSize: a,
    borderSize: o
  };
}, gB = yB;
function Tk(e, t, n) {
  var r = uB(n);
  x.useLayoutEffect(function() {
    var i = function(o) {
      return r.current(o);
    };
    if (e)
      return e.addEventListener(t, i), function() {
        return e.removeEventListener(t, i);
      };
  }, []);
}
var bB = function(t) {
  Tk(window, "resize", t);
}, wB = function(t) {
  Tk(document.fonts, "loadingdone", t);
}, xB = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"], SB = function(t, n) {
  var r = t.cacheMeasurements, i = t.maxRows, a = t.minRows, o = t.onChange, s = o === void 0 ? yw : o, c = t.onHeightChange, l = c === void 0 ? yw : c, u = lB(t, xB), f = u.value !== void 0, d = x.useRef(null), p = fB(d, n), m = x.useRef(0), h = x.useRef(), y = function() {
    var w = d.current, T = r && h.current ? h.current : gB(w);
    if (T) {
      h.current = T;
      var E = pB(T, w.value || w.placeholder || "x", a, i), _ = E[0], $ = E[1];
      m.current !== _ && (m.current = _, w.style.setProperty("height", _ + "px", "important"), l(_, {
        rowHeight: $
      }));
    }
  }, v = function(w) {
    f || y(), s(w);
  };
  return x.useLayoutEffect(y), bB(y), wB(y), /* @__PURE__ */ x.createElement("textarea", zh({}, u, {
    onChange: v,
    ref: p
  }));
}, EB = /* @__PURE__ */ x.forwardRef(SB);
const _B = ({
  inputRef: e,
  composerPlaceholder: t,
  composerDisabled: n,
  textInput: r,
  historyIndex: i,
  setTextInput: a,
  setHistoryIndex: o,
  sendComposerMessage: s
}) => {
  const c = E_((u) => u.messageHistory), { input: l } = ut.composer;
  return /* @__PURE__ */ O.jsx(
    EB,
    {
      ...l,
      ref: e,
      placeholder: t ?? "Type your message...",
      disabled: n,
      value: r,
      "data-has-value": !!r,
      onChange: (u) => a(u.target.value),
      maxRows: 5,
      onKeyDown: (u) => {
        n || (u.key === "Enter" && u.shiftKey ? (u.preventDefault(), a(`${r}
`)) : u.key === "Enter" && (u.preventDefault(), s()), u.key === "ArrowUp" && (u.preventDefault(), i < c.length - 1 && a(c[i + 1] ?? ""), o(Math.min(i + 1, c.length - 1))), u.key === "ArrowDown" && (u.preventDefault(), a(i === 0 ? "" : c[i - 1] ?? ""), o(Math.max(i - 1, -1))));
      }
    }
  );
}, kB = ({ textInput: e, setTextInput: t }) => {
  const [n, r] = He(!1), i = Tt(null), { icon: a, container: o } = ut.composer.voiceButton, s = window.SpeechRecognition || window.webkitSpeechRecognition, c = () => {
    i.current || (i.current = new s());
    const l = i.current;
    l && (l.continuous = !0, l.onresult = (u) => {
      var d, p, m;
      const f = ((m = (p = (d = u.results) == null ? void 0 : d[0]) == null ? void 0 : p[0]) == null ? void 0 : m.transcript) ?? "";
      t(f ?? ""), l.stop(), r(!1);
    }, n ? (l.stop(), r(!1)) : (l.start(), r(!0)));
  };
  if (s)
    return /* @__PURE__ */ O.jsx(
      "button",
      {
        ...o,
        type: "button",
        "aria-label": "Activate voice input",
        disabled: !!e,
        onClick: c,
        "data-listens": !!n,
        children: /* @__PURE__ */ O.jsx(aB, { ...a })
      }
    );
}, TB = qu(
  An(
    ({
      className: e,
      inputRef: t,
      disableComposer: n,
      isReadOnly: r,
      allowFileUpload: i,
      connected: a,
      composerPlaceholder: o,
      showPoweredBy: s,
      sendMessage: c,
      uploadFile: l,
      ...u
    }, f) => {
      const { composer: d } = ut, p = n || r || !a, [m, h] = He(""), [y, v] = He(-1), b = Yo((U) => U.files), w = Yo((U) => U.setFiles), T = Yo((U) => U.deleteFile), E = Yo((U) => U.uploadFile), _ = E_((U) => U.addMessageToHistory), $ = m || b.filter((U) => U.status === "uploaded").length > 0, B = () => {
        const U = b.filter((q) => q.status === "uploaded");
        if (!U.length && !m) return;
        const k = (U == null ? void 0 : U.map((q) => {
          const L = q.url, R = q.type;
          return {
            video: { type: "video", videoUrl: L },
            audio: { type: "audio", audioUrl: L },
            image: { type: "image", imageUrl: L }
          }[R] ?? { title: q.name, type: "file", fileUrl: L };
        })) ?? [];
        m && k.push({ type: "text", text: m });
        let D;
        k.length == 1 ? D = k[0] : D = {
          type: "bloc",
          items: k.map((L) => {
            const { type: R, ...A } = L;
            return {
              type: R,
              payload: A
            };
          })
        }, c == null || c(D), w([]), h(""), _(m), v(-1);
      };
      return r ? null : /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
        /* @__PURE__ */ O.jsxs(
          "div",
          {
            "data-disabled": p,
            ...u,
            className: As(d.container.className, e),
            ref: f,
            children: [
              b.length > 0 && /* @__PURE__ */ O.jsx("div", { ...d == null ? void 0 : d.fileContainer, children: b.map((U) => /* @__PURE__ */ O.jsx(sB, { ...U, removeFile: T }, U.name)) }),
              /* @__PURE__ */ O.jsxs("div", { ...d.inputContainer, children: [
                i && /* @__PURE__ */ O.jsx(
                  oB,
                  {
                    disabled: p || !l,
                    onFileSelected: (U) => {
                      l && E(U, l);
                    }
                  }
                ),
                /* @__PURE__ */ O.jsx(
                  _B,
                  {
                    inputRef: t,
                    composerPlaceholder: o,
                    composerDisabled: p,
                    textInput: m,
                    historyIndex: y,
                    setTextInput: h,
                    setHistoryIndex: v,
                    sendComposerMessage: B
                  }
                ),
                $ && /* @__PURE__ */ O.jsx(
                  "button",
                  {
                    type: "button",
                    "aria-label": "Send message",
                    ...d.button.container,
                    disabled: p,
                    onClick: () => B(),
                    children: /* @__PURE__ */ O.jsx(rB, { ...d.button.icon })
                  }
                ),
                !$ && /* @__PURE__ */ O.jsx(kB, { textInput: m, setTextInput: h })
              ] })
            ]
          }
        ),
        /* @__PURE__ */ O.jsx(
          "a",
          {
            ...d.poweredBy,
            "data-hidden": s === !1,
            hidden: s === !1,
            href: "https://botpress.com/?from=webchat",
            target: "_blank",
            rel: "noopener noreferrer",
            children: "⚡ by Botpress"
          }
        )
      ] });
    }
  )
);
var qh = { exports: {} }, Jl = { exports: {} }, dt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var gw;
function CB() {
  if (gw) return dt;
  gw = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, o = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, y = e ? Symbol.for("react.fundamental") : 60117, v = e ? Symbol.for("react.responder") : 60118, b = e ? Symbol.for("react.scope") : 60119;
  function w(E) {
    if (typeof E == "object" && E !== null) {
      var _ = E.$$typeof;
      switch (_) {
        case t:
          switch (E = E.type, E) {
            case c:
            case l:
            case r:
            case a:
            case i:
            case f:
              return E;
            default:
              switch (E = E && E.$$typeof, E) {
                case s:
                case u:
                case m:
                case p:
                case o:
                  return E;
                default:
                  return _;
              }
          }
        case n:
          return _;
      }
    }
  }
  function T(E) {
    return w(E) === l;
  }
  return dt.AsyncMode = c, dt.ConcurrentMode = l, dt.ContextConsumer = s, dt.ContextProvider = o, dt.Element = t, dt.ForwardRef = u, dt.Fragment = r, dt.Lazy = m, dt.Memo = p, dt.Portal = n, dt.Profiler = a, dt.StrictMode = i, dt.Suspense = f, dt.isAsyncMode = function(E) {
    return T(E) || w(E) === c;
  }, dt.isConcurrentMode = T, dt.isContextConsumer = function(E) {
    return w(E) === s;
  }, dt.isContextProvider = function(E) {
    return w(E) === o;
  }, dt.isElement = function(E) {
    return typeof E == "object" && E !== null && E.$$typeof === t;
  }, dt.isForwardRef = function(E) {
    return w(E) === u;
  }, dt.isFragment = function(E) {
    return w(E) === r;
  }, dt.isLazy = function(E) {
    return w(E) === m;
  }, dt.isMemo = function(E) {
    return w(E) === p;
  }, dt.isPortal = function(E) {
    return w(E) === n;
  }, dt.isProfiler = function(E) {
    return w(E) === a;
  }, dt.isStrictMode = function(E) {
    return w(E) === i;
  }, dt.isSuspense = function(E) {
    return w(E) === f;
  }, dt.isValidElementType = function(E) {
    return typeof E == "string" || typeof E == "function" || E === r || E === l || E === a || E === i || E === f || E === d || typeof E == "object" && E !== null && (E.$$typeof === m || E.$$typeof === p || E.$$typeof === o || E.$$typeof === s || E.$$typeof === u || E.$$typeof === y || E.$$typeof === v || E.$$typeof === b || E.$$typeof === h);
  }, dt.typeOf = w, dt;
}
var pt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var bw;
function OB() {
  return bw || (bw = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, a = e ? Symbol.for("react.profiler") : 60114, o = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, c = e ? Symbol.for("react.async_mode") : 60111, l = e ? Symbol.for("react.concurrent_mode") : 60111, u = e ? Symbol.for("react.forward_ref") : 60112, f = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, p = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, h = e ? Symbol.for("react.block") : 60121, y = e ? Symbol.for("react.fundamental") : 60117, v = e ? Symbol.for("react.responder") : 60118, b = e ? Symbol.for("react.scope") : 60119;
    function w(K) {
      return typeof K == "string" || typeof K == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      K === r || K === l || K === a || K === i || K === f || K === d || typeof K == "object" && K !== null && (K.$$typeof === m || K.$$typeof === p || K.$$typeof === o || K.$$typeof === s || K.$$typeof === u || K.$$typeof === y || K.$$typeof === v || K.$$typeof === b || K.$$typeof === h);
    }
    function T(K) {
      if (typeof K == "object" && K !== null) {
        var fe = K.$$typeof;
        switch (fe) {
          case t:
            var ye = K.type;
            switch (ye) {
              case c:
              case l:
              case r:
              case a:
              case i:
              case f:
                return ye;
              default:
                var $e = ye && ye.$$typeof;
                switch ($e) {
                  case s:
                  case u:
                  case m:
                  case p:
                  case o:
                    return $e;
                  default:
                    return fe;
                }
            }
          case n:
            return fe;
        }
      }
    }
    var E = c, _ = l, $ = s, B = o, U = t, k = u, D = r, q = m, L = p, R = n, A = a, F = i, H = f, V = !1;
    function I(K) {
      return V || (V = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), g(K) || T(K) === c;
    }
    function g(K) {
      return T(K) === l;
    }
    function j(K) {
      return T(K) === s;
    }
    function W(K) {
      return T(K) === o;
    }
    function S(K) {
      return typeof K == "object" && K !== null && K.$$typeof === t;
    }
    function Z(K) {
      return T(K) === u;
    }
    function Y(K) {
      return T(K) === r;
    }
    function G(K) {
      return T(K) === m;
    }
    function X(K) {
      return T(K) === p;
    }
    function ie(K) {
      return T(K) === n;
    }
    function ae(K) {
      return T(K) === a;
    }
    function J(K) {
      return T(K) === i;
    }
    function Q(K) {
      return T(K) === f;
    }
    pt.AsyncMode = E, pt.ConcurrentMode = _, pt.ContextConsumer = $, pt.ContextProvider = B, pt.Element = U, pt.ForwardRef = k, pt.Fragment = D, pt.Lazy = q, pt.Memo = L, pt.Portal = R, pt.Profiler = A, pt.StrictMode = F, pt.Suspense = H, pt.isAsyncMode = I, pt.isConcurrentMode = g, pt.isContextConsumer = j, pt.isContextProvider = W, pt.isElement = S, pt.isForwardRef = Z, pt.isFragment = Y, pt.isLazy = G, pt.isMemo = X, pt.isPortal = ie, pt.isProfiler = ae, pt.isStrictMode = J, pt.isSuspense = Q, pt.isValidElementType = w, pt.typeOf = T;
  }()), pt;
}
var ww;
function sf() {
  return ww || (ww = 1, process.env.NODE_ENV === "production" ? Jl.exports = CB() : Jl.exports = OB()), Jl.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var _d, xw;
function Ck() {
  if (xw) return _d;
  xw = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(a) {
    if (a == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(a);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var a = new String("abc");
      if (a[5] = "de", Object.getOwnPropertyNames(a)[0] === "5")
        return !1;
      for (var o = {}, s = 0; s < 10; s++)
        o["_" + String.fromCharCode(s)] = s;
      var c = Object.getOwnPropertyNames(o).map(function(u) {
        return o[u];
      });
      if (c.join("") !== "0123456789")
        return !1;
      var l = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(u) {
        l[u] = u;
      }), Object.keys(Object.assign({}, l)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return _d = i() ? Object.assign : function(a, o) {
    for (var s, c = r(a), l, u = 1; u < arguments.length; u++) {
      s = Object(arguments[u]);
      for (var f in s)
        t.call(s, f) && (c[f] = s[f]);
      if (e) {
        l = e(s);
        for (var d = 0; d < l.length; d++)
          n.call(s, l[d]) && (c[l[d]] = s[l[d]]);
      }
    }
    return c;
  }, _d;
}
var kd, Sw;
function Lv() {
  if (Sw) return kd;
  Sw = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return kd = e, kd;
}
var Td, Ew;
function Ok() {
  return Ew || (Ew = 1, Td = Function.call.bind(Object.prototype.hasOwnProperty)), Td;
}
var Cd, _w;
function $B() {
  if (_w) return Cd;
  _w = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Lv(), n = {}, r = Ok();
    e = function(a) {
      var o = "Warning: " + a;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function i(a, o, s, c, l) {
    if (process.env.NODE_ENV !== "production") {
      for (var u in a)
        if (r(a, u)) {
          var f;
          try {
            if (typeof a[u] != "function") {
              var d = Error(
                (c || "React class") + ": " + s + " type `" + u + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[u] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            f = a[u](o, u, c, s, null, t);
          } catch (m) {
            f = m;
          }
          if (f && !(f instanceof Error) && e(
            (c || "React class") + ": type specification of " + s + " `" + u + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in n)) {
            n[f.message] = !0;
            var p = l ? l() : "";
            e(
              "Failed " + s + " type: " + f.message + (p ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Cd = i, Cd;
}
var Od, kw;
function RB() {
  if (kw) return Od;
  kw = 1;
  var e = sf(), t = Ck(), n = Lv(), r = Ok(), i = $B(), a = function() {
  };
  process.env.NODE_ENV !== "production" && (a = function(s) {
    var c = "Warning: " + s;
    typeof console < "u" && console.error(c);
    try {
      throw new Error(c);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return Od = function(s, c) {
    var l = typeof Symbol == "function" && Symbol.iterator, u = "@@iterator";
    function f(g) {
      var j = g && (l && g[l] || g[u]);
      if (typeof j == "function")
        return j;
    }
    var d = "<<anonymous>>", p = {
      array: v("array"),
      bigint: v("bigint"),
      bool: v("boolean"),
      func: v("function"),
      number: v("number"),
      object: v("object"),
      string: v("string"),
      symbol: v("symbol"),
      any: b(),
      arrayOf: w,
      element: T(),
      elementType: E(),
      instanceOf: _,
      node: k(),
      objectOf: B,
      oneOf: $,
      oneOfType: U,
      shape: q,
      exact: L
    };
    function m(g, j) {
      return g === j ? g !== 0 || 1 / g === 1 / j : g !== g && j !== j;
    }
    function h(g, j) {
      this.message = g, this.data = j && typeof j == "object" ? j : {}, this.stack = "";
    }
    h.prototype = Error.prototype;
    function y(g) {
      if (process.env.NODE_ENV !== "production")
        var j = {}, W = 0;
      function S(Y, G, X, ie, ae, J, Q) {
        if (ie = ie || d, J = J || X, Q !== n) {
          if (c) {
            var K = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw K.name = "Invariant Violation", K;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var fe = ie + ":" + X;
            !j[fe] && // Avoid spamming the console because they are often not actionable except for lib authors
            W < 3 && (a(
              "You are manually calling a React.PropTypes validation function for the `" + J + "` prop on `" + ie + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), j[fe] = !0, W++);
          }
        }
        return G[X] == null ? Y ? G[X] === null ? new h("The " + ae + " `" + J + "` is marked as required " + ("in `" + ie + "`, but its value is `null`.")) : new h("The " + ae + " `" + J + "` is marked as required in " + ("`" + ie + "`, but its value is `undefined`.")) : null : g(G, X, ie, ae, J);
      }
      var Z = S.bind(null, !1);
      return Z.isRequired = S.bind(null, !0), Z;
    }
    function v(g) {
      function j(W, S, Z, Y, G, X) {
        var ie = W[S], ae = F(ie);
        if (ae !== g) {
          var J = H(ie);
          return new h(
            "Invalid " + Y + " `" + G + "` of type " + ("`" + J + "` supplied to `" + Z + "`, expected ") + ("`" + g + "`."),
            { expectedType: g }
          );
        }
        return null;
      }
      return y(j);
    }
    function b() {
      return y(o);
    }
    function w(g) {
      function j(W, S, Z, Y, G) {
        if (typeof g != "function")
          return new h("Property `" + G + "` of component `" + Z + "` has invalid PropType notation inside arrayOf.");
        var X = W[S];
        if (!Array.isArray(X)) {
          var ie = F(X);
          return new h("Invalid " + Y + " `" + G + "` of type " + ("`" + ie + "` supplied to `" + Z + "`, expected an array."));
        }
        for (var ae = 0; ae < X.length; ae++) {
          var J = g(X, ae, Z, Y, G + "[" + ae + "]", n);
          if (J instanceof Error)
            return J;
        }
        return null;
      }
      return y(j);
    }
    function T() {
      function g(j, W, S, Z, Y) {
        var G = j[W];
        if (!s(G)) {
          var X = F(G);
          return new h("Invalid " + Z + " `" + Y + "` of type " + ("`" + X + "` supplied to `" + S + "`, expected a single ReactElement."));
        }
        return null;
      }
      return y(g);
    }
    function E() {
      function g(j, W, S, Z, Y) {
        var G = j[W];
        if (!e.isValidElementType(G)) {
          var X = F(G);
          return new h("Invalid " + Z + " `" + Y + "` of type " + ("`" + X + "` supplied to `" + S + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return y(g);
    }
    function _(g) {
      function j(W, S, Z, Y, G) {
        if (!(W[S] instanceof g)) {
          var X = g.name || d, ie = I(W[S]);
          return new h("Invalid " + Y + " `" + G + "` of type " + ("`" + ie + "` supplied to `" + Z + "`, expected ") + ("instance of `" + X + "`."));
        }
        return null;
      }
      return y(j);
    }
    function $(g) {
      if (!Array.isArray(g))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? a(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : a("Invalid argument supplied to oneOf, expected an array.")), o;
      function j(W, S, Z, Y, G) {
        for (var X = W[S], ie = 0; ie < g.length; ie++)
          if (m(X, g[ie]))
            return null;
        var ae = JSON.stringify(g, function(Q, K) {
          var fe = H(K);
          return fe === "symbol" ? String(K) : K;
        });
        return new h("Invalid " + Y + " `" + G + "` of value `" + String(X) + "` " + ("supplied to `" + Z + "`, expected one of " + ae + "."));
      }
      return y(j);
    }
    function B(g) {
      function j(W, S, Z, Y, G) {
        if (typeof g != "function")
          return new h("Property `" + G + "` of component `" + Z + "` has invalid PropType notation inside objectOf.");
        var X = W[S], ie = F(X);
        if (ie !== "object")
          return new h("Invalid " + Y + " `" + G + "` of type " + ("`" + ie + "` supplied to `" + Z + "`, expected an object."));
        for (var ae in X)
          if (r(X, ae)) {
            var J = g(X, ae, Z, Y, G + "." + ae, n);
            if (J instanceof Error)
              return J;
          }
        return null;
      }
      return y(j);
    }
    function U(g) {
      if (!Array.isArray(g))
        return process.env.NODE_ENV !== "production" && a("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var j = 0; j < g.length; j++) {
        var W = g[j];
        if (typeof W != "function")
          return a(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + V(W) + " at index " + j + "."
          ), o;
      }
      function S(Z, Y, G, X, ie) {
        for (var ae = [], J = 0; J < g.length; J++) {
          var Q = g[J], K = Q(Z, Y, G, X, ie, n);
          if (K == null)
            return null;
          K.data && r(K.data, "expectedType") && ae.push(K.data.expectedType);
        }
        var fe = ae.length > 0 ? ", expected one of type [" + ae.join(", ") + "]" : "";
        return new h("Invalid " + X + " `" + ie + "` supplied to " + ("`" + G + "`" + fe + "."));
      }
      return y(S);
    }
    function k() {
      function g(j, W, S, Z, Y) {
        return R(j[W]) ? null : new h("Invalid " + Z + " `" + Y + "` supplied to " + ("`" + S + "`, expected a ReactNode."));
      }
      return y(g);
    }
    function D(g, j, W, S, Z) {
      return new h(
        (g || "React class") + ": " + j + " type `" + W + "." + S + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Z + "`."
      );
    }
    function q(g) {
      function j(W, S, Z, Y, G) {
        var X = W[S], ie = F(X);
        if (ie !== "object")
          return new h("Invalid " + Y + " `" + G + "` of type `" + ie + "` " + ("supplied to `" + Z + "`, expected `object`."));
        for (var ae in g) {
          var J = g[ae];
          if (typeof J != "function")
            return D(Z, Y, G, ae, H(J));
          var Q = J(X, ae, Z, Y, G + "." + ae, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return y(j);
    }
    function L(g) {
      function j(W, S, Z, Y, G) {
        var X = W[S], ie = F(X);
        if (ie !== "object")
          return new h("Invalid " + Y + " `" + G + "` of type `" + ie + "` " + ("supplied to `" + Z + "`, expected `object`."));
        var ae = t({}, W[S], g);
        for (var J in ae) {
          var Q = g[J];
          if (r(g, J) && typeof Q != "function")
            return D(Z, Y, G, J, H(Q));
          if (!Q)
            return new h(
              "Invalid " + Y + " `" + G + "` key `" + J + "` supplied to `" + Z + "`.\nBad object: " + JSON.stringify(W[S], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(g), null, "  ")
            );
          var K = Q(X, J, Z, Y, G + "." + J, n);
          if (K)
            return K;
        }
        return null;
      }
      return y(j);
    }
    function R(g) {
      switch (typeof g) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !g;
        case "object":
          if (Array.isArray(g))
            return g.every(R);
          if (g === null || s(g))
            return !0;
          var j = f(g);
          if (j) {
            var W = j.call(g), S;
            if (j !== g.entries) {
              for (; !(S = W.next()).done; )
                if (!R(S.value))
                  return !1;
            } else
              for (; !(S = W.next()).done; ) {
                var Z = S.value;
                if (Z && !R(Z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function A(g, j) {
      return g === "symbol" ? !0 : j ? j["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && j instanceof Symbol : !1;
    }
    function F(g) {
      var j = typeof g;
      return Array.isArray(g) ? "array" : g instanceof RegExp ? "object" : A(j, g) ? "symbol" : j;
    }
    function H(g) {
      if (typeof g > "u" || g === null)
        return "" + g;
      var j = F(g);
      if (j === "object") {
        if (g instanceof Date)
          return "date";
        if (g instanceof RegExp)
          return "regexp";
      }
      return j;
    }
    function V(g) {
      var j = H(g);
      switch (j) {
        case "array":
        case "object":
          return "an " + j;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + j;
        default:
          return j;
      }
    }
    function I(g) {
      return !g.constructor || !g.constructor.name ? d : g.constructor.name;
    }
    return p.checkPropTypes = i, p.resetWarningCache = i.resetWarningCache, p.PropTypes = p, p;
  }, Od;
}
var $d, Tw;
function IB() {
  if (Tw) return $d;
  Tw = 1;
  var e = Lv();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, $d = function() {
    function r(o, s, c, l, u, f) {
      if (f !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var a = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return a.PropTypes = a, a;
  }, $d;
}
if (process.env.NODE_ENV !== "production") {
  var AB = sf(), PB = !0;
  qh.exports = RB()(AB.isElement, PB);
} else
  qh.exports = IB()();
var DB = qh.exports;
const wt = /* @__PURE__ */ Ye(DB);
var jB = /* @__PURE__ */ new Map([
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  ["aac", "audio/aac"],
  ["abw", "application/x-abiword"],
  ["arc", "application/x-freearc"],
  ["avif", "image/avif"],
  ["avi", "video/x-msvideo"],
  ["azw", "application/vnd.amazon.ebook"],
  ["bin", "application/octet-stream"],
  ["bmp", "image/bmp"],
  ["bz", "application/x-bzip"],
  ["bz2", "application/x-bzip2"],
  ["cda", "application/x-cdf"],
  ["csh", "application/x-csh"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["doc", "application/msword"],
  ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
  ["eot", "application/vnd.ms-fontobject"],
  ["epub", "application/epub+zip"],
  ["gz", "application/gzip"],
  ["gif", "image/gif"],
  ["heic", "image/heic"],
  ["heif", "image/heif"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["ico", "image/vnd.microsoft.icon"],
  ["ics", "text/calendar"],
  ["jar", "application/java-archive"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["js", "text/javascript"],
  ["json", "application/json"],
  ["jsonld", "application/ld+json"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["mjs", "text/javascript"],
  ["mp3", "audio/mpeg"],
  ["mp4", "video/mp4"],
  ["mpeg", "video/mpeg"],
  ["mpkg", "application/vnd.apple.installer+xml"],
  ["odp", "application/vnd.oasis.opendocument.presentation"],
  ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
  ["odt", "application/vnd.oasis.opendocument.text"],
  ["oga", "audio/ogg"],
  ["ogv", "video/ogg"],
  ["ogx", "application/ogg"],
  ["opus", "audio/opus"],
  ["otf", "font/otf"],
  ["png", "image/png"],
  ["pdf", "application/pdf"],
  ["php", "application/x-httpd-php"],
  ["ppt", "application/vnd.ms-powerpoint"],
  ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
  ["rar", "application/vnd.rar"],
  ["rtf", "application/rtf"],
  ["sh", "application/x-sh"],
  ["svg", "image/svg+xml"],
  ["swf", "application/x-shockwave-flash"],
  ["tar", "application/x-tar"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["ts", "video/mp2t"],
  ["ttf", "font/ttf"],
  ["txt", "text/plain"],
  ["vsd", "application/vnd.visio"],
  ["wav", "audio/wav"],
  ["weba", "audio/webm"],
  ["webm", "video/webm"],
  ["webp", "image/webp"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["xhtml", "application/xhtml+xml"],
  ["xls", "application/vnd.ms-excel"],
  ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
  ["xml", "application/xml"],
  ["xul", "application/vnd.mozilla.xul+xml"],
  ["zip", "application/zip"],
  ["7z", "application/x-7z-compressed"],
  // Others
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["msg", "application/vnd.ms-outlook"]
]);
function pl(e, t) {
  var n = NB(e);
  if (typeof n.path != "string") {
    var r = e.webkitRelativePath;
    Object.defineProperty(n, "path", {
      value: typeof t == "string" ? t : typeof r == "string" && r.length > 0 ? r : e.name,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return n;
}
function NB(e) {
  var t = e.name, n = t && t.lastIndexOf(".") !== -1;
  if (n && !e.type) {
    var r = t.split(".").pop().toLowerCase(), i = jB.get(r);
    i && Object.defineProperty(e, "type", {
      value: i,
      writable: !1,
      configurable: !1,
      enumerable: !0
    });
  }
  return e;
}
var MB = [
  // Thumbnail cache files for macOS and Windows
  ".DS_Store",
  "Thumbs.db"
  // Windows
];
function FB(e) {
  return bo(this, void 0, void 0, function() {
    return wo(this, function(t) {
      return hu(e) && LB(e.dataTransfer) ? [2, qB(e.dataTransfer, e.type)] : BB(e) ? [2, UB(e)] : Array.isArray(e) && e.every(function(n) {
        return "getFile" in n && typeof n.getFile == "function";
      }) ? [2, zB(e)] : [2, []];
    });
  });
}
function LB(e) {
  return hu(e);
}
function BB(e) {
  return hu(e) && hu(e.target);
}
function hu(e) {
  return typeof e == "object" && e !== null;
}
function UB(e) {
  return Wh(e.target.files).map(function(t) {
    return pl(t);
  });
}
function zB(e) {
  return bo(this, void 0, void 0, function() {
    var t;
    return wo(this, function(n) {
      switch (n.label) {
        case 0:
          return [4, Promise.all(e.map(function(r) {
            return r.getFile();
          }))];
        case 1:
          return t = n.sent(), [2, t.map(function(r) {
            return pl(r);
          })];
      }
    });
  });
}
function qB(e, t) {
  return bo(this, void 0, void 0, function() {
    var n, r;
    return wo(this, function(i) {
      switch (i.label) {
        case 0:
          return e.items ? (n = Wh(e.items).filter(function(a) {
            return a.kind === "file";
          }), t !== "drop" ? [2, n] : [4, Promise.all(n.map(WB))]) : [3, 2];
        case 1:
          return r = i.sent(), [2, Cw($k(r))];
        case 2:
          return [2, Cw(Wh(e.files).map(function(a) {
            return pl(a);
          }))];
      }
    });
  });
}
function Cw(e) {
  return e.filter(function(t) {
    return MB.indexOf(t.name) === -1;
  });
}
function Wh(e) {
  if (e === null)
    return [];
  for (var t = [], n = 0; n < e.length; n++) {
    var r = e[n];
    t.push(r);
  }
  return t;
}
function WB(e) {
  if (typeof e.webkitGetAsEntry != "function")
    return Ow(e);
  var t = e.webkitGetAsEntry();
  return t && t.isDirectory ? Rk(t) : Ow(e);
}
function $k(e) {
  return e.reduce(function(t, n) {
    return Nh(Nh([], zb(t), !1), zb(Array.isArray(n) ? $k(n) : [n]), !1);
  }, []);
}
function Ow(e) {
  var t = e.getAsFile();
  if (!t)
    return Promise.reject("".concat(e, " is not a File"));
  var n = pl(t);
  return Promise.resolve(n);
}
function VB(e) {
  return bo(this, void 0, void 0, function() {
    return wo(this, function(t) {
      return [2, e.isDirectory ? Rk(e) : HB(e)];
    });
  });
}
function Rk(e) {
  var t = e.createReader();
  return new Promise(function(n, r) {
    var i = [];
    function a() {
      var o = this;
      t.readEntries(function(s) {
        return bo(o, void 0, void 0, function() {
          var c, l, u;
          return wo(this, function(f) {
            switch (f.label) {
              case 0:
                if (s.length) return [3, 5];
                f.label = 1;
              case 1:
                return f.trys.push([1, 3, , 4]), [4, Promise.all(i)];
              case 2:
                return c = f.sent(), n(c), [3, 4];
              case 3:
                return l = f.sent(), r(l), [3, 4];
              case 4:
                return [3, 6];
              case 5:
                u = Promise.all(s.map(VB)), i.push(u), a(), f.label = 6;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, function(s) {
        r(s);
      });
    }
    a();
  });
}
function HB(e) {
  return bo(this, void 0, void 0, function() {
    return wo(this, function(t) {
      return [2, new Promise(function(n, r) {
        e.file(function(i) {
          var a = pl(i, e.fullPath);
          n(a);
        }, function(i) {
          r(i);
        });
      })];
    });
  });
}
var ZB = function(e, t) {
  if (e && t) {
    var n = Array.isArray(t) ? t : t.split(",");
    if (n.length === 0)
      return !0;
    var r = e.name || "", i = (e.type || "").toLowerCase(), a = i.replace(/\/.*$/, "");
    return n.some(function(o) {
      var s = o.trim().toLowerCase();
      return s.charAt(0) === "." ? r.toLowerCase().endsWith(s) : s.endsWith("/*") ? a === s.replace(/\/.*$/, "") : i === s;
    });
  }
  return !0;
};
function $w(e) {
  return YB(e) || GB(e) || Ak(e) || KB();
}
function KB() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function GB(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function YB(e) {
  if (Array.isArray(e)) return Vh(e);
}
function Rw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Iw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Rw(Object(n), !0).forEach(function(r) {
      Ik(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Ik(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function Ps(e, t) {
  return QB(e) || XB(e, t) || Ak(e, t) || JB();
}
function JB() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ak(e, t) {
  if (e) {
    if (typeof e == "string") return Vh(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Vh(e, t);
  }
}
function Vh(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function XB(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r = [], i = !0, a = !1, o, s;
    try {
      for (n = n.call(e); !(i = (o = n.next()).done) && (r.push(o.value), !(t && r.length === t)); i = !0)
        ;
    } catch (c) {
      a = !0, s = c;
    } finally {
      try {
        !i && n.return != null && n.return();
      } finally {
        if (a) throw s;
      }
    }
    return r;
  }
}
function QB(e) {
  if (Array.isArray(e)) return e;
}
var e3 = "file-invalid-type", t3 = "file-too-large", n3 = "file-too-small", r3 = "too-many-files", i3 = function(t) {
  t = Array.isArray(t) && t.length === 1 ? t[0] : t;
  var n = Array.isArray(t) ? "one of ".concat(t.join(", ")) : t;
  return {
    code: e3,
    message: "File type must be ".concat(n)
  };
}, Aw = function(t) {
  return {
    code: t3,
    message: "File is larger than ".concat(t, " ").concat(t === 1 ? "byte" : "bytes")
  };
}, Pw = function(t) {
  return {
    code: n3,
    message: "File is smaller than ".concat(t, " ").concat(t === 1 ? "byte" : "bytes")
  };
}, a3 = {
  code: r3,
  message: "Too many files"
};
function Pk(e, t) {
  var n = e.type === "application/x-moz-file" || ZB(e, t);
  return [n, n ? null : i3(t)];
}
function Dk(e, t, n) {
  if (zi(e.size))
    if (zi(t) && zi(n)) {
      if (e.size > n) return [!1, Aw(n)];
      if (e.size < t) return [!1, Pw(t)];
    } else {
      if (zi(t) && e.size < t) return [!1, Pw(t)];
      if (zi(n) && e.size > n) return [!1, Aw(n)];
    }
  return [!0, null];
}
function zi(e) {
  return e != null;
}
function o3(e) {
  var t = e.files, n = e.accept, r = e.minSize, i = e.maxSize, a = e.multiple, o = e.maxFiles, s = e.validator;
  return !a && t.length > 1 || a && o >= 1 && t.length > o ? !1 : t.every(function(c) {
    var l = Pk(c, n), u = Ps(l, 1), f = u[0], d = Dk(c, r, i), p = Ps(d, 1), m = p[0], h = s ? s(c) : null;
    return f && m && !h;
  });
}
function mu(e) {
  return typeof e.isPropagationStopped == "function" ? e.isPropagationStopped() : typeof e.cancelBubble < "u" ? e.cancelBubble : !1;
}
function Xl(e) {
  return e.dataTransfer ? Array.prototype.some.call(e.dataTransfer.types, function(t) {
    return t === "Files" || t === "application/x-moz-file";
  }) : !!e.target && !!e.target.files;
}
function Dw(e) {
  e.preventDefault();
}
function s3(e) {
  return e.indexOf("MSIE") !== -1 || e.indexOf("Trident/") !== -1;
}
function l3(e) {
  return e.indexOf("Edge/") !== -1;
}
function c3() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
  return s3(e) || l3(e);
}
function br() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(r) {
    for (var i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++)
      a[o - 1] = arguments[o];
    return t.some(function(s) {
      return !mu(r) && s && s.apply(void 0, [r].concat(a)), mu(r);
    });
  };
}
function u3() {
  return "showOpenFilePicker" in window;
}
function f3(e) {
  if (zi(e)) {
    var t = Object.entries(e).filter(function(n) {
      var r = Ps(n, 2), i = r[0], a = r[1], o = !0;
      return jk(i) || (console.warn('Skipped "'.concat(i, '" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.')), o = !1), (!Array.isArray(a) || !a.every(Nk)) && (console.warn('Skipped "'.concat(i, '" because an invalid file extension was provided.')), o = !1), o;
    }).reduce(function(n, r) {
      var i = Ps(r, 2), a = i[0], o = i[1];
      return Iw(Iw({}, n), {}, Ik({}, a, o));
    }, {});
    return [{
      // description is required due to https://crbug.com/1264708
      description: "Files",
      accept: t
    }];
  }
  return e;
}
function d3(e) {
  if (zi(e))
    return Object.entries(e).reduce(function(t, n) {
      var r = Ps(n, 2), i = r[0], a = r[1];
      return [].concat($w(t), [i], $w(a));
    }, []).filter(function(t) {
      return jk(t) || Nk(t);
    }).join(",");
}
function p3(e) {
  return e instanceof DOMException && (e.name === "AbortError" || e.code === e.ABORT_ERR);
}
function h3(e) {
  return e instanceof DOMException && (e.name === "SecurityError" || e.code === e.SECURITY_ERR);
}
function jk(e) {
  return e === "audio/*" || e === "video/*" || e === "image/*" || e === "text/*" || /\w+\/[-+.\w]+/g.test(e);
}
function Nk(e) {
  return /^.*\.[\w]+$/.test(e);
}
var m3 = ["children"], v3 = ["open"], y3 = ["refKey", "role", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"], g3 = ["refKey", "onChange", "onClick"];
function b3(e) {
  return S3(e) || x3(e) || Mk(e) || w3();
}
function w3() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function x3(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function S3(e) {
  if (Array.isArray(e)) return Hh(e);
}
function Rd(e, t) {
  return k3(e) || _3(e, t) || Mk(e, t) || E3();
}
function E3() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Mk(e, t) {
  if (e) {
    if (typeof e == "string") return Hh(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set") return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Hh(e, t);
  }
}
function Hh(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function _3(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r = [], i = !0, a = !1, o, s;
    try {
      for (n = n.call(e); !(i = (o = n.next()).done) && (r.push(o.value), !(t && r.length === t)); i = !0)
        ;
    } catch (c) {
      a = !0, s = c;
    } finally {
      try {
        !i && n.return != null && n.return();
      } finally {
        if (a) throw s;
      }
    }
    return r;
  }
}
function k3(e) {
  if (Array.isArray(e)) return e;
}
function jw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function It(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jw(Object(n), !0).forEach(function(r) {
      Zh(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Zh(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function vu(e, t) {
  if (e == null) return {};
  var n = T3(e, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (i = 0; i < a.length; i++)
      r = a[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function T3(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), i, a;
  for (a = 0; a < r.length; a++)
    i = r[a], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
var lf = /* @__PURE__ */ An(function(e, t) {
  var n = e.children, r = vu(e, m3), i = C3(r), a = i.open, o = vu(i, v3);
  return kR(t, function() {
    return {
      open: a
    };
  }, [a]), /* @__PURE__ */ vt.createElement(TR, null, n(It(It({}, o), {}, {
    open: a
  })));
});
lf.displayName = "Dropzone";
var Fk = {
  disabled: !1,
  getFilesFromEvent: FB,
  maxSize: 1 / 0,
  minSize: 0,
  multiple: !0,
  maxFiles: 0,
  preventDropOnDocument: !0,
  noClick: !1,
  noKeyboard: !1,
  noDrag: !1,
  noDragEventsBubbling: !1,
  validator: null,
  useFsAccessApi: !0,
  autoFocus: !1
};
lf.defaultProps = Fk;
lf.propTypes = {
  /**
   * Render function that exposes the dropzone state and prop getter fns
   *
   * @param {object} params
   * @param {Function} params.getRootProps Returns the props you should apply to the root drop container you render
   * @param {Function} params.getInputProps Returns the props you should apply to hidden file input you render
   * @param {Function} params.open Open the native file selection dialog
   * @param {boolean} params.isFocused Dropzone area is in focus
   * @param {boolean} params.isFileDialogActive File dialog is opened
   * @param {boolean} params.isDragActive Active drag is in progress
   * @param {boolean} params.isDragAccept Dragged files are accepted
   * @param {boolean} params.isDragReject Some dragged files are rejected
   * @param {File[]} params.acceptedFiles Accepted files
   * @param {FileRejection[]} params.fileRejections Rejected files and why they were rejected
   */
  children: wt.func,
  /**
   * Set accepted file types.
   * Checkout https://developer.mozilla.org/en-US/docs/Web/API/window/showOpenFilePicker types option for more information.
   * Keep in mind that mime type determination is not reliable across platforms. CSV files,
   * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
   * Windows. In some cases there might not be a mime type set at all (https://github.com/react-dropzone/react-dropzone/issues/276).
   */
  accept: wt.objectOf(wt.arrayOf(wt.string)),
  /**
   * Allow drag 'n' drop (or selection from the file dialog) of multiple files
   */
  multiple: wt.bool,
  /**
   * If false, allow dropped items to take over the current browser window
   */
  preventDropOnDocument: wt.bool,
  /**
   * If true, disables click to open the native file selection dialog
   */
  noClick: wt.bool,
  /**
   * If true, disables SPACE/ENTER to open the native file selection dialog.
   * Note that it also stops tracking the focus state.
   */
  noKeyboard: wt.bool,
  /**
   * If true, disables drag 'n' drop
   */
  noDrag: wt.bool,
  /**
   * If true, stops drag event propagation to parents
   */
  noDragEventsBubbling: wt.bool,
  /**
   * Minimum file size (in bytes)
   */
  minSize: wt.number,
  /**
   * Maximum file size (in bytes)
   */
  maxSize: wt.number,
  /**
   * Maximum accepted number of files
   * The default value is 0 which means there is no limitation to how many files are accepted.
   */
  maxFiles: wt.number,
  /**
   * Enable/disable the dropzone
   */
  disabled: wt.bool,
  /**
   * Use this to provide a custom file aggregator
   *
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  getFilesFromEvent: wt.func,
  /**
   * Cb for when closing the file dialog with no selection
   */
  onFileDialogCancel: wt.func,
  /**
   * Cb for when opening the file dialog
   */
  onFileDialogOpen: wt.func,
  /**
   * Set to true to use the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API
   * to open the file picker instead of using an `<input type="file">` click event.
   */
  useFsAccessApi: wt.bool,
  /**
   * Set to true to focus the root element on render
   */
  autoFocus: wt.bool,
  /**
   * Cb for when the `dragenter` event occurs.
   *
   * @param {DragEvent} event
   */
  onDragEnter: wt.func,
  /**
   * Cb for when the `dragleave` event occurs
   *
   * @param {DragEvent} event
   */
  onDragLeave: wt.func,
  /**
   * Cb for when the `dragover` event occurs
   *
   * @param {DragEvent} event
   */
  onDragOver: wt.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that this callback is invoked after the `getFilesFromEvent` callback is done.
   *
   * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.
   * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.
   * If `multiple` is set to false and additional files are dropped,
   * all files besides the first will be rejected.
   * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.
   *
   * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.
   * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.
   *
   * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.
   * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:
   *
   * ```js
   * function onDrop(acceptedFiles) {
   *   const req = request.post('/upload')
   *   acceptedFiles.forEach(file => {
   *     req.attach(file.name, file)
   *   })
   *   req.end(callback)
   * }
   * ```
   *
   * @param {File[]} acceptedFiles
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  onDrop: wt.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are accepted, this callback is not invoked.
   *
   * @param {File[]} files
   * @param {(DragEvent|Event)} event
   */
  onDropAccepted: wt.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are rejected, this callback is not invoked.
   *
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event
   */
  onDropRejected: wt.func,
  /**
   * Cb for when there's some error from any of the promises.
   *
   * @param {Error} error
   */
  onError: wt.func,
  /**
   * Custom validation function. It must return null if there's no errors.
   * @param {File} file
   * @returns {FileError|FileError[]|null}
   */
  validator: wt.func
};
var Kh = {
  isFocused: !1,
  isFileDialogActive: !1,
  isDragActive: !1,
  isDragAccept: !1,
  isDragReject: !1,
  acceptedFiles: [],
  fileRejections: []
};
function C3() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = It(It({}, Fk), e), n = t.accept, r = t.disabled, i = t.getFilesFromEvent, a = t.maxSize, o = t.minSize, s = t.multiple, c = t.maxFiles, l = t.onDragEnter, u = t.onDragLeave, f = t.onDragOver, d = t.onDrop, p = t.onDropAccepted, m = t.onDropRejected, h = t.onFileDialogCancel, y = t.onFileDialogOpen, v = t.useFsAccessApi, b = t.autoFocus, w = t.preventDropOnDocument, T = t.noClick, E = t.noKeyboard, _ = t.noDrag, $ = t.noDragEventsBubbling, B = t.onError, U = t.validator, k = zt(function() {
    return d3(n);
  }, [n]), D = zt(function() {
    return f3(n);
  }, [n]), q = zt(function() {
    return typeof y == "function" ? y : Nw;
  }, [y]), L = zt(function() {
    return typeof h == "function" ? h : Nw;
  }, [h]), R = Tt(null), A = Tt(null), F = CR(O3, Kh), H = Rd(F, 2), V = H[0], I = H[1], g = V.isFocused, j = V.isFileDialogActive, W = Tt(typeof window < "u" && window.isSecureContext && v && u3()), S = function() {
    !W.current && j && setTimeout(function() {
      if (A.current) {
        var ue = A.current.files;
        ue.length || (I({
          type: "closeDialog"
        }), L());
      }
    }, 300);
  };
  Pt(function() {
    return window.addEventListener("focus", S, !1), function() {
      window.removeEventListener("focus", S, !1);
    };
  }, [A, j, L, W]);
  var Z = Tt([]), Y = function(ue) {
    R.current && R.current.contains(ue.target) || (ue.preventDefault(), Z.current = []);
  };
  Pt(function() {
    return w && (document.addEventListener("dragover", Dw, !1), document.addEventListener("drop", Y, !1)), function() {
      w && (document.removeEventListener("dragover", Dw), document.removeEventListener("drop", Y));
    };
  }, [R, w]), Pt(function() {
    return !r && b && R.current && R.current.focus(), function() {
    };
  }, [R, b, r]);
  var G = ot(function(ee) {
    B ? B(ee) : console.error(ee);
  }, [B]), X = ot(function(ee) {
    ee.preventDefault(), ee.persist(), Te(ee), Z.current = [].concat(b3(Z.current), [ee.target]), Xl(ee) && Promise.resolve(i(ee)).then(function(ue) {
      if (!(mu(ee) && !$)) {
        var z = ue.length, N = z > 0 && o3({
          files: ue,
          accept: k,
          minSize: o,
          maxSize: a,
          multiple: s,
          maxFiles: c,
          validator: U
        }), te = z > 0 && !N;
        I({
          isDragAccept: N,
          isDragReject: te,
          isDragActive: !0,
          type: "setDraggedFiles"
        }), l && l(ee);
      }
    }).catch(function(ue) {
      return G(ue);
    });
  }, [i, l, G, $, k, o, a, s, c, U]), ie = ot(function(ee) {
    ee.preventDefault(), ee.persist(), Te(ee);
    var ue = Xl(ee);
    if (ue && ee.dataTransfer)
      try {
        ee.dataTransfer.dropEffect = "copy";
      } catch {
      }
    return ue && f && f(ee), !1;
  }, [f, $]), ae = ot(function(ee) {
    ee.preventDefault(), ee.persist(), Te(ee);
    var ue = Z.current.filter(function(N) {
      return R.current && R.current.contains(N);
    }), z = ue.indexOf(ee.target);
    z !== -1 && ue.splice(z, 1), Z.current = ue, !(ue.length > 0) && (I({
      type: "setDraggedFiles",
      isDragActive: !1,
      isDragAccept: !1,
      isDragReject: !1
    }), Xl(ee) && u && u(ee));
  }, [R, u, $]), J = ot(function(ee, ue) {
    var z = [], N = [];
    ee.forEach(function(te) {
      var de = Pk(te, k), be = Rd(de, 2), Oe = be[0], Ve = be[1], Qe = Dk(te, o, a), Ct = Rd(Qe, 2), _t = Ct[0], Ue = Ct[1], kt = U ? U(te) : null;
      if (Oe && _t && !kt)
        z.push(te);
      else {
        var Ze = [Ve, Ue];
        kt && (Ze = Ze.concat(kt)), N.push({
          file: te,
          errors: Ze.filter(function(fn) {
            return fn;
          })
        });
      }
    }), (!s && z.length > 1 || s && c >= 1 && z.length > c) && (z.forEach(function(te) {
      N.push({
        file: te,
        errors: [a3]
      });
    }), z.splice(0)), I({
      acceptedFiles: z,
      fileRejections: N,
      type: "setFiles"
    }), d && d(z, N, ue), N.length > 0 && m && m(N, ue), z.length > 0 && p && p(z, ue);
  }, [I, s, k, o, a, c, d, p, m, U]), Q = ot(function(ee) {
    ee.preventDefault(), ee.persist(), Te(ee), Z.current = [], Xl(ee) && Promise.resolve(i(ee)).then(function(ue) {
      mu(ee) && !$ || J(ue, ee);
    }).catch(function(ue) {
      return G(ue);
    }), I({
      type: "reset"
    });
  }, [i, J, G, $]), K = ot(function() {
    if (W.current) {
      I({
        type: "openDialog"
      }), q();
      var ee = {
        multiple: s,
        types: D
      };
      window.showOpenFilePicker(ee).then(function(ue) {
        return i(ue);
      }).then(function(ue) {
        J(ue, null), I({
          type: "closeDialog"
        });
      }).catch(function(ue) {
        p3(ue) ? (L(ue), I({
          type: "closeDialog"
        })) : h3(ue) ? (W.current = !1, A.current ? (A.current.value = null, A.current.click()) : G(new Error("Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."))) : G(ue);
      });
      return;
    }
    A.current && (I({
      type: "openDialog"
    }), q(), A.current.value = null, A.current.click());
  }, [I, q, L, v, J, G, D, s]), fe = ot(function(ee) {
    !R.current || !R.current.isEqualNode(ee.target) || (ee.key === " " || ee.key === "Enter" || ee.keyCode === 32 || ee.keyCode === 13) && (ee.preventDefault(), K());
  }, [R, K]), ye = ot(function() {
    I({
      type: "focus"
    });
  }, []), $e = ot(function() {
    I({
      type: "blur"
    });
  }, []), M = ot(function() {
    T || (c3() ? setTimeout(K, 0) : K());
  }, [T, K]), re = function(ue) {
    return r ? null : ue;
  }, le = function(ue) {
    return E ? null : re(ue);
  }, oe = function(ue) {
    return _ ? null : re(ue);
  }, Te = function(ue) {
    $ && ue.stopPropagation();
  }, Se = zt(function() {
    return function() {
      var ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ue = ee.refKey, z = ue === void 0 ? "ref" : ue, N = ee.role, te = ee.onKeyDown, de = ee.onFocus, be = ee.onBlur, Oe = ee.onClick, Ve = ee.onDragEnter, Qe = ee.onDragOver, Ct = ee.onDragLeave, _t = ee.onDrop, Ue = vu(ee, y3);
      return It(It(Zh({
        onKeyDown: le(br(te, fe)),
        onFocus: le(br(de, ye)),
        onBlur: le(br(be, $e)),
        onClick: re(br(Oe, M)),
        onDragEnter: oe(br(Ve, X)),
        onDragOver: oe(br(Qe, ie)),
        onDragLeave: oe(br(Ct, ae)),
        onDrop: oe(br(_t, Q)),
        role: typeof N == "string" && N !== "" ? N : "presentation"
      }, z, R), !r && !E ? {
        tabIndex: 0
      } : {}), Ue);
    };
  }, [R, fe, ye, $e, M, X, ie, ae, Q, E, _, r]), Re = ot(function(ee) {
    ee.stopPropagation();
  }, []), ze = zt(function() {
    return function() {
      var ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, ue = ee.refKey, z = ue === void 0 ? "ref" : ue, N = ee.onChange, te = ee.onClick, de = vu(ee, g3), be = Zh({
        accept: k,
        multiple: s,
        type: "file",
        style: {
          display: "none"
        },
        onChange: re(br(N, Q)),
        onClick: re(br(te, Re)),
        tabIndex: -1
      }, z, A);
      return It(It({}, be), de);
    };
  }, [A, n, s, Q, r]);
  return It(It({}, V), {}, {
    isFocused: g && !r,
    getRootProps: Se,
    getInputProps: ze,
    rootRef: R,
    inputRef: A,
    open: re(K)
  });
}
function O3(e, t) {
  switch (t.type) {
    case "focus":
      return It(It({}, e), {}, {
        isFocused: !0
      });
    case "blur":
      return It(It({}, e), {}, {
        isFocused: !1
      });
    case "openDialog":
      return It(It({}, Kh), {}, {
        isFileDialogActive: !0
      });
    case "closeDialog":
      return It(It({}, e), {}, {
        isFileDialogActive: !1
      });
    case "setDraggedFiles":
      return It(It({}, e), {}, {
        isDragActive: t.isDragActive,
        isDragAccept: t.isDragAccept,
        isDragReject: t.isDragReject
      });
    case "setFiles":
      return It(It({}, e), {}, {
        acceptedFiles: t.acceptedFiles,
        fileRejections: t.fileRejections
      });
    case "reset":
      return It({}, Kh);
    default:
      return e;
  }
}
function Nw() {
}
const Mw = ({ children: e }) => {
  const [t, n] = He(!1), [r, i] = He(""), [a, o] = He(null), s = ({ title: l, content: u }) => {
    i(l), o(u), n(!0);
  }, c = () => {
    n(!1);
  };
  return /* @__PURE__ */ O.jsxs(N_.Provider, { value: { hideModal: c, showModal: s, title: r, content: a, open: t }, children: [
    /* @__PURE__ */ O.jsx(ra, { open: t, onOpenChange: n, children: /* @__PURE__ */ O.jsx(ra.Content, { title: r, children: a }) }),
    e
  ] });
}, $3 = ({ color: e, fontFamily: t, radius: n, themeMode: r, variant: i }) => {
  const a = zt(
    () => RA({ color: e, fontFamily: t, radius: n, themeMode: r, variant: i }),
    [e, t, n, r, i]
  );
  return /* @__PURE__ */ O.jsx("style", { children: a });
};
function Xr(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
function Fw(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function Lk(...e) {
  return (t) => {
    let n = !1;
    const r = e.map((i) => {
      const a = Fw(i, t);
      return !n && typeof a == "function" && (n = !0), a;
    });
    if (n)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const a = r[i];
          typeof a == "function" ? a() : Fw(e[i], null);
        }
      };
  };
}
function Di(...e) {
  return x.useCallback(Lk(...e), e);
}
function R3(e, t) {
  const n = x.createContext(t), r = (a) => {
    const { children: o, ...s } = a, c = x.useMemo(() => s, Object.values(s));
    return /* @__PURE__ */ O.jsx(n.Provider, { value: c, children: o });
  };
  r.displayName = e + "Provider";
  function i(a) {
    const o = x.useContext(n);
    if (o) return o;
    if (t !== void 0) return t;
    throw new Error(`\`${a}\` must be used within \`${e}\``);
  }
  return [r, i];
}
function Bk(e, t = []) {
  let n = [];
  function r(a, o) {
    const s = x.createContext(o), c = n.length;
    n = [...n, o];
    const l = (f) => {
      var v;
      const { scope: d, children: p, ...m } = f, h = ((v = d == null ? void 0 : d[e]) == null ? void 0 : v[c]) || s, y = x.useMemo(() => m, Object.values(m));
      return /* @__PURE__ */ O.jsx(h.Provider, { value: y, children: p });
    };
    l.displayName = a + "Provider";
    function u(f, d) {
      var h;
      const p = ((h = d == null ? void 0 : d[e]) == null ? void 0 : h[c]) || s, m = x.useContext(p);
      if (m) return m;
      if (o !== void 0) return o;
      throw new Error(`\`${f}\` must be used within \`${a}\``);
    }
    return [l, u];
  }
  const i = () => {
    const a = n.map((o) => x.createContext(o));
    return function(s) {
      const c = (s == null ? void 0 : s[e]) || a;
      return x.useMemo(
        () => ({ [`__scope${e}`]: { ...s, [e]: c } }),
        [s, c]
      );
    };
  };
  return i.scopeName = e, [r, I3(i, ...t)];
}
function I3(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(a) {
      const o = r.reduce((s, { useScope: c, scopeName: l }) => {
        const f = c(a)[`__scope${l}`];
        return { ...s, ...f };
      }, {});
      return x.useMemo(() => ({ [`__scope${t.scopeName}`]: o }), [o]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
var A3 = x.useId || (() => {
}), P3 = 0;
function Cc(e) {
  const [t, n] = x.useState(A3());
  return Za(() => {
    e || n((r) => r ?? String(P3++));
  }, [e]), e || (t ? `radix-${t}` : "");
}
function Uk({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [r, i] = D3({ defaultProp: t, onChange: n }), a = e !== void 0, o = a ? e : r, s = _i(n), c = x.useCallback(
    (l) => {
      if (a) {
        const f = typeof l == "function" ? l(e) : l;
        f !== e && s(f);
      } else
        i(l);
    },
    [a, e, i, s]
  );
  return [o, c];
}
function D3({
  defaultProp: e,
  onChange: t
}) {
  const n = x.useState(e), [r] = n, i = x.useRef(r), a = _i(t);
  return x.useEffect(() => {
    i.current !== r && (a(r), i.current = r);
  }, [r, i, a]), n;
}
var Bv = x.forwardRef((e, t) => {
  const { children: n, ...r } = e, i = x.Children.toArray(n), a = i.find(N3);
  if (a) {
    const o = a.props.children, s = i.map((c) => c === a ? x.Children.count(o) > 1 ? x.Children.only(null) : x.isValidElement(o) ? o.props.children : null : c);
    return /* @__PURE__ */ O.jsx(Gh, { ...r, ref: t, children: x.isValidElement(o) ? x.cloneElement(o, void 0, s) : null });
  }
  return /* @__PURE__ */ O.jsx(Gh, { ...r, ref: t, children: n });
});
Bv.displayName = "Slot";
var Gh = x.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  if (x.isValidElement(n)) {
    const i = F3(n);
    return x.cloneElement(n, {
      ...M3(r, n.props),
      // @ts-ignore
      ref: t ? Lk(t, i) : i
    });
  }
  return x.Children.count(n) > 1 ? x.Children.only(null) : null;
});
Gh.displayName = "SlotClone";
var j3 = ({ children: e }) => /* @__PURE__ */ O.jsx(O.Fragment, { children: e });
function N3(e) {
  return x.isValidElement(e) && e.type === j3;
}
function M3(e, t) {
  const n = { ...t };
  for (const r in t) {
    const i = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? i && a ? n[r] = (...s) => {
      a(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = { ...i, ...a } : r === "className" && (n[r] = [i, a].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function F3(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var L3 = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], mr = L3.reduce((e, t) => {
  const n = x.forwardRef((r, i) => {
    const { asChild: a, ...o } = r, s = a ? Bv : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ O.jsx(s, { ...o, ref: i });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {});
function B3(e, t) {
  e && MS.flushSync(() => e.dispatchEvent(t));
}
function U3(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = _i(e);
  x.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var z3 = "DismissableLayer", Yh = "dismissableLayer.update", q3 = "dismissableLayer.pointerDownOutside", W3 = "dismissableLayer.focusOutside", Lw, zk = x.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), qk = x.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: a,
      onInteractOutside: o,
      onDismiss: s,
      ...c
    } = e, l = x.useContext(zk), [u, f] = x.useState(null), d = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, p] = x.useState({}), m = Di(t, ($) => f($)), h = Array.from(l.layers), [y] = [...l.layersWithOutsidePointerEventsDisabled].slice(-1), v = h.indexOf(y), b = u ? h.indexOf(u) : -1, w = l.layersWithOutsidePointerEventsDisabled.size > 0, T = b >= v, E = Z3(($) => {
      const B = $.target, U = [...l.branches].some((k) => k.contains(B));
      !T || U || (i == null || i($), o == null || o($), $.defaultPrevented || s == null || s());
    }, d), _ = K3(($) => {
      const B = $.target;
      [...l.branches].some((k) => k.contains(B)) || (a == null || a($), o == null || o($), $.defaultPrevented || s == null || s());
    }, d);
    return U3(($) => {
      b === l.layers.size - 1 && (r == null || r($), !$.defaultPrevented && s && ($.preventDefault(), s()));
    }, d), x.useEffect(() => {
      if (u)
        return n && (l.layersWithOutsidePointerEventsDisabled.size === 0 && (Lw = d.body.style.pointerEvents, d.body.style.pointerEvents = "none"), l.layersWithOutsidePointerEventsDisabled.add(u)), l.layers.add(u), Bw(), () => {
          n && l.layersWithOutsidePointerEventsDisabled.size === 1 && (d.body.style.pointerEvents = Lw);
        };
    }, [u, d, n, l]), x.useEffect(() => () => {
      u && (l.layers.delete(u), l.layersWithOutsidePointerEventsDisabled.delete(u), Bw());
    }, [u, l]), x.useEffect(() => {
      const $ = () => p({});
      return document.addEventListener(Yh, $), () => document.removeEventListener(Yh, $);
    }, []), /* @__PURE__ */ O.jsx(
      mr.div,
      {
        ...c,
        ref: m,
        style: {
          pointerEvents: w ? T ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Xr(e.onFocusCapture, _.onFocusCapture),
        onBlurCapture: Xr(e.onBlurCapture, _.onBlurCapture),
        onPointerDownCapture: Xr(
          e.onPointerDownCapture,
          E.onPointerDownCapture
        )
      }
    );
  }
);
qk.displayName = z3;
var V3 = "DismissableLayerBranch", H3 = x.forwardRef((e, t) => {
  const n = x.useContext(zk), r = x.useRef(null), i = Di(t, r);
  return x.useEffect(() => {
    const a = r.current;
    if (a)
      return n.branches.add(a), () => {
        n.branches.delete(a);
      };
  }, [n.branches]), /* @__PURE__ */ O.jsx(mr.div, { ...e, ref: i });
});
H3.displayName = V3;
function Z3(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = _i(e), r = x.useRef(!1), i = x.useRef(() => {
  });
  return x.useEffect(() => {
    const a = (s) => {
      if (s.target && !r.current) {
        let c = function() {
          Wk(
            q3,
            n,
            l,
            { discrete: !0 }
          );
        };
        const l = { originalEvent: s };
        s.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = c, t.addEventListener("click", i.current, { once: !0 })) : c();
      } else
        t.removeEventListener("click", i.current);
      r.current = !1;
    }, o = window.setTimeout(() => {
      t.addEventListener("pointerdown", a);
    }, 0);
    return () => {
      window.clearTimeout(o), t.removeEventListener("pointerdown", a), t.removeEventListener("click", i.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function K3(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = _i(e), r = x.useRef(!1);
  return x.useEffect(() => {
    const i = (a) => {
      a.target && !r.current && Wk(W3, n, { originalEvent: a }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function Bw() {
  const e = new CustomEvent(Yh);
  document.dispatchEvent(e);
}
function Wk(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, a = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && i.addEventListener(e, t, { once: !0 }), r ? B3(i, a) : i.dispatchEvent(a);
}
var Id = "focusScope.autoFocusOnMount", Ad = "focusScope.autoFocusOnUnmount", Uw = { bubbles: !1, cancelable: !0 }, G3 = "FocusScope", Vk = x.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: a,
    ...o
  } = e, [s, c] = x.useState(null), l = _i(i), u = _i(a), f = x.useRef(null), d = Di(t, (h) => c(h)), p = x.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  x.useEffect(() => {
    if (r) {
      let h = function(w) {
        if (p.paused || !s) return;
        const T = w.target;
        s.contains(T) ? f.current = T : di(f.current, { select: !0 });
      }, y = function(w) {
        if (p.paused || !s) return;
        const T = w.relatedTarget;
        T !== null && (s.contains(T) || di(f.current, { select: !0 }));
      }, v = function(w) {
        if (document.activeElement === document.body)
          for (const E of w)
            E.removedNodes.length > 0 && di(s);
      };
      document.addEventListener("focusin", h), document.addEventListener("focusout", y);
      const b = new MutationObserver(v);
      return s && b.observe(s, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", h), document.removeEventListener("focusout", y), b.disconnect();
      };
    }
  }, [r, s, p.paused]), x.useEffect(() => {
    if (s) {
      qw.add(p);
      const h = document.activeElement;
      if (!s.contains(h)) {
        const v = new CustomEvent(Id, Uw);
        s.addEventListener(Id, l), s.dispatchEvent(v), v.defaultPrevented || (Y3(tU(Hk(s)), { select: !0 }), document.activeElement === h && di(s));
      }
      return () => {
        s.removeEventListener(Id, l), setTimeout(() => {
          const v = new CustomEvent(Ad, Uw);
          s.addEventListener(Ad, u), s.dispatchEvent(v), v.defaultPrevented || di(h ?? document.body, { select: !0 }), s.removeEventListener(Ad, u), qw.remove(p);
        }, 0);
      };
    }
  }, [s, l, u, p]);
  const m = x.useCallback(
    (h) => {
      if (!n && !r || p.paused) return;
      const y = h.key === "Tab" && !h.altKey && !h.ctrlKey && !h.metaKey, v = document.activeElement;
      if (y && v) {
        const b = h.currentTarget, [w, T] = J3(b);
        w && T ? !h.shiftKey && v === T ? (h.preventDefault(), n && di(w, { select: !0 })) : h.shiftKey && v === w && (h.preventDefault(), n && di(T, { select: !0 })) : v === b && h.preventDefault();
      }
    },
    [n, r, p.paused]
  );
  return /* @__PURE__ */ O.jsx(mr.div, { tabIndex: -1, ...o, ref: d, onKeyDown: m });
});
Vk.displayName = G3;
function Y3(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (di(r, { select: t }), document.activeElement !== n) return;
}
function J3(e) {
  const t = Hk(e), n = zw(t, e), r = zw(t.reverse(), e);
  return [n, r];
}
function Hk(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function zw(e, t) {
  for (const n of e)
    if (!X3(n, { upTo: t })) return n;
}
function X3(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function Q3(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function di(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && Q3(e) && t && e.select();
  }
}
var qw = eU();
function eU() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = Ww(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = Ww(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function Ww(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function tU(e) {
  return e.filter((t) => t.tagName !== "A");
}
function nU(e, t) {
  return x.useReducer((n, r) => t[n][r] ?? n, e);
}
var cf = (e) => {
  const { present: t, children: n } = e, r = rU(t), i = typeof n == "function" ? n({ present: r.isPresent }) : x.Children.only(n), a = Di(r.ref, iU(i));
  return typeof n == "function" || r.isPresent ? x.cloneElement(i, { ref: a }) : null;
};
cf.displayName = "Presence";
function rU(e) {
  const [t, n] = x.useState(), r = x.useRef({}), i = x.useRef(e), a = x.useRef("none"), o = e ? "mounted" : "unmounted", [s, c] = nU(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return x.useEffect(() => {
    const l = Ql(r.current);
    a.current = s === "mounted" ? l : "none";
  }, [s]), Za(() => {
    const l = r.current, u = i.current;
    if (u !== e) {
      const d = a.current, p = Ql(l);
      e ? c("MOUNT") : p === "none" || (l == null ? void 0 : l.display) === "none" ? c("UNMOUNT") : c(u && d !== p ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [e, c]), Za(() => {
    if (t) {
      let l;
      const u = t.ownerDocument.defaultView ?? window, f = (p) => {
        const h = Ql(r.current).includes(p.animationName);
        if (p.target === t && h && (c("ANIMATION_END"), !i.current)) {
          const y = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", l = u.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = y);
          });
        }
      }, d = (p) => {
        p.target === t && (a.current = Ql(r.current));
      };
      return t.addEventListener("animationstart", d), t.addEventListener("animationcancel", f), t.addEventListener("animationend", f), () => {
        u.clearTimeout(l), t.removeEventListener("animationstart", d), t.removeEventListener("animationcancel", f), t.removeEventListener("animationend", f);
      };
    } else
      c("ANIMATION_END");
  }, [t, c]), {
    isPresent: ["mounted", "unmountSuspended"].includes(s),
    ref: x.useCallback((l) => {
      l && (r.current = getComputedStyle(l)), n(l);
    }, [])
  };
}
function Ql(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function iU(e) {
  var r, i;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (i = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : i.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Pd = 0;
function aU() {
  x.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? Vw()), document.body.insertAdjacentElement("beforeend", e[1] ?? Vw()), Pd++, () => {
      Pd === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), Pd--;
    };
  }, []);
}
function Vw() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Oc = "right-scroll-bar-position", $c = "width-before-scroll-bar", oU = "with-scroll-bars-hidden", sU = "--removed-body-scroll-bar-size";
function Dd(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function lU(e, t) {
  var n = He(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var cU = typeof window < "u" ? x.useLayoutEffect : x.useEffect, Hw = /* @__PURE__ */ new WeakMap();
function uU(e, t) {
  var n = lU(null, function(r) {
    return e.forEach(function(i) {
      return Dd(i, r);
    });
  });
  return cU(function() {
    var r = Hw.get(n);
    if (r) {
      var i = new Set(r), a = new Set(e), o = n.current;
      i.forEach(function(s) {
        a.has(s) || Dd(s, null);
      }), a.forEach(function(s) {
        i.has(s) || Dd(s, o);
      });
    }
    Hw.set(n, e);
  }, [e]), n;
}
function fU(e) {
  return e;
}
function dU(e, t) {
  t === void 0 && (t = fU);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(a) {
      var o = t(a, r);
      return n.push(o), function() {
        n = n.filter(function(s) {
          return s !== o;
        });
      };
    },
    assignSyncMedium: function(a) {
      for (r = !0; n.length; ) {
        var o = n;
        n = [], o.forEach(a);
      }
      n = {
        push: function(s) {
          return a(s);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(a) {
      r = !0;
      var o = [];
      if (n.length) {
        var s = n;
        n = [], s.forEach(a), o = n;
      }
      var c = function() {
        var u = o;
        o = [], u.forEach(a);
      }, l = function() {
        return Promise.resolve().then(c);
      };
      l(), n = {
        push: function(u) {
          o.push(u), l();
        },
        filter: function(u) {
          return o = o.filter(u), n;
        }
      };
    }
  };
  return i;
}
function pU(e) {
  e === void 0 && (e = {});
  var t = dU(null);
  return t.options = Zn({ async: !0, ssr: !1 }, e), t;
}
var Zk = function(e) {
  var t = e.sideCar, n = F_(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return x.createElement(r, Zn({}, n));
};
Zk.isSideCarExport = !0;
function hU(e, t) {
  return e.useMedium(t), Zk;
}
var Kk = pU(), jd = function() {
}, uf = x.forwardRef(function(e, t) {
  var n = x.useRef(null), r = x.useState({
    onScrollCapture: jd,
    onWheelCapture: jd,
    onTouchMoveCapture: jd
  }), i = r[0], a = r[1], o = e.forwardProps, s = e.children, c = e.className, l = e.removeScrollBar, u = e.enabled, f = e.shards, d = e.sideCar, p = e.noIsolation, m = e.inert, h = e.allowPinchZoom, y = e.as, v = y === void 0 ? "div" : y, b = e.gapMode, w = F_(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), T = d, E = uU([n, t]), _ = Zn(Zn({}, w), i);
  return x.createElement(
    x.Fragment,
    null,
    u && x.createElement(T, { sideCar: Kk, removeScrollBar: l, shards: f, noIsolation: p, inert: m, setCallbacks: a, allowPinchZoom: !!h, lockRef: n, gapMode: b }),
    o ? x.cloneElement(x.Children.only(s), Zn(Zn({}, _), { ref: E })) : x.createElement(v, Zn({}, _, { className: c, ref: E }), s)
  );
});
uf.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
uf.classNames = {
  fullWidth: $c,
  zeroRight: Oc
};
var mU = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function vU() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = mU();
  return t && e.setAttribute("nonce", t), e;
}
function yU(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function gU(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var bU = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = vU()) && (yU(t, n), gU(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, wU = function() {
  var e = bU();
  return function(t, n) {
    x.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, Gk = function() {
  var e = wU(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, xU = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Nd = function(e) {
  return parseInt(e || "", 10) || 0;
}, SU = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [Nd(n), Nd(r), Nd(i)];
}, EU = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return xU;
  var t = SU(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, _U = Gk(), za = "data-scroll-locked", kU = function(e, t, n, r) {
  var i = e.left, a = e.top, o = e.right, s = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(oU, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(s, "px ").concat(r, `;
  }
  body[`).concat(za, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Oc, ` {
    right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat($c, ` {
    margin-right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(Oc, " .").concat(Oc, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat($c, " .").concat($c, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(za, `] {
    `).concat(sU, ": ").concat(s, `px;
  }
`);
}, Zw = function() {
  var e = parseInt(document.body.getAttribute(za) || "0", 10);
  return isFinite(e) ? e : 0;
}, TU = function() {
  x.useEffect(function() {
    return document.body.setAttribute(za, (Zw() + 1).toString()), function() {
      var e = Zw() - 1;
      e <= 0 ? document.body.removeAttribute(za) : document.body.setAttribute(za, e.toString());
    };
  }, []);
}, CU = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r;
  TU();
  var a = x.useMemo(function() {
    return EU(i);
  }, [i]);
  return x.createElement(_U, { styles: kU(a, !t, i, n ? "" : "!important") });
}, Jh = !1;
if (typeof window < "u")
  try {
    var ec = Object.defineProperty({}, "passive", {
      get: function() {
        return Jh = !0, !0;
      }
    });
    window.addEventListener("test", ec, ec), window.removeEventListener("test", ec, ec);
  } catch {
    Jh = !1;
  }
var ya = Jh ? { passive: !1 } : !1, OU = function(e) {
  return e.tagName === "TEXTAREA";
}, Yk = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !OU(e) && n[t] === "visible")
  );
}, $U = function(e) {
  return Yk(e, "overflowY");
}, RU = function(e) {
  return Yk(e, "overflowX");
}, Kw = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = Jk(e, r);
    if (i) {
      var a = Xk(e, r), o = a[1], s = a[2];
      if (o > s)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, IU = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, AU = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, Jk = function(e, t) {
  return e === "v" ? $U(t) : RU(t);
}, Xk = function(e, t) {
  return e === "v" ? IU(t) : AU(t);
}, PU = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, DU = function(e, t, n, r, i) {
  var a = PU(e, window.getComputedStyle(t).direction), o = a * r, s = n.target, c = t.contains(s), l = !1, u = o > 0, f = 0, d = 0;
  do {
    var p = Xk(e, s), m = p[0], h = p[1], y = p[2], v = h - y - a * m;
    (m || v) && Jk(e, s) && (f += v, d += m), s instanceof ShadowRoot ? s = s.host : s = s.parentNode;
  } while (
    // portaled content
    !c && s !== document.body || // self content
    c && (t.contains(s) || t === s)
  );
  return (u && (Math.abs(f) < 1 || !i) || !u && (Math.abs(d) < 1 || !i)) && (l = !0), l;
}, tc = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, Gw = function(e) {
  return [e.deltaX, e.deltaY];
}, Yw = function(e) {
  return e && "current" in e ? e.current : e;
}, jU = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, NU = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, MU = 0, ga = [];
function FU(e) {
  var t = x.useRef([]), n = x.useRef([0, 0]), r = x.useRef(), i = x.useState(MU++)[0], a = x.useState(Gk)[0], o = x.useRef(e);
  x.useEffect(function() {
    o.current = e;
  }, [e]), x.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var h = Nh([e.lockRef.current], (e.shards || []).map(Yw), !0).filter(Boolean);
      return h.forEach(function(y) {
        return y.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), h.forEach(function(y) {
          return y.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var s = x.useCallback(function(h, y) {
    if ("touches" in h && h.touches.length === 2 || h.type === "wheel" && h.ctrlKey)
      return !o.current.allowPinchZoom;
    var v = tc(h), b = n.current, w = "deltaX" in h ? h.deltaX : b[0] - v[0], T = "deltaY" in h ? h.deltaY : b[1] - v[1], E, _ = h.target, $ = Math.abs(w) > Math.abs(T) ? "h" : "v";
    if ("touches" in h && $ === "h" && _.type === "range")
      return !1;
    var B = Kw($, _);
    if (!B)
      return !0;
    if (B ? E = $ : (E = $ === "v" ? "h" : "v", B = Kw($, _)), !B)
      return !1;
    if (!r.current && "changedTouches" in h && (w || T) && (r.current = E), !E)
      return !0;
    var U = r.current || E;
    return DU(U, y, h, U === "h" ? w : T, !0);
  }, []), c = x.useCallback(function(h) {
    var y = h;
    if (!(!ga.length || ga[ga.length - 1] !== a)) {
      var v = "deltaY" in y ? Gw(y) : tc(y), b = t.current.filter(function(E) {
        return E.name === y.type && (E.target === y.target || y.target === E.shadowParent) && jU(E.delta, v);
      })[0];
      if (b && b.should) {
        y.cancelable && y.preventDefault();
        return;
      }
      if (!b) {
        var w = (o.current.shards || []).map(Yw).filter(Boolean).filter(function(E) {
          return E.contains(y.target);
        }), T = w.length > 0 ? s(y, w[0]) : !o.current.noIsolation;
        T && y.cancelable && y.preventDefault();
      }
    }
  }, []), l = x.useCallback(function(h, y, v, b) {
    var w = { name: h, delta: y, target: v, should: b, shadowParent: LU(v) };
    t.current.push(w), setTimeout(function() {
      t.current = t.current.filter(function(T) {
        return T !== w;
      });
    }, 1);
  }, []), u = x.useCallback(function(h) {
    n.current = tc(h), r.current = void 0;
  }, []), f = x.useCallback(function(h) {
    l(h.type, Gw(h), h.target, s(h, e.lockRef.current));
  }, []), d = x.useCallback(function(h) {
    l(h.type, tc(h), h.target, s(h, e.lockRef.current));
  }, []);
  x.useEffect(function() {
    return ga.push(a), e.setCallbacks({
      onScrollCapture: f,
      onWheelCapture: f,
      onTouchMoveCapture: d
    }), document.addEventListener("wheel", c, ya), document.addEventListener("touchmove", c, ya), document.addEventListener("touchstart", u, ya), function() {
      ga = ga.filter(function(h) {
        return h !== a;
      }), document.removeEventListener("wheel", c, ya), document.removeEventListener("touchmove", c, ya), document.removeEventListener("touchstart", u, ya);
    };
  }, []);
  var p = e.removeScrollBar, m = e.inert;
  return x.createElement(
    x.Fragment,
    null,
    m ? x.createElement(a, { styles: NU(i) }) : null,
    p ? x.createElement(CU, { gapMode: e.gapMode }) : null
  );
}
function LU(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const BU = hU(Kk, FU);
var Qk = x.forwardRef(function(e, t) {
  return x.createElement(uf, Zn({}, e, { ref: t, sideCar: BU }));
});
Qk.classNames = uf.classNames;
var UU = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, ba = /* @__PURE__ */ new WeakMap(), nc = /* @__PURE__ */ new WeakMap(), rc = {}, Md = 0, eT = function(e) {
  return e && (e.host || eT(e.parentNode));
}, zU = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = eT(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, qU = function(e, t, n, r) {
  var i = zU(t, Array.isArray(e) ? e : [e]);
  rc[n] || (rc[n] = /* @__PURE__ */ new WeakMap());
  var a = rc[n], o = [], s = /* @__PURE__ */ new Set(), c = new Set(i), l = function(f) {
    !f || s.has(f) || (s.add(f), l(f.parentNode));
  };
  i.forEach(l);
  var u = function(f) {
    !f || c.has(f) || Array.prototype.forEach.call(f.children, function(d) {
      if (s.has(d))
        u(d);
      else
        try {
          var p = d.getAttribute(r), m = p !== null && p !== "false", h = (ba.get(d) || 0) + 1, y = (a.get(d) || 0) + 1;
          ba.set(d, h), a.set(d, y), o.push(d), h === 1 && m && nc.set(d, !0), y === 1 && d.setAttribute(n, "true"), m || d.setAttribute(r, "true");
        } catch (v) {
          console.error("aria-hidden: cannot operate on ", d, v);
        }
    });
  };
  return u(t), s.clear(), Md++, function() {
    o.forEach(function(f) {
      var d = ba.get(f) - 1, p = a.get(f) - 1;
      ba.set(f, d), a.set(f, p), d || (nc.has(f) || f.removeAttribute(r), nc.delete(f)), p || f.removeAttribute(n);
    }), Md--, Md || (ba = /* @__PURE__ */ new WeakMap(), ba = /* @__PURE__ */ new WeakMap(), nc = /* @__PURE__ */ new WeakMap(), rc = {});
  };
}, WU = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = UU(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), qU(r, i, n, "aria-hidden")) : function() {
    return null;
  };
}, Uv = "Dialog", [tT, pde] = Bk(Uv), [VU, Br] = tT(Uv), nT = (e) => {
  const {
    __scopeDialog: t,
    children: n,
    open: r,
    defaultOpen: i,
    onOpenChange: a,
    modal: o = !0
  } = e, s = x.useRef(null), c = x.useRef(null), [l = !1, u] = Uk({
    prop: r,
    defaultProp: i,
    onChange: a
  });
  return /* @__PURE__ */ O.jsx(
    VU,
    {
      scope: t,
      triggerRef: s,
      contentRef: c,
      contentId: Cc(),
      titleId: Cc(),
      descriptionId: Cc(),
      open: l,
      onOpenChange: u,
      onOpenToggle: x.useCallback(() => u((f) => !f), [u]),
      modal: o,
      children: n
    }
  );
};
nT.displayName = Uv;
var rT = "DialogTrigger", iT = x.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Br(rT, n), a = Di(t, i.triggerRef);
    return /* @__PURE__ */ O.jsx(
      mr.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": qv(i.open),
        ...r,
        ref: a,
        onClick: Xr(e.onClick, i.onOpenToggle)
      }
    );
  }
);
iT.displayName = rT;
var HU = "DialogPortal", [hde, aT] = tT(HU, {
  forceMount: void 0
}), yu = "DialogOverlay", oT = x.forwardRef(
  (e, t) => {
    const n = aT(yu, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, a = Br(yu, e.__scopeDialog);
    return a.modal ? /* @__PURE__ */ O.jsx(cf, { present: r || a.open, children: /* @__PURE__ */ O.jsx(ZU, { ...i, ref: t }) }) : null;
  }
);
oT.displayName = yu;
var ZU = x.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Br(yu, n);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ O.jsx(Qk, { as: Bv, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ O.jsx(
        mr.div,
        {
          "data-state": qv(i.open),
          ...r,
          ref: t,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), na = "DialogContent", sT = x.forwardRef(
  (e, t) => {
    const n = aT(na, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, a = Br(na, e.__scopeDialog);
    return /* @__PURE__ */ O.jsx(cf, { present: r || a.open, children: a.modal ? /* @__PURE__ */ O.jsx(KU, { ...i, ref: t }) : /* @__PURE__ */ O.jsx(GU, { ...i, ref: t }) });
  }
);
sT.displayName = na;
var KU = x.forwardRef(
  (e, t) => {
    const n = Br(na, e.__scopeDialog), r = x.useRef(null), i = Di(t, n.contentRef, r);
    return x.useEffect(() => {
      const a = r.current;
      if (a) return WU(a);
    }, []), /* @__PURE__ */ O.jsx(
      lT,
      {
        ...e,
        ref: i,
        trapFocus: n.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: Xr(e.onCloseAutoFocus, (a) => {
          var o;
          a.preventDefault(), (o = n.triggerRef.current) == null || o.focus();
        }),
        onPointerDownOutside: Xr(e.onPointerDownOutside, (a) => {
          const o = a.detail.originalEvent, s = o.button === 0 && o.ctrlKey === !0;
          (o.button === 2 || s) && a.preventDefault();
        }),
        onFocusOutside: Xr(
          e.onFocusOutside,
          (a) => a.preventDefault()
        )
      }
    );
  }
), GU = x.forwardRef(
  (e, t) => {
    const n = Br(na, e.__scopeDialog), r = x.useRef(!1), i = x.useRef(!1);
    return /* @__PURE__ */ O.jsx(
      lT,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          var o, s;
          (o = e.onCloseAutoFocus) == null || o.call(e, a), a.defaultPrevented || (r.current || (s = n.triggerRef.current) == null || s.focus(), a.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (a) => {
          var c, l;
          (c = e.onInteractOutside) == null || c.call(e, a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const o = a.target;
          ((l = n.triggerRef.current) == null ? void 0 : l.contains(o)) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && i.current && a.preventDefault();
        }
      }
    );
  }
), lT = x.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: a, ...o } = e, s = Br(na, n), c = x.useRef(null), l = Di(t, c);
    return aU(), /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
      /* @__PURE__ */ O.jsx(
        Vk,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: a,
          children: /* @__PURE__ */ O.jsx(
            qk,
            {
              role: "dialog",
              id: s.contentId,
              "aria-describedby": s.descriptionId,
              "aria-labelledby": s.titleId,
              "data-state": qv(s.open),
              ...o,
              ref: l,
              onDismiss: () => s.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
        /* @__PURE__ */ O.jsx(JU, { titleId: s.titleId }),
        /* @__PURE__ */ O.jsx(QU, { contentRef: c, descriptionId: s.descriptionId })
      ] })
    ] });
  }
), zv = "DialogTitle", cT = x.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Br(zv, n);
    return /* @__PURE__ */ O.jsx(mr.h2, { id: i.titleId, ...r, ref: t });
  }
);
cT.displayName = zv;
var uT = "DialogDescription", YU = x.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Br(uT, n);
    return /* @__PURE__ */ O.jsx(mr.p, { id: i.descriptionId, ...r, ref: t });
  }
);
YU.displayName = uT;
var fT = "DialogClose", dT = x.forwardRef(
  (e, t) => {
    const { __scopeDialog: n, ...r } = e, i = Br(fT, n);
    return /* @__PURE__ */ O.jsx(
      mr.button,
      {
        type: "button",
        ...r,
        ref: t,
        onClick: Xr(e.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
dT.displayName = fT;
function qv(e) {
  return e ? "open" : "closed";
}
var pT = "DialogTitleWarning", [mde, hT] = R3(pT, {
  contentName: na,
  titleName: zv,
  docsSlug: "dialog"
}), JU = ({ titleId: e }) => {
  const t = hT(pT), n = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return x.useEffect(() => {
    e && (document.getElementById(e) || console.error(n));
  }, [n, e]), null;
}, XU = "DialogDescriptionWarning", QU = ({ contentRef: e, descriptionId: t }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${hT(XU).contentName}}.`;
  return x.useEffect(() => {
    var a;
    const i = (a = e.current) == null ? void 0 : a.getAttribute("aria-describedby");
    t && i && (document.getElementById(t) || console.warn(r));
  }, [r, e, t]), null;
}, e7 = nT, t7 = iT, n7 = oT, r7 = sT, i7 = cT, mT = dT;
function ra({
  open: e,
  onOpenChange: t,
  children: n
}) {
  return /* @__PURE__ */ O.jsx(e7, { open: e, onOpenChange: t, children: n });
}
function a7({ title: e, children: t }) {
  var r, i, a, o, s, c, l, u;
  const { modal: n } = ut;
  return /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
    /* @__PURE__ */ O.jsx(n7, { ...n == null ? void 0 : n.overlay }),
    /* @__PURE__ */ O.jsx("div", { ...n == null ? void 0 : n.container, children: /* @__PURE__ */ O.jsxs(r7, { ...(r = n == null ? void 0 : n.dialog) == null ? void 0 : r.container, children: [
      /* @__PURE__ */ O.jsxs("div", { ...(a = (i = n == null ? void 0 : n.dialog) == null ? void 0 : i.title) == null ? void 0 : a.container, children: [
        /* @__PURE__ */ O.jsx(i7, { ...(s = (o = n == null ? void 0 : n.dialog) == null ? void 0 : o.title) == null ? void 0 : s.text, children: e }),
        /* @__PURE__ */ O.jsx(mT, { children: /* @__PURE__ */ O.jsx(g_, { role: "button", tabIndex: 0, ...(l = (c = n == null ? void 0 : n.dialog) == null ? void 0 : c.title) == null ? void 0 : l.closeIcon }) })
      ] }),
      /* @__PURE__ */ O.jsx("div", { ...(u = n == null ? void 0 : n.dialog) == null ? void 0 : u.content, children: t })
    ] }) })
  ] });
}
ra.Button = t7;
ra.Close = mT;
ra.Content = a7;
const vT = ({ children: e, className: t, connected: n, uploadFile: r, allowFileUpload: i, ...a }) => {
  const { container: o } = ut, s = _v((u) => u.setMessageContainerRef), c = Yo((u) => u.uploadFile), l = Tt(null);
  return Pt(() => {
    s(l);
  }, [l]), i && r ? /* @__PURE__ */ O.jsx(lf, { noClick: !0, onDrop: (u) => u.forEach((f) => c(f, r)), children: ({ getRootProps: u, isDragActive: f }) => /* @__PURE__ */ O.jsxs("div", { ...a, className: As(o.className, t), ref: l, children: [
    /* @__PURE__ */ O.jsxs("div", { "data-hover": f, ...o.dropzone.overlay, children: [
      "Drop files to upload",
      /* @__PURE__ */ O.jsx(QL, { style: { width: "50px" } })
    ] }),
    /* @__PURE__ */ O.jsxs(Mw, { children: [
      /* @__PURE__ */ O.jsx(Jw, { connected: n }),
      /* @__PURE__ */ O.jsx("div", { ...o.dropzone.container, ...u(), children: e })
    ] })
  ] }) }) : /* @__PURE__ */ O.jsx("div", { ...a, className: As(o.className, t), ref: l, children: /* @__PURE__ */ O.jsxs(Mw, { children: [
    /* @__PURE__ */ O.jsx(Jw, { connected: n }),
    e
  ] }) });
}, Jw = ({ connected: e }) => {
  const { modal: t } = ut, { showModal: n } = M_();
  return Pt(() => {
    var r, i, a, o;
    e === !1 && n({
      title: "Connection Error",
      content: /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
        /* @__PURE__ */ O.jsx("p", { ...(i = (r = t == null ? void 0 : t.dialog) == null ? void 0 : r.newConversation) == null ? void 0 : i.text, children: "There was an error connecting to the server. Please check your internet connection and try again." }),
        /* @__PURE__ */ O.jsx(ra.Close, { asChild: !0, children: /* @__PURE__ */ O.jsx(
          "button",
          {
            type: "button",
            ...(o = (a = t == null ? void 0 : t.dialog) == null ? void 0 : a.newConversation) == null ? void 0 : o.button,
            onClick: () => window.location.reload(),
            children: "Restart"
          }
        ) })
      ] })
    });
  }, [e]), /* @__PURE__ */ O.jsx(O.Fragment, {});
};
vT.displayName = "Container";
const o7 = An(({ children: e, onClick: t, ...n }, r) => {
  const { fab: i } = ut, { container: a, icon: o } = i ?? {};
  return /* @__PURE__ */ O.jsx("div", { ...n, ...a, ref: r, onClick: t, children: /* @__PURE__ */ O.jsx("div", { ...o }) });
});
o7.displayName = "Fab";
var Wv = "Collapsible", [s7, vde] = Bk(Wv), [l7, Vv] = s7(Wv), yT = x.forwardRef(
  (e, t) => {
    const {
      __scopeCollapsible: n,
      open: r,
      defaultOpen: i,
      disabled: a,
      onOpenChange: o,
      ...s
    } = e, [c = !1, l] = Uk({
      prop: r,
      defaultProp: i,
      onChange: o
    });
    return /* @__PURE__ */ O.jsx(
      l7,
      {
        scope: n,
        disabled: a,
        contentId: Cc(),
        open: c,
        onOpenToggle: x.useCallback(() => l((u) => !u), [l]),
        children: /* @__PURE__ */ O.jsx(
          mr.div,
          {
            "data-state": Zv(c),
            "data-disabled": a ? "" : void 0,
            ...s,
            ref: t
          }
        )
      }
    );
  }
);
yT.displayName = Wv;
var gT = "CollapsibleTrigger", bT = x.forwardRef(
  (e, t) => {
    const { __scopeCollapsible: n, ...r } = e, i = Vv(gT, n);
    return /* @__PURE__ */ O.jsx(
      mr.button,
      {
        type: "button",
        "aria-controls": i.contentId,
        "aria-expanded": i.open || !1,
        "data-state": Zv(i.open),
        "data-disabled": i.disabled ? "" : void 0,
        disabled: i.disabled,
        ...r,
        ref: t,
        onClick: Xr(e.onClick, i.onOpenToggle)
      }
    );
  }
);
bT.displayName = gT;
var Hv = "CollapsibleContent", wT = x.forwardRef(
  (e, t) => {
    const { forceMount: n, ...r } = e, i = Vv(Hv, e.__scopeCollapsible);
    return /* @__PURE__ */ O.jsx(cf, { present: n || i.open, children: ({ present: a }) => /* @__PURE__ */ O.jsx(c7, { ...r, ref: t, present: a }) });
  }
);
wT.displayName = Hv;
var c7 = x.forwardRef((e, t) => {
  const { __scopeCollapsible: n, present: r, children: i, ...a } = e, o = Vv(Hv, n), [s, c] = x.useState(r), l = x.useRef(null), u = Di(t, l), f = x.useRef(0), d = f.current, p = x.useRef(0), m = p.current, h = o.open || s, y = x.useRef(h), v = x.useRef(void 0);
  return x.useEffect(() => {
    const b = requestAnimationFrame(() => y.current = !1);
    return () => cancelAnimationFrame(b);
  }, []), Za(() => {
    const b = l.current;
    if (b) {
      v.current = v.current || {
        transitionDuration: b.style.transitionDuration,
        animationName: b.style.animationName
      }, b.style.transitionDuration = "0s", b.style.animationName = "none";
      const w = b.getBoundingClientRect();
      f.current = w.height, p.current = w.width, y.current || (b.style.transitionDuration = v.current.transitionDuration, b.style.animationName = v.current.animationName), c(r);
    }
  }, [o.open, r]), /* @__PURE__ */ O.jsx(
    mr.div,
    {
      "data-state": Zv(o.open),
      "data-disabled": o.disabled ? "" : void 0,
      id: o.contentId,
      hidden: !h,
      ...a,
      ref: u,
      style: {
        "--radix-collapsible-content-height": d ? `${d}px` : void 0,
        "--radix-collapsible-content-width": m ? `${m}px` : void 0,
        ...e.style
      },
      children: h && i
    }
  );
});
function Zv(e) {
  return e ? "open" : "closed";
}
var u7 = yT, f7 = wT;
const d7 = ({ onClick: e, ...t }) => {
  var o, s;
  const { header: n, modal: r } = ut, { showModal: i } = M_(), a = (c) => {
    var l, u, f, d;
    c.stopPropagation(), i({
      title: "Restart Conversation",
      content: /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
        /* @__PURE__ */ O.jsx("p", { ...(u = (l = r == null ? void 0 : r.dialog) == null ? void 0 : l.newConversation) == null ? void 0 : u.text, children: "Are you sure you want to restart a new conversation?" }),
        /* @__PURE__ */ O.jsx(ra.Close, { asChild: !0, children: /* @__PURE__ */ O.jsx("button", { type: "button", ...(d = (f = r == null ? void 0 : r.dialog) == null ? void 0 : f.newConversation) == null ? void 0 : d.button, onClick: e, children: "Restart" }) })
      ] })
    });
  };
  return /* @__PURE__ */ O.jsx(
    aL,
    {
      ...t,
      ...(s = (o = n == null ? void 0 : n.content) == null ? void 0 : o.actions) == null ? void 0 : s.icons,
      role: "button",
      tabIndex: 0,
      onClick: a,
      onKeyDown: (c) => {
        c.key === "Enter" && a(c);
      }
    }
  );
}, p7 = ({ onClick: e, ...t }) => {
  const { header: n } = ut, r = (i) => {
    i.stopPropagation(), e == null || e();
  };
  return /* @__PURE__ */ O.jsx(
    g_,
    {
      ...t,
      ...n.content.actions.icons,
      role: "button",
      tabIndex: 0,
      onClick: r,
      onKeyDown: (i) => {
        i.key === "Enter" && r(i);
      }
    }
  );
}, Lo = ({ icon: e, title: t, link: n, ...r }) => {
  var o, s, c, l, u, f, d, p, m, h, y, v;
  const { header: i } = ut, a = e ?? ZL;
  return t ? n ? /* @__PURE__ */ O.jsxs(
    "a",
    {
      ...r,
      ...(s = (o = i.expandedContent) == null ? void 0 : o.descriptionItems) == null ? void 0 : s.container,
      href: n,
      target: "_blank",
      rel: "noreferrer noopener",
      children: [
        /* @__PURE__ */ O.jsx(a, { ...(l = (c = i.expandedContent) == null ? void 0 : c.descriptionItems) == null ? void 0 : l.icon }),
        /* @__PURE__ */ O.jsx("p", { ...(f = (u = i.expandedContent) == null ? void 0 : u.descriptionItems) == null ? void 0 : f.link, children: t })
      ]
    }
  ) : /* @__PURE__ */ O.jsxs("div", { ...r, ...(p = (d = i.expandedContent) == null ? void 0 : d.descriptionItems) == null ? void 0 : p.container, children: [
    /* @__PURE__ */ O.jsx(a, { ...(h = (m = i.expandedContent) == null ? void 0 : m.descriptionItems) == null ? void 0 : h.icon }),
    /* @__PURE__ */ O.jsx("p", { ...(v = (y = i.expandedContent) == null ? void 0 : y.descriptionItems) == null ? void 0 : v.text, children: t })
  ] }) : null;
}, h7 = ({ defaultOpen: e, closeWindow: t, configuration: n, restartConversation: r, ...i }) => {
  var u, f, d, p, m, h, y, v, b, w, T, E, _, $, B, U, k, D, q, L, R, A;
  const { header: a } = ut, [o, s] = He(!!e), c = !!((u = n.email) != null && u.title) || !!((f = n.phone) != null && f.title) || !!((d = n.website) != null && d.title) || !!((p = n.termsOfService) != null && p.link) || !!((m = n.privacyPolicy) != null && m.link), l = c || !!n.botDescription;
  return /* @__PURE__ */ O.jsxs(
    u7,
    {
      open: l ? o : !1,
      onOpenChange: s,
      "data-disabled": l ? void 0 : "",
      ...a.container,
      ...i,
      children: [
        /* @__PURE__ */ O.jsxs(bT, { ...a.content.container, children: [
          /* @__PURE__ */ O.jsx(av, { ...i, src: n.botAvatar, ...a.content.avatar, children: n.botName || "Bot" }),
          /* @__PURE__ */ O.jsx("h2", { ...a.content.title, children: n.botName || "Bot" }),
          n.botDescription && /* @__PURE__ */ O.jsx("p", { ...a.content.description, children: n.botDescription }),
          /* @__PURE__ */ O.jsxs("div", { ...a.content.actions.container, children: [
            r && /* @__PURE__ */ O.jsx(d7, { onClick: r }),
            t && /* @__PURE__ */ O.jsx(p7, { onClick: t })
          ] })
        ] }),
        c && /* @__PURE__ */ O.jsxs(f7, { ...a.expandedContent.container, children: [
          /* @__PURE__ */ O.jsxs("div", { "data-links": "", ...a.expandedContent.group, children: [
            /* @__PURE__ */ O.jsx(
              Lo,
              {
                "data-email": "",
                icon: r5,
                title: (h = n.email) == null ? void 0 : h.title,
                link: (v = (y = n.email) == null ? void 0 : y.link) != null && v.startsWith("mailto:") ? (b = n.email) == null ? void 0 : b.link : `mailto:${(w = n.email) == null ? void 0 : w.link}`
              }
            ),
            /* @__PURE__ */ O.jsx(
              Lo,
              {
                "data-phone": "",
                icon: c5,
                title: (T = n.phone) == null ? void 0 : T.title,
                link: (_ = (E = n.phone) == null ? void 0 : E.link) != null && _.startsWith("tel:") ? ($ = n.phone) == null ? void 0 : $.link : `tel:${(B = n.phone) == null ? void 0 : B.link}`
              }
            ),
            /* @__PURE__ */ O.jsx(
              Lo,
              {
                "data-website": "",
                link: (U = n.website) == null ? void 0 : U.link,
                icon: a5,
                title: (k = n.website) == null ? void 0 : k.title
              }
            )
          ] }),
          /* @__PURE__ */ O.jsxs("div", { "data-legal": "", ...(D = a.expandedContent) == null ? void 0 : D.group, children: [
            /* @__PURE__ */ O.jsx(
              Lo,
              {
                "data-terms": "",
                link: (q = n.termsOfService) == null ? void 0 : q.link,
                icon: t5,
                title: (L = n.termsOfService) == null ? void 0 : L.title
              }
            ),
            /* @__PURE__ */ O.jsx(
              Lo,
              {
                "data-privacy": "",
                link: (R = n.privacyPolicy) == null ? void 0 : R.link,
                icon: s5,
                title: (A = n.privacyPolicy) == null ? void 0 : A.title
              }
            )
          ] })
        ] })
      ]
    }
  );
}, m7 = qu(({ ...e }) => {
  const { typingIndicator: t } = ut;
  return /* @__PURE__ */ O.jsx("div", { ...e, ...t == null ? void 0 : t.container, children: /* @__PURE__ */ O.jsx("div", { ...t == null ? void 0 : t.loader }) });
}), Xw = qu(
  An(
    ({ direction: e, block: t, disableInput: n, children: r, sender: i, id: a, authorId: o, renderers: s, sendMessage: c, isReadOnly: l, timestamp: u }, f) => {
      var b, w, T;
      const [d, p] = He([]), { message: m } = ut, h = zS(o ?? "", 15), [y, v] = He("idle");
      return /* @__PURE__ */ O.jsx(j_.Provider, { value: { isLoading: d, setIsLoading: p }, children: /* @__PURE__ */ O.jsxs(
        "div",
        {
          ...m == null ? void 0 : m.container,
          "data-loaded": d.length === 0,
          "data-disable-input": !!n,
          "data-direction": e,
          ref: f,
          children: [
            /* @__PURE__ */ O.jsxs(tv, { "data-color": h, "data-loading-status": y, ...(b = m == null ? void 0 : m.avatar) == null ? void 0 : b.container, children: [
              /* @__PURE__ */ O.jsx(nv, { ...(w = m == null ? void 0 : m.avatar) == null ? void 0 : w.image, onLoadingStatusChange: v, src: i == null ? void 0 : i.avatar }),
              /* @__PURE__ */ O.jsxs(rv, { ...(T = m == null ? void 0 : m.avatar) == null ? void 0 : T.fallback, children: [
                i == null ? void 0 : i.name[0],
                " "
              ] })
            ] }),
            t && /* @__PURE__ */ O.jsx(
              dl,
              {
                block: {
                  ...t,
                  isReadOnly: l,
                  direction: e,
                  timestamp: u,
                  sender: i,
                  messageId: a,
                  sendMessage: c
                },
                renderers: s
              }
            ),
            r
          ]
        }
      ) });
    }
  )
);
function v7({ botAvatar: e, botDescription: t, botName: n }) {
  const {
    messageList: { marquee: r }
  } = ut;
  return /* @__PURE__ */ O.jsxs("li", { ...r.container, children: [
    /* @__PURE__ */ O.jsx(av, { src: e, ...r.avatar, children: (n || "Bot").slice(0, 1) }),
    /* @__PURE__ */ O.jsxs("div", { ...r.content, children: [
      /* @__PURE__ */ O.jsx("h1", { ...r.title, children: n || "Bot" }),
      /* @__PURE__ */ O.jsx("p", { ...r.description, children: t })
    ] })
  ] });
}
function y7(e, t) {
  try {
    var n = global, r = n.document;
    if (typeof r < "u" && r.createElement && r.head && r.head.appendChild) {
      var i = r.querySelector('html meta[name="'.concat(encodeURI(e), '"]')) || r.createElement("meta");
      i.setAttribute("name", e), i.setAttribute("content", t), r.head.appendChild(i);
    }
  } catch {
  }
}
function g7() {
  y7("react-scroll-to-bottom:version", "4.2.0");
}
var Bo = function(e) {
  return e && e.Math === Math && e;
}, Qt = (
  // eslint-disable-next-line es/no-global-this -- safe
  Bo(typeof globalThis == "object" && globalThis) || Bo(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  Bo(typeof self == "object" && self) || Bo(typeof yt == "object" && yt) || Bo(typeof yt == "object" && yt) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
), en = function(e) {
  try {
    return !!e();
  } catch {
    return !0;
  }
}, b7 = en, ff = !b7(function() {
  var e = (function() {
  }).bind();
  return typeof e != "function" || e.hasOwnProperty("prototype");
}), w7 = ff, xT = Function.prototype, Qw = xT.apply, e0 = xT.call, Kv = typeof Reflect == "object" && Reflect.apply || (w7 ? e0.bind(Qw) : function() {
  return e0.apply(Qw, arguments);
}), ST = ff, ET = Function.prototype, Xh = ET.call, x7 = ST && ET.bind.bind(Xh, Xh), tn = ST ? x7 : function(e) {
  return function() {
    return Xh.apply(e, arguments);
  };
}, _T = tn, S7 = _T({}.toString), E7 = _T("".slice), ca = function(e) {
  return E7(S7(e), 8, -1);
}, _7 = ca, k7 = tn, Gv = function(e) {
  if (_7(e) === "Function") return k7(e);
}, Fd = typeof document == "object" && document.all, gn = typeof Fd > "u" && Fd !== void 0 ? function(e) {
  return typeof e == "function" || e === Fd;
} : function(e) {
  return typeof e == "function";
}, hl = {}, T7 = en, Pn = !T7(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] !== 7;
}), C7 = ff, ic = Function.prototype.call, Ur = C7 ? ic.bind(ic) : function() {
  return ic.apply(ic, arguments);
}, Yv = {}, kT = {}.propertyIsEnumerable, TT = Object.getOwnPropertyDescriptor, O7 = TT && !kT.call({ 1: 2 }, 1);
Yv.f = O7 ? function(t) {
  var n = TT(this, t);
  return !!n && n.enumerable;
} : kT;
var ml = function(e, t) {
  return {
    enumerable: !(e & 1),
    configurable: !(e & 2),
    writable: !(e & 4),
    value: t
  };
}, $7 = tn, R7 = en, I7 = ca, Ld = Object, A7 = $7("".split), CT = R7(function() {
  return !Ld("z").propertyIsEnumerable(0);
}) ? function(e) {
  return I7(e) === "String" ? A7(e, "") : Ld(e);
} : Ld, Jv = function(e) {
  return e == null;
}, P7 = Jv, D7 = TypeError, Xv = function(e) {
  if (P7(e)) throw new D7("Can't call method on " + e);
  return e;
}, j7 = CT, N7 = Xv, zr = function(e) {
  return j7(N7(e));
}, M7 = gn, ii = function(e) {
  return typeof e == "object" ? e !== null : M7(e);
}, un = {}, Bd = un, Ud = Qt, F7 = gn, t0 = function(e) {
  return F7(e) ? e : void 0;
}, qr = function(e, t) {
  return arguments.length < 2 ? t0(Bd[e]) || t0(Ud[e]) : Bd[e] && Bd[e][t] || Ud[e] && Ud[e][t];
}, L7 = tn, ai = L7({}.isPrototypeOf), B7 = Qt, n0 = B7.navigator, r0 = n0 && n0.userAgent, Qv = r0 ? String(r0) : "", OT = Qt, zd = Qv, i0 = OT.process, a0 = OT.Deno, o0 = i0 && i0.versions || a0 && a0.version, s0 = o0 && o0.v8, ir, gu;
s0 && (ir = s0.split("."), gu = ir[0] > 0 && ir[0] < 4 ? 1 : +(ir[0] + ir[1]));
!gu && zd && (ir = zd.match(/Edge\/(\d+)/), (!ir || ir[1] >= 74) && (ir = zd.match(/Chrome\/(\d+)/), ir && (gu = +ir[1])));
var ey = gu, l0 = ey, U7 = en, z7 = Qt, q7 = z7.String, So = !!Object.getOwnPropertySymbols && !U7(function() {
  var e = Symbol("symbol detection");
  return !q7(e) || !(Object(e) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && l0 && l0 < 41;
}), W7 = So, $T = W7 && !Symbol.sham && typeof Symbol.iterator == "symbol", V7 = qr, H7 = gn, Z7 = ai, K7 = $T, G7 = Object, vl = K7 ? function(e) {
  return typeof e == "symbol";
} : function(e) {
  var t = V7("Symbol");
  return H7(t) && Z7(t.prototype, G7(e));
}, Y7 = String, df = function(e) {
  try {
    return Y7(e);
  } catch {
    return "Object";
  }
}, J7 = gn, X7 = df, Q7 = TypeError, ty = function(e) {
  if (J7(e)) return e;
  throw new Q7(X7(e) + " is not a function");
}, e6 = ty, t6 = Jv, ny = function(e, t) {
  var n = e[t];
  return t6(n) ? void 0 : e6(n);
}, qd = Ur, Wd = gn, Vd = ii, n6 = TypeError, r6 = function(e, t) {
  var n, r;
  if (t === "string" && Wd(n = e.toString) && !Vd(r = qd(n, e)) || Wd(n = e.valueOf) && !Vd(r = qd(n, e)) || t !== "string" && Wd(n = e.toString) && !Vd(r = qd(n, e))) return r;
  throw new n6("Can't convert object to primitive value");
}, RT = { exports: {} }, c0 = Qt, i6 = Object.defineProperty, a6 = function(e, t) {
  try {
    i6(c0, e, { value: t, configurable: !0, writable: !0 });
  } catch {
    c0[e] = t;
  }
  return t;
}, o6 = Qt, s6 = a6, u0 = "__core-js_shared__", f0 = RT.exports = o6[u0] || s6(u0, {});
(f0.versions || (f0.versions = [])).push({
  version: "3.38.1",
  mode: "pure",
  copyright: "© 2014-2024 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.38.1/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var ry = RT.exports, d0 = ry, Eo = function(e, t) {
  return d0[e] || (d0[e] = t || {});
}, l6 = Xv, c6 = Object, oi = function(e) {
  return c6(l6(e));
}, u6 = tn, f6 = oi, d6 = u6({}.hasOwnProperty), Bn = Object.hasOwn || function(t, n) {
  return d6(f6(t), n);
}, p6 = tn, h6 = 0, m6 = Math.random(), v6 = p6(1 .toString), iy = function(e) {
  return "Symbol(" + (e === void 0 ? "" : e) + ")_" + v6(++h6 + m6, 36);
}, y6 = Qt, g6 = Eo, p0 = Bn, b6 = iy, w6 = So, x6 = $T, Da = y6.Symbol, Hd = g6("wks"), S6 = x6 ? Da.for || Da : Da && Da.withoutSetter || b6, an = function(e) {
  return p0(Hd, e) || (Hd[e] = w6 && p0(Da, e) ? Da[e] : S6("Symbol." + e)), Hd[e];
}, E6 = Ur, h0 = ii, m0 = vl, _6 = ny, k6 = r6, T6 = an, C6 = TypeError, O6 = T6("toPrimitive"), $6 = function(e, t) {
  if (!h0(e) || m0(e)) return e;
  var n = _6(e, O6), r;
  if (n) {
    if (t === void 0 && (t = "default"), r = E6(n, e, t), !h0(r) || m0(r)) return r;
    throw new C6("Can't convert object to primitive value");
  }
  return t === void 0 && (t = "number"), k6(e, t);
}, R6 = $6, I6 = vl, ay = function(e) {
  var t = R6(e, "string");
  return I6(t) ? t : t + "";
}, A6 = Qt, v0 = ii, Qh = A6.document, P6 = v0(Qh) && v0(Qh.createElement), IT = function(e) {
  return P6 ? Qh.createElement(e) : {};
}, D6 = Pn, j6 = en, N6 = IT, AT = !D6 && !j6(function() {
  return Object.defineProperty(N6("div"), "a", {
    get: function() {
      return 7;
    }
  }).a !== 7;
}), M6 = Pn, F6 = Ur, L6 = Yv, B6 = ml, U6 = zr, z6 = ay, q6 = Bn, W6 = AT, y0 = Object.getOwnPropertyDescriptor;
hl.f = M6 ? y0 : function(t, n) {
  if (t = U6(t), n = z6(n), W6) try {
    return y0(t, n);
  } catch {
  }
  if (q6(t, n)) return B6(!F6(L6.f, t, n), t[n]);
};
var V6 = en, H6 = gn, Z6 = /#|\.prototype\./, yl = function(e, t) {
  var n = G6[K6(e)];
  return n === J6 ? !0 : n === Y6 ? !1 : H6(t) ? V6(t) : !!t;
}, K6 = yl.normalize = function(e) {
  return String(e).replace(Z6, ".").toLowerCase();
}, G6 = yl.data = {}, Y6 = yl.NATIVE = "N", J6 = yl.POLYFILL = "P", X6 = yl, g0 = Gv, Q6 = ty, ez = ff, tz = g0(g0.bind), oy = function(e, t) {
  return Q6(e), t === void 0 ? e : ez ? tz(e, t) : function() {
    return e.apply(t, arguments);
  };
}, vr = {}, nz = Pn, rz = en, PT = nz && rz(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: !1
  }).prototype !== 42;
}), iz = ii, az = String, oz = TypeError, ji = function(e) {
  if (iz(e)) return e;
  throw new oz(az(e) + " is not an object");
}, sz = Pn, lz = AT, cz = PT, ac = ji, b0 = ay, uz = TypeError, Zd = Object.defineProperty, fz = Object.getOwnPropertyDescriptor, Kd = "enumerable", Gd = "configurable", Yd = "writable";
vr.f = sz ? cz ? function(t, n, r) {
  if (ac(t), n = b0(n), ac(r), typeof t == "function" && n === "prototype" && "value" in r && Yd in r && !r[Yd]) {
    var i = fz(t, n);
    i && i[Yd] && (t[n] = r.value, r = {
      configurable: Gd in r ? r[Gd] : i[Gd],
      enumerable: Kd in r ? r[Kd] : i[Kd],
      writable: !1
    });
  }
  return Zd(t, n, r);
} : Zd : function(t, n, r) {
  if (ac(t), n = b0(n), ac(r), lz) try {
    return Zd(t, n, r);
  } catch {
  }
  if ("get" in r || "set" in r) throw new uz("Accessors not supported");
  return "value" in r && (t[n] = r.value), t;
};
var dz = Pn, pz = vr, hz = ml, pf = dz ? function(e, t, n) {
  return pz.f(e, t, hz(1, n));
} : function(e, t, n) {
  return e[t] = n, e;
}, Uo = Qt, mz = Kv, vz = Gv, yz = gn, gz = hl.f, bz = X6, wa = un, wz = oy, xa = pf, w0 = Bn, xz = function(e) {
  var t = function(n, r, i) {
    if (this instanceof t) {
      switch (arguments.length) {
        case 0:
          return new e();
        case 1:
          return new e(n);
        case 2:
          return new e(n, r);
      }
      return new e(n, r, i);
    }
    return mz(e, this, arguments);
  };
  return t.prototype = e.prototype, t;
}, gt = function(e, t) {
  var n = e.target, r = e.global, i = e.stat, a = e.proto, o = r ? Uo : i ? Uo[n] : Uo[n] && Uo[n].prototype, s = r ? wa : wa[n] || xa(wa, n, {})[n], c = s.prototype, l, u, f, d, p, m, h, y, v;
  for (d in t)
    l = bz(r ? d : n + (i ? "." : "#") + d, e.forced), u = !l && o && w0(o, d), m = s[d], u && (e.dontCallGetSet ? (v = gz(o, d), h = v && v.value) : h = o[d]), p = u && h ? h : t[d], !(!l && !a && typeof m == typeof p) && (e.bind && u ? y = wz(p, Uo) : e.wrap && u ? y = xz(p) : a && yz(p) ? y = vz(p) : y = p, (e.sham || p && p.sham || m && m.sham) && xa(y, "sham", !0), xa(s, d, y), a && (f = n + "Prototype", w0(wa, f) || xa(wa, f, {}), xa(wa[f], d, p), e.real && c && (l || !c[d]) && xa(c, d, p)));
}, Sz = ca, _o = Array.isArray || function(t) {
  return Sz(t) === "Array";
}, Ez = gt, _z = _o;
Ez({ target: "Array", stat: !0 }, {
  isArray: _z
});
var kz = un, Tz = kz.Array.isArray, Cz = Tz, DT = Cz, Oz = DT, $z = Oz, Rz = $z, Iz = Rz, Az = Iz;
const jT = /* @__PURE__ */ Ye(Az);
function Pz(e) {
  if (jT(e)) return e;
}
var Dz = Math.ceil, jz = Math.floor, Nz = Math.trunc || function(t) {
  var n = +t;
  return (n > 0 ? jz : Dz)(n);
}, Mz = Nz, hf = function(e) {
  var t = +e;
  return t !== t || t === 0 ? 0 : Mz(t);
}, Fz = hf, Lz = Math.min, Bz = function(e) {
  var t = Fz(e);
  return t > 0 ? Lz(t, 9007199254740991) : 0;
}, Uz = Bz, ua = function(e) {
  return Uz(e.length);
}, zz = TypeError, qz = 9007199254740991, sy = function(e) {
  if (e > qz) throw zz("Maximum allowed index exceeded");
  return e;
}, Wz = Pn, Vz = vr, Hz = ml, gl = function(e, t, n) {
  Wz ? Vz.f(e, t, Hz(0, n)) : e[t] = n;
}, Zz = an, Kz = Zz("toStringTag"), NT = {};
NT[Kz] = "z";
var ly = String(NT) === "[object z]", Gz = ly, Yz = gn, Rc = ca, Jz = an, Xz = Jz("toStringTag"), Qz = Object, e9 = Rc(/* @__PURE__ */ function() {
  return arguments;
}()) === "Arguments", t9 = function(e, t) {
  try {
    return e[t];
  } catch {
  }
}, bl = Gz ? Rc : function(e) {
  var t, n, r;
  return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (n = t9(t = Qz(e), Xz)) == "string" ? n : e9 ? Rc(t) : (r = Rc(t)) === "Object" && Yz(t.callee) ? "Arguments" : r;
}, n9 = tn, r9 = gn, em = ry, i9 = n9(Function.toString);
r9(em.inspectSource) || (em.inspectSource = function(e) {
  return i9(e);
});
var a9 = em.inspectSource, o9 = tn, s9 = en, MT = gn, l9 = bl, c9 = qr, u9 = a9, FT = function() {
}, LT = c9("Reflect", "construct"), cy = /^\s*(?:class|function)\b/, f9 = o9(cy.exec), d9 = !cy.test(FT), zo = function(t) {
  if (!MT(t)) return !1;
  try {
    return LT(FT, [], t), !0;
  } catch {
    return !1;
  }
}, BT = function(t) {
  if (!MT(t)) return !1;
  switch (l9(t)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return !1;
  }
  try {
    return d9 || !!f9(cy, u9(t));
  } catch {
    return !0;
  }
};
BT.sham = !0;
var uy = !LT || s9(function() {
  var e;
  return zo(zo.call) || !zo(Object) || !zo(function() {
    e = !0;
  }) || e;
}) ? BT : zo, x0 = _o, p9 = uy, h9 = ii, m9 = an, v9 = m9("species"), S0 = Array, y9 = function(e) {
  var t;
  return x0(e) && (t = e.constructor, p9(t) && (t === S0 || x0(t.prototype)) ? t = void 0 : h9(t) && (t = t[v9], t === null && (t = void 0))), t === void 0 ? S0 : t;
}, g9 = y9, fy = function(e, t) {
  return new (g9(e))(t === 0 ? 0 : t);
}, b9 = en, w9 = an, x9 = ey, S9 = w9("species"), mf = function(e) {
  return x9 >= 51 || !b9(function() {
    var t = [], n = t.constructor = {};
    return n[S9] = function() {
      return { foo: 1 };
    }, t[e](Boolean).foo !== 1;
  });
}, E9 = gt, _9 = en, k9 = _o, T9 = ii, C9 = oi, O9 = ua, E0 = sy, _0 = gl, $9 = fy, R9 = mf, I9 = an, A9 = ey, UT = I9("isConcatSpreadable"), P9 = A9 >= 51 || !_9(function() {
  var e = [];
  return e[UT] = !1, e.concat()[0] !== e;
}), D9 = function(e) {
  if (!T9(e)) return !1;
  var t = e[UT];
  return t !== void 0 ? !!t : k9(e);
}, j9 = !P9 || !R9("concat");
E9({ target: "Array", proto: !0, arity: 1, forced: j9 }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function(t) {
    var n = C9(this), r = $9(n, 0), i = 0, a, o, s, c, l;
    for (a = -1, s = arguments.length; a < s; a++)
      if (l = a === -1 ? n : arguments[a], D9(l))
        for (c = O9(l), E0(i + c), o = 0; o < c; o++, i++) o in l && _0(r, i, l[o]);
      else
        E0(i + 1), _0(r, i++, l);
    return r.length = i, r;
  }
});
var N9 = bl, M9 = String, wl = function(e) {
  if (N9(e) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
  return M9(e);
}, vf = {}, F9 = hf, L9 = Math.max, B9 = Math.min, dy = function(e, t) {
  var n = F9(e);
  return n < 0 ? L9(n + t, 0) : B9(n, t);
}, U9 = zr, z9 = dy, q9 = ua, k0 = function(e) {
  return function(t, n, r) {
    var i = U9(t), a = q9(i);
    if (a === 0) return !e && -1;
    var o = z9(r, a), s;
    if (e && n !== n) {
      for (; a > o; )
        if (s = i[o++], s !== s) return !0;
    } else for (; a > o; o++)
      if ((e || o in i) && i[o] === n) return e || o || 0;
    return !e && -1;
  };
}, zT = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: k0(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: k0(!1)
}, yf = {}, W9 = tn, Jd = Bn, V9 = zr, H9 = zT.indexOf, Z9 = yf, T0 = W9([].push), qT = function(e, t) {
  var n = V9(e), r = 0, i = [], a;
  for (a in n) !Jd(Z9, a) && Jd(n, a) && T0(i, a);
  for (; t.length > r; ) Jd(n, a = t[r++]) && (~H9(i, a) || T0(i, a));
  return i;
}, py = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], K9 = qT, G9 = py, hy = Object.keys || function(t) {
  return K9(t, G9);
}, Y9 = Pn, J9 = PT, X9 = vr, Q9 = ji, eq = zr, tq = hy;
vf.f = Y9 && !J9 ? Object.defineProperties : function(t, n) {
  Q9(t);
  for (var r = eq(n), i = tq(n), a = i.length, o = 0, s; a > o; ) X9.f(t, s = i[o++], r[s]);
  return t;
};
var nq = qr, rq = nq("document", "documentElement"), iq = Eo, aq = iy, C0 = iq("keys"), gf = function(e) {
  return C0[e] || (C0[e] = aq(e));
}, oq = ji, sq = vf, O0 = py, lq = yf, cq = rq, uq = IT, fq = gf, $0 = ">", R0 = "<", tm = "prototype", nm = "script", WT = fq("IE_PROTO"), Xd = function() {
}, VT = function(e) {
  return R0 + nm + $0 + e + R0 + "/" + nm + $0;
}, I0 = function(e) {
  e.write(VT("")), e.close();
  var t = e.parentWindow.Object;
  return e = null, t;
}, dq = function() {
  var e = uq("iframe"), t = "java" + nm + ":", n;
  return e.style.display = "none", cq.appendChild(e), e.src = String(t), n = e.contentWindow.document, n.open(), n.write(VT("document.F=Object")), n.close(), n.F;
}, oc, Ic = function() {
  try {
    oc = new ActiveXObject("htmlfile");
  } catch {
  }
  Ic = typeof document < "u" ? document.domain && oc ? I0(oc) : dq() : I0(oc);
  for (var e = O0.length; e--; ) delete Ic[tm][O0[e]];
  return Ic();
};
lq[WT] = !0;
var my = Object.create || function(t, n) {
  var r;
  return t !== null ? (Xd[tm] = oq(t), r = new Xd(), Xd[tm] = null, r[WT] = t) : r = Ic(), n === void 0 ? r : sq.f(r, n);
}, bf = {}, pq = qT, hq = py, mq = hq.concat("length", "prototype");
bf.f = Object.getOwnPropertyNames || function(t) {
  return pq(t, mq);
};
var HT = {}, vq = tn, wf = vq([].slice), yq = ca, gq = zr, ZT = bf.f, bq = wf, KT = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], wq = function(e) {
  try {
    return ZT(e);
  } catch {
    return bq(KT);
  }
};
HT.f = function(t) {
  return KT && yq(t) === "Window" ? wq(t) : ZT(gq(t));
};
var xf = {};
xf.f = Object.getOwnPropertySymbols;
var xq = pf, Sf = function(e, t, n, r) {
  return r && r.enumerable ? e[t] = n : xq(e, t, n), e;
}, Sq = vr, Eq = function(e, t, n) {
  return Sq.f(e, t, n);
}, xl = {}, _q = an;
xl.f = _q;
var A0 = un, kq = Bn, Tq = xl, Cq = vr.f, Dt = function(e) {
  var t = A0.Symbol || (A0.Symbol = {});
  kq(t, e) || Cq(t, e, {
    value: Tq.f(e)
  });
}, Oq = Ur, $q = qr, Rq = an, Iq = Sf, GT = function() {
  var e = $q("Symbol"), t = e && e.prototype, n = t && t.valueOf, r = Rq("toPrimitive");
  t && !t[r] && Iq(t, r, function(i) {
    return Oq(n, this);
  }, { arity: 1 });
}, Aq = ly, Pq = bl, Dq = Aq ? {}.toString : function() {
  return "[object " + Pq(this) + "]";
}, jq = ly, Nq = vr.f, Mq = pf, Fq = Bn, Lq = Dq, Bq = an, P0 = Bq("toStringTag"), ko = function(e, t, n, r) {
  var i = n ? e : e && e.prototype;
  i && (Fq(i, P0) || Nq(i, P0, { configurable: !0, value: t }), r && !jq && Mq(i, "toString", Lq));
}, Uq = Qt, zq = gn, D0 = Uq.WeakMap, qq = zq(D0) && /native code/.test(String(D0)), Wq = qq, YT = Qt, Vq = ii, Hq = pf, Qd = Bn, ep = ry, Zq = gf, Kq = yf, j0 = "Object already initialized", rm = YT.TypeError, Gq = YT.WeakMap, bu, Ds, wu, Yq = function(e) {
  return wu(e) ? Ds(e) : bu(e, {});
}, Jq = function(e) {
  return function(t) {
    var n;
    if (!Vq(t) || (n = Ds(t)).type !== e)
      throw new rm("Incompatible receiver, " + e + " required");
    return n;
  };
};
if (Wq || ep.state) {
  var wr = ep.state || (ep.state = new Gq());
  wr.get = wr.get, wr.has = wr.has, wr.set = wr.set, bu = function(e, t) {
    if (wr.has(e)) throw new rm(j0);
    return t.facade = e, wr.set(e, t), t;
  }, Ds = function(e) {
    return wr.get(e) || {};
  }, wu = function(e) {
    return wr.has(e);
  };
} else {
  var Sa = Zq("state");
  Kq[Sa] = !0, bu = function(e, t) {
    if (Qd(e, Sa)) throw new rm(j0);
    return t.facade = e, Hq(e, Sa, t), t;
  }, Ds = function(e) {
    return Qd(e, Sa) ? e[Sa] : {};
  }, wu = function(e) {
    return Qd(e, Sa);
  };
}
var vy = {
  set: bu,
  get: Ds,
  has: wu,
  enforce: Yq,
  getterFor: Jq
}, Xq = oy, Qq = tn, eW = CT, tW = oi, nW = ua, rW = fy, N0 = Qq([].push), ui = function(e) {
  var t = e === 1, n = e === 2, r = e === 3, i = e === 4, a = e === 6, o = e === 7, s = e === 5 || a;
  return function(c, l, u, f) {
    for (var d = tW(c), p = eW(d), m = nW(p), h = Xq(l, u), y = 0, v = f || rW, b = t ? v(c, m) : n || o ? v(c, 0) : void 0, w, T; m > y; y++) if ((s || y in p) && (w = p[y], T = h(w, y, d), e))
      if (t) b[y] = T;
      else if (T) switch (e) {
        case 3:
          return !0;
        case 5:
          return w;
        case 6:
          return y;
        case 2:
          N0(b, w);
      }
      else switch (e) {
        case 4:
          return !1;
        case 7:
          N0(b, w);
      }
    return a ? -1 : r || i ? i : b;
  };
}, yy = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: ui(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: ui(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: ui(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: ui(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: ui(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: ui(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: ui(6),
  // `Array.prototype.filterReject` method
  // https://github.com/tc39/proposal-array-filtering
  filterReject: ui(7)
}, Ef = gt, Sl = Qt, gy = Ur, iW = tn, no = Pn, ro = So, aW = en, rn = Bn, oW = ai, im = ji, _f = zr, by = ay, sW = wl, am = ml, io = my, JT = hy, lW = bf, XT = HT, cW = xf, QT = hl, eC = vr, uW = vf, tC = Yv, M0 = Sf, fW = Eq, wy = Eo, dW = gf, nC = yf, F0 = iy, pW = an, hW = xl, mW = Dt, vW = GT, yW = ko, rC = vy, kf = yy.forEach, $n = dW("hidden"), Tf = "Symbol", js = "prototype", gW = rC.set, L0 = rC.getterFor(Tf), or = Object[js], Zi = Sl.Symbol, Jo = Zi && Zi[js], bW = Sl.RangeError, wW = Sl.TypeError, tp = Sl.QObject, iC = QT.f, Ki = eC.f, aC = XT.f, xW = tC.f, oC = iW([].push), ti = wy("symbols"), El = wy("op-symbols"), SW = wy("wks"), om = !tp || !tp[js] || !tp[js].findChild, sC = function(e, t, n) {
  var r = iC(or, t);
  r && delete or[t], Ki(e, t, n), r && e !== or && Ki(or, t, r);
}, sm = no && aW(function() {
  return io(Ki({}, "a", {
    get: function() {
      return Ki(this, "a", { value: 7 }).a;
    }
  })).a !== 7;
}) ? sC : Ki, np = function(e, t) {
  var n = ti[e] = io(Jo);
  return gW(n, {
    type: Tf,
    tag: e,
    description: t
  }), no || (n.description = t), n;
}, Cf = function(t, n, r) {
  t === or && Cf(El, n, r), im(t);
  var i = by(n);
  return im(r), rn(ti, i) ? (r.enumerable ? (rn(t, $n) && t[$n][i] && (t[$n][i] = !1), r = io(r, { enumerable: am(0, !1) })) : (rn(t, $n) || Ki(t, $n, am(1, io(null))), t[$n][i] = !0), sm(t, i, r)) : Ki(t, i, r);
}, xy = function(t, n) {
  im(t);
  var r = _f(n), i = JT(r).concat(fC(r));
  return kf(i, function(a) {
    (!no || gy(lC, r, a)) && Cf(t, a, r[a]);
  }), t;
}, EW = function(t, n) {
  return n === void 0 ? io(t) : xy(io(t), n);
}, lC = function(t) {
  var n = by(t), r = gy(xW, this, n);
  return this === or && rn(ti, n) && !rn(El, n) ? !1 : r || !rn(this, n) || !rn(ti, n) || rn(this, $n) && this[$n][n] ? r : !0;
}, cC = function(t, n) {
  var r = _f(t), i = by(n);
  if (!(r === or && rn(ti, i) && !rn(El, i))) {
    var a = iC(r, i);
    return a && rn(ti, i) && !(rn(r, $n) && r[$n][i]) && (a.enumerable = !0), a;
  }
}, uC = function(t) {
  var n = aC(_f(t)), r = [];
  return kf(n, function(i) {
    !rn(ti, i) && !rn(nC, i) && oC(r, i);
  }), r;
}, fC = function(e) {
  var t = e === or, n = aC(t ? El : _f(e)), r = [];
  return kf(n, function(i) {
    rn(ti, i) && (!t || rn(or, i)) && oC(r, ti[i]);
  }), r;
};
ro || (Zi = function() {
  if (oW(Jo, this)) throw new wW("Symbol is not a constructor");
  var t = !arguments.length || arguments[0] === void 0 ? void 0 : sW(arguments[0]), n = F0(t), r = function(i) {
    var a = this === void 0 ? Sl : this;
    a === or && gy(r, El, i), rn(a, $n) && rn(a[$n], n) && (a[$n][n] = !1);
    var o = am(1, i);
    try {
      sm(a, n, o);
    } catch (s) {
      if (!(s instanceof bW)) throw s;
      sC(a, n, o);
    }
  };
  return no && om && sm(or, n, { configurable: !0, set: r }), np(n, t);
}, Jo = Zi[js], M0(Jo, "toString", function() {
  return L0(this).tag;
}), M0(Zi, "withoutSetter", function(e) {
  return np(F0(e), e);
}), tC.f = lC, eC.f = Cf, uW.f = xy, QT.f = cC, lW.f = XT.f = uC, cW.f = fC, hW.f = function(e) {
  return np(pW(e), e);
}, no && fW(Jo, "description", {
  configurable: !0,
  get: function() {
    return L0(this).description;
  }
}));
Ef({ global: !0, constructor: !0, wrap: !0, forced: !ro, sham: !ro }, {
  Symbol: Zi
});
kf(JT(SW), function(e) {
  mW(e);
});
Ef({ target: Tf, stat: !0, forced: !ro }, {
  useSetter: function() {
    om = !0;
  },
  useSimple: function() {
    om = !1;
  }
});
Ef({ target: "Object", stat: !0, forced: !ro, sham: !no }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: EW,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: Cf,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: xy,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: cC
});
Ef({ target: "Object", stat: !0, forced: !ro }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: uC
});
vW();
yW(Zi, Tf);
nC[$n] = !0;
var _W = So, dC = _W && !!Symbol.for && !!Symbol.keyFor, kW = gt, TW = qr, CW = Bn, OW = wl, pC = Eo, $W = dC, rp = pC("string-to-symbol-registry"), RW = pC("symbol-to-string-registry");
kW({ target: "Symbol", stat: !0, forced: !$W }, {
  for: function(e) {
    var t = OW(e);
    if (CW(rp, t)) return rp[t];
    var n = TW("Symbol")(t);
    return rp[t] = n, RW[n] = t, n;
  }
});
var IW = gt, AW = Bn, PW = vl, DW = df, jW = Eo, NW = dC, B0 = jW("symbol-to-string-registry");
IW({ target: "Symbol", stat: !0, forced: !NW }, {
  keyFor: function(t) {
    if (!PW(t)) throw new TypeError(DW(t) + " is not a symbol");
    if (AW(B0, t)) return B0[t];
  }
});
var MW = tn, U0 = _o, FW = gn, z0 = ca, LW = wl, q0 = MW([].push), BW = function(e) {
  if (FW(e)) return e;
  if (U0(e)) {
    for (var t = e.length, n = [], r = 0; r < t; r++) {
      var i = e[r];
      typeof i == "string" ? q0(n, i) : (typeof i == "number" || z0(i) === "Number" || z0(i) === "String") && q0(n, LW(i));
    }
    var a = n.length, o = !0;
    return function(s, c) {
      if (o)
        return o = !1, c;
      if (U0(this)) return c;
      for (var l = 0; l < a; l++) if (n[l] === s) return c;
    };
  }
}, UW = gt, hC = qr, mC = Kv, zW = Ur, _l = tn, vC = en, W0 = gn, V0 = vl, yC = wf, qW = BW, WW = So, VW = String, Si = hC("JSON", "stringify"), sc = _l(/./.exec), H0 = _l("".charAt), HW = _l("".charCodeAt), ZW = _l("".replace), KW = _l(1 .toString), GW = /[\uD800-\uDFFF]/g, Z0 = /^[\uD800-\uDBFF]$/, K0 = /^[\uDC00-\uDFFF]$/, G0 = !WW || vC(function() {
  var e = hC("Symbol")("stringify detection");
  return Si([e]) !== "[null]" || Si({ a: e }) !== "{}" || Si(Object(e)) !== "{}";
}), Y0 = vC(function() {
  return Si("\uDF06\uD834") !== '"\\udf06\\ud834"' || Si("\uDEAD") !== '"\\udead"';
}), YW = function(e, t) {
  var n = yC(arguments), r = qW(t);
  if (!(!W0(r) && (e === void 0 || V0(e))))
    return n[1] = function(i, a) {
      if (W0(r) && (a = zW(r, this, VW(i), a)), !V0(a)) return a;
    }, mC(Si, null, n);
}, JW = function(e, t, n) {
  var r = H0(n, t - 1), i = H0(n, t + 1);
  return sc(Z0, e) && !sc(K0, i) || sc(K0, e) && !sc(Z0, r) ? "\\u" + KW(HW(e, 0), 16) : e;
};
Si && UW({ target: "JSON", stat: !0, arity: 3, forced: G0 || Y0 }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  stringify: function(t, n, r) {
    var i = yC(arguments), a = mC(G0 ? YW : Si, null, i);
    return Y0 && typeof a == "string" ? ZW(a, GW, JW) : a;
  }
});
var XW = gt, QW = So, e8 = en, gC = xf, t8 = oi, n8 = !QW || e8(function() {
  gC.f(1);
});
XW({ target: "Object", stat: !0, forced: n8 }, {
  getOwnPropertySymbols: function(t) {
    var n = gC.f;
    return n ? n(t8(t)) : [];
  }
});
var r8 = Dt;
r8("asyncIterator");
var i8 = Dt;
i8("hasInstance");
var a8 = Dt;
a8("isConcatSpreadable");
var o8 = Dt;
o8("iterator");
var s8 = Dt;
s8("match");
var l8 = Dt;
l8("matchAll");
var c8 = Dt;
c8("replace");
var u8 = Dt;
u8("search");
var f8 = Dt;
f8("species");
var d8 = Dt;
d8("split");
var p8 = Dt, h8 = GT;
p8("toPrimitive");
h8();
var m8 = qr, v8 = Dt, y8 = ko;
v8("toStringTag");
y8(m8("Symbol"), "Symbol");
var g8 = Dt;
g8("unscopables");
var b8 = Qt, w8 = ko;
w8(b8.JSON, "JSON", !0);
var x8 = un, S8 = x8.Symbol, To = {}, lm = Pn, E8 = Bn, bC = Function.prototype, _8 = lm && Object.getOwnPropertyDescriptor, Sy = E8(bC, "name"), k8 = Sy && (function() {
}).name === "something", T8 = Sy && (!lm || lm && _8(bC, "name").configurable), C8 = {
  EXISTS: Sy,
  PROPER: k8,
  CONFIGURABLE: T8
}, O8 = en, $8 = !O8(function() {
  function e() {
  }
  return e.prototype.constructor = null, Object.getPrototypeOf(new e()) !== e.prototype;
}), R8 = Bn, I8 = gn, A8 = oi, P8 = gf, D8 = $8, J0 = P8("IE_PROTO"), cm = Object, j8 = cm.prototype, wC = D8 ? cm.getPrototypeOf : function(e) {
  var t = A8(e);
  if (R8(t, J0)) return t[J0];
  var n = t.constructor;
  return I8(n) && t instanceof n ? n.prototype : t instanceof cm ? j8 : null;
}, N8 = en, M8 = gn, F8 = ii, L8 = my, X0 = wC, B8 = Sf, U8 = an, um = U8("iterator"), xC = !1, Qr, ip, ap;
[].keys && (ap = [].keys(), "next" in ap ? (ip = X0(X0(ap)), ip !== Object.prototype && (Qr = ip)) : xC = !0);
var z8 = !F8(Qr) || N8(function() {
  var e = {};
  return Qr[um].call(e) !== e;
});
z8 ? Qr = {} : Qr = L8(Qr);
M8(Qr[um]) || B8(Qr, um, function() {
  return this;
});
var SC = {
  IteratorPrototype: Qr,
  BUGGY_SAFARI_ITERATORS: xC
}, q8 = SC.IteratorPrototype, W8 = my, V8 = ml, H8 = ko, Z8 = To, K8 = function() {
  return this;
}, G8 = function(e, t, n, r) {
  var i = t + " Iterator";
  return e.prototype = W8(q8, { next: V8(+!r, n) }), H8(e, i, !1, !0), Z8[i] = K8, e;
}, Y8 = gt, J8 = Ur, EC = C8, X8 = G8, Q8 = wC, eV = ko, Q0 = Sf, tV = an, ex = To, _C = SC, nV = EC.PROPER;
EC.CONFIGURABLE;
_C.IteratorPrototype;
var lc = _C.BUGGY_SAFARI_ITERATORS, op = tV("iterator"), tx = "keys", cc = "values", nx = "entries", rV = function() {
  return this;
}, kC = function(e, t, n, r, i, a, o) {
  X8(n, t, r);
  var s = function(v) {
    if (v === i && d) return d;
    if (!lc && v && v in u) return u[v];
    switch (v) {
      case tx:
        return function() {
          return new n(this, v);
        };
      case cc:
        return function() {
          return new n(this, v);
        };
      case nx:
        return function() {
          return new n(this, v);
        };
    }
    return function() {
      return new n(this);
    };
  }, c = t + " Iterator", l = !1, u = e.prototype, f = u[op] || u["@@iterator"] || i && u[i], d = !lc && f || s(i), p = t === "Array" && u.entries || f, m, h, y;
  if (p && (m = Q8(p.call(new e())), m !== Object.prototype && m.next && (eV(m, c, !0, !0), ex[c] = rV)), nV && i === cc && f && f.name !== cc && (l = !0, d = function() {
    return J8(f, this);
  }), i)
    if (h = {
      values: s(cc),
      keys: a ? d : s(tx),
      entries: s(nx)
    }, o) for (y in h)
      (lc || l || !(y in u)) && Q0(u, y, h[y]);
    else Y8({ target: t, proto: !0, forced: lc || l }, h);
  return o && u[op] !== d && Q0(u, op, d, { name: i }), ex[t] = d, h;
}, TC = function(e, t) {
  return { value: e, done: t };
}, iV = zr, rx = To, CC = vy;
vr.f;
var aV = kC, uc = TC, OC = "Array Iterator", oV = CC.set, sV = CC.getterFor(OC);
aV(Array, "Array", function(e, t) {
  oV(this, {
    type: OC,
    target: iV(e),
    // target
    index: 0,
    // next index
    kind: t
    // kind
  });
}, function() {
  var e = sV(this), t = e.target, n = e.index++;
  if (!t || n >= t.length)
    return e.target = null, uc(void 0, !0);
  switch (e.kind) {
    case "keys":
      return uc(n, !1);
    case "values":
      return uc(t[n], !1);
  }
  return uc([n, t[n]], !1);
}, "values");
rx.Arguments = rx.Array;
var lV = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
}, cV = lV, uV = Qt, fV = ko, ix = To;
for (var sp in cV)
  fV(uV[sp], sp), ix[sp] = ix.Array;
var dV = S8, pV = dV, hV = an, mV = vr.f, ax = hV("metadata"), ox = Function.prototype;
ox[ax] === void 0 && mV(ox, ax, {
  value: null
});
var vV = Dt;
vV("asyncDispose");
var yV = Dt;
yV("dispose");
var gV = Dt;
gV("metadata");
var bV = pV, wV = bV, xV = qr, SV = tn, Ey = xV("Symbol"), EV = Ey.keyFor, _V = SV(Ey.prototype.valueOf), $C = Ey.isRegisteredSymbol || function(t) {
  try {
    return EV(_V(t)) !== void 0;
  } catch {
    return !1;
  }
}, kV = gt, TV = $C;
kV({ target: "Symbol", stat: !0 }, {
  isRegisteredSymbol: TV
});
var CV = Eo, RC = qr, OV = tn, $V = vl, RV = an, xu = RC("Symbol"), sx = xu.isWellKnownSymbol, IC = RC("Object", "getOwnPropertyNames"), IV = OV(xu.prototype.valueOf), lx = CV("wks");
for (var lp = 0, cx = IC(xu), AV = cx.length; lp < AV; lp++)
  try {
    var ux = cx[lp];
    $V(xu[ux]) && RV(ux);
  } catch {
  }
var AC = function(t) {
  if (sx && sx(t)) return !0;
  try {
    for (var n = IV(t), r = 0, i = IC(lx), a = i.length; r < a; r++)
      if (lx[i[r]] == n) return !0;
  } catch {
  }
  return !1;
}, PV = gt, DV = AC;
PV({ target: "Symbol", stat: !0, forced: !0 }, {
  isWellKnownSymbol: DV
});
var jV = Dt;
jV("customMatcher");
var NV = Dt;
NV("observable");
var MV = gt, FV = $C;
MV({ target: "Symbol", stat: !0, name: "isRegisteredSymbol" }, {
  isRegistered: FV
});
var LV = gt, BV = AC;
LV({ target: "Symbol", stat: !0, name: "isWellKnownSymbol", forced: !0 }, {
  isWellKnown: BV
});
var UV = Dt;
UV("matcher");
var zV = Dt;
zV("metadataKey");
var qV = Dt;
qV("patternMatch");
var WV = Dt;
WV("replaceAll");
var VV = wV, HV = VV, ZV = HV;
const ja = /* @__PURE__ */ Ye(ZV);
var _y = tn, KV = hf, GV = wl, YV = Xv, JV = _y("".charAt), fx = _y("".charCodeAt), XV = _y("".slice), dx = function(e) {
  return function(t, n) {
    var r = GV(YV(t)), i = KV(n), a = r.length, o, s;
    return i < 0 || i >= a ? e ? "" : void 0 : (o = fx(r, i), o < 55296 || o > 56319 || i + 1 === a || (s = fx(r, i + 1)) < 56320 || s > 57343 ? e ? JV(r, i) : o : e ? XV(r, i, i + 2) : (o - 55296 << 10) + (s - 56320) + 65536);
  };
}, QV = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: dx(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: dx(!0)
}, eH = QV.charAt, tH = wl, PC = vy, nH = kC, px = TC, DC = "String Iterator", rH = PC.set, iH = PC.getterFor(DC);
nH(String, "String", function(e) {
  rH(this, {
    type: DC,
    string: tH(e),
    index: 0
  });
}, function() {
  var t = iH(this), n = t.string, r = t.index, i;
  return r >= n.length ? px(void 0, !0) : (i = eH(n, r), t.index += i.length, px(i, !1));
});
var aH = bl, hx = ny, oH = Jv, sH = To, lH = an, cH = lH("iterator"), ky = function(e) {
  if (!oH(e)) return hx(e, cH) || hx(e, "@@iterator") || sH[aH(e)];
}, uH = ky, fH = uH, dH = fH, pH = dH, hH = pH, mH = hH, vH = mH, yH = vH, gH = yH;
const jC = /* @__PURE__ */ Ye(gH);
var bH = Pn, wH = _o, xH = TypeError, SH = Object.getOwnPropertyDescriptor, EH = bH && !function() {
  if (this !== void 0) return !0;
  try {
    Object.defineProperty([], "length", { writable: !1 }).length = 1;
  } catch (e) {
    return e instanceof TypeError;
  }
}(), NC = EH ? function(e, t) {
  if (wH(e) && !SH(e, "length").writable)
    throw new xH("Cannot set read only .length");
  return e.length = t;
} : function(e, t) {
  return e.length = t;
}, _H = gt, kH = oi, TH = ua, CH = NC, OH = sy, $H = en, RH = $H(function() {
  return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
}), IH = function() {
  try {
    Object.defineProperty([], "length", { writable: !1 }).push();
  } catch (e) {
    return e instanceof TypeError;
  }
}, AH = RH || !IH();
_H({ target: "Array", proto: !0, arity: 1, forced: AH }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  push: function(t) {
    var n = kH(this), r = TH(n), i = arguments.length;
    OH(r + i);
    for (var a = 0; a < i; a++)
      n[r] = arguments[a], r++;
    return CH(n, r), r;
  }
});
var PH = Qt, DH = un, fa = function(e, t) {
  var n = DH[e + "Prototype"], r = n && n[t];
  if (r) return r;
  var i = PH[e], a = i && i.prototype;
  return a && a[t];
}, jH = fa, NH = jH("Array", "push"), MH = ai, FH = NH, cp = Array.prototype, LH = function(e) {
  var t = e.push;
  return e === cp || MH(cp, e) && t === cp.push ? FH : t;
}, BH = LH, UH = BH, zH = UH, qH = zH, WH = qH, VH = WH, HH = VH;
const ZH = /* @__PURE__ */ Ye(HH);
function KH(e, t) {
  var n = e == null ? null : typeof ja < "u" && jC(e) || e["@@iterator"];
  if (n != null) {
    var r, i, a, o, s = [], c = !0, l = !1;
    try {
      if (a = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n) return;
        c = !1;
      } else for (; !(c = (r = a.call(n)).done) && (ZH(s).call(s, r.value), s.length !== t); c = !0) ;
    } catch (u) {
      l = !0, i = u;
    } finally {
      try {
        if (!c && n.return != null && (o = n.return(), Object(o) !== o)) return;
      } finally {
        if (l) throw i;
      }
    }
    return s;
  }
}
var GH = gt, mx = _o, YH = uy, JH = ii, vx = dy, XH = ua, QH = zr, eZ = gl, tZ = an, nZ = mf, rZ = wf, iZ = nZ("slice"), aZ = tZ("species"), up = Array, oZ = Math.max;
GH({ target: "Array", proto: !0, forced: !iZ }, {
  slice: function(t, n) {
    var r = QH(this), i = XH(r), a = vx(t, i), o = vx(n === void 0 ? i : n, i), s, c, l;
    if (mx(r) && (s = r.constructor, YH(s) && (s === up || mx(s.prototype)) ? s = void 0 : JH(s) && (s = s[aZ], s === null && (s = void 0)), s === up || s === void 0))
      return rZ(r, a, o);
    for (c = new (s === void 0 ? up : s)(oZ(o - a, 0)), l = 0; a < o; a++, l++) a in r && eZ(c, l, r[a]);
    return c.length = l, c;
  }
});
var sZ = fa, lZ = sZ("Array", "slice"), cZ = ai, uZ = lZ, fp = Array.prototype, fZ = function(e) {
  var t = e.slice;
  return e === fp || cZ(fp, e) && t === fp.slice ? uZ : t;
}, dZ = fZ, pZ = dZ, hZ = pZ, mZ = hZ, vZ = mZ, yZ = vZ, gZ = yZ;
const bZ = /* @__PURE__ */ Ye(gZ);
var wZ = Ur, yx = ji, xZ = ny, SZ = function(e, t, n) {
  var r, i;
  yx(e);
  try {
    if (r = xZ(e, "return"), !r) {
      if (t === "throw") throw n;
      return n;
    }
    r = wZ(r, e);
  } catch (a) {
    i = !0, r = a;
  }
  if (t === "throw") throw n;
  if (i) throw r;
  return yx(r), n;
}, EZ = ji, _Z = SZ, kZ = function(e, t, n, r) {
  try {
    return r ? t(EZ(n)[0], n[1]) : t(n);
  } catch (i) {
    _Z(e, "throw", i);
  }
}, TZ = an, CZ = To, OZ = TZ("iterator"), $Z = Array.prototype, RZ = function(e) {
  return e !== void 0 && (CZ.Array === e || $Z[OZ] === e);
}, IZ = Ur, AZ = ty, PZ = ji, DZ = df, jZ = ky, NZ = TypeError, MZ = function(e, t) {
  var n = arguments.length < 2 ? jZ(e) : t;
  if (AZ(n)) return PZ(IZ(n, e));
  throw new NZ(DZ(e) + " is not iterable");
}, FZ = oy, LZ = Ur, BZ = oi, UZ = kZ, zZ = RZ, qZ = uy, WZ = ua, gx = gl, VZ = MZ, HZ = ky, bx = Array, ZZ = function(t) {
  var n = BZ(t), r = qZ(this), i = arguments.length, a = i > 1 ? arguments[1] : void 0, o = a !== void 0;
  o && (a = FZ(a, i > 2 ? arguments[2] : void 0));
  var s = HZ(n), c = 0, l, u, f, d, p, m;
  if (s && !(this === bx && zZ(s)))
    for (u = r ? new this() : [], d = VZ(n, s), p = d.next; !(f = LZ(p, d)).done; c++)
      m = o ? UZ(d, a, [f.value, c], !0) : f.value, gx(u, c, m);
  else
    for (l = WZ(n), u = r ? new this(l) : bx(l); l > c; c++)
      m = o ? a(n[c], c) : n[c], gx(u, c, m);
  return u.length = c, u;
}, KZ = an, MC = KZ("iterator"), FC = !1;
try {
  var GZ = 0, wx = {
    next: function() {
      return { done: !!GZ++ };
    },
    return: function() {
      FC = !0;
    }
  };
  wx[MC] = function() {
    return this;
  }, Array.from(wx, function() {
    throw 2;
  });
} catch {
}
var YZ = function(e, t) {
  try {
    if (!t && !FC) return !1;
  } catch {
    return !1;
  }
  var n = !1;
  try {
    var r = {};
    r[MC] = function() {
      return {
        next: function() {
          return { done: n = !0 };
        }
      };
    }, e(r);
  } catch {
  }
  return n;
}, JZ = gt, XZ = ZZ, QZ = YZ, eK = !QZ(function(e) {
  Array.from(e);
});
JZ({ target: "Array", stat: !0, forced: eK }, {
  from: XZ
});
var tK = un, nK = tK.Array.from, rK = nK, iK = rK, aK = iK, oK = aK, sK = oK, lK = sK, cK = lK;
const LC = /* @__PURE__ */ Ye(cK);
function fm(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = Array(t); n < t; n++) r[n] = e[n];
  return r;
}
function BC(e, t) {
  if (e) {
    var n;
    if (typeof e == "string") return fm(e, t);
    var r = bZ(n = {}.toString.call(e)).call(n, 8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? LC(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? fm(e, t) : void 0;
  }
}
function uK() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Tr(e, t) {
  return Pz(e) || KH(e, t) || BC(e, t) || uK();
}
var UC = { exports: {} };
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function n() {
      for (var r = [], i = 0; i < arguments.length; i++) {
        var a = arguments[i];
        if (a) {
          var o = typeof a;
          if (o === "string" || o === "number")
            r.push(a);
          else if (Array.isArray(a)) {
            if (a.length) {
              var s = n.apply(null, a);
              s && r.push(s);
            }
          } else if (o === "object")
            if (a.toString === Object.prototype.toString)
              for (var c in a)
                t.call(a, c) && a[c] && r.push(c);
            else
              r.push(a.toString());
        }
      }
      return r.join(" ");
    }
    e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
  })();
})(UC);
var fK = UC.exports;
const Ty = /* @__PURE__ */ Ye(fK);
var dm = { exports: {} }, dp, xx;
function Cy() {
  if (xx) return dp;
  xx = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return dp = e, dp;
}
var pp, Sx;
function dK() {
  if (Sx) return pp;
  Sx = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Cy(), n = {}, r = Function.call.bind(Object.prototype.hasOwnProperty);
    e = function(a) {
      var o = "Warning: " + a;
      typeof console < "u" && console.error(o);
      try {
        throw new Error(o);
      } catch {
      }
    };
  }
  function i(a, o, s, c, l) {
    if (process.env.NODE_ENV !== "production") {
      for (var u in a)
        if (r(a, u)) {
          var f;
          try {
            if (typeof a[u] != "function") {
              var d = Error(
                (c || "React class") + ": " + s + " type `" + u + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof a[u] + "`."
              );
              throw d.name = "Invariant Violation", d;
            }
            f = a[u](o, u, c, s, null, t);
          } catch (m) {
            f = m;
          }
          if (f && !(f instanceof Error) && e(
            (c || "React class") + ": type specification of " + s + " `" + u + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof f + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), f instanceof Error && !(f.message in n)) {
            n[f.message] = !0;
            var p = l ? l() : "";
            e(
              "Failed " + s + " type: " + f.message + (p ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, pp = i, pp;
}
var hp, Ex;
function pK() {
  if (Ex) return hp;
  Ex = 1;
  var e = sf(), t = Ck(), n = Cy(), r = dK(), i = Function.call.bind(Object.prototype.hasOwnProperty), a = function() {
  };
  process.env.NODE_ENV !== "production" && (a = function(s) {
    var c = "Warning: " + s;
    typeof console < "u" && console.error(c);
    try {
      throw new Error(c);
    } catch {
    }
  });
  function o() {
    return null;
  }
  return hp = function(s, c) {
    var l = typeof Symbol == "function" && Symbol.iterator, u = "@@iterator";
    function f(I) {
      var g = I && (l && I[l] || I[u]);
      if (typeof g == "function")
        return g;
    }
    var d = "<<anonymous>>", p = {
      array: v("array"),
      bool: v("boolean"),
      func: v("function"),
      number: v("number"),
      object: v("object"),
      string: v("string"),
      symbol: v("symbol"),
      any: b(),
      arrayOf: w,
      element: T(),
      elementType: E(),
      instanceOf: _,
      node: k(),
      objectOf: B,
      oneOf: $,
      oneOfType: U,
      shape: D,
      exact: q
    };
    function m(I, g) {
      return I === g ? I !== 0 || 1 / I === 1 / g : I !== I && g !== g;
    }
    function h(I) {
      this.message = I, this.stack = "";
    }
    h.prototype = Error.prototype;
    function y(I) {
      if (process.env.NODE_ENV !== "production")
        var g = {}, j = 0;
      function W(Z, Y, G, X, ie, ae, J) {
        if (X = X || d, ae = ae || G, J !== n) {
          if (c) {
            var Q = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw Q.name = "Invariant Violation", Q;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var K = X + ":" + G;
            !g[K] && // Avoid spamming the console because they are often not actionable except for lib authors
            j < 3 && (a(
              "You are manually calling a React.PropTypes validation function for the `" + ae + "` prop on `" + X + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), g[K] = !0, j++);
          }
        }
        return Y[G] == null ? Z ? Y[G] === null ? new h("The " + ie + " `" + ae + "` is marked as required " + ("in `" + X + "`, but its value is `null`.")) : new h("The " + ie + " `" + ae + "` is marked as required in " + ("`" + X + "`, but its value is `undefined`.")) : null : I(Y, G, X, ie, ae);
      }
      var S = W.bind(null, !1);
      return S.isRequired = W.bind(null, !0), S;
    }
    function v(I) {
      function g(j, W, S, Z, Y, G) {
        var X = j[W], ie = A(X);
        if (ie !== I) {
          var ae = F(X);
          return new h("Invalid " + Z + " `" + Y + "` of type " + ("`" + ae + "` supplied to `" + S + "`, expected ") + ("`" + I + "`."));
        }
        return null;
      }
      return y(g);
    }
    function b() {
      return y(o);
    }
    function w(I) {
      function g(j, W, S, Z, Y) {
        if (typeof I != "function")
          return new h("Property `" + Y + "` of component `" + S + "` has invalid PropType notation inside arrayOf.");
        var G = j[W];
        if (!Array.isArray(G)) {
          var X = A(G);
          return new h("Invalid " + Z + " `" + Y + "` of type " + ("`" + X + "` supplied to `" + S + "`, expected an array."));
        }
        for (var ie = 0; ie < G.length; ie++) {
          var ae = I(G, ie, S, Z, Y + "[" + ie + "]", n);
          if (ae instanceof Error)
            return ae;
        }
        return null;
      }
      return y(g);
    }
    function T() {
      function I(g, j, W, S, Z) {
        var Y = g[j];
        if (!s(Y)) {
          var G = A(Y);
          return new h("Invalid " + S + " `" + Z + "` of type " + ("`" + G + "` supplied to `" + W + "`, expected a single ReactElement."));
        }
        return null;
      }
      return y(I);
    }
    function E() {
      function I(g, j, W, S, Z) {
        var Y = g[j];
        if (!e.isValidElementType(Y)) {
          var G = A(Y);
          return new h("Invalid " + S + " `" + Z + "` of type " + ("`" + G + "` supplied to `" + W + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return y(I);
    }
    function _(I) {
      function g(j, W, S, Z, Y) {
        if (!(j[W] instanceof I)) {
          var G = I.name || d, X = V(j[W]);
          return new h("Invalid " + Z + " `" + Y + "` of type " + ("`" + X + "` supplied to `" + S + "`, expected ") + ("instance of `" + G + "`."));
        }
        return null;
      }
      return y(g);
    }
    function $(I) {
      if (!Array.isArray(I))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? a(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : a("Invalid argument supplied to oneOf, expected an array.")), o;
      function g(j, W, S, Z, Y) {
        for (var G = j[W], X = 0; X < I.length; X++)
          if (m(G, I[X]))
            return null;
        var ie = JSON.stringify(I, function(J, Q) {
          var K = F(Q);
          return K === "symbol" ? String(Q) : Q;
        });
        return new h("Invalid " + Z + " `" + Y + "` of value `" + String(G) + "` " + ("supplied to `" + S + "`, expected one of " + ie + "."));
      }
      return y(g);
    }
    function B(I) {
      function g(j, W, S, Z, Y) {
        if (typeof I != "function")
          return new h("Property `" + Y + "` of component `" + S + "` has invalid PropType notation inside objectOf.");
        var G = j[W], X = A(G);
        if (X !== "object")
          return new h("Invalid " + Z + " `" + Y + "` of type " + ("`" + X + "` supplied to `" + S + "`, expected an object."));
        for (var ie in G)
          if (i(G, ie)) {
            var ae = I(G, ie, S, Z, Y + "." + ie, n);
            if (ae instanceof Error)
              return ae;
          }
        return null;
      }
      return y(g);
    }
    function U(I) {
      if (!Array.isArray(I))
        return process.env.NODE_ENV !== "production" && a("Invalid argument supplied to oneOfType, expected an instance of array."), o;
      for (var g = 0; g < I.length; g++) {
        var j = I[g];
        if (typeof j != "function")
          return a(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + H(j) + " at index " + g + "."
          ), o;
      }
      function W(S, Z, Y, G, X) {
        for (var ie = 0; ie < I.length; ie++) {
          var ae = I[ie];
          if (ae(S, Z, Y, G, X, n) == null)
            return null;
        }
        return new h("Invalid " + G + " `" + X + "` supplied to " + ("`" + Y + "`."));
      }
      return y(W);
    }
    function k() {
      function I(g, j, W, S, Z) {
        return L(g[j]) ? null : new h("Invalid " + S + " `" + Z + "` supplied to " + ("`" + W + "`, expected a ReactNode."));
      }
      return y(I);
    }
    function D(I) {
      function g(j, W, S, Z, Y) {
        var G = j[W], X = A(G);
        if (X !== "object")
          return new h("Invalid " + Z + " `" + Y + "` of type `" + X + "` " + ("supplied to `" + S + "`, expected `object`."));
        for (var ie in I) {
          var ae = I[ie];
          if (ae) {
            var J = ae(G, ie, S, Z, Y + "." + ie, n);
            if (J)
              return J;
          }
        }
        return null;
      }
      return y(g);
    }
    function q(I) {
      function g(j, W, S, Z, Y) {
        var G = j[W], X = A(G);
        if (X !== "object")
          return new h("Invalid " + Z + " `" + Y + "` of type `" + X + "` " + ("supplied to `" + S + "`, expected `object`."));
        var ie = t({}, j[W], I);
        for (var ae in ie) {
          var J = I[ae];
          if (!J)
            return new h(
              "Invalid " + Z + " `" + Y + "` key `" + ae + "` supplied to `" + S + "`.\nBad object: " + JSON.stringify(j[W], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(I), null, "  ")
            );
          var Q = J(G, ae, S, Z, Y + "." + ae, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return y(g);
    }
    function L(I) {
      switch (typeof I) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !I;
        case "object":
          if (Array.isArray(I))
            return I.every(L);
          if (I === null || s(I))
            return !0;
          var g = f(I);
          if (g) {
            var j = g.call(I), W;
            if (g !== I.entries) {
              for (; !(W = j.next()).done; )
                if (!L(W.value))
                  return !1;
            } else
              for (; !(W = j.next()).done; ) {
                var S = W.value;
                if (S && !L(S[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function R(I, g) {
      return I === "symbol" ? !0 : g ? g["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && g instanceof Symbol : !1;
    }
    function A(I) {
      var g = typeof I;
      return Array.isArray(I) ? "array" : I instanceof RegExp ? "object" : R(g, I) ? "symbol" : g;
    }
    function F(I) {
      if (typeof I > "u" || I === null)
        return "" + I;
      var g = A(I);
      if (g === "object") {
        if (I instanceof Date)
          return "date";
        if (I instanceof RegExp)
          return "regexp";
      }
      return g;
    }
    function H(I) {
      var g = F(I);
      switch (g) {
        case "array":
        case "object":
          return "an " + g;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + g;
        default:
          return g;
      }
    }
    function V(I) {
      return !I.constructor || !I.constructor.name ? d : I.constructor.name;
    }
    return p.checkPropTypes = r, p.resetWarningCache = r.resetWarningCache, p.PropTypes = p, p;
  }, hp;
}
var mp, _x;
function hK() {
  if (_x) return mp;
  _x = 1;
  var e = Cy();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, mp = function() {
    function r(o, s, c, l, u, f) {
      if (f !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var a = {
      array: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return a.PropTypes = a, a;
  }, mp;
}
if (process.env.NODE_ENV !== "production") {
  var mK = sf(), vK = !0;
  dm.exports = pK()(mK.isElement, vK);
} else
  dm.exports = hK()();
var yK = dm.exports;
const it = /* @__PURE__ */ Ye(yK);
var Oy = /* @__PURE__ */ vt.createContext({
  scrollTo: function() {
    return 0;
  },
  scrollToBottom: function() {
    return 0;
  },
  scrollToEnd: function() {
    return 0;
  },
  scrollToStart: function() {
    return 0;
  },
  scrollToTop: function() {
    return 0;
  }
});
Oy.displayName = "ScrollToBottomFunctionContext";
function gK() {
  return ho(Oy);
}
function bK() {
  var e = gK(), t = e.scrollToEnd;
  return t;
}
var $y = /* @__PURE__ */ vt.createContext({
  atBottom: !0,
  atEnd: !0,
  atStart: !1,
  atTop: !0,
  mode: "bottom"
});
$y.displayName = "ScrollToBottomState1Context";
var Ry = /* @__PURE__ */ vt.createContext({
  animating: !1,
  animatingToEnd: !1,
  sticky: !0
});
Ry.displayName = "ScrollToBottomState2Context";
var Iy = /* @__PURE__ */ vt.createContext({
  animating: !1,
  animatingToEnd: !1,
  atBottom: !0,
  atEnd: !0,
  atStart: !1,
  atTop: !0,
  mode: "bottom",
  sticky: !0
});
Iy.displayName = "ScrollToBottomStateContext";
var kx = [Iy, $y, Ry];
function wK(e) {
  return ho(kx[e] || kx[0]);
}
function xK() {
  var e = wK(2), t = e.sticky;
  return [t];
}
var Of = /* @__PURE__ */ vt.createContext({
  offsetHeight: 0,
  scrollHeight: 0,
  setTarget: function() {
    return 0;
  },
  styleToClassName: function() {
    return "";
  }
});
Of.displayName = "ScrollToBottomInternalContext";
function SK() {
  return ho(Of);
}
function Ay() {
  var e = SK(), t = e.styleToClassName;
  return t;
}
var EK = {
  backgroundColor: "rgba(0, 0, 0, .2)",
  borderRadius: 10,
  borderWidth: 0,
  bottom: 5,
  cursor: "pointer",
  height: 20,
  outline: 0,
  position: "absolute",
  right: 20,
  width: 20,
  "&:hover": {
    backgroundColor: "rgba(0, 0, 0, .4)"
  },
  "&:active": {
    backgroundColor: "rgba(0, 0, 0, .6)"
  }
}, Py = function(t) {
  var n = t.children, r = t.className, i = xK(), a = Tr(i, 1), o = a[0], s = Ay()(EK), c = bK();
  return !o && /* @__PURE__ */ vt.createElement("button", {
    className: Ty(s, (r || "") + ""),
    onClick: c,
    type: "button"
  }, n);
};
Py.defaultProps = {
  children: void 0,
  className: ""
};
Py.propTypes = {
  children: it.any,
  className: it.string
};
var zC = { exports: {} }, _K = gt, kK = Pn, Tx = vr.f;
_K({ target: "Object", stat: !0, forced: Object.defineProperty !== Tx, sham: !kK }, {
  defineProperty: Tx
});
var TK = un, qC = TK.Object, CK = zC.exports = function(t, n, r) {
  return qC.defineProperty(t, n, r);
};
qC.defineProperty.sham && (CK.sham = !0);
var OK = zC.exports, $K = OK, WC = $K, RK = WC, IK = RK, AK = IK, PK = AK, DK = PK;
const jK = /* @__PURE__ */ Ye(DK);
var NK = xl, MK = NK.f("iterator"), FK = MK, LK = FK, BK = LK, UK = BK, zK = UK, qK = zK, WK = qK;
const VK = /* @__PURE__ */ Ye(WK);
function Ns(e) {
  "@babel/helpers - typeof";
  return Ns = typeof ja == "function" && typeof VK == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof ja == "function" && t.constructor === ja && t !== ja.prototype ? "symbol" : typeof t;
  }, Ns(e);
}
var HK = xl, ZK = HK.f("toPrimitive"), KK = ZK, GK = KK, YK = GK, JK = YK, XK = JK, QK = XK, eG = QK;
const tG = /* @__PURE__ */ Ye(eG);
function nG(e, t) {
  if (Ns(e) != "object" || !e) return e;
  var n = e[tG];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ns(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function rG(e) {
  var t = nG(e, "string");
  return Ns(t) == "symbol" ? t : t + "";
}
function iG(e, t, n) {
  return (t = rG(t)) in e ? jK(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function aG(e) {
  if (jT(e)) return fm(e);
}
function oG(e) {
  if (typeof ja < "u" && jC(e) != null || e["@@iterator"] != null) return LC(e);
}
function sG() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function tt(e) {
  return aG(e) || oG(e) || BC(e) || sG();
}
var fc = function(e) {
  return e && e.Math == Math && e;
}, Un = (
  // eslint-disable-next-line es/no-global-this -- safe
  fc(typeof globalThis == "object" && globalThis) || fc(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  fc(typeof self == "object" && self) || fc(typeof yt == "object" && yt) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")()
), Dy = {}, yr = function(e) {
  try {
    return !!e();
  } catch {
    return !0;
  }
}, lG = yr, da = !lG(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
}), VC = {}, HC = {}.propertyIsEnumerable, ZC = Object.getOwnPropertyDescriptor, cG = ZC && !HC.call({ 1: 2 }, 1);
VC.f = cG ? function(t) {
  var n = ZC(this, t);
  return !!n && n.enumerable;
} : HC;
var KC = function(e, t) {
  return {
    enumerable: !(e & 1),
    configurable: !(e & 2),
    writable: !(e & 4),
    value: t
  };
}, uG = {}.toString, jy = function(e) {
  return uG.call(e).slice(8, -1);
}, fG = yr, dG = jy, pG = "".split, hG = fG(function() {
  return !Object("z").propertyIsEnumerable(0);
}) ? function(e) {
  return dG(e) == "String" ? pG.call(e, "") : Object(e);
} : Object, $f = function(e) {
  if (e == null) throw TypeError("Can't call method on " + e);
  return e;
}, mG = hG, vG = $f, Ny = function(e) {
  return mG(vG(e));
}, Xn = function(e) {
  return typeof e == "function";
}, yG = Xn, kl = function(e) {
  return typeof e == "object" ? e !== null : yG(e);
}, vp = Un, gG = Xn, bG = function(e) {
  return gG(e) ? e : void 0;
}, Rf = function(e, t) {
  return arguments.length < 2 ? bG(vp[e]) : vp[e] && vp[e][t];
}, wG = Rf, xG = wG("navigator", "userAgent") || "", GC = Un, yp = xG, Cx = GC.process, Ox = GC.Deno, $x = Cx && Cx.versions || Ox && Ox.version, Rx = $x && $x.v8, xr, Su;
Rx ? (xr = Rx.split("."), Su = xr[0] < 4 ? 1 : xr[0] + xr[1]) : yp && (xr = yp.match(/Edge\/(\d+)/), (!xr || xr[1] >= 74) && (xr = yp.match(/Chrome\/(\d+)/), xr && (Su = xr[1])));
var SG = Su && +Su, Ix = SG, EG = yr, YC = !!Object.getOwnPropertySymbols && !EG(function() {
  var e = Symbol();
  return !String(e) || !(Object(e) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
  !Symbol.sham && Ix && Ix < 41;
}), _G = YC, JC = _G && !Symbol.sham && typeof Symbol.iterator == "symbol", kG = Xn, TG = Rf, CG = JC, XC = CG ? function(e) {
  return typeof e == "symbol";
} : function(e) {
  var t = TG("Symbol");
  return kG(t) && Object(e) instanceof t;
}, OG = function(e) {
  try {
    return String(e);
  } catch {
    return "Object";
  }
}, $G = Xn, RG = OG, IG = function(e) {
  if ($G(e)) return e;
  throw TypeError(RG(e) + " is not a function");
}, AG = IG, QC = function(e, t) {
  var n = e[t];
  return n == null ? void 0 : AG(n);
}, gp = Xn, bp = kl, PG = function(e, t) {
  var n, r;
  if (t === "string" && gp(n = e.toString) && !bp(r = n.call(e)) || gp(n = e.valueOf) && !bp(r = n.call(e)) || t !== "string" && gp(n = e.toString) && !bp(r = n.call(e))) return r;
  throw TypeError("Can't convert object to primitive value");
}, eO = { exports: {} }, Ax = Un, My = function(e, t) {
  try {
    Object.defineProperty(Ax, e, { value: t, configurable: !0, writable: !0 });
  } catch {
    Ax[e] = t;
  }
  return t;
}, DG = Un, jG = My, Px = "__core-js_shared__", NG = DG[Px] || jG(Px, {}), Fy = NG, Dx = Fy;
(eO.exports = function(e, t) {
  return Dx[e] || (Dx[e] = t !== void 0 ? t : {});
})("versions", []).push({
  version: "3.18.3",
  mode: "global",
  copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
});
var Ly = eO.exports, MG = $f, tO = function(e) {
  return Object(MG(e));
}, FG = tO, LG = {}.hasOwnProperty, pa = Object.hasOwn || function(t, n) {
  return LG.call(FG(t), n);
}, BG = 0, UG = Math.random(), nO = function(e) {
  return "Symbol(" + String(e === void 0 ? "" : e) + ")_" + (++BG + UG).toString(36);
}, zG = Un, qG = Ly, jx = pa, WG = nO, Nx = YC, VG = JC, qo = qG("wks"), os = zG.Symbol, HG = VG ? os : os && os.withoutSetter || WG, Tl = function(e) {
  return (!jx(qo, e) || !(Nx || typeof qo[e] == "string")) && (Nx && jx(os, e) ? qo[e] = os[e] : qo[e] = HG("Symbol." + e)), qo[e];
}, Mx = kl, Fx = XC, ZG = QC, KG = PG, GG = Tl, YG = GG("toPrimitive"), JG = function(e, t) {
  if (!Mx(e) || Fx(e)) return e;
  var n = ZG(e, YG), r;
  if (n) {
    if (t === void 0 && (t = "default"), r = n.call(e, t), !Mx(r) || Fx(r)) return r;
    throw TypeError("Can't convert object to primitive value");
  }
  return t === void 0 && (t = "number"), KG(e, t);
}, XG = JG, QG = XC, rO = function(e) {
  var t = XG(e, "string");
  return QG(t) ? t : String(t);
}, eY = Un, Lx = kl, pm = eY.document, tY = Lx(pm) && Lx(pm.createElement), iO = function(e) {
  return tY ? pm.createElement(e) : {};
}, nY = da, rY = yr, iY = iO, aO = !nY && !rY(function() {
  return Object.defineProperty(iY("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
}), aY = da, oY = VC, sY = KC, lY = Ny, cY = rO, uY = pa, fY = aO, Bx = Object.getOwnPropertyDescriptor;
Dy.f = aY ? Bx : function(t, n) {
  if (t = lY(t), n = cY(n), fY) try {
    return Bx(t, n);
  } catch {
  }
  if (uY(t, n)) return sY(!oY.f.call(t, n), t[n]);
};
var Cl = {}, dY = kl, Ni = function(e) {
  if (dY(e)) return e;
  throw TypeError(String(e) + " is not an object");
}, pY = da, hY = aO, Ux = Ni, mY = rO, zx = Object.defineProperty;
Cl.f = pY ? zx : function(t, n, r) {
  if (Ux(t), n = mY(n), Ux(r), hY) try {
    return zx(t, n, r);
  } catch {
  }
  if ("get" in r || "set" in r) throw TypeError("Accessors not supported");
  return "value" in r && (t[n] = r.value), t;
};
var vY = da, yY = Cl, gY = KC, If = vY ? function(e, t, n) {
  return yY.f(e, t, gY(1, n));
} : function(e, t, n) {
  return e[t] = n, e;
}, oO = { exports: {} }, bY = Xn, hm = Fy, wY = Function.toString;
bY(hm.inspectSource) || (hm.inspectSource = function(e) {
  return wY.call(e);
});
var sO = hm.inspectSource, xY = Un, SY = Xn, EY = sO, qx = xY.WeakMap, _Y = SY(qx) && /native code/.test(EY(qx)), kY = Ly, TY = nO, Wx = kY("keys"), lO = function(e) {
  return Wx[e] || (Wx[e] = TY(e));
}, By = {}, CY = _Y, OY = Un, $Y = kl, RY = If, wp = pa, xp = Fy, IY = lO, AY = By, Vx = "Object already initialized", PY = OY.WeakMap, Eu, Ms, _u, DY = function(e) {
  return _u(e) ? Ms(e) : Eu(e, {});
}, jY = function(e) {
  return function(t) {
    var n;
    if (!$Y(t) || (n = Ms(t)).type !== e)
      throw TypeError("Incompatible receiver, " + e + " required");
    return n;
  };
};
if (CY || xp.state) {
  var Bi = xp.state || (xp.state = new PY()), NY = Bi.get, Hx = Bi.has, MY = Bi.set;
  Eu = function(e, t) {
    if (Hx.call(Bi, e)) throw new TypeError(Vx);
    return t.facade = e, MY.call(Bi, e, t), t;
  }, Ms = function(e) {
    return NY.call(Bi, e) || {};
  }, _u = function(e) {
    return Hx.call(Bi, e);
  };
} else {
  var Ea = IY("state");
  AY[Ea] = !0, Eu = function(e, t) {
    if (wp(e, Ea)) throw new TypeError(Vx);
    return t.facade = e, RY(e, Ea, t), t;
  }, Ms = function(e) {
    return wp(e, Ea) ? e[Ea] : {};
  }, _u = function(e) {
    return wp(e, Ea);
  };
}
var cO = {
  set: Eu,
  get: Ms,
  has: _u,
  enforce: DY,
  getterFor: jY
}, mm = da, FY = pa, uO = Function.prototype, LY = mm && Object.getOwnPropertyDescriptor, Uy = FY(uO, "name"), BY = Uy && (function() {
}).name === "something", UY = Uy && (!mm || mm && LY(uO, "name").configurable), zy = {
  EXISTS: Uy,
  PROPER: BY,
  CONFIGURABLE: UY
}, zY = Un, Zx = Xn, qY = pa, Kx = If, WY = My, VY = sO, fO = cO, HY = zy.CONFIGURABLE, ZY = fO.get, KY = fO.enforce, GY = String(String).split("String");
(oO.exports = function(e, t, n, r) {
  var i = r ? !!r.unsafe : !1, a = r ? !!r.enumerable : !1, o = r ? !!r.noTargetGet : !1, s = r && r.name !== void 0 ? r.name : t, c;
  if (Zx(n) && (String(s).slice(0, 7) === "Symbol(" && (s = "[" + String(s).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!qY(n, "name") || HY && n.name !== s) && Kx(n, "name", s), c = KY(n), c.source || (c.source = GY.join(typeof s == "string" ? s : ""))), e === zY) {
    a ? e[t] = n : WY(t, n);
    return;
  } else i ? !o && e[t] && (a = !0) : delete e[t];
  a ? e[t] = n : Kx(e, t, n);
})(Function.prototype, "toString", function() {
  return Zx(this) && ZY(this).source || VY(this);
});
var Ol = oO.exports, dO = {}, YY = Math.ceil, JY = Math.floor, Af = function(e) {
  var t = +e;
  return t !== t || t === 0 ? 0 : (t > 0 ? JY : YY)(t);
}, XY = Af, QY = Math.max, eJ = Math.min, tJ = function(e, t) {
  var n = XY(e);
  return n < 0 ? QY(n + t, 0) : eJ(n, t);
}, nJ = Af, rJ = Math.min, pO = function(e) {
  return e > 0 ? rJ(nJ(e), 9007199254740991) : 0;
}, iJ = pO, aJ = function(e) {
  return iJ(e.length);
}, oJ = Ny, sJ = tJ, lJ = aJ, Gx = function(e) {
  return function(t, n, r) {
    var i = oJ(t), a = lJ(i), o = sJ(r, a), s;
    if (e && n != n) {
      for (; a > o; )
        if (s = i[o++], s != s) return !0;
    } else for (; a > o; o++)
      if ((e || o in i) && i[o] === n) return e || o || 0;
    return !e && -1;
  };
}, cJ = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: Gx(!0),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: Gx(!1)
}, Sp = pa, uJ = Ny, fJ = cJ.indexOf, dJ = By, hO = function(e, t) {
  var n = uJ(e), r = 0, i = [], a;
  for (a in n) !Sp(dJ, a) && Sp(n, a) && i.push(a);
  for (; t.length > r; ) Sp(n, a = t[r++]) && (~fJ(i, a) || i.push(a));
  return i;
}, qy = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
], pJ = hO, hJ = qy, mJ = hJ.concat("length", "prototype");
dO.f = Object.getOwnPropertyNames || function(t) {
  return pJ(t, mJ);
};
var mO = {};
mO.f = Object.getOwnPropertySymbols;
var vJ = Rf, yJ = dO, gJ = mO, bJ = Ni, wJ = vJ("Reflect", "ownKeys") || function(t) {
  var n = yJ.f(bJ(t)), r = gJ.f;
  return r ? n.concat(r(t)) : n;
}, xJ = pa, SJ = wJ, EJ = Dy, _J = Cl, kJ = function(e, t) {
  for (var n = SJ(t), r = _J.f, i = EJ.f, a = 0; a < n.length; a++) {
    var o = n[a];
    xJ(e, o) || r(e, o, i(t, o));
  }
}, TJ = yr, CJ = Xn, OJ = /#|\.prototype\./, $l = function(e, t) {
  var n = RJ[$J(e)];
  return n == AJ ? !0 : n == IJ ? !1 : CJ(t) ? TJ(t) : !!t;
}, $J = $l.normalize = function(e) {
  return String(e).replace(OJ, ".").toLowerCase();
}, RJ = $l.data = {}, IJ = $l.NATIVE = "N", AJ = $l.POLYFILL = "P", PJ = $l, Ep = Un, DJ = Dy.f, jJ = If, NJ = Ol, MJ = My, FJ = kJ, LJ = PJ, BJ = function(e, t) {
  var n = e.target, r = e.global, i = e.stat, a, o, s, c, l, u;
  if (r ? o = Ep : i ? o = Ep[n] || MJ(n, {}) : o = (Ep[n] || {}).prototype, o) for (s in t) {
    if (l = t[s], e.noTargetGet ? (u = DJ(o, s), c = u && u.value) : c = o[s], a = LJ(r ? s : n + (i ? "." : "#") + s, e.forced), !a && c !== void 0) {
      if (typeof l == typeof c) continue;
      FJ(l, c);
    }
    (e.sham || c && c.sham) && jJ(l, "sham", !0), NJ(o, s, l, e);
  }
}, UJ = Tl, zJ = UJ("toStringTag"), vO = {};
vO[zJ] = "z";
var Wy = String(vO) === "[object z]", qJ = Wy, WJ = Xn, Ac = jy, VJ = Tl, HJ = VJ("toStringTag"), ZJ = Ac(/* @__PURE__ */ function() {
  return arguments;
}()) == "Arguments", KJ = function(e, t) {
  try {
    return e[t];
  } catch {
  }
}, yO = qJ ? Ac : function(e) {
  var t, n, r;
  return e === void 0 ? "Undefined" : e === null ? "Null" : typeof (n = KJ(t = Object(e), HJ)) == "string" ? n : ZJ ? Ac(t) : (r = Ac(t)) == "Object" && WJ(t.callee) ? "Arguments" : r;
}, GJ = yO, Pf = function(e) {
  if (GJ(e) === "Symbol") throw TypeError("Cannot convert a Symbol value to a string");
  return String(e);
}, YJ = Ni, gO = function() {
  var e = YJ(this), t = "";
  return e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.dotAll && (t += "s"), e.unicode && (t += "u"), e.sticky && (t += "y"), t;
}, Vy = {}, bO = yr, JJ = Un, wO = JJ.RegExp;
Vy.UNSUPPORTED_Y = bO(function() {
  var e = wO("a", "y");
  return e.lastIndex = 2, e.exec("abcd") != null;
});
Vy.BROKEN_CARET = bO(function() {
  var e = wO("^r", "gy");
  return e.lastIndex = 2, e.exec("str") != null;
});
var XJ = hO, QJ = qy, eX = Object.keys || function(t) {
  return XJ(t, QJ);
}, tX = da, nX = Cl, rX = Ni, iX = eX, aX = tX ? Object.defineProperties : function(t, n) {
  rX(t);
  for (var r = iX(n), i = r.length, a = 0, o; i > a; ) nX.f(t, o = r[a++], n[o]);
  return t;
}, oX = Rf, sX = oX("document", "documentElement"), lX = Ni, cX = aX, Yx = qy, uX = By, fX = sX, dX = iO, pX = lO, Jx = ">", Xx = "<", vm = "prototype", ym = "script", xO = pX("IE_PROTO"), _p = function() {
}, SO = function(e) {
  return Xx + ym + Jx + e + Xx + "/" + ym + Jx;
}, Qx = function(e) {
  e.write(SO("")), e.close();
  var t = e.parentWindow.Object;
  return e = null, t;
}, hX = function() {
  var e = dX("iframe"), t = "java" + ym + ":", n;
  return e.style.display = "none", fX.appendChild(e), e.src = String(t), n = e.contentWindow.document, n.open(), n.write(SO("document.F=Object")), n.close(), n.F;
}, dc, Pc = function() {
  try {
    dc = new ActiveXObject("htmlfile");
  } catch {
  }
  Pc = typeof document < "u" ? document.domain && dc ? Qx(dc) : hX() : Qx(dc);
  for (var e = Yx.length; e--; ) delete Pc[vm][Yx[e]];
  return Pc();
};
uX[xO] = !0;
var mX = Object.create || function(t, n) {
  var r;
  return t !== null ? (_p[vm] = lX(t), r = new _p(), _p[vm] = null, r[xO] = t) : r = Pc(), n === void 0 ? r : cX(r, n);
}, vX = yr, yX = Un, gX = yX.RegExp, bX = vX(function() {
  var e = gX(".", "s");
  return !(e.dotAll && e.exec(`
`) && e.flags === "s");
}), wX = yr, xX = Un, SX = xX.RegExp, EX = wX(function() {
  var e = SX("(?<a>b)", "g");
  return e.exec("b").groups.a !== "b" || "b".replace(e, "$<a>c") !== "bc";
}), _X = Pf, kX = gO, e1 = Vy, TX = Ly, CX = mX, OX = cO.get, $X = bX, RX = EX, ku = RegExp.prototype.exec, IX = TX("native-string-replace", String.prototype.replace), gm = ku, bm = function() {
  var e = /a/, t = /b*/g;
  return ku.call(e, "a"), ku.call(t, "a"), e.lastIndex !== 0 || t.lastIndex !== 0;
}(), EO = e1.UNSUPPORTED_Y || e1.BROKEN_CARET, wm = /()??/.exec("")[1] !== void 0, AX = bm || wm || EO || $X || RX;
AX && (gm = function(t) {
  var n = this, r = OX(n), i = _X(t), a = r.raw, o, s, c, l, u, f, d;
  if (a)
    return a.lastIndex = n.lastIndex, o = gm.call(a, i), n.lastIndex = a.lastIndex, o;
  var p = r.groups, m = EO && n.sticky, h = kX.call(n), y = n.source, v = 0, b = i;
  if (m && (h = h.replace("y", ""), h.indexOf("g") === -1 && (h += "g"), b = i.slice(n.lastIndex), n.lastIndex > 0 && (!n.multiline || n.multiline && i.charAt(n.lastIndex - 1) !== `
`) && (y = "(?: " + y + ")", b = " " + b, v++), s = new RegExp("^(?:" + y + ")", h)), wm && (s = new RegExp("^" + y + "$(?!\\s)", h)), bm && (c = n.lastIndex), l = ku.call(m ? s : n, b), m ? l ? (l.input = l.input.slice(v), l[0] = l[0].slice(v), l.index = n.lastIndex, n.lastIndex += l[0].length) : n.lastIndex = 0 : bm && l && (n.lastIndex = n.global ? l.index + l[0].length : c), wm && l && l.length > 1 && IX.call(l[0], s, function() {
    for (u = 1; u < arguments.length - 2; u++)
      arguments[u] === void 0 && (l[u] = void 0);
  }), l && p)
    for (l.groups = f = CX(null), u = 0; u < p.length; u++)
      d = p[u], f[d[0]] = l[d[1]];
  return l;
});
var Hy = gm, PX = BJ, t1 = Hy;
PX({ target: "RegExp", proto: !0, forced: /./.exec !== t1 }, {
  exec: t1
});
var n1 = Ol, DX = Hy, r1 = yr, _O = Tl, jX = If, NX = _O("species"), kp = RegExp.prototype, MX = function(e, t, n, r) {
  var i = _O(e), a = !r1(function() {
    var l = {};
    return l[i] = function() {
      return 7;
    }, ""[e](l) != 7;
  }), o = a && !r1(function() {
    var l = !1, u = /a/;
    return e === "split" && (u = {}, u.constructor = {}, u.constructor[NX] = function() {
      return u;
    }, u.flags = "", u[i] = /./[i]), u.exec = function() {
      return l = !0, null;
    }, u[i](""), !l;
  });
  if (!a || !o || n) {
    var s = /./[i], c = t(i, ""[e], function(l, u, f, d, p) {
      var m = u.exec;
      return m === DX || m === kp.exec ? a && !p ? { done: !0, value: s.call(u, f, d) } : { done: !0, value: l.call(f, u, d) } : { done: !1 };
    });
    n1(String.prototype, e, c[0]), n1(kp, i, c[1]);
  }
  r && jX(kp[i], "sham", !0);
}, FX = Af, LX = Pf, BX = $f, i1 = function(e) {
  return function(t, n) {
    var r = LX(BX(t)), i = FX(n), a = r.length, o, s;
    return i < 0 || i >= a ? e ? "" : void 0 : (o = r.charCodeAt(i), o < 55296 || o > 56319 || i + 1 === a || (s = r.charCodeAt(i + 1)) < 56320 || s > 57343 ? e ? r.charAt(i) : o : e ? r.slice(i, i + 2) : (o - 55296 << 10) + (s - 56320) + 65536);
  };
}, UX = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: i1(!1),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: i1(!0)
}, zX = UX.charAt, qX = function(e, t, n) {
  return t + (n ? zX(e, t).length : 1);
}, WX = tO, VX = Math.floor, HX = "".replace, ZX = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, KX = /\$([$&'`]|\d{1,2})/g, GX = function(e, t, n, r, i, a) {
  var o = n + e.length, s = r.length, c = KX;
  return i !== void 0 && (i = WX(i), c = ZX), HX.call(a, c, function(l, u) {
    var f;
    switch (u.charAt(0)) {
      case "$":
        return "$";
      case "&":
        return e;
      case "`":
        return t.slice(0, n);
      case "'":
        return t.slice(o);
      case "<":
        f = i[u.slice(1, -1)];
        break;
      default:
        var d = +u;
        if (d === 0) return l;
        if (d > s) {
          var p = VX(d / 10);
          return p === 0 ? l : p <= s ? r[p - 1] === void 0 ? u.charAt(1) : r[p - 1] + u.charAt(1) : l;
        }
        f = r[d - 1];
    }
    return f === void 0 ? "" : f;
  });
}, YX = Ni, JX = Xn, XX = jy, QX = Hy, eQ = function(e, t) {
  var n = e.exec;
  if (JX(n)) {
    var r = n.call(e, t);
    return r !== null && YX(r), r;
  }
  if (XX(e) === "RegExp") return QX.call(e, t);
  throw TypeError("RegExp#exec called on incompatible receiver");
}, tQ = MX, nQ = yr, rQ = Ni, iQ = Xn, aQ = Af, oQ = pO, _a = Pf, sQ = $f, lQ = qX, cQ = QC, uQ = GX, fQ = eQ, dQ = Tl, xm = dQ("replace"), pQ = Math.max, hQ = Math.min, mQ = function(e) {
  return e === void 0 ? e : String(e);
}, vQ = function() {
  return "a".replace(/./, "$0") === "$0";
}(), a1 = function() {
  return /./[xm] ? /./[xm]("a", "$0") === "" : !1;
}(), yQ = !nQ(function() {
  var e = /./;
  return e.exec = function() {
    var t = [];
    return t.groups = { a: "7" }, t;
  }, "".replace(e, "$<a>") !== "7";
});
tQ("replace", function(e, t, n) {
  var r = a1 ? "$" : "$0";
  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function(a, o) {
      var s = sQ(this), c = a == null ? void 0 : cQ(a, xm);
      return c ? c.call(a, s, o) : t.call(_a(s), a, o);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function(i, a) {
      var o = rQ(this), s = _a(i);
      if (typeof a == "string" && a.indexOf(r) === -1 && a.indexOf("$<") === -1) {
        var c = n(t, o, s, a);
        if (c.done) return c.value;
      }
      var l = iQ(a);
      l || (a = _a(a));
      var u = o.global;
      if (u) {
        var f = o.unicode;
        o.lastIndex = 0;
      }
      for (var d = []; ; ) {
        var p = fQ(o, s);
        if (p === null || (d.push(p), !u)) break;
        var m = _a(p[0]);
        m === "" && (o.lastIndex = lQ(s, oQ(o.lastIndex), f));
      }
      for (var h = "", y = 0, v = 0; v < d.length; v++) {
        p = d[v];
        for (var b = _a(p[0]), w = pQ(hQ(aQ(p.index), s.length), 0), T = [], E = 1; E < p.length; E++) T.push(mQ(p[E]));
        var _ = p.groups;
        if (l) {
          var $ = [b].concat(T, w, s);
          _ !== void 0 && $.push(_);
          var B = _a(a.apply(void 0, $));
        } else
          B = uQ(b, s, w, T, _, a);
        w >= y && (h += s.slice(y, w) + B, y = w + b.length);
      }
      return h + s.slice(y);
    }
  ];
}, !yQ || !vQ || a1);
var Wo = Qt, gQ = Qv, bQ = ca, pc = function(e) {
  return gQ.slice(0, e.length) === e;
}, wQ = function() {
  return pc("Bun/") ? "BUN" : pc("Cloudflare-Workers") ? "CLOUDFLARE" : pc("Deno/") ? "DENO" : pc("Node.js/") ? "NODE" : Wo.Bun && typeof Bun.version == "string" ? "BUN" : Wo.Deno && typeof Deno.version == "object" ? "DENO" : bQ(Wo.process) === "process" ? "NODE" : Wo.window && Wo.document ? "BROWSER" : "REST";
}(), xQ = TypeError, SQ = function(e, t) {
  if (e < t) throw new xQ("Not enough arguments");
  return e;
}, kO = Qt, EQ = Kv, _Q = gn, kQ = wQ, TQ = Qv, CQ = wf, OQ = SQ, $Q = kO.Function, RQ = /MSIE .\./.test(TQ) || kQ === "BUN" && function() {
  var e = kO.Bun.version.split(".");
  return e.length < 3 || e[0] === "0" && (e[1] < 3 || e[1] === "3" && e[2] === "0");
}(), TO = function(e, t) {
  var n = t ? 2 : 1;
  return RQ ? function(r, i) {
    var a = OQ(arguments.length, 1) > n, o = _Q(r) ? r : $Q(r), s = a ? CQ(arguments, n) : [], c = a ? function() {
      EQ(o, this, s);
    } : o;
    return t ? e(c, i) : e(c);
  } : e;
}, IQ = gt, CO = Qt, AQ = TO, o1 = AQ(CO.setInterval, !0);
IQ({ global: !0, bind: !0, forced: CO.setInterval !== o1 }, {
  setInterval: o1
});
var PQ = gt, OO = Qt, DQ = TO, s1 = DQ(OO.setTimeout, !0);
PQ({ global: !0, bind: !0, forced: OO.setTimeout !== s1 }, {
  setTimeout: s1
});
var jQ = un, NQ = jQ.setInterval, MQ = NQ;
const FQ = /* @__PURE__ */ Ye(MQ);
var LQ = en, $O = function(e, t) {
  var n = [][e];
  return !!n && LQ(function() {
    n.call(null, t || function() {
      return 1;
    }, 1);
  });
}, BQ = gt, UQ = Gv, zQ = zT.indexOf, qQ = $O, Sm = UQ([].indexOf), RO = !!Sm && 1 / Sm([1], 1, -0) < 0, WQ = RO || !qQ("indexOf");
BQ({ target: "Array", proto: !0, forced: WQ }, {
  indexOf: function(t) {
    var n = arguments.length > 1 ? arguments[1] : void 0;
    return RO ? Sm(this, t, n) || 0 : zQ(this, t, n);
  }
});
var VQ = fa, HQ = VQ("Array", "indexOf"), ZQ = ai, KQ = HQ, Tp = Array.prototype, GQ = function(e) {
  var t = e.indexOf;
  return e === Tp || ZQ(Tp, e) && t === Tp.indexOf ? KQ : t;
}, YQ = GQ, JQ = YQ, XQ = JQ;
const QQ = /* @__PURE__ */ Ye(XQ);
var l1 = df, eee = TypeError, tee = function(e, t) {
  if (!delete e[t]) throw new eee("Cannot delete property " + l1(t) + " of " + l1(e));
}, nee = gt, ree = oi, iee = dy, aee = hf, oee = ua, see = NC, lee = sy, cee = fy, uee = gl, Cp = tee, fee = mf, dee = fee("splice"), pee = Math.max, hee = Math.min;
nee({ target: "Array", proto: !0, forced: !dee }, {
  splice: function(t, n) {
    var r = ree(this), i = oee(r), a = iee(t, i), o = arguments.length, s, c, l, u, f, d;
    for (o === 0 ? s = c = 0 : o === 1 ? (s = 0, c = i - a) : (s = o - 2, c = hee(pee(aee(n), 0), i - a)), lee(i + s - c), l = cee(r, c), u = 0; u < c; u++)
      f = a + u, f in r && uee(l, u, r[f]);
    if (l.length = c, s < c) {
      for (u = a; u < i - c; u++)
        f = u + c, d = u + s, f in r ? r[d] = r[f] : Cp(r, d);
      for (u = i; u > i - c + s; u--) Cp(r, u - 1);
    } else if (s > c)
      for (u = i - c; u > a; u--)
        f = u + c - 1, d = u + s - 1, f in r ? r[d] = r[f] : Cp(r, d);
    for (u = 0; u < s; u++)
      r[u + a] = arguments[u + 2];
    return see(r, i - c + s), l;
  }
});
var mee = fa, vee = mee("Array", "splice"), yee = ai, gee = vee, Op = Array.prototype, bee = function(e) {
  var t = e.splice;
  return e === Op || yee(Op, e) && t === Op.splice ? gee : t;
}, wee = bee, xee = wee, See = xee;
const Eee = /* @__PURE__ */ Ye(See);
var _ee = fa, kee = _ee("Array", "concat"), Tee = ai, Cee = kee, $p = Array.prototype, Oee = function(e) {
  var t = e.concat;
  return e === $p || Tee($p, e) && t === $p.concat ? Cee : t;
}, $ee = Oee, Ree = $ee, Iee = Ree;
const Rt = /* @__PURE__ */ Ye(Iee);
var Aee = gt, Pee = tn, IO = Date, Dee = Pee(IO.prototype.getTime);
Aee({ target: "Date", stat: !0 }, {
  now: function() {
    return Dee(new IO());
  }
});
var jee = un, Nee = jee.Date.now, Mee = Nee, Fee = Mee, Lee = Fee;
const Ei = /* @__PURE__ */ Ye(Lee);
var Bee = yy.forEach, Uee = $O, zee = Uee("forEach"), qee = zee ? [].forEach : function(t) {
  return Bee(this, t, arguments.length > 1 ? arguments[1] : void 0);
}, Wee = gt, c1 = qee;
Wee({ target: "Array", proto: !0, forced: [].forEach !== c1 }, {
  forEach: c1
});
var Vee = fa, Hee = Vee("Array", "forEach"), Zee = Hee, Kee = Zee, Gee = bl, Yee = Bn, Jee = ai, Xee = Kee, Rp = Array.prototype, Qee = {
  DOMTokenList: !0,
  NodeList: !0
}, ete = function(e) {
  var t = e.forEach;
  return e === Rp || Jee(Rp, e) && t === Rp.forEach || Yee(Qee, Gee(e)) ? Xee : t;
}, tte = ete;
const Tu = /* @__PURE__ */ Ye(tte);
var nte = gt, rte = oi, AO = hy, ite = en, ate = ite(function() {
  AO(1);
});
nte({ target: "Object", stat: !0, forced: ate }, {
  keys: function(t) {
    return AO(rte(t));
  }
});
var ote = un, ste = ote.Object.keys, lte = ste, cte = lte, ute = cte;
const fte = /* @__PURE__ */ Ye(ute);
var dte = un, pte = dte.Object.getOwnPropertySymbols, hte = pte, mte = hte, vte = mte;
const u1 = /* @__PURE__ */ Ye(vte);
var yte = gt, gte = yy.filter, bte = mf, wte = bte("filter");
yte({ target: "Array", proto: !0, forced: !wte }, {
  filter: function(t) {
    return gte(this, t, arguments.length > 1 ? arguments[1] : void 0);
  }
});
var xte = fa, Ste = xte("Array", "filter"), Ete = ai, _te = Ste, Ip = Array.prototype, kte = function(e) {
  var t = e.filter;
  return e === Ip || Ete(Ip, e) && t === Ip.filter ? _te : t;
}, Tte = kte, Cte = Tte, Ote = Cte;
const $te = /* @__PURE__ */ Ye(Ote);
var PO = { exports: {} }, Rte = gt, Ite = en, Ate = zr, DO = hl.f, jO = Pn, Pte = !jO || Ite(function() {
  DO(1);
});
Rte({ target: "Object", stat: !0, forced: Pte, sham: !jO }, {
  getOwnPropertyDescriptor: function(t, n) {
    return DO(Ate(t), n);
  }
});
var Dte = un, NO = Dte.Object, jte = PO.exports = function(t, n) {
  return NO.getOwnPropertyDescriptor(t, n);
};
NO.getOwnPropertyDescriptor.sham && (jte.sham = !0);
var Nte = PO.exports, Mte = Nte, Fte = Mte, Lte = Fte;
const MO = /* @__PURE__ */ Ye(Lte);
var Bte = qr, Ute = tn, zte = bf, qte = xf, Wte = ji, Vte = Ute([].concat), Hte = Bte("Reflect", "ownKeys") || function(t) {
  var n = zte.f(Wte(t)), r = qte.f;
  return r ? Vte(n, r(t)) : n;
}, Zte = gt, Kte = Pn, Gte = Hte, Yte = zr, Jte = hl, Xte = gl;
Zte({ target: "Object", stat: !0, sham: !Kte }, {
  getOwnPropertyDescriptors: function(t) {
    for (var n = Yte(t), r = Jte.f, i = Gte(n), a = {}, o = 0, s, c; i.length > o; )
      c = r(n, s = i[o++]), c !== void 0 && Xte(a, s, c);
    return a;
  }
});
var Qte = un, ene = Qte.Object.getOwnPropertyDescriptors, tne = ene, nne = tne, rne = nne;
const f1 = /* @__PURE__ */ Ye(rne);
var FO = { exports: {} }, ine = gt, ane = Pn, d1 = vf.f;
ine({ target: "Object", stat: !0, forced: Object.defineProperties !== d1, sham: !ane }, {
  defineProperties: d1
});
var one = un, LO = one.Object, sne = FO.exports = function(t, n) {
  return LO.defineProperties(t, n);
};
LO.defineProperties.sham && (sne.sham = !0);
var lne = FO.exports, cne = lne, une = cne, fne = une;
const dne = /* @__PURE__ */ Ye(fne);
var pne = WC;
const hne = /* @__PURE__ */ Ye(pne);
var mne = !1;
function vne(e) {
  if (e.sheet)
    return e.sheet;
  for (var t = 0; t < document.styleSheets.length; t++)
    if (document.styleSheets[t].ownerNode === e)
      return document.styleSheets[t];
}
function yne(e) {
  var t = document.createElement("style");
  return t.setAttribute("data-emotion", e.key), e.nonce !== void 0 && t.setAttribute("nonce", e.nonce), t.appendChild(document.createTextNode("")), t.setAttribute("data-s", ""), t;
}
var gne = /* @__PURE__ */ function() {
  function e(n) {
    var r = this;
    this._insertTag = function(i) {
      var a;
      r.tags.length === 0 ? r.insertionPoint ? a = r.insertionPoint.nextSibling : r.prepend ? a = r.container.firstChild : a = r.before : a = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, a), r.tags.push(i);
    }, this.isSpeedy = n.speedy === void 0 ? !mne : n.speedy, this.tags = [], this.ctr = 0, this.nonce = n.nonce, this.key = n.key, this.container = n.container, this.prepend = n.prepend, this.insertionPoint = n.insertionPoint, this.before = null;
  }
  var t = e.prototype;
  return t.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, t.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(yne(this));
    var i = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var a = vne(i);
      try {
        a.insertRule(r, a.cssRules.length);
      } catch {
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, t.flush = function() {
    this.tags.forEach(function(r) {
      var i;
      return (i = r.parentNode) == null ? void 0 : i.removeChild(r);
    }), this.tags = [], this.ctr = 0;
  }, e;
}(), dn = "-ms-", Cu = "-moz-", lt = "-webkit-", BO = "comm", Zy = "rule", Ky = "decl", bne = "@import", UO = "@keyframes", wne = "@layer", xne = Math.abs, Df = String.fromCharCode, Sne = Object.assign;
function Ene(e, t) {
  return cn(e, 0) ^ 45 ? (((t << 2 ^ cn(e, 0)) << 2 ^ cn(e, 1)) << 2 ^ cn(e, 2)) << 2 ^ cn(e, 3) : 0;
}
function zO(e) {
  return e.trim();
}
function _ne(e, t) {
  return (e = t.exec(e)) ? e[0] : e;
}
function ct(e, t, n) {
  return e.replace(t, n);
}
function Em(e, t) {
  return e.indexOf(t);
}
function cn(e, t) {
  return e.charCodeAt(t) | 0;
}
function Fs(e, t, n) {
  return e.slice(t, n);
}
function Or(e) {
  return e.length;
}
function Gy(e) {
  return e.length;
}
function hc(e, t) {
  return t.push(e), e;
}
function kne(e, t) {
  return e.map(t).join("");
}
var jf = 1, ao = 1, qO = 0, In = 0, Vt = 0, Co = "";
function Nf(e, t, n, r, i, a, o) {
  return { value: e, root: t, parent: n, type: r, props: i, children: a, line: jf, column: ao, length: o, return: "" };
}
function Vo(e, t) {
  return Sne(Nf("", null, null, "", null, null, 0), e, { length: -e.length }, t);
}
function Tne() {
  return Vt;
}
function Cne() {
  return Vt = In > 0 ? cn(Co, --In) : 0, ao--, Vt === 10 && (ao = 1, jf--), Vt;
}
function Fn() {
  return Vt = In < qO ? cn(Co, In++) : 0, ao++, Vt === 10 && (ao = 1, jf++), Vt;
}
function Ar() {
  return cn(Co, In);
}
function Dc() {
  return In;
}
function Rl(e, t) {
  return Fs(Co, e, t);
}
function Ls(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function WO(e) {
  return jf = ao = 1, qO = Or(Co = e), In = 0, [];
}
function VO(e) {
  return Co = "", e;
}
function jc(e) {
  return zO(Rl(In - 1, _m(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function One(e) {
  for (; (Vt = Ar()) && Vt < 33; )
    Fn();
  return Ls(e) > 2 || Ls(Vt) > 3 ? "" : " ";
}
function $ne(e, t) {
  for (; --t && Fn() && !(Vt < 48 || Vt > 102 || Vt > 57 && Vt < 65 || Vt > 70 && Vt < 97); )
    ;
  return Rl(e, Dc() + (t < 6 && Ar() == 32 && Fn() == 32));
}
function _m(e) {
  for (; Fn(); )
    switch (Vt) {
      case e:
        return In;
      case 34:
      case 39:
        e !== 34 && e !== 39 && _m(Vt);
        break;
      case 40:
        e === 41 && _m(e);
        break;
      case 92:
        Fn();
        break;
    }
  return In;
}
function Rne(e, t) {
  for (; Fn() && e + Vt !== 57; )
    if (e + Vt === 84 && Ar() === 47)
      break;
  return "/*" + Rl(t, In - 1) + "*" + Df(e === 47 ? e : Fn());
}
function Ine(e) {
  for (; !Ls(Ar()); )
    Fn();
  return Rl(e, In);
}
function Ane(e) {
  return VO(Nc("", null, null, null, [""], e = WO(e), 0, [0], e));
}
function Nc(e, t, n, r, i, a, o, s, c) {
  for (var l = 0, u = 0, f = o, d = 0, p = 0, m = 0, h = 1, y = 1, v = 1, b = 0, w = "", T = i, E = a, _ = r, $ = w; y; )
    switch (m = b, b = Fn()) {
      case 40:
        if (m != 108 && cn($, f - 1) == 58) {
          Em($ += ct(jc(b), "&", "&\f"), "&\f") != -1 && (v = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        $ += jc(b);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        $ += One(m);
        break;
      case 92:
        $ += $ne(Dc() - 1, 7);
        continue;
      case 47:
        switch (Ar()) {
          case 42:
          case 47:
            hc(Pne(Rne(Fn(), Dc()), t, n), c);
            break;
          default:
            $ += "/";
        }
        break;
      case 123 * h:
        s[l++] = Or($) * v;
      case 125 * h:
      case 59:
      case 0:
        switch (b) {
          case 0:
          case 125:
            y = 0;
          case 59 + u:
            v == -1 && ($ = ct($, /\f/g, "")), p > 0 && Or($) - f && hc(p > 32 ? h1($ + ";", r, n, f - 1) : h1(ct($, " ", "") + ";", r, n, f - 2), c);
            break;
          case 59:
            $ += ";";
          default:
            if (hc(_ = p1($, t, n, l, u, i, s, w, T = [], E = [], f), a), b === 123)
              if (u === 0)
                Nc($, t, _, _, T, a, f, s, E);
              else
                switch (d === 99 && cn($, 3) === 110 ? 100 : d) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Nc(e, _, _, r && hc(p1(e, _, _, 0, 0, i, s, w, i, T = [], f), E), i, E, f, s, r ? T : E);
                    break;
                  default:
                    Nc($, _, _, _, [""], E, 0, s, E);
                }
        }
        l = u = p = 0, h = v = 1, w = $ = "", f = o;
        break;
      case 58:
        f = 1 + Or($), p = m;
      default:
        if (h < 1) {
          if (b == 123)
            --h;
          else if (b == 125 && h++ == 0 && Cne() == 125)
            continue;
        }
        switch ($ += Df(b), b * h) {
          case 38:
            v = u > 0 ? 1 : ($ += "\f", -1);
            break;
          case 44:
            s[l++] = (Or($) - 1) * v, v = 1;
            break;
          case 64:
            Ar() === 45 && ($ += jc(Fn())), d = Ar(), u = f = Or(w = $ += Ine(Dc())), b++;
            break;
          case 45:
            m === 45 && Or($) == 2 && (h = 0);
        }
    }
  return a;
}
function p1(e, t, n, r, i, a, o, s, c, l, u) {
  for (var f = i - 1, d = i === 0 ? a : [""], p = Gy(d), m = 0, h = 0, y = 0; m < r; ++m)
    for (var v = 0, b = Fs(e, f + 1, f = xne(h = o[m])), w = e; v < p; ++v)
      (w = zO(h > 0 ? d[v] + " " + b : ct(b, /&\f/g, d[v]))) && (c[y++] = w);
  return Nf(e, t, n, i === 0 ? Zy : s, c, l, u);
}
function Pne(e, t, n) {
  return Nf(e, t, n, BO, Df(Tne()), Fs(e, 2, -2), 0);
}
function h1(e, t, n, r) {
  return Nf(e, t, n, Ky, Fs(e, 0, r), Fs(e, r + 1, -1), r);
}
function qa(e, t) {
  for (var n = "", r = Gy(e), i = 0; i < r; i++)
    n += t(e[i], i, e, t) || "";
  return n;
}
function Dne(e, t, n, r) {
  switch (e.type) {
    case wne:
      if (e.children.length) break;
    case bne:
    case Ky:
      return e.return = e.return || e.value;
    case BO:
      return "";
    case UO:
      return e.return = e.value + "{" + qa(e.children, r) + "}";
    case Zy:
      e.value = e.props.join(",");
  }
  return Or(n = qa(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function jne(e) {
  var t = Gy(e);
  return function(n, r, i, a) {
    for (var o = "", s = 0; s < t; s++)
      o += e[s](n, r, i, a) || "";
    return o;
  };
}
function Nne(e) {
  return function(t) {
    t.root || (t = t.return) && e(t);
  };
}
function Mne(e) {
  var t = /* @__PURE__ */ Object.create(null);
  return function(n) {
    return t[n] === void 0 && (t[n] = e(n)), t[n];
  };
}
var Fne = function(t, n, r) {
  for (var i = 0, a = 0; i = a, a = Ar(), i === 38 && a === 12 && (n[r] = 1), !Ls(a); )
    Fn();
  return Rl(t, In);
}, Lne = function(t, n) {
  var r = -1, i = 44;
  do
    switch (Ls(i)) {
      case 0:
        i === 38 && Ar() === 12 && (n[r] = 1), t[r] += Fne(In - 1, n, r);
        break;
      case 2:
        t[r] += jc(i);
        break;
      case 4:
        if (i === 44) {
          t[++r] = Ar() === 58 ? "&\f" : "", n[r] = t[r].length;
          break;
        }
      default:
        t[r] += Df(i);
    }
  while (i = Fn());
  return t;
}, Bne = function(t, n) {
  return VO(Lne(WO(t), n));
}, m1 = /* @__PURE__ */ new WeakMap(), Une = function(t) {
  if (!(t.type !== "rule" || !t.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  t.length < 1)) {
    for (var n = t.value, r = t.parent, i = t.column === r.column && t.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r) return;
    if (!(t.props.length === 1 && n.charCodeAt(0) !== 58 && !m1.get(r)) && !i) {
      m1.set(t, !0);
      for (var a = [], o = Bne(n, a), s = r.props, c = 0, l = 0; c < o.length; c++)
        for (var u = 0; u < s.length; u++, l++)
          t.props[l] = a[c] ? o[c].replace(/&\f/g, s[u]) : s[u] + " " + o[c];
    }
  }
}, zne = function(t) {
  if (t.type === "decl") {
    var n = t.value;
    // charcode for l
    n.charCodeAt(0) === 108 && // charcode for b
    n.charCodeAt(2) === 98 && (t.return = "", t.value = "");
  }
};
function HO(e, t) {
  switch (Ene(e, t)) {
    case 5103:
      return lt + "print-" + e + e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return lt + e + e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return lt + e + Cu + e + dn + e + e;
    case 6828:
    case 4268:
      return lt + e + dn + e + e;
    case 6165:
      return lt + e + dn + "flex-" + e + e;
    case 5187:
      return lt + e + ct(e, /(\w+).+(:[^]+)/, lt + "box-$1$2" + dn + "flex-$1$2") + e;
    case 5443:
      return lt + e + dn + "flex-item-" + ct(e, /flex-|-self/, "") + e;
    case 4675:
      return lt + e + dn + "flex-line-pack" + ct(e, /align-content|flex-|-self/, "") + e;
    case 5548:
      return lt + e + dn + ct(e, "shrink", "negative") + e;
    case 5292:
      return lt + e + dn + ct(e, "basis", "preferred-size") + e;
    case 6060:
      return lt + "box-" + ct(e, "-grow", "") + lt + e + dn + ct(e, "grow", "positive") + e;
    case 4554:
      return lt + ct(e, /([^-])(transform)/g, "$1" + lt + "$2") + e;
    case 6187:
      return ct(ct(ct(e, /(zoom-|grab)/, lt + "$1"), /(image-set)/, lt + "$1"), e, "") + e;
    case 5495:
    case 3959:
      return ct(e, /(image-set\([^]*)/, lt + "$1$`$1");
    case 4968:
      return ct(ct(e, /(.+:)(flex-)?(.*)/, lt + "box-pack:$3" + dn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + lt + e + e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return ct(e, /(.+)-inline(.+)/, lt + "$1$2") + e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Or(e) - 1 - t > 6) switch (cn(e, t + 1)) {
        case 109:
          if (cn(e, t + 4) !== 45) break;
        case 102:
          return ct(e, /(.+:)(.+)-([^]+)/, "$1" + lt + "$2-$3$1" + Cu + (cn(e, t + 3) == 108 ? "$3" : "$2-$3")) + e;
        case 115:
          return ~Em(e, "stretch") ? HO(ct(e, "stretch", "fill-available"), t) + e : e;
      }
      break;
    case 4949:
      if (cn(e, t + 1) !== 115) break;
    case 6444:
      switch (cn(e, Or(e) - 3 - (~Em(e, "!important") && 10))) {
        case 107:
          return ct(e, ":", ":" + lt) + e;
        case 101:
          return ct(e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + lt + (cn(e, 14) === 45 ? "inline-" : "") + "box$3$1" + lt + "$2$3$1" + dn + "$2box$3") + e;
      }
      break;
    case 5936:
      switch (cn(e, t + 11)) {
        case 114:
          return lt + e + dn + ct(e, /[svh]\w+-[tblr]{2}/, "tb") + e;
        case 108:
          return lt + e + dn + ct(e, /[svh]\w+-[tblr]{2}/, "tb-rl") + e;
        case 45:
          return lt + e + dn + ct(e, /[svh]\w+-[tblr]{2}/, "lr") + e;
      }
      return lt + e + dn + e + e;
  }
  return e;
}
var qne = function(t, n, r, i) {
  if (t.length > -1 && !t.return) switch (t.type) {
    case Ky:
      t.return = HO(t.value, t.length);
      break;
    case UO:
      return qa([Vo(t, {
        value: ct(t.value, "@", "@" + lt)
      })], i);
    case Zy:
      if (t.length) return kne(t.props, function(a) {
        switch (_ne(a, /(::plac\w+|:read-\w+)/)) {
          case ":read-only":
          case ":read-write":
            return qa([Vo(t, {
              props: [ct(a, /:(read-\w+)/, ":" + Cu + "$1")]
            })], i);
          case "::placeholder":
            return qa([Vo(t, {
              props: [ct(a, /:(plac\w+)/, ":" + lt + "input-$1")]
            }), Vo(t, {
              props: [ct(a, /:(plac\w+)/, ":" + Cu + "$1")]
            }), Vo(t, {
              props: [ct(a, /:(plac\w+)/, dn + "input-$1")]
            })], i);
        }
        return "";
      });
  }
}, Wne = [qne], Vne = function(t) {
  var n = t.key;
  if (n === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(h) {
      var y = h.getAttribute("data-emotion");
      y.indexOf(" ") !== -1 && (document.head.appendChild(h), h.setAttribute("data-s", ""));
    });
  }
  var i = t.stylisPlugins || Wne, a = {}, o, s = [];
  o = t.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
    function(h) {
      for (var y = h.getAttribute("data-emotion").split(" "), v = 1; v < y.length; v++)
        a[y[v]] = !0;
      s.push(h);
    }
  );
  var c, l = [Une, zne];
  {
    var u, f = [Dne, Nne(function(h) {
      u.insert(h);
    })], d = jne(l.concat(i, f)), p = function(y) {
      return qa(Ane(y), d);
    };
    c = function(y, v, b, w) {
      u = b, p(y ? y + "{" + v.styles + "}" : v.styles), w && (m.inserted[v.name] = !0);
    };
  }
  var m = {
    key: n,
    sheet: new gne({
      key: n,
      container: o,
      nonce: t.nonce,
      speedy: t.speedy,
      prepend: t.prepend,
      insertionPoint: t.insertionPoint
    }),
    nonce: t.nonce,
    inserted: a,
    registered: {},
    insert: c
  };
  return m.sheet.hydrate(s), m;
};
function Hne(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
var Zne = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  scale: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, Kne = !1, Gne = /[A-Z]|^ms/g, Yne = /_EMO_([^_]+?)_([^]*?)_EMO_/g, ZO = function(t) {
  return t.charCodeAt(1) === 45;
}, v1 = function(t) {
  return t != null && typeof t != "boolean";
}, Ap = /* @__PURE__ */ Mne(function(e) {
  return ZO(e) ? e : e.replace(Gne, "-$&").toLowerCase();
}), y1 = function(t, n) {
  switch (t) {
    case "animation":
    case "animationName":
      if (typeof n == "string")
        return n.replace(Yne, function(r, i, a) {
          return yi = {
            name: i,
            styles: a,
            next: yi
          }, i;
        });
  }
  return Zne[t] !== 1 && !ZO(t) && typeof n == "number" && n !== 0 ? n + "px" : n;
}, Jne = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function Ou(e, t, n) {
  if (n == null)
    return "";
  var r = n;
  if (r.__emotion_styles !== void 0)
    return r;
  switch (typeof n) {
    case "boolean":
      return "";
    case "object": {
      var i = n;
      if (i.anim === 1)
        return yi = {
          name: i.name,
          styles: i.styles,
          next: yi
        }, i.name;
      var a = n;
      if (a.styles !== void 0) {
        var o = a.next;
        if (o !== void 0)
          for (; o !== void 0; )
            yi = {
              name: o.name,
              styles: o.styles,
              next: yi
            }, o = o.next;
        var s = a.styles + ";";
        return s;
      }
      return Xne(e, t, n);
    }
  }
  var c = n;
  if (t == null)
    return c;
  var l = t[c];
  return l !== void 0 ? l : c;
}
function Xne(e, t, n) {
  var r = "";
  if (Array.isArray(n))
    for (var i = 0; i < n.length; i++)
      r += Ou(e, t, n[i]) + ";";
  else
    for (var a in n) {
      var o = n[a];
      if (typeof o != "object") {
        var s = o;
        t != null && t[s] !== void 0 ? r += a + "{" + t[s] + "}" : v1(s) && (r += Ap(a) + ":" + y1(a, s) + ";");
      } else {
        if (a === "NO_COMPONENT_SELECTOR" && Kne)
          throw new Error(Jne);
        if (Array.isArray(o) && typeof o[0] == "string" && (t == null || t[o[0]] === void 0))
          for (var c = 0; c < o.length; c++)
            v1(o[c]) && (r += Ap(a) + ":" + y1(a, o[c]) + ";");
        else {
          var l = Ou(e, t, o);
          switch (a) {
            case "animation":
            case "animationName": {
              r += Ap(a) + ":" + l + ";";
              break;
            }
            default:
              r += a + "{" + l + "}";
          }
        }
      }
    }
  return r;
}
var g1 = /label:\s*([^\s;{]+)\s*(;|$)/g, yi;
function Pp(e, t, n) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var r = !0, i = "";
  yi = void 0;
  var a = e[0];
  if (a == null || a.raw === void 0)
    r = !1, i += Ou(n, t, a);
  else {
    var o = a;
    i += o[0];
  }
  for (var s = 1; s < e.length; s++)
    if (i += Ou(n, t, e[s]), r) {
      var c = a;
      i += c[s];
    }
  g1.lastIndex = 0;
  for (var l = "", u; (u = g1.exec(i)) !== null; )
    l += "-" + u[1];
  var f = Hne(i) + l;
  return {
    name: f,
    styles: i,
    next: yi
  };
}
function KO(e, t, n) {
  var r = "";
  return n.split(" ").forEach(function(i) {
    e[i] !== void 0 ? t.push(e[i] + ";") : i && (r += i + " ");
  }), r;
}
var Qne = function(t, n, r) {
  var i = t.key + "-" + n.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  t.registered[i] === void 0 && (t.registered[i] = n.styles);
}, ere = function(t, n, r) {
  Qne(t, n);
  var i = t.key + "-" + n.name;
  if (t.inserted[n.name] === void 0) {
    var a = n;
    do
      t.insert(n === a ? "." + i : "", a, t.sheet, !0), a = a.next;
    while (a !== void 0);
  }
};
function b1(e, t) {
  if (e.inserted[t.name] === void 0)
    return e.insert("", t, e.sheet, !0);
}
function w1(e, t, n) {
  var r = [], i = KO(e, r, n);
  return r.length < 2 ? n : i + t(r);
}
var tre = function(t) {
  var n = Vne(t);
  n.sheet.speedy = function(s) {
    if (process.env.NODE_ENV !== "production" && this.ctr !== 0)
      throw new Error("speedy must be changed before any rules are inserted");
    this.isSpeedy = s;
  }, n.compat = !0;
  var r = function() {
    for (var c = arguments.length, l = new Array(c), u = 0; u < c; u++)
      l[u] = arguments[u];
    var f = Pp(l, n.registered, void 0);
    return ere(n, f), n.key + "-" + f.name;
  }, i = function() {
    for (var c = arguments.length, l = new Array(c), u = 0; u < c; u++)
      l[u] = arguments[u];
    var f = Pp(l, n.registered), d = "animation-" + f.name;
    return b1(n, {
      name: f.name,
      styles: "@keyframes " + d + "{" + f.styles + "}"
    }), d;
  }, a = function() {
    for (var c = arguments.length, l = new Array(c), u = 0; u < c; u++)
      l[u] = arguments[u];
    var f = Pp(l, n.registered);
    b1(n, f);
  }, o = function() {
    for (var c = arguments.length, l = new Array(c), u = 0; u < c; u++)
      l[u] = arguments[u];
    return w1(n.registered, r, nre(l));
  };
  return {
    css: r,
    cx: o,
    injectGlobal: a,
    keyframes: i,
    hydrate: function(c) {
      c.forEach(function(l) {
        n.inserted[l] = !0;
      });
    },
    flush: function() {
      n.registered = {}, n.inserted = {}, n.sheet.flush();
    },
    // $FlowFixMe
    sheet: n.sheet,
    cache: n,
    getRegisteredStyles: KO.bind(null, n.registered),
    merge: w1.bind(null, n.registered, r)
  };
}, nre = function e(t) {
  for (var n = "", r = 0; r < t.length; r++) {
    var i = t[r];
    if (i != null) {
      var a = void 0;
      switch (typeof i) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(i))
            a = e(i);
          else {
            a = "";
            for (var o in i)
              i[o] && o && (a && (a += " "), a += o);
          }
          break;
        }
        default:
          a = i;
      }
      a && (n && (n += " "), n += a);
    }
  }
  return n;
}, rre = Ol, Yy = Date.prototype, x1 = "Invalid Date", GO = "toString", ire = Yy[GO], are = Yy.getTime;
String(/* @__PURE__ */ new Date(NaN)) != x1 && rre(Yy, GO, function() {
  var t = are.call(this);
  return t === t ? ire.call(this) : x1;
});
var ore = Wy, sre = yO, lre = ore ? {}.toString : function() {
  return "[object " + sre(this) + "]";
}, cre = Wy, ure = Ol, fre = lre;
cre || ure(Object.prototype, "toString", fre, { unsafe: !0 });
var dre = zy.PROPER, pre = Ol, hre = Ni, S1 = Pf, mre = yr, vre = gO, Jy = "toString", YO = RegExp.prototype, JO = YO[Jy], yre = mre(function() {
  return JO.call({ source: "a", flags: "b" }) != "/a/b";
}), gre = dre && JO.name != Jy;
(yre || gre) && pre(RegExp.prototype, Jy, function() {
  var t = hre(this), n = S1(t.source), r = t.flags, i = S1(r === void 0 && t instanceof RegExp && !("flags" in YO) ? vre.call(t) : r);
  return "/" + n + "/" + i;
}, { unsafe: !0 });
var E1 = typeof window < "u" ? window : self, bre = E1.crypto || E1.msCrypto, wre = function(e) {
  if (!e) return Math.random;
  var t = Math.pow(2, 32), n = new Uint32Array(1);
  return function() {
    return e.getRandomValues(n)[0] / t;
  };
}(bre);
const xre = /* @__PURE__ */ Ye(wre);
function Sre() {
  return xre().toString(26).substr(2, 5).replace(/[0-9]/g, function(e) {
    return String.fromCharCode(e.charCodeAt(0) + 65);
  });
}
var Ere = DT;
const _1 = /* @__PURE__ */ Ye(Ere);
function mt(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "white", n = "background-color: ".concat(e, "; border-radius: 4px; padding: 2px 4px;");
  return t && (n += " color: ".concat(t, ";")), [n, ""];
}
function k1(e, t) {
  for (var n, r, i = arguments.length, a = new Array(i > 2 ? i - 2 : 0), o = 2; o < i; o++)
    a[o - 2] = arguments[o];
  return Rt(n = [Rt(r = "%c".concat(e, "%c ")).call(r, t)]).call(n, tt(mt("green", "white")), a);
}
function _re(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.force, r = n === void 0 ? !1 : n;
  return r ? function() {
    for (var i = arguments.length, a = new Array(i), o = 0; o < i; o++)
      a[o] = arguments[o];
    if (a.length) {
      var s = a, c = Tr(s, 1), l = c[0];
      typeof l == "function" && (a = l());
      var u = _1(a[0]) ? a : [a], f = u.length === 1;
      Tu(u).call(u, function(d, p) {
        if (f) {
          var m, h;
          (m = console).log.apply(m, tt(k1.apply(void 0, Rt(h = [e]).call(h, tt(d)))));
        } else if (p) {
          var y;
          (y = console).log.apply(y, tt(_1(d) ? d : [d]));
        } else {
          var v, b;
          (v = console).groupCollapsed.apply(v, tt(k1.apply(void 0, Rt(b = [e]).call(b, tt(d)))));
        }
      }), f || console.groupEnd();
    }
  } : function() {
    return 0;
  };
}
var kre = da, Tre = zy.EXISTS, Cre = Cl.f, XO = Function.prototype, Ore = XO.toString, $re = /^\s*function ([^ (]*)/, Rre = "name";
kre && !Tre && Cre(XO, Rre, {
  configurable: !0,
  get: function() {
    try {
      return Ore.call(this).match($re)[1];
    } catch {
      return "";
    }
  }
});
var Ire = un, Are = Ire.setTimeout, Pre = Are;
const Dre = /* @__PURE__ */ Ye(Pre);
function jre(e, t) {
  if (!t)
    return e;
  var n = 0, r = null;
  return function() {
    for (var i = arguments.length, a = new Array(i), o = 0; o < i; o++)
      a[o] = arguments[o];
    var s = Ei();
    s - n > t ? (e.apply(void 0, a), n = s) : (clearTimeout(r), r = Dre(function() {
      e.apply(void 0, a), n = Ei();
    }, Math.max(0, t - s + n)));
  };
}
var QO = function(t) {
  var n = t.debounce, r = t.name, i = t.onEvent, a = t.target, o = Tt();
  o.current = i;
  var s = zt(function() {
    return jre(function(l) {
      var u = o.current;
      u && u(l);
    }, n);
  }, [n, o]), c = ot(function(l) {
    l.timeStampLow = Ei(), s(l);
  }, [s]);
  return mo(function() {
    return a.addEventListener(r, c, {
      passive: !0
    }), c({
      target: a,
      type: r
    }), function() {
      return a.removeEventListener(r, c);
    };
  }, [r, c, a]), !1;
};
QO.defaultProps = {
  debounce: 200
};
var Nre = Math.sign || function(t) {
  var n = +t;
  return n === 0 || n !== n ? n : n < 0 ? -1 : 1;
}, Mre = gt, Fre = Nre;
Mre({ target: "Math", stat: !0 }, {
  sign: Fre
});
var Lre = un, Bre = Lre.Math.sign, Ure = Bre, zre = Ure, qre = zre;
const Wre = /* @__PURE__ */ Ye(qre);
function Vre(e, t) {
  var n = Wre(t - e), r = Math.sqrt(Math.abs(t - e)), i = e + r * n;
  return n > 0 ? Math.min(t, i) : Math.max(t, i);
}
function Hre(e, t, n, r) {
  for (var i = e, a = 0; a < r; a++)
    i = n(i, t);
  return i;
}
var e$ = function(t) {
  var n = t.name, r = t.onEnd, i = t.target, a = t.value, o = Tt(), s = ot(function(l, u, f, d) {
    var p = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Ei();
    (f === "100%" || typeof f == "number") && (cancelAnimationFrame(o.current), o.current = requestAnimationFrame(function() {
      if (i) {
        var m = f === "100%" ? i.scrollHeight - i.offsetHeight : f, h = Hre(u, m, Vre, (Ei() - p) / 5);
        Math.abs(m - h) < 1.5 && (h = m), i[l] = h, m === h ? r && r(!0) : s(l, u, f, d + 1, p);
      }
    }));
  }, [o, r, i]), c = ot(function() {
    cancelAnimationFrame(o.current), r && r(!1);
  }, [r]);
  return mo(function() {
    return s(n, i[n], a, 1), i ? (i.addEventListener("pointerdown", c, {
      passive: !0
    }), i.addEventListener("wheel", c, {
      passive: !0
    }), function() {
      i.removeEventListener("pointerdown", c), i.removeEventListener("wheel", c), cancelAnimationFrame(o.current);
    }) : function() {
      return cancelAnimationFrame(o.current);
    };
  }, [s, o, c, n, i, a]), !1;
};
e$.propTypes = {
  name: it.string.isRequired,
  onEnd: it.func,
  target: it.any.isRequired,
  value: it.oneOfType([it.number, it.oneOf(["100%"])]).isRequired
};
function Dp(e) {
  var t = He(e), n = Tr(t, 2), r = n[0], i = n[1], a = Tt(), o = ot(function(s) {
    typeof s == "function" ? o(function(c) {
      return s = s(c), a.current = s, s;
    }) : (a.current = s, o(s));
  }, [a]);
  return a.current = r, [r, i, a];
}
function T1(e, t) {
  var n = fte(e);
  if (u1) {
    var r = u1(e);
    t && (r = $te(r).call(r, function(i) {
      return MO(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function C1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    if (t % 2) {
      var r;
      Tu(r = T1(Object(n), !0)).call(r, function(a) {
        iG(e, a, n[a]);
      });
    } else if (f1)
      dne(e, f1(n));
    else {
      var i;
      Tu(i = T1(Object(n))).call(i, function(a) {
        hne(e, a, MO(n, a));
      });
    }
  }
  return e;
}
var Zre = function() {
  return 1 / 0;
}, O1 = 17, Kre = "bottom", rr = "top", $1 = 1, Gre = 34, R1 = {};
function Yre(e, t) {
  return e(), FQ(e, t);
}
function I1(e) {
  var t = e.mode, n = e.target, r = n.offsetHeight, i = n.scrollHeight, a = n.scrollTop, o = i - a - r < $1, s = a < $1, c = t === rr ? s : o, l = t !== rr ? s : o;
  return {
    atBottom: o,
    atEnd: c,
    atStart: l,
    atTop: s
  };
}
function Ho(e, t) {
  return e === (t === rr ? 0 : "100%");
}
var Xy = function(t) {
  var n = t.checkInterval, r = t.children, i = t.debounce, a = t.debug, o = t.initialScrollBehavior, s = t.mode, c = t.nonce, l = t.scroller, u = zt(function() {
    return _re("<ScrollToBottom>", {
      force: a
    });
  }, [a]);
  s = s === rr ? rr : Kre;
  var f = Tt(0), d = Tt(o), p = Dp(s === rr ? 0 : "100%"), m = Tr(p, 3), h = m[0], y = m[1], v = m[2], b = Dp(null), w = Tr(b, 3), T = w[0], E = w[1], _ = w[2], $ = Tt(0), B = Tt(0), U = Tt(0), k = He(!0), D = Tr(k, 2), q = D[0], L = D[1], R = He(!0), A = Tr(R, 2), F = A[0], H = A[1], V = He(!0), I = Tr(V, 2), g = I[0], j = I[1], W = He(!1), S = Tr(W, 2), Z = S[0], Y = S[1], G = Dp(!0), X = Tr(G, 3), ie = X[0], ae = X[1], J = X[2], Q = Tt([]), K = ot(function(N) {
    var te = _.current;
    return Q.current.push(N), te && N({
      scrollTop: te.scrollTop
    }), function() {
      var de = Q.current, be = QQ(de).call(de, N);
      ~be && Eee(de).call(de, be, 1);
    };
  }, [Q, _]), fe = ot(function() {
    var N = v.current;
    u(function() {
      var te;
      return Rt(te = ["%cSpineTo%c: %conEnd%c is fired."]).call(te, tt(mt("magenta")), tt(mt("orange")), [{
        animateTo: N
      }]);
    }), f.current = Ei(), Ho(N, s) || ae(!1), y(null);
  }, [v, u, f, s, y, ae]), ye = ot(function(N) {
    var te = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, de = te.behavior, be = _.current;
    if (typeof N != "number" && N !== "100%")
      return console.warn('react-scroll-to-bottom: Arguments passed to scrollTo() must be either number or "100%".');
    u(function() {
      var Oe;
      return [Rt(Oe = ["%cscrollTo%c: Will scroll to %c".concat(typeof N == "number" ? N + "px" : N.replace(/%/g, "%%"), "%c")]).call(Oe, tt(mt("lime", "")), tt(mt("purple"))), {
        behavior: de,
        nextAnimateTo: N,
        target: be
      }];
    }), de === "auto" ? (fe(), be && (be.scrollTop = N === "100%" ? be.scrollHeight - be.offsetHeight : N)) : (de !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollTo". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'), y(N)), Ho(N, s) && (u(function() {
      var Oe;
      return [Rt(Oe = ["%cscrollTo%c: Scrolling to end, will set sticky to %ctrue%c."]).call(Oe, tt(mt("lime", "")), tt(mt("purple"))), [{
        mode: s,
        nextAnimateTo: N
      }]];
    }), ae(!0));
  }, [u, fe, s, y, ae, _]), $e = ot(function() {
    var N = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, te = N.behavior;
    u(function() {
      var de;
      return Rt(de = ["%cscrollToBottom%c: Called"]).call(de, tt(mt("yellow", "")));
    }), te !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToBottom". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'), ye("100%", {
      behavior: te || "smooth"
    });
  }, [u, ye]), M = ot(function() {
    var N = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, te = N.behavior;
    u(function() {
      var de;
      return Rt(de = ["%cscrollToTop%c: Called"]).call(de, tt(mt("yellow", "")));
    }), te !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToTop". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.'), ye(0, {
      behavior: te || "smooth"
    });
  }, [u, ye]), re = ot(function() {
    var N = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, te = N.behavior;
    u(function() {
      var be;
      return Rt(be = ["%cscrollToEnd%c: Called"]).call(be, tt(mt("yellow", "")));
    }), te !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToEnd". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var de = {
      behavior: te || "smooth"
    };
    s === rr ? M(de) : $e(de);
  }, [u, s, $e, M]), le = ot(function() {
    var N = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, te = N.behavior;
    u(function() {
      var be;
      return Rt(be = ["%cscrollToStart%c: Called"]).call(be, tt(mt("yellow", "")));
    }), te !== "smooth" && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToStart". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var de = {
      behavior: te || "smooth"
    };
    s === rr ? $e(de) : M(de);
  }, [u, s, $e, M]), oe = ot(function() {
    var N = _.current;
    if (N) {
      if (d.current === "auto") {
        u(function() {
          var kt;
          return Rt(kt = ["%ctarget changed%c: Initial scroll"]).call(kt, tt(mt("blue")));
        }), N.scrollTop = s === rr ? 0 : N.scrollHeight - N.offsetHeight, d.current = !1;
        return;
      }
      var te = $.current, de = N.offsetHeight, be = N.scrollHeight, Oe = N.scrollTop, Ve = s === rr ? 0 : Math.max(0, be - de - Oe), Qe = Math.max(0, te - Oe), Ct = l({
        maxValue: Ve,
        minValue: Qe,
        offsetHeight: de,
        scrollHeight: be,
        scrollTop: Oe
      }), _t = Math.max(0, Math.min(Ve, Ct)), Ue;
      s === rr || _t !== Ve ? Ue = Oe + _t : Ue = "100%", u(function() {
        var kt, Ze, fn;
        return [Rt(kt = [Rt(Ze = Rt(fn = "%cscrollToSticky%c: Will animate from %c".concat(te, "px%c to %c")).call(fn, typeof Ue == "number" ? Ue + "px" : Ue.replace(/%/g, "%%"), "%c (%c")).call(Ze, (Ue === "100%" ? Ve : Ue) + te, "px%c)")]).call(kt, tt(mt("orange")), tt(mt("purple")), tt(mt("purple")), tt(mt("purple"))), {
          animateFrom: te,
          maxValue: Ve,
          minValue: Qe,
          nextAnimateTo: Ue,
          nextValue: _t,
          offsetHeight: de,
          rawNextValue: Ct,
          scrollHeight: be,
          scrollTop: Oe
        }];
      }), ye(Ue, {
        behavior: "smooth"
      });
    }
  }, [$, u, s, l, ye, _]), Te = ot(function(N) {
    var te, de = N.timeStampLow, be = v.current, Oe = _.current, Ve = be !== null;
    if (!(de <= f.current || !Oe)) {
      var Qe = I1({
        mode: s,
        target: Oe
      }), Ct = Qe.atBottom, _t = Qe.atEnd, Ue = Qe.atStart, kt = Qe.atTop;
      L(Ct), H(_t), Y(Ue), j(kt);
      var Ze = Oe.offsetHeight, fn = Oe.scrollHeight, Dn = B.current, Qn = U.current, Wr = Ze !== Dn, gr = fn !== Qn;
      if (Wr && (B.current = Ze), gr && (U.current = fn), !Wr && !gr) {
        var er = Ve && Ho(be, s) || _t;
        J.current !== er && (u(function() {
          var ht, Ot, Zt, Kt;
          return [Rt(ht = ["%conScroll%c: %csetSticky%c(%c".concat(er, "%c)")]).call(ht, tt(mt("red")), tt(mt("red")), tt(mt("purple"))), Rt(Ot = [Rt(Zt = Rt(Kt = "(animating = %c".concat(Ve, "%c && isEnd = %c")).call(Kt, Ho(be, s), "%c) || atEnd = %c")).call(Zt, _t, "%c")]).call(Ot, tt(mt("purple")), tt(mt("purple")), tt(mt("purple")), [{
            animating: Ve,
            animateTo: be,
            atEnd: _t,
            mode: s,
            offsetHeight: Oe.offsetHeight,
            scrollHeight: Oe.scrollHeight,
            sticky: J.current,
            nextSticky: er
          }])];
        }), ae(er));
      } else J.current && (u(function() {
        var ht;
        return [Rt(ht = ["%conScroll%c: Size changed while sticky, calling %cscrollToSticky()%c"]).call(ht, tt(mt("red")), tt(mt("orange")), [{
          offsetHeightChanged: Wr,
          scrollHeightChanged: gr
        }]), {
          nextOffsetHeight: Ze,
          prevOffsetHeight: Dn,
          nextScrollHeight: fn,
          prevScrollHeight: Qn
        }];
      }), oe());
      var Vr = Oe.scrollTop;
      Tu(te = Q.current).call(te, function(ht) {
        return ht({
          scrollTop: Vr
        });
      });
    }
  }, [v, u, f, s, B, U, Q, oe, L, H, Y, j, ae, J, _]);
  Pt(function() {
    if (T) {
      var N = !1, te = Yre(function() {
        var de = _.current, be = v.current !== null;
        J.current ? I1({
          mode: s,
          target: de
        }).atEnd ? N = !1 : N ? Ei() - N > Gre && (be || ($.current = de.scrollTop, u(function() {
          var Oe;
          return Rt(Oe = ["%cInterval check%c: Should sticky but not at end, calling %cscrollToSticky()%c to scroll"]).call(Oe, tt(mt("navy")), tt(mt("orange")));
        }), oe()), N = !1) : N = Ei() : de.scrollHeight <= de.offsetHeight && !J.current && (u(function() {
          var Oe;
          return [Rt(Oe = ["%cInterval check%c: Container is emptied, setting sticky back to %ctrue%c"]).call(Oe, tt(mt("navy")), tt(mt("purple"))), [{
            offsetHeight: de.offsetHeight,
            scrollHeight: de.scrollHeight,
            sticky: J.current
          }]];
        }), ae(!0));
      }, Math.max(O1, n) || O1);
      return function() {
        return clearInterval(te);
      };
    }
  }, [v, n, u, s, oe, ae, J, T, _]);
  var Se = zt(function() {
    var N = R1[c] || (R1[c] = tre({
      key: "react-scroll-to-bottom--css-" + Sre(),
      nonce: c
    }));
    return function(te) {
      return N.css(te) + "";
    };
  }, [c]), Re = zt(function() {
    return {
      observeScrollPosition: K,
      setTarget: E,
      styleToClassName: Se
    };
  }, [K, E, Se]), ze = zt(function() {
    return {
      atBottom: q,
      atEnd: F,
      atStart: Z,
      atTop: g,
      mode: s
    };
  }, [q, F, Z, g, s]), ee = zt(function() {
    var N = h !== null;
    return {
      animating: N,
      animatingToEnd: N && Ho(h, s),
      sticky: ie
    };
  }, [h, s, ie]), ue = zt(function() {
    return C1(C1({}, ze), ee);
  }, [ze, ee]), z = zt(function() {
    return {
      scrollTo: ye,
      scrollToBottom: $e,
      scrollToEnd: re,
      scrollToStart: le,
      scrollToTop: M
    };
  }, [ye, $e, re, le, M]);
  return Pt(function() {
    if (T) {
      var N = function() {
        U.current = T.scrollHeight;
      };
      return T.addEventListener("focus", N, {
        capture: !0,
        passive: !0
      }), function() {
        return T.removeEventListener("focus", N);
      };
    }
  }, [T]), u(function() {
    var N;
    return [Rt(N = ["%cRender%c: Render"]).call(N, tt(mt("cyan", ""))), {
      animateTo: h,
      animating: h !== null,
      sticky: ie,
      target: T
    }];
  }), /* @__PURE__ */ vt.createElement(Of.Provider, {
    value: Re
  }, /* @__PURE__ */ vt.createElement(Oy.Provider, {
    value: z
  }, /* @__PURE__ */ vt.createElement(Iy.Provider, {
    value: ue
  }, /* @__PURE__ */ vt.createElement($y.Provider, {
    value: ze
  }, /* @__PURE__ */ vt.createElement(Ry.Provider, {
    value: ee
  }, r, T && /* @__PURE__ */ vt.createElement(QO, {
    debounce: i,
    name: "scroll",
    onEvent: Te,
    target: T
  }), T && h !== null && /* @__PURE__ */ vt.createElement(e$, {
    name: "scrollTop",
    onEnd: fe,
    target: T,
    value: h
  }))))));
};
Xy.defaultProps = {
  checkInterval: 100,
  children: void 0,
  debounce: 17,
  debug: void 0,
  initialScrollBehavior: "smooth",
  mode: void 0,
  nonce: void 0,
  scroller: Zre
};
Xy.propTypes = {
  checkInterval: it.number,
  children: it.any,
  debounce: it.number,
  debug: it.bool,
  initialScrollBehavior: it.oneOf(["auto", "smooth"]),
  mode: it.oneOf(["bottom", "top"]),
  nonce: it.string,
  scroller: it.func
};
var Jre = {
  height: "100%",
  overflowY: "auto",
  width: "100%"
}, Qy = function(t) {
  var n = t.children, r = t.className, i = ho(Of), a = i.setTarget, o = Ay()(Jre);
  return /* @__PURE__ */ vt.createElement("div", {
    className: Ty(o, (r || "") + ""),
    ref: a
  }, n);
};
Qy.defaultProps = {
  children: void 0,
  className: void 0
};
Qy.propTypes = {
  children: it.any,
  className: it.string
};
var Xre = {
  position: "relative"
}, eg = function(t) {
  var n = t.children, r = t.className, i = t.followButtonClassName, a = t.scrollViewClassName, o = Ay()(Xre);
  return /* @__PURE__ */ vt.createElement("div", {
    className: Ty(o, (r || "") + "")
  }, /* @__PURE__ */ vt.createElement(Qy, {
    className: (a || "") + ""
  }, n), /* @__PURE__ */ vt.createElement(Py, {
    className: (i || "") + ""
  }));
};
eg.defaultProps = {
  children: void 0,
  className: void 0,
  followButtonClassName: void 0,
  scrollViewClassName: void 0
};
eg.propTypes = {
  children: it.any,
  className: it.string,
  followButtonClassName: it.string,
  scrollViewClassName: it.string
};
var tg = function(t) {
  var n = t.checkInterval, r = t.children, i = t.className, a = t.debounce, o = t.debug, s = t.followButtonClassName, c = t.initialScrollBehavior, l = t.mode, u = t.nonce, f = t.scroller, d = t.scrollViewClassName;
  return /* @__PURE__ */ vt.createElement(Xy, {
    checkInterval: n,
    debounce: a,
    debug: o,
    initialScrollBehavior: c,
    mode: l,
    nonce: u,
    scroller: f
  }, /* @__PURE__ */ vt.createElement(eg, {
    className: i,
    followButtonClassName: s,
    scrollViewClassName: d
  }, r));
};
tg.defaultProps = {
  checkInterval: void 0,
  children: void 0,
  className: void 0,
  debounce: void 0,
  debug: void 0,
  followButtonClassName: void 0,
  initialScrollBehavior: "smooth",
  mode: void 0,
  nonce: void 0,
  scroller: void 0,
  scrollViewClassName: void 0
};
tg.propTypes = {
  checkInterval: it.number,
  children: it.any,
  className: it.string,
  debounce: it.number,
  debug: it.bool,
  followButtonClassName: it.string,
  initialScrollBehavior: it.oneOf(["auto", "smooth"]),
  mode: it.oneOf(["bottom", "top"]),
  nonce: it.string,
  scroller: it.func,
  scrollViewClassName: it.string
};
g7();
let ng = (e = 21) => crypto.getRandomValues(new Uint8Array(e)).reduce((t, n) => (n &= 63, n < 36 ? t += n.toString(36) : n < 62 ? t += (n - 26).toString(36).toUpperCase() : n > 62 ? t += "-" : t += "_", t), "");
const t$ = qu(
  ({
    className: e,
    messages: t = [],
    isTyping: n,
    headerMessage: r,
    renderers: i,
    botAvatar: a,
    botDescription: o,
    botName: s,
    sendMessage: c,
    showMarquee: l = !0,
    ...u
  }) => {
    const { messageList: f } = ut, d = zt(() => yI(t), [t.length]);
    return /* @__PURE__ */ O.jsxs(
      tg,
      {
        ...u,
        className: As(f.container.className, e),
        followButtonClassName: f.scrollDownButton.button.className,
        scrollViewClassName: f.viewPort.className,
        children: [
          r && /* @__PURE__ */ O.jsx("span", { ...f.headerMessage, children: r }),
          l && /* @__PURE__ */ O.jsx(v7, { botAvatar: a, botDescription: o, botName: s }),
          d.map((p) => /* @__PURE__ */ O.jsx(Xw, { renderers: i, sendMessage: c, ...p }, p.id)),
          n && /* @__PURE__ */ O.jsx(
            Xw,
            {
              id: ng(),
              renderers: i,
              sendMessage: c,
              direction: "incoming",
              timestamp: /* @__PURE__ */ new Date(),
              block: void 0,
              sender: { name: s ?? "", avatar: a },
              children: /* @__PURE__ */ O.jsx(m7, {})
            }
          )
        ]
      }
    );
  }
);
t$.displayName = "MessageList";
const Qre = ({ className: e, ...t }) => {
  const { className: n } = ut.loader;
  return /* @__PURE__ */ O.jsx("div", { ...t, className: As(e, n) });
}, eie = ({
  connected: e,
  configuration: t,
  closeWindow: n,
  isTyping: r,
  messages: i,
  user: a,
  sendMessage: o,
  uploadFile: s,
  isLoading: c,
  renderers: l,
  isReadOnly: u,
  disableComposer: f,
  restartConversation: d,
  allowFileUpload: p,
  ...m
}) => {
  const {
    color: h,
    fontFamily: y,
    radius: v,
    themeMode: b,
    variant: w,
    botAvatar: T,
    botDescription: E,
    botName: _,
    composerPlaceholder: $,
    showPoweredBy: B
  } = t, U = { color: h, fontFamily: y, radius: v, themeMode: b, variant: w }, k = zt(
    () => i.map((D) => {
      const { authorId: q } = D, L = q === (a == null ? void 0 : a.id) ? "outgoing" : "incoming";
      return {
        ...D,
        direction: L,
        sender: L === "outgoing" ? { name: "You" } : { name: t.botName ?? "Bot", avatar: t.botAvatar }
      };
    }),
    [t.botAvatar, t.botName, i.length, a == null ? void 0 : a.id]
  );
  return /* @__PURE__ */ O.jsxs(O.Fragment, { children: [
    /* @__PURE__ */ O.jsx($3, { ...U }),
    /* @__PURE__ */ O.jsxs(vT, { connected: e, allowFileUpload: p, uploadFile: s, ...m, children: [
      /* @__PURE__ */ O.jsx(h7, { closeWindow: n, configuration: t, restartConversation: d }),
      c ? /* @__PURE__ */ O.jsx(Qre, {}) : /* @__PURE__ */ O.jsx(O.Fragment, { children: /* @__PURE__ */ O.jsx(
        t$,
        {
          botAvatar: T,
          botDescription: E,
          botName: _,
          renderers: l,
          isTyping: r,
          sendMessage: o,
          messages: k
        }
      ) }),
      /* @__PURE__ */ O.jsx(
        TB,
        {
          sendMessage: o,
          uploadFile: s,
          connected: e,
          isReadOnly: u,
          disableComposer: f,
          showPoweredBy: B,
          composerPlaceholder: $,
          allowFileUpload: p
        }
      )
    ] })
  ] });
};
function n$(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: r$ } = Object.prototype, { getPrototypeOf: rg } = Object, ig = /* @__PURE__ */ ((e) => (t) => {
  const n = r$.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), si = (e) => (e = e.toLowerCase(), (t) => ig(t) === e), Mf = (e) => (t) => typeof t === e, { isArray: Oo } = Array, Bs = Mf("undefined");
function tie(e) {
  return e !== null && !Bs(e) && e.constructor !== null && !Bs(e.constructor) && ia(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const i$ = si("ArrayBuffer");
function nie(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && i$(e.buffer), t;
}
const rie = Mf("string"), ia = Mf("function"), a$ = Mf("number"), ag = (e) => e !== null && typeof e == "object", iie = (e) => e === !0 || e === !1, Mc = (e) => {
  if (ig(e) !== "object")
    return !1;
  const t = rg(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, aie = si("Date"), oie = si("File"), sie = si("Blob"), lie = si("FileList"), cie = (e) => ag(e) && ia(e.pipe), uie = (e) => {
  const t = "[object FormData]";
  return e && (typeof FormData == "function" && e instanceof FormData || r$.call(e) === t || ia(e.toString) && e.toString() === t);
}, fie = si("URLSearchParams"), die = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Il(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), Oo(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e), o = a.length;
    let s;
    for (r = 0; r < o; r++)
      s = a[r], t.call(null, e[s], s, e);
  }
}
function o$(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const s$ = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, l$ = (e) => !Bs(e) && e !== s$;
function km() {
  const { caseless: e } = l$(this) && this || {}, t = {}, n = (r, i) => {
    const a = e && o$(t, i) || i;
    Mc(t[a]) && Mc(r) ? t[a] = km(t[a], r) : Mc(r) ? t[a] = km({}, r) : Oo(r) ? t[a] = r.slice() : t[a] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && Il(arguments[r], n);
  return t;
}
const pie = (e, t, n, { allOwnKeys: r } = {}) => (Il(t, (i, a) => {
  n && ia(i) ? e[a] = n$(i, n) : e[a] = i;
}, { allOwnKeys: r }), e), hie = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), mie = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, vie = (e, t, n, r) => {
  let i, a, o;
  const s = {};
  if (t = t || {}, e == null) return t;
  do {
    for (i = Object.getOwnPropertyNames(e), a = i.length; a-- > 0; )
      o = i[a], (!r || r(o, e, t)) && !s[o] && (t[o] = e[o], s[o] = !0);
    e = n !== !1 && rg(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, yie = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, gie = (e) => {
  if (!e) return null;
  if (Oo(e)) return e;
  let t = e.length;
  if (!a$(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, bie = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && rg(Uint8Array)), wie = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const a = i.value;
    t.call(e, a[0], a[1]);
  }
}, xie = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, Sie = si("HTMLFormElement"), Eie = (e) => e.toLowerCase().replace(
  /[_-\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), A1 = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), _ie = si("RegExp"), c$ = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  Il(n, (i, a) => {
    t(i, a, e) !== !1 && (r[a] = i);
  }), Object.defineProperties(e, r);
}, kie = (e) => {
  c$(e, (t, n) => {
    if (ia(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (ia(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, Tie = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((a) => {
      n[a] = !0;
    });
  };
  return Oo(e) ? r(e) : r(String(e).split(t)), n;
}, Cie = () => {
}, Oie = (e, t) => (e = +e, Number.isFinite(e) ? e : t), $ie = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (ag(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const a = Oo(r) ? [] : {};
        return Il(r, (o, s) => {
          const c = n(o, i + 1);
          !Bs(c) && (a[s] = c);
        }), t[i] = void 0, a;
      }
    }
    return r;
  };
  return n(e, 0);
}, ne = {
  isArray: Oo,
  isArrayBuffer: i$,
  isBuffer: tie,
  isFormData: uie,
  isArrayBufferView: nie,
  isString: rie,
  isNumber: a$,
  isBoolean: iie,
  isObject: ag,
  isPlainObject: Mc,
  isUndefined: Bs,
  isDate: aie,
  isFile: oie,
  isBlob: sie,
  isRegExp: _ie,
  isFunction: ia,
  isStream: cie,
  isURLSearchParams: fie,
  isTypedArray: bie,
  isFileList: lie,
  forEach: Il,
  merge: km,
  extend: pie,
  trim: die,
  stripBOM: hie,
  inherits: mie,
  toFlatObject: vie,
  kindOf: ig,
  kindOfTest: si,
  endsWith: yie,
  toArray: gie,
  forEachEntry: wie,
  matchAll: xie,
  isHTMLForm: Sie,
  hasOwnProperty: A1,
  hasOwnProp: A1,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: c$,
  freezeMethods: kie,
  toObjectSet: Tie,
  toCamelCase: Eie,
  noop: Cie,
  toFiniteNumber: Oie,
  findKey: o$,
  global: s$,
  isContextDefined: l$,
  toJSONObject: $ie
};
function at(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i);
}
ne.inherits(at, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ne.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const u$ = at.prototype, f$ = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  f$[e] = { value: e };
});
Object.defineProperties(at, f$);
Object.defineProperty(u$, "isAxiosError", { value: !0 });
at.from = (e, t, n, r, i, a) => {
  const o = Object.create(u$);
  return ne.toFlatObject(e, o, function(c) {
    return c !== Error.prototype;
  }, (s) => s !== "isAxiosError"), at.call(o, e.message, t, n, r, i), o.cause = e, o.name = e.name, a && Object.assign(o, a), o;
};
var Rie = typeof self == "object" ? self.FormData : window.FormData;
const Iie = /* @__PURE__ */ Ye(Rie);
function Tm(e) {
  return ne.isPlainObject(e) || ne.isArray(e);
}
function d$(e) {
  return ne.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function P1(e, t, n) {
  return e ? e.concat(t).map(function(i, a) {
    return i = d$(i), !n && a ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function Aie(e) {
  return ne.isArray(e) && !e.some(Tm);
}
const Pie = ne.toFlatObject(ne, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Die(e) {
  return e && ne.isFunction(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator];
}
function Ff(e, t, n) {
  if (!ne.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new (Iie || FormData)(), n = ne.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(h, y) {
    return !ne.isUndefined(y[h]);
  });
  const r = n.metaTokens, i = n.visitor || u, a = n.dots, o = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && Die(t);
  if (!ne.isFunction(i))
    throw new TypeError("visitor must be a function");
  function l(m) {
    if (m === null) return "";
    if (ne.isDate(m))
      return m.toISOString();
    if (!c && ne.isBlob(m))
      throw new at("Blob is not supported. Use a Buffer instead.");
    return ne.isArrayBuffer(m) || ne.isTypedArray(m) ? c && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m;
  }
  function u(m, h, y) {
    let v = m;
    if (m && !y && typeof m == "object") {
      if (ne.endsWith(h, "{}"))
        h = r ? h : h.slice(0, -2), m = JSON.stringify(m);
      else if (ne.isArray(m) && Aie(m) || ne.isFileList(m) || ne.endsWith(h, "[]") && (v = ne.toArray(m)))
        return h = d$(h), v.forEach(function(w, T) {
          !(ne.isUndefined(w) || w === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? P1([h], T, a) : o === null ? h : h + "[]",
            l(w)
          );
        }), !1;
    }
    return Tm(m) ? !0 : (t.append(P1(y, h, a), l(m)), !1);
  }
  const f = [], d = Object.assign(Pie, {
    defaultVisitor: u,
    convertValue: l,
    isVisitable: Tm
  });
  function p(m, h) {
    if (!ne.isUndefined(m)) {
      if (f.indexOf(m) !== -1)
        throw Error("Circular reference detected in " + h.join("."));
      f.push(m), ne.forEach(m, function(v, b) {
        (!(ne.isUndefined(v) || v === null) && i.call(
          t,
          v,
          ne.isString(b) ? b.trim() : b,
          h,
          d
        )) === !0 && p(v, h ? h.concat(b) : [b]);
      }), f.pop();
    }
  }
  if (!ne.isObject(e))
    throw new TypeError("data must be an object");
  return p(e), t;
}
function D1(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function og(e, t) {
  this._pairs = [], e && Ff(e, this, t);
}
const p$ = og.prototype;
p$.append = function(t, n) {
  this._pairs.push([t, n]);
};
p$.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, D1);
  } : D1;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function jie(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function h$(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || jie, i = n && n.serialize;
  let a;
  if (i ? a = i(t, n) : a = ne.isURLSearchParams(t) ? t.toString() : new og(t, n).toString(r), a) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return e;
}
class j1 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    ne.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const m$ = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, Nie = typeof URLSearchParams < "u" ? URLSearchParams : og, Mie = FormData, Fie = (() => {
  let e;
  return typeof navigator < "u" && ((e = navigator.product) === "ReactNative" || e === "NativeScript" || e === "NS") ? !1 : typeof window < "u" && typeof document < "u";
})(), Lie = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Ir = {
  isBrowser: !0,
  classes: {
    URLSearchParams: Nie,
    FormData: Mie,
    Blob
  },
  isStandardBrowserEnv: Fie,
  isStandardBrowserWebWorkerEnv: Lie,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function Bie(e, t) {
  return Ff(e, new Ir.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, a) {
      return Ir.isNode && ne.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function Uie(e) {
  return ne.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function zie(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let a;
  for (r = 0; r < i; r++)
    a = n[r], t[a] = e[a];
  return t;
}
function v$(e) {
  function t(n, r, i, a) {
    let o = n[a++];
    const s = Number.isFinite(+o), c = a >= n.length;
    return o = !o && ne.isArray(i) ? i.length : o, c ? (ne.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !s) : ((!i[o] || !ne.isObject(i[o])) && (i[o] = []), t(n, r, i[o], a) && ne.isArray(i[o]) && (i[o] = zie(i[o])), !s);
  }
  if (ne.isFormData(e) && ne.isFunction(e.entries)) {
    const n = {};
    return ne.forEachEntry(e, (r, i) => {
      t(Uie(r), i, n, 0);
    }), n;
  }
  return null;
}
const qie = {
  "Content-Type": void 0
};
function Wie(e, t, n) {
  if (ne.isString(e))
    try {
      return (t || JSON.parse)(e), ne.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const $o = {
  transitional: m$,
  adapter: ["xhr", "http"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, a = ne.isObject(t);
    if (a && ne.isHTMLForm(t) && (t = new FormData(t)), ne.isFormData(t))
      return i && i ? JSON.stringify(v$(t)) : t;
    if (ne.isArrayBuffer(t) || ne.isBuffer(t) || ne.isStream(t) || ne.isFile(t) || ne.isBlob(t))
      return t;
    if (ne.isArrayBufferView(t))
      return t.buffer;
    if (ne.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let s;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return Bie(t, this.formSerializer).toString();
      if ((s = ne.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const c = this.env && this.env.FormData;
        return Ff(
          s ? { "files[]": t } : t,
          c && new c(),
          this.formSerializer
        );
      }
    }
    return a || i ? (n.setContentType("application/json", !1), Wie(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || $o.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (t && ne.isString(t) && (r && !this.responseType || i)) {
      const o = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (s) {
        if (o)
          throw s.name === "SyntaxError" ? at.from(s, at.ERR_BAD_RESPONSE, this, null, this.response) : s;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Ir.classes.FormData,
    Blob: Ir.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
ne.forEach(["delete", "get", "head"], function(t) {
  $o.headers[t] = {};
});
ne.forEach(["post", "put", "patch"], function(t) {
  $o.headers[t] = ne.merge(qie);
});
const Vie = ne.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), Hie = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || t[n] && Vie[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, N1 = Symbol("internals");
function Zo(e) {
  return e && String(e).trim().toLowerCase();
}
function Fc(e) {
  return e === !1 || e == null ? e : ne.isArray(e) ? e.map(Fc) : String(e);
}
function Zie(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
function Kie(e) {
  return /^[-_a-zA-Z]+$/.test(e.trim());
}
function M1(e, t, n, r) {
  if (ne.isFunction(r))
    return r.call(this, t, n);
  if (ne.isString(t)) {
    if (ne.isString(r))
      return t.indexOf(r) !== -1;
    if (ne.isRegExp(r))
      return r.test(t);
  }
}
function Gie(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function Yie(e, t) {
  const n = ne.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, a, o) {
        return this[r].call(this, t, i, a, o);
      },
      configurable: !0
    });
  });
}
class Gn {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function a(s, c, l) {
      const u = Zo(c);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const f = ne.findKey(i, u);
      (!f || i[f] === void 0 || l === !0 || l === void 0 && i[f] !== !1) && (i[f || c] = Fc(s));
    }
    const o = (s, c) => ne.forEach(s, (l, u) => a(l, u, c));
    return ne.isPlainObject(t) || t instanceof this.constructor ? o(t, n) : ne.isString(t) && (t = t.trim()) && !Kie(t) ? o(Hie(t), n) : t != null && a(n, t, r), this;
  }
  get(t, n) {
    if (t = Zo(t), t) {
      const r = ne.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return Zie(i);
        if (ne.isFunction(n))
          return n.call(this, i, r);
        if (ne.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = Zo(t), t) {
      const r = ne.findKey(this, t);
      return !!(r && (!n || M1(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function a(o) {
      if (o = Zo(o), o) {
        const s = ne.findKey(r, o);
        s && (!n || M1(r, r[s], s, n)) && (delete r[s], i = !0);
      }
    }
    return ne.isArray(t) ? t.forEach(a) : a(t), i;
  }
  clear() {
    return Object.keys(this).forEach(this.delete.bind(this));
  }
  normalize(t) {
    const n = this, r = {};
    return ne.forEach(this, (i, a) => {
      const o = ne.findKey(r, a);
      if (o) {
        n[o] = Fc(i), delete n[a];
        return;
      }
      const s = t ? Gie(a) : String(a).trim();
      s !== a && delete n[a], n[s] = Fc(i), r[s] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return ne.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && ne.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[N1] = this[N1] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function a(o) {
      const s = Zo(o);
      r[s] || (Yie(i, o), r[s] = !0);
    }
    return ne.isArray(t) ? t.forEach(a) : a(t), this;
  }
}
Gn.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
ne.freezeMethods(Gn.prototype);
ne.freezeMethods(Gn);
function jp(e, t) {
  const n = this || $o, r = t || n, i = Gn.from(r.headers);
  let a = r.data;
  return ne.forEach(e, function(s) {
    a = s.call(n, a, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), a;
}
function y$(e) {
  return !!(e && e.__CANCEL__);
}
function Al(e, t, n) {
  at.call(this, e ?? "canceled", at.ERR_CANCELED, t, n), this.name = "CanceledError";
}
ne.inherits(Al, at, {
  __CANCEL__: !0
});
const Jie = null;
function Xie(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new at(
    "Request failed with status code " + n.status,
    [at.ERR_BAD_REQUEST, at.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
const Qie = Ir.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  /* @__PURE__ */ function() {
    return {
      write: function(n, r, i, a, o, s) {
        const c = [];
        c.push(n + "=" + encodeURIComponent(r)), ne.isNumber(i) && c.push("expires=" + new Date(i).toGMTString()), ne.isString(a) && c.push("path=" + a), ne.isString(o) && c.push("domain=" + o), s === !0 && c.push("secure"), document.cookie = c.join("; ");
      },
      read: function(n) {
        const r = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
        return r ? decodeURIComponent(r[3]) : null;
      },
      remove: function(n) {
        this.write(n, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }()
);
function eae(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function tae(e, t) {
  return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function g$(e, t) {
  return e && !eae(t) ? tae(e, t) : t;
}
const nae = Ir.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
    let r;
    function i(a) {
      let o = a;
      return t && (n.setAttribute("href", o), o = n.href), n.setAttribute("href", o), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return r = i(window.location.href), function(o) {
      const s = ne.isString(o) ? i(o) : o;
      return s.protocol === r.protocol && s.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function() {
    return function() {
      return !0;
    };
  }()
);
function rae(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function iae(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, a = 0, o;
  return t = t !== void 0 ? t : 1e3, function(c) {
    const l = Date.now(), u = r[a];
    o || (o = l), n[i] = c, r[i] = l;
    let f = a, d = 0;
    for (; f !== i; )
      d += n[f++], f = f % e;
    if (i = (i + 1) % e, i === a && (a = (a + 1) % e), l - o < t)
      return;
    const p = u && l - u;
    return p ? Math.round(d * 1e3 / p) : void 0;
  };
}
function F1(e, t) {
  let n = 0;
  const r = iae(50, 250);
  return (i) => {
    const a = i.loaded, o = i.lengthComputable ? i.total : void 0, s = a - n, c = r(s), l = a <= o;
    n = a;
    const u = {
      loaded: a,
      total: o,
      progress: o ? a / o : void 0,
      bytes: s,
      rate: c || void 0,
      estimated: c && o && l ? (o - a) / c : void 0,
      event: i
    };
    u[t ? "download" : "upload"] = !0, e(u);
  };
}
const aae = typeof XMLHttpRequest < "u", oae = aae && function(e) {
  return new Promise(function(n, r) {
    let i = e.data;
    const a = Gn.from(e.headers).normalize(), o = e.responseType;
    let s;
    function c() {
      e.cancelToken && e.cancelToken.unsubscribe(s), e.signal && e.signal.removeEventListener("abort", s);
    }
    ne.isFormData(i) && (Ir.isStandardBrowserEnv || Ir.isStandardBrowserWebWorkerEnv) && a.setContentType(!1);
    let l = new XMLHttpRequest();
    if (e.auth) {
      const p = e.auth.username || "", m = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      a.set("Authorization", "Basic " + btoa(p + ":" + m));
    }
    const u = g$(e.baseURL, e.url);
    l.open(e.method.toUpperCase(), h$(u, e.params, e.paramsSerializer), !0), l.timeout = e.timeout;
    function f() {
      if (!l)
        return;
      const p = Gn.from(
        "getAllResponseHeaders" in l && l.getAllResponseHeaders()
      ), h = {
        data: !o || o === "text" || o === "json" ? l.responseText : l.response,
        status: l.status,
        statusText: l.statusText,
        headers: p,
        config: e,
        request: l
      };
      Xie(function(v) {
        n(v), c();
      }, function(v) {
        r(v), c();
      }, h), l = null;
    }
    if ("onloadend" in l ? l.onloadend = f : l.onreadystatechange = function() {
      !l || l.readyState !== 4 || l.status === 0 && !(l.responseURL && l.responseURL.indexOf("file:") === 0) || setTimeout(f);
    }, l.onabort = function() {
      l && (r(new at("Request aborted", at.ECONNABORTED, e, l)), l = null);
    }, l.onerror = function() {
      r(new at("Network Error", at.ERR_NETWORK, e, l)), l = null;
    }, l.ontimeout = function() {
      let m = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const h = e.transitional || m$;
      e.timeoutErrorMessage && (m = e.timeoutErrorMessage), r(new at(
        m,
        h.clarifyTimeoutError ? at.ETIMEDOUT : at.ECONNABORTED,
        e,
        l
      )), l = null;
    }, Ir.isStandardBrowserEnv) {
      const p = (e.withCredentials || nae(u)) && e.xsrfCookieName && Qie.read(e.xsrfCookieName);
      p && a.set(e.xsrfHeaderName, p);
    }
    i === void 0 && a.setContentType(null), "setRequestHeader" in l && ne.forEach(a.toJSON(), function(m, h) {
      l.setRequestHeader(h, m);
    }), ne.isUndefined(e.withCredentials) || (l.withCredentials = !!e.withCredentials), o && o !== "json" && (l.responseType = e.responseType), typeof e.onDownloadProgress == "function" && l.addEventListener("progress", F1(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && l.upload && l.upload.addEventListener("progress", F1(e.onUploadProgress)), (e.cancelToken || e.signal) && (s = (p) => {
      l && (r(!p || p.type ? new Al(null, e, l) : p), l.abort(), l = null);
    }, e.cancelToken && e.cancelToken.subscribe(s), e.signal && (e.signal.aborted ? s() : e.signal.addEventListener("abort", s)));
    const d = rae(u);
    if (d && Ir.protocols.indexOf(d) === -1) {
      r(new at("Unsupported protocol " + d + ":", at.ERR_BAD_REQUEST, e));
      return;
    }
    l.send(i || null);
  });
}, Lc = {
  http: Jie,
  xhr: oae
};
ne.forEach(Lc, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const sae = {
  getAdapter: (e) => {
    e = ne.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    for (let i = 0; i < t && (n = e[i], !(r = ne.isString(n) ? Lc[n.toLowerCase()] : n)); i++)
      ;
    if (!r)
      throw r === !1 ? new at(
        `Adapter ${n} is not supported by the environment`,
        "ERR_NOT_SUPPORT"
      ) : new Error(
        ne.hasOwnProp(Lc, n) ? `Adapter '${n}' is not available in the build` : `Unknown adapter '${n}'`
      );
    if (!ne.isFunction(r))
      throw new TypeError("adapter is not a function");
    return r;
  },
  adapters: Lc
};
function Np(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Al(null, e);
}
function L1(e) {
  return Np(e), e.headers = Gn.from(e.headers), e.data = jp.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), sae.getAdapter(e.adapter || $o.adapter)(e).then(function(r) {
    return Np(e), r.data = jp.call(
      e,
      e.transformResponse,
      r
    ), r.headers = Gn.from(r.headers), r;
  }, function(r) {
    return y$(r) || (Np(e), r && r.response && (r.response.data = jp.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = Gn.from(r.response.headers))), Promise.reject(r);
  });
}
const B1 = (e) => e instanceof Gn ? e.toJSON() : e;
function oo(e, t) {
  t = t || {};
  const n = {};
  function r(l, u, f) {
    return ne.isPlainObject(l) && ne.isPlainObject(u) ? ne.merge.call({ caseless: f }, l, u) : ne.isPlainObject(u) ? ne.merge({}, u) : ne.isArray(u) ? u.slice() : u;
  }
  function i(l, u, f) {
    if (ne.isUndefined(u)) {
      if (!ne.isUndefined(l))
        return r(void 0, l, f);
    } else return r(l, u, f);
  }
  function a(l, u) {
    if (!ne.isUndefined(u))
      return r(void 0, u);
  }
  function o(l, u) {
    if (ne.isUndefined(u)) {
      if (!ne.isUndefined(l))
        return r(void 0, l);
    } else return r(void 0, u);
  }
  function s(l, u, f) {
    if (f in t)
      return r(l, u);
    if (f in e)
      return r(void 0, l);
  }
  const c = {
    url: a,
    method: a,
    data: a,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: s,
    headers: (l, u) => i(B1(l), B1(u), !0)
  };
  return ne.forEach(Object.keys(e).concat(Object.keys(t)), function(u) {
    const f = c[u] || i, d = f(e[u], t[u], u);
    ne.isUndefined(d) && f !== s || (n[u] = d);
  }), n;
}
const b$ = "1.2.5", sg = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  sg[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const U1 = {};
sg.transitional = function(t, n, r) {
  function i(a, o) {
    return "[Axios v" + b$ + "] Transitional option '" + a + "'" + o + (r ? ". " + r : "");
  }
  return (a, o, s) => {
    if (t === !1)
      throw new at(
        i(o, " has been removed" + (n ? " in " + n : "")),
        at.ERR_DEPRECATED
      );
    return n && !U1[o] && (U1[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(a, o, s) : !0;
  };
};
function lae(e, t, n) {
  if (typeof e != "object")
    throw new at("options must be an object", at.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const a = r[i], o = t[a];
    if (o) {
      const s = e[a], c = s === void 0 || o(s, a, e);
      if (c !== !0)
        throw new at("option " + a + " must be " + c, at.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new at("Unknown option " + a, at.ERR_BAD_OPTION);
  }
}
const Cm = {
  assertOptions: lae,
  validators: sg
}, fi = Cm.validators;
class Gi {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new j1(),
      response: new j1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = oo(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: a } = n;
    r !== void 0 && Cm.assertOptions(r, {
      silentJSONParsing: fi.transitional(fi.boolean),
      forcedJSONParsing: fi.transitional(fi.boolean),
      clarifyTimeoutError: fi.transitional(fi.boolean)
    }, !1), i !== void 0 && Cm.assertOptions(i, {
      encode: fi.function,
      serialize: fi.function
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let o;
    o = a && ne.merge(
      a.common,
      a[n.method]
    ), o && ne.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (m) => {
        delete a[m];
      }
    ), n.headers = Gn.concat(o, a);
    const s = [];
    let c = !0;
    this.interceptors.request.forEach(function(h) {
      typeof h.runWhen == "function" && h.runWhen(n) === !1 || (c = c && h.synchronous, s.unshift(h.fulfilled, h.rejected));
    });
    const l = [];
    this.interceptors.response.forEach(function(h) {
      l.push(h.fulfilled, h.rejected);
    });
    let u, f = 0, d;
    if (!c) {
      const m = [L1.bind(this), void 0];
      for (m.unshift.apply(m, s), m.push.apply(m, l), d = m.length, u = Promise.resolve(n); f < d; )
        u = u.then(m[f++], m[f++]);
      return u;
    }
    d = s.length;
    let p = n;
    for (f = 0; f < d; ) {
      const m = s[f++], h = s[f++];
      try {
        p = m(p);
      } catch (y) {
        h.call(this, y);
        break;
      }
    }
    try {
      u = L1.call(this, p);
    } catch (m) {
      return Promise.reject(m);
    }
    for (f = 0, d = l.length; f < d; )
      u = u.then(l[f++], l[f++]);
    return u;
  }
  getUri(t) {
    t = oo(this.defaults, t);
    const n = g$(t.baseURL, t.url);
    return h$(n, t.params, t.paramsSerializer);
  }
}
ne.forEach(["delete", "get", "head", "options"], function(t) {
  Gi.prototype[t] = function(n, r) {
    return this.request(oo(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
ne.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(a, o, s) {
      return this.request(oo(s || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: o
      }));
    };
  }
  Gi.prototype[t] = n(), Gi.prototype[t + "Form"] = n(!0);
});
class lg {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners) return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let a;
      const o = new Promise((s) => {
        r.subscribe(s), a = s;
      }).then(i);
      return o.cancel = function() {
        r.unsubscribe(a);
      }, o;
    }, t(function(a, o, s) {
      r.reason || (r.reason = new Al(a, o, s), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new lg(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
}
function cae(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function uae(e) {
  return ne.isObject(e) && e.isAxiosError === !0;
}
const Om = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Om).forEach(([e, t]) => {
  Om[t] = e;
});
function w$(e) {
  const t = new Gi(e), n = n$(Gi.prototype.request, t);
  return ne.extend(n, Gi.prototype, t, { allOwnKeys: !0 }), ne.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return w$(oo(e, i));
  }, n;
}
const Ht = w$($o);
Ht.Axios = Gi;
Ht.CanceledError = Al;
Ht.CancelToken = lg;
Ht.isCancel = y$;
Ht.VERSION = b$;
Ht.toFormData = Ff;
Ht.AxiosError = at;
Ht.Cancel = Ht.CanceledError;
Ht.all = function(t) {
  return Promise.all(t);
};
Ht.spread = cae;
Ht.isAxiosError = uae;
Ht.mergeConfig = oo;
Ht.AxiosHeaders = Gn;
Ht.formToJSON = (e) => v$(ne.isHTMLForm(e) ? new FormData(e) : e);
Ht.HttpStatusCode = Om;
Ht.default = Ht;
const x$ = {}, fae = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: x$
}, Symbol.toStringTag, { value: "Module" }));
var S$ = Object, dae = Error, pae = EvalError, hae = RangeError, mae = ReferenceError, E$ = SyntaxError, Ro = TypeError, vae = URIError, yae = Math.abs, gae = Math.floor, bae = Math.max, wae = Math.min, xae = Math.pow, Sae = Math.round, Eae = Number.isNaN || function(t) {
  return t !== t;
}, _ae = Eae, kae = function(t) {
  return _ae(t) || t === 0 ? t : t < 0 ? -1 : 1;
}, Tae = Object.getOwnPropertyDescriptor, Bc = Tae;
if (Bc)
  try {
    Bc([], "length");
  } catch {
    Bc = null;
  }
var Lf = Bc, Uc = Object.defineProperty || !1;
if (Uc)
  try {
    Uc({}, "a", { value: 1 });
  } catch {
    Uc = !1;
  }
var Bf = Uc, Mp, z1;
function Cae() {
  return z1 || (z1 = 1, Mp = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var t = {}, n = Symbol("test"), r = Object(n);
    if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
      return !1;
    var i = 42;
    t[n] = i;
    for (var a in t)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
      return !1;
    var o = Object.getOwnPropertySymbols(t);
    if (o.length !== 1 || o[0] !== n || !Object.prototype.propertyIsEnumerable.call(t, n))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var s = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(t, n)
      );
      if (s.value !== i || s.enumerable !== !0)
        return !1;
    }
    return !0;
  }), Mp;
}
var Fp, q1;
function Oae() {
  if (q1) return Fp;
  q1 = 1;
  var e = typeof Symbol < "u" && Symbol, t = Cae();
  return Fp = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, Fp;
}
var Lp, W1;
function _$() {
  return W1 || (W1 = 1, Lp = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Lp;
}
var Bp, V1;
function k$() {
  if (V1) return Bp;
  V1 = 1;
  var e = S$;
  return Bp = e.getPrototypeOf || null, Bp;
}
var Up, H1;
function $ae() {
  if (H1) return Up;
  H1 = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, n = Math.max, r = "[object Function]", i = function(c, l) {
    for (var u = [], f = 0; f < c.length; f += 1)
      u[f] = c[f];
    for (var d = 0; d < l.length; d += 1)
      u[d + c.length] = l[d];
    return u;
  }, a = function(c, l) {
    for (var u = [], f = l, d = 0; f < c.length; f += 1, d += 1)
      u[d] = c[f];
    return u;
  }, o = function(s, c) {
    for (var l = "", u = 0; u < s.length; u += 1)
      l += s[u], u + 1 < s.length && (l += c);
    return l;
  };
  return Up = function(c) {
    var l = this;
    if (typeof l != "function" || t.apply(l) !== r)
      throw new TypeError(e + l);
    for (var u = a(arguments, 1), f, d = function() {
      if (this instanceof f) {
        var v = l.apply(
          this,
          i(u, arguments)
        );
        return Object(v) === v ? v : this;
      }
      return l.apply(
        c,
        i(u, arguments)
      );
    }, p = n(0, l.length - u.length), m = [], h = 0; h < p; h++)
      m[h] = "$" + h;
    if (f = Function("binder", "return function (" + o(m, ",") + "){ return binder.apply(this,arguments); }")(d), l.prototype) {
      var y = function() {
      };
      y.prototype = l.prototype, f.prototype = new y(), y.prototype = null;
    }
    return f;
  }, Up;
}
var zp, Z1;
function Pl() {
  if (Z1) return zp;
  Z1 = 1;
  var e = $ae();
  return zp = Function.prototype.bind || e, zp;
}
var qp, K1;
function cg() {
  return K1 || (K1 = 1, qp = Function.prototype.call), qp;
}
var Wp, G1;
function T$() {
  return G1 || (G1 = 1, Wp = Function.prototype.apply), Wp;
}
var Vp, Y1;
function Rae() {
  return Y1 || (Y1 = 1, Vp = typeof Reflect < "u" && Reflect && Reflect.apply), Vp;
}
var Hp, J1;
function Iae() {
  if (J1) return Hp;
  J1 = 1;
  var e = Pl(), t = T$(), n = cg(), r = Rae();
  return Hp = r || e.call(n, t), Hp;
}
var Zp, X1;
function Aae() {
  if (X1) return Zp;
  X1 = 1;
  var e = Pl(), t = Ro, n = cg(), r = Iae();
  return Zp = function(a) {
    if (a.length < 1 || typeof a[0] != "function")
      throw new t("a function is required");
    return r(e, n, a);
  }, Zp;
}
var Kp, Q1;
function Pae() {
  if (Q1) return Kp;
  Q1 = 1;
  var e = Aae(), t = Lf, n;
  try {
    n = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (o) {
    if (!o || typeof o != "object" || !("code" in o) || o.code !== "ERR_PROTO_ACCESS")
      throw o;
  }
  var r = !!n && t && t(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), i = Object, a = i.getPrototypeOf;
  return Kp = r && typeof r.get == "function" ? e([r.get]) : typeof a == "function" ? (
    /** @type {import('./get')} */
    function(s) {
      return a(s == null ? s : i(s));
    }
  ) : !1, Kp;
}
var Gp, eS;
function Dae() {
  if (eS) return Gp;
  eS = 1;
  var e = _$(), t = k$(), n = Pae();
  return Gp = e ? function(i) {
    return e(i);
  } : t ? function(i) {
    if (!i || typeof i != "object" && typeof i != "function")
      throw new TypeError("getProto: not an object");
    return t(i);
  } : n ? function(i) {
    return n(i);
  } : null, Gp;
}
var Yp, tS;
function jae() {
  if (tS) return Yp;
  tS = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, n = Pl();
  return Yp = n.call(e, t), Yp;
}
var Xe, Nae = S$, Mae = dae, Fae = pae, Lae = hae, Bae = mae, so = E$, Wa = Ro, Uae = vae, zae = yae, qae = gae, Wae = bae, Vae = wae, Hae = xae, Zae = Sae, Kae = kae, C$ = Function, Jp = function(e) {
  try {
    return C$('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, Us = Lf, Gae = Bf, Xp = function() {
  throw new Wa();
}, Yae = Us ? function() {
  try {
    return arguments.callee, Xp;
  } catch {
    try {
      return Us(arguments, "callee").get;
    } catch {
      return Xp;
    }
  }
}() : Xp, ka = Oae()(), nn = Dae(), Jae = k$(), Xae = _$(), O$ = T$(), Dl = cg(), $a = {}, Qae = typeof Uint8Array > "u" || !nn ? Xe : nn(Uint8Array), Yi = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? Xe : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? Xe : ArrayBuffer,
  "%ArrayIteratorPrototype%": ka && nn ? nn([][Symbol.iterator]()) : Xe,
  "%AsyncFromSyncIteratorPrototype%": Xe,
  "%AsyncFunction%": $a,
  "%AsyncGenerator%": $a,
  "%AsyncGeneratorFunction%": $a,
  "%AsyncIteratorPrototype%": $a,
  "%Atomics%": typeof Atomics > "u" ? Xe : Atomics,
  "%BigInt%": typeof BigInt > "u" ? Xe : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? Xe : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? Xe : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? Xe : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Mae,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": Fae,
  "%Float32Array%": typeof Float32Array > "u" ? Xe : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? Xe : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? Xe : FinalizationRegistry,
  "%Function%": C$,
  "%GeneratorFunction%": $a,
  "%Int8Array%": typeof Int8Array > "u" ? Xe : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? Xe : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? Xe : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": ka && nn ? nn(nn([][Symbol.iterator]())) : Xe,
  "%JSON%": typeof JSON == "object" ? JSON : Xe,
  "%Map%": typeof Map > "u" ? Xe : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !ka || !nn ? Xe : nn((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Nae,
  "%Object.getOwnPropertyDescriptor%": Us,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? Xe : Promise,
  "%Proxy%": typeof Proxy > "u" ? Xe : Proxy,
  "%RangeError%": Lae,
  "%ReferenceError%": Bae,
  "%Reflect%": typeof Reflect > "u" ? Xe : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? Xe : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !ka || !nn ? Xe : nn((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? Xe : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": ka && nn ? nn(""[Symbol.iterator]()) : Xe,
  "%Symbol%": ka ? Symbol : Xe,
  "%SyntaxError%": so,
  "%ThrowTypeError%": Yae,
  "%TypedArray%": Qae,
  "%TypeError%": Wa,
  "%Uint8Array%": typeof Uint8Array > "u" ? Xe : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? Xe : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? Xe : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? Xe : Uint32Array,
  "%URIError%": Uae,
  "%WeakMap%": typeof WeakMap > "u" ? Xe : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? Xe : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? Xe : WeakSet,
  "%Function.prototype.call%": Dl,
  "%Function.prototype.apply%": O$,
  "%Object.defineProperty%": Gae,
  "%Object.getPrototypeOf%": Jae,
  "%Math.abs%": zae,
  "%Math.floor%": qae,
  "%Math.max%": Wae,
  "%Math.min%": Vae,
  "%Math.pow%": Hae,
  "%Math.round%": Zae,
  "%Math.sign%": Kae,
  "%Reflect.getPrototypeOf%": Xae
};
if (nn)
  try {
    null.error;
  } catch (e) {
    var eoe = nn(nn(e));
    Yi["%Error.prototype%"] = eoe;
  }
var toe = function e(t) {
  var n;
  if (t === "%AsyncFunction%")
    n = Jp("async function () {}");
  else if (t === "%GeneratorFunction%")
    n = Jp("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    n = Jp("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var r = e("%AsyncGeneratorFunction%");
    r && (n = r.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var i = e("%AsyncGenerator%");
    i && nn && (n = nn(i.prototype));
  }
  return Yi[t] = n, n;
}, nS = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, jl = Pl(), $u = jae(), noe = jl.call(Dl, Array.prototype.concat), roe = jl.call(O$, Array.prototype.splice), rS = jl.call(Dl, String.prototype.replace), Ru = jl.call(Dl, String.prototype.slice), ioe = jl.call(Dl, RegExp.prototype.exec), aoe = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, ooe = /\\(\\)?/g, soe = function(t) {
  var n = Ru(t, 0, 1), r = Ru(t, -1);
  if (n === "%" && r !== "%")
    throw new so("invalid intrinsic syntax, expected closing `%`");
  if (r === "%" && n !== "%")
    throw new so("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return rS(t, aoe, function(a, o, s, c) {
    i[i.length] = s ? rS(c, ooe, "$1") : o || a;
  }), i;
}, loe = function(t, n) {
  var r = t, i;
  if ($u(nS, r) && (i = nS[r], r = "%" + i[0] + "%"), $u(Yi, r)) {
    var a = Yi[r];
    if (a === $a && (a = toe(r)), typeof a > "u" && !n)
      throw new Wa("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: r,
      value: a
    };
  }
  throw new so("intrinsic " + t + " does not exist!");
}, Uf = function(t, n) {
  if (typeof t != "string" || t.length === 0)
    throw new Wa("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new Wa('"allowMissing" argument must be a boolean');
  if (ioe(/^%?[^%]*%?$/, t) === null)
    throw new so("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var r = soe(t), i = r.length > 0 ? r[0] : "", a = loe("%" + i + "%", n), o = a.name, s = a.value, c = !1, l = a.alias;
  l && (i = l[0], roe(r, noe([0, 1], l)));
  for (var u = 1, f = !0; u < r.length; u += 1) {
    var d = r[u], p = Ru(d, 0, 1), m = Ru(d, -1);
    if ((p === '"' || p === "'" || p === "`" || m === '"' || m === "'" || m === "`") && p !== m)
      throw new so("property names with quotes must have matching quotes");
    if ((d === "constructor" || !f) && (c = !0), i += "." + d, o = "%" + i + "%", $u(Yi, o))
      s = Yi[o];
    else if (s != null) {
      if (!(d in s)) {
        if (!n)
          throw new Wa("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (Us && u + 1 >= r.length) {
        var h = Us(s, d);
        f = !!h, f && "get" in h && !("originalValue" in h.get) ? s = h.get : s = s[d];
      } else
        f = $u(s, d), s = s[d];
      f && !c && (Yi[o] = s);
    }
  }
  return s;
}, $$ = { exports: {} }, iS = Bf, coe = E$, Ta = Ro, aS = Lf, uoe = function(t, n, r) {
  if (!t || typeof t != "object" && typeof t != "function")
    throw new Ta("`obj` must be an object or a function`");
  if (typeof n != "string" && typeof n != "symbol")
    throw new Ta("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new Ta("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new Ta("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new Ta("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new Ta("`loose`, if provided, must be a boolean");
  var i = arguments.length > 3 ? arguments[3] : null, a = arguments.length > 4 ? arguments[4] : null, o = arguments.length > 5 ? arguments[5] : null, s = arguments.length > 6 ? arguments[6] : !1, c = !!aS && aS(t, n);
  if (iS)
    iS(t, n, {
      configurable: o === null && c ? c.configurable : !o,
      enumerable: i === null && c ? c.enumerable : !i,
      value: r,
      writable: a === null && c ? c.writable : !a
    });
  else if (s || !i && !a && !o)
    t[n] = r;
  else
    throw new coe("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $m = Bf, R$ = function() {
  return !!$m;
};
R$.hasArrayLengthDefineBug = function() {
  if (!$m)
    return null;
  try {
    return $m([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var foe = R$, doe = Uf, oS = uoe, poe = foe(), sS = Lf, lS = Ro, hoe = doe("%Math.floor%"), moe = function(t, n) {
  if (typeof t != "function")
    throw new lS("`fn` is not a function");
  if (typeof n != "number" || n < 0 || n > 4294967295 || hoe(n) !== n)
    throw new lS("`length` must be a positive 32-bit integer");
  var r = arguments.length > 2 && !!arguments[2], i = !0, a = !0;
  if ("length" in t && sS) {
    var o = sS(t, "length");
    o && !o.configurable && (i = !1), o && !o.writable && (a = !1);
  }
  return (i || a || !r) && (poe ? oS(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    n,
    !0,
    !0
  ) : oS(
    /** @type {Parameters<define>[0]} */
    t,
    "length",
    n
  )), t;
};
(function(e) {
  var t = Pl(), n = Uf, r = moe, i = Ro, a = n("%Function.prototype.apply%"), o = n("%Function.prototype.call%"), s = n("%Reflect.apply%", !0) || t.call(o, a), c = Bf, l = n("%Math.max%");
  e.exports = function(d) {
    if (typeof d != "function")
      throw new i("a function is required");
    var p = s(t, o, arguments);
    return r(
      p,
      1 + l(0, d.length - (arguments.length - 1)),
      !0
    );
  };
  var u = function() {
    return s(t, a, arguments);
  };
  c ? c(e.exports, "apply", { value: u }) : e.exports.apply = u;
})($$);
var voe = $$.exports, I$ = Uf, A$ = voe, yoe = A$(I$("String.prototype.indexOf")), goe = function(t, n) {
  var r = I$(t, !!n);
  return typeof r == "function" && yoe(t, ".prototype.") > -1 ? A$(r) : r;
};
const boe = /* @__PURE__ */ $R(fae);
var ug = typeof Map == "function" && Map.prototype, Qp = Object.getOwnPropertyDescriptor && ug ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, Iu = ug && Qp && typeof Qp.get == "function" ? Qp.get : null, cS = ug && Map.prototype.forEach, fg = typeof Set == "function" && Set.prototype, eh = Object.getOwnPropertyDescriptor && fg ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, Au = fg && eh && typeof eh.get == "function" ? eh.get : null, uS = fg && Set.prototype.forEach, woe = typeof WeakMap == "function" && WeakMap.prototype, ss = woe ? WeakMap.prototype.has : null, xoe = typeof WeakSet == "function" && WeakSet.prototype, ls = xoe ? WeakSet.prototype.has : null, Soe = typeof WeakRef == "function" && WeakRef.prototype, fS = Soe ? WeakRef.prototype.deref : null, Eoe = Boolean.prototype.valueOf, _oe = Object.prototype.toString, koe = Function.prototype.toString, Toe = String.prototype.match, dg = String.prototype.slice, gi = String.prototype.replace, Coe = String.prototype.toUpperCase, dS = String.prototype.toLowerCase, P$ = RegExp.prototype.test, pS = Array.prototype.concat, $r = Array.prototype.join, Ooe = Array.prototype.slice, hS = Math.floor, Rm = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, th = Object.getOwnPropertySymbols, Im = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, lo = typeof Symbol == "function" && typeof Symbol.iterator == "object", mn = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === lo || !0) ? Symbol.toStringTag : null, D$ = Object.prototype.propertyIsEnumerable, mS = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
  return e.__proto__;
} : null);
function vS(e, t) {
  if (e === 1 / 0 || e === -1 / 0 || e !== e || e && e > -1e3 && e < 1e3 || P$.call(/e/, t))
    return t;
  var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof e == "number") {
    var r = e < 0 ? -hS(-e) : hS(e);
    if (r !== e) {
      var i = String(r), a = dg.call(t, i.length + 1);
      return gi.call(i, n, "$&_") + "." + gi.call(gi.call(a, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return gi.call(t, n, "$&_");
}
var Am = boe, yS = Am.custom, gS = N$(yS) ? yS : null, $oe = function e(t, n, r, i) {
  var a = n || {};
  if (pi(a, "quoteStyle") && a.quoteStyle !== "single" && a.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if (pi(a, "maxStringLength") && (typeof a.maxStringLength == "number" ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : a.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var o = pi(a, "customInspect") ? a.customInspect : !0;
  if (typeof o != "boolean" && o !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if (pi(a, "indent") && a.indent !== null && a.indent !== "	" && !(parseInt(a.indent, 10) === a.indent && a.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if (pi(a, "numericSeparator") && typeof a.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var s = a.numericSeparator;
  if (typeof t > "u")
    return "undefined";
  if (t === null)
    return "null";
  if (typeof t == "boolean")
    return t ? "true" : "false";
  if (typeof t == "string")
    return F$(t, a);
  if (typeof t == "number") {
    if (t === 0)
      return 1 / 0 / t > 0 ? "0" : "-0";
    var c = String(t);
    return s ? vS(t, c) : c;
  }
  if (typeof t == "bigint") {
    var l = String(t) + "n";
    return s ? vS(t, l) : l;
  }
  var u = typeof a.depth > "u" ? 5 : a.depth;
  if (typeof r > "u" && (r = 0), r >= u && u > 0 && typeof t == "object")
    return Pm(t) ? "[Array]" : "[Object]";
  var f = Zoe(a, r);
  if (typeof i > "u")
    i = [];
  else if (M$(i, t) >= 0)
    return "[Circular]";
  function d(L, R, A) {
    if (R && (i = Ooe.call(i), i.push(R)), A) {
      var F = {
        depth: a.depth
      };
      return pi(a, "quoteStyle") && (F.quoteStyle = a.quoteStyle), e(L, F, r + 1, i);
    }
    return e(L, a, r + 1, i);
  }
  if (typeof t == "function" && !bS(t)) {
    var p = Foe(t), m = mc(t, d);
    return "[Function" + (p ? ": " + p : " (anonymous)") + "]" + (m.length > 0 ? " { " + $r.call(m, ", ") + " }" : "");
  }
  if (N$(t)) {
    var h = lo ? gi.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : Im.call(t);
    return typeof t == "object" && !lo ? Ko(h) : h;
  }
  if (Woe(t)) {
    for (var y = "<" + dS.call(String(t.nodeName)), v = t.attributes || [], b = 0; b < v.length; b++)
      y += " " + v[b].name + "=" + j$(Roe(v[b].value), "double", a);
    return y += ">", t.childNodes && t.childNodes.length && (y += "..."), y += "</" + dS.call(String(t.nodeName)) + ">", y;
  }
  if (Pm(t)) {
    if (t.length === 0)
      return "[]";
    var w = mc(t, d);
    return f && !Hoe(w) ? "[" + Dm(w, f) + "]" : "[ " + $r.call(w, ", ") + " ]";
  }
  if (Aoe(t)) {
    var T = mc(t, d);
    return !("cause" in Error.prototype) && "cause" in t && !D$.call(t, "cause") ? "{ [" + String(t) + "] " + $r.call(pS.call("[cause]: " + d(t.cause), T), ", ") + " }" : T.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + $r.call(T, ", ") + " }";
  }
  if (typeof t == "object" && o) {
    if (gS && typeof t[gS] == "function" && Am)
      return Am(t, { depth: u - r });
    if (o !== "symbol" && typeof t.inspect == "function")
      return t.inspect();
  }
  if (Loe(t)) {
    var E = [];
    return cS && cS.call(t, function(L, R) {
      E.push(d(R, t, !0) + " => " + d(L, t));
    }), wS("Map", Iu.call(t), E, f);
  }
  if (zoe(t)) {
    var _ = [];
    return uS && uS.call(t, function(L) {
      _.push(d(L, t));
    }), wS("Set", Au.call(t), _, f);
  }
  if (Boe(t))
    return nh("WeakMap");
  if (qoe(t))
    return nh("WeakSet");
  if (Uoe(t))
    return nh("WeakRef");
  if (Doe(t))
    return Ko(d(Number(t)));
  if (Noe(t))
    return Ko(d(Rm.call(t)));
  if (joe(t))
    return Ko(Eoe.call(t));
  if (Poe(t))
    return Ko(d(String(t)));
  if (typeof window < "u" && t === window)
    return "{ [object Window] }";
  if (typeof globalThis < "u" && t === globalThis || typeof yt < "u" && t === yt)
    return "{ [object globalThis] }";
  if (!Ioe(t) && !bS(t)) {
    var $ = mc(t, d), B = mS ? mS(t) === Object.prototype : t instanceof Object || t.constructor === Object, U = t instanceof Object ? "" : "null prototype", k = !B && mn && Object(t) === t && mn in t ? dg.call(Mi(t), 8, -1) : U ? "Object" : "", D = B || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "", q = D + (k || U ? "[" + $r.call(pS.call([], k || [], U || []), ": ") + "] " : "");
    return $.length === 0 ? q + "{}" : f ? q + "{" + Dm($, f) + "}" : q + "{ " + $r.call($, ", ") + " }";
  }
  return String(t);
};
function j$(e, t, n) {
  var r = (n.quoteStyle || t) === "double" ? '"' : "'";
  return r + e + r;
}
function Roe(e) {
  return gi.call(String(e), /"/g, "&quot;");
}
function Pm(e) {
  return Mi(e) === "[object Array]" && (!mn || !(typeof e == "object" && mn in e));
}
function Ioe(e) {
  return Mi(e) === "[object Date]" && (!mn || !(typeof e == "object" && mn in e));
}
function bS(e) {
  return Mi(e) === "[object RegExp]" && (!mn || !(typeof e == "object" && mn in e));
}
function Aoe(e) {
  return Mi(e) === "[object Error]" && (!mn || !(typeof e == "object" && mn in e));
}
function Poe(e) {
  return Mi(e) === "[object String]" && (!mn || !(typeof e == "object" && mn in e));
}
function Doe(e) {
  return Mi(e) === "[object Number]" && (!mn || !(typeof e == "object" && mn in e));
}
function joe(e) {
  return Mi(e) === "[object Boolean]" && (!mn || !(typeof e == "object" && mn in e));
}
function N$(e) {
  if (lo)
    return e && typeof e == "object" && e instanceof Symbol;
  if (typeof e == "symbol")
    return !0;
  if (!e || typeof e != "object" || !Im)
    return !1;
  try {
    return Im.call(e), !0;
  } catch {
  }
  return !1;
}
function Noe(e) {
  if (!e || typeof e != "object" || !Rm)
    return !1;
  try {
    return Rm.call(e), !0;
  } catch {
  }
  return !1;
}
var Moe = Object.prototype.hasOwnProperty || function(e) {
  return e in this;
};
function pi(e, t) {
  return Moe.call(e, t);
}
function Mi(e) {
  return _oe.call(e);
}
function Foe(e) {
  if (e.name)
    return e.name;
  var t = Toe.call(koe.call(e), /^function\s*([\w$]+)/);
  return t ? t[1] : null;
}
function M$(e, t) {
  if (e.indexOf)
    return e.indexOf(t);
  for (var n = 0, r = e.length; n < r; n++)
    if (e[n] === t)
      return n;
  return -1;
}
function Loe(e) {
  if (!Iu || !e || typeof e != "object")
    return !1;
  try {
    Iu.call(e);
    try {
      Au.call(e);
    } catch {
      return !0;
    }
    return e instanceof Map;
  } catch {
  }
  return !1;
}
function Boe(e) {
  if (!ss || !e || typeof e != "object")
    return !1;
  try {
    ss.call(e, ss);
    try {
      ls.call(e, ls);
    } catch {
      return !0;
    }
    return e instanceof WeakMap;
  } catch {
  }
  return !1;
}
function Uoe(e) {
  if (!fS || !e || typeof e != "object")
    return !1;
  try {
    return fS.call(e), !0;
  } catch {
  }
  return !1;
}
function zoe(e) {
  if (!Au || !e || typeof e != "object")
    return !1;
  try {
    Au.call(e);
    try {
      Iu.call(e);
    } catch {
      return !0;
    }
    return e instanceof Set;
  } catch {
  }
  return !1;
}
function qoe(e) {
  if (!ls || !e || typeof e != "object")
    return !1;
  try {
    ls.call(e, ls);
    try {
      ss.call(e, ss);
    } catch {
      return !0;
    }
    return e instanceof WeakSet;
  } catch {
  }
  return !1;
}
function Woe(e) {
  return !e || typeof e != "object" ? !1 : typeof HTMLElement < "u" && e instanceof HTMLElement ? !0 : typeof e.nodeName == "string" && typeof e.getAttribute == "function";
}
function F$(e, t) {
  if (e.length > t.maxStringLength) {
    var n = e.length - t.maxStringLength, r = "... " + n + " more character" + (n > 1 ? "s" : "");
    return F$(dg.call(e, 0, t.maxStringLength), t) + r;
  }
  var i = gi.call(gi.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, Voe);
  return j$(i, "single", t);
}
function Voe(e) {
  var t = e.charCodeAt(0), n = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[t];
  return n ? "\\" + n : "\\x" + (t < 16 ? "0" : "") + Coe.call(t.toString(16));
}
function Ko(e) {
  return "Object(" + e + ")";
}
function nh(e) {
  return e + " { ? }";
}
function wS(e, t, n, r) {
  var i = r ? Dm(n, r) : $r.call(n, ", ");
  return e + " (" + t + ") {" + i + "}";
}
function Hoe(e) {
  for (var t = 0; t < e.length; t++)
    if (M$(e[t], `
`) >= 0)
      return !1;
  return !0;
}
function Zoe(e, t) {
  var n;
  if (e.indent === "	")
    n = "	";
  else if (typeof e.indent == "number" && e.indent > 0)
    n = $r.call(Array(e.indent + 1), " ");
  else
    return null;
  return {
    base: n,
    prev: $r.call(Array(t + 1), n)
  };
}
function Dm(e, t) {
  if (e.length === 0)
    return "";
  var n = `
` + t.prev + t.base;
  return n + $r.call(e, "," + n) + `
` + t.prev;
}
function mc(e, t) {
  var n = Pm(e), r = [];
  if (n) {
    r.length = e.length;
    for (var i = 0; i < e.length; i++)
      r[i] = pi(e, i) ? t(e[i], e) : "";
  }
  var a = typeof th == "function" ? th(e) : [], o;
  if (lo) {
    o = {};
    for (var s = 0; s < a.length; s++)
      o["$" + a[s]] = a[s];
  }
  for (var c in e)
    pi(e, c) && (n && String(Number(c)) === c && c < e.length || lo && o["$" + c] instanceof Symbol || (P$.call(/[^\w$]/, c) ? r.push(t(c, e) + ": " + t(e[c], e)) : r.push(c + ": " + t(e[c], e))));
  if (typeof th == "function")
    for (var l = 0; l < a.length; l++)
      D$.call(e, a[l]) && r.push("[" + t(a[l]) + "]: " + t(e[a[l]], e));
  return r;
}
var L$ = Uf, Io = goe, Koe = $oe, Goe = Ro, vc = L$("%WeakMap%", !0), yc = L$("%Map%", !0), Yoe = Io("WeakMap.prototype.get", !0), Joe = Io("WeakMap.prototype.set", !0), Xoe = Io("WeakMap.prototype.has", !0), Qoe = Io("Map.prototype.get", !0), ese = Io("Map.prototype.set", !0), tse = Io("Map.prototype.has", !0), pg = function(e, t) {
  for (var n = e, r; (r = n.next) !== null; n = r)
    if (r.key === t)
      return n.next = r.next, r.next = /** @type {NonNullable<typeof list.next>} */
      e.next, e.next = r, r;
}, nse = function(e, t) {
  var n = pg(e, t);
  return n && n.value;
}, rse = function(e, t, n) {
  var r = pg(e, t);
  r ? r.value = n : e.next = /** @type {import('.').ListNode<typeof value>} */
  {
    // eslint-disable-line no-param-reassign, no-extra-parens
    key: t,
    next: e.next,
    value: n
  };
}, ise = function(e, t) {
  return !!pg(e, t);
}, ase = function() {
  var t, n, r, i = {
    assert: function(a) {
      if (!i.has(a))
        throw new Goe("Side channel does not contain " + Koe(a));
    },
    get: function(a) {
      if (vc && a && (typeof a == "object" || typeof a == "function")) {
        if (t)
          return Yoe(t, a);
      } else if (yc) {
        if (n)
          return Qoe(n, a);
      } else if (r)
        return nse(r, a);
    },
    has: function(a) {
      if (vc && a && (typeof a == "object" || typeof a == "function")) {
        if (t)
          return Xoe(t, a);
      } else if (yc) {
        if (n)
          return tse(n, a);
      } else if (r)
        return ise(r, a);
      return !1;
    },
    set: function(a, o) {
      vc && a && (typeof a == "object" || typeof a == "function") ? (t || (t = new vc()), Joe(t, a, o)) : yc ? (n || (n = new yc()), ese(n, a, o)) : (r || (r = { key: {}, next: null }), rse(r, a, o));
    }
  };
  return i;
}, ose = String.prototype.replace, sse = /%20/g, rh = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, hg = {
  default: rh.RFC3986,
  formatters: {
    RFC1738: function(e) {
      return ose.call(e, sse, "+");
    },
    RFC3986: function(e) {
      return String(e);
    }
  },
  RFC1738: rh.RFC1738,
  RFC3986: rh.RFC3986
}, lse = hg, ih = Object.prototype.hasOwnProperty, qi = Array.isArray, Sr = function() {
  for (var e = [], t = 0; t < 256; ++t)
    e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
  return e;
}(), cse = function(t) {
  for (; t.length > 1; ) {
    var n = t.pop(), r = n.obj[n.prop];
    if (qi(r)) {
      for (var i = [], a = 0; a < r.length; ++a)
        typeof r[a] < "u" && i.push(r[a]);
      n.obj[n.prop] = i;
    }
  }
}, B$ = function(t, n) {
  for (var r = n && n.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, i = 0; i < t.length; ++i)
    typeof t[i] < "u" && (r[i] = t[i]);
  return r;
}, use = function e(t, n, r) {
  if (!n)
    return t;
  if (typeof n != "object") {
    if (qi(t))
      t.push(n);
    else if (t && typeof t == "object")
      (r && (r.plainObjects || r.allowPrototypes) || !ih.call(Object.prototype, n)) && (t[n] = !0);
    else
      return [t, n];
    return t;
  }
  if (!t || typeof t != "object")
    return [t].concat(n);
  var i = t;
  return qi(t) && !qi(n) && (i = B$(t, r)), qi(t) && qi(n) ? (n.forEach(function(a, o) {
    if (ih.call(t, o)) {
      var s = t[o];
      s && typeof s == "object" && a && typeof a == "object" ? t[o] = e(s, a, r) : t.push(a);
    } else
      t[o] = a;
  }), t) : Object.keys(n).reduce(function(a, o) {
    var s = n[o];
    return ih.call(a, o) ? a[o] = e(a[o], s, r) : a[o] = s, a;
  }, i);
}, fse = function(t, n) {
  return Object.keys(n).reduce(function(r, i) {
    return r[i] = n[i], r;
  }, t);
}, dse = function(e, t, n) {
  var r = e.replace(/\+/g, " ");
  if (n === "iso-8859-1")
    return r.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(r);
  } catch {
    return r;
  }
}, ah = 1024, pse = function(t, n, r, i, a) {
  if (t.length === 0)
    return t;
  var o = t;
  if (typeof t == "symbol" ? o = Symbol.prototype.toString.call(t) : typeof t != "string" && (o = String(t)), r === "iso-8859-1")
    return escape(o).replace(/%u[0-9a-f]{4}/gi, function(p) {
      return "%26%23" + parseInt(p.slice(2), 16) + "%3B";
    });
  for (var s = "", c = 0; c < o.length; c += ah) {
    for (var l = o.length >= ah ? o.slice(c, c + ah) : o, u = [], f = 0; f < l.length; ++f) {
      var d = l.charCodeAt(f);
      if (d === 45 || d === 46 || d === 95 || d === 126 || d >= 48 && d <= 57 || d >= 65 && d <= 90 || d >= 97 && d <= 122 || a === lse.RFC1738 && (d === 40 || d === 41)) {
        u[u.length] = l.charAt(f);
        continue;
      }
      if (d < 128) {
        u[u.length] = Sr[d];
        continue;
      }
      if (d < 2048) {
        u[u.length] = Sr[192 | d >> 6] + Sr[128 | d & 63];
        continue;
      }
      if (d < 55296 || d >= 57344) {
        u[u.length] = Sr[224 | d >> 12] + Sr[128 | d >> 6 & 63] + Sr[128 | d & 63];
        continue;
      }
      f += 1, d = 65536 + ((d & 1023) << 10 | l.charCodeAt(f) & 1023), u[u.length] = Sr[240 | d >> 18] + Sr[128 | d >> 12 & 63] + Sr[128 | d >> 6 & 63] + Sr[128 | d & 63];
    }
    s += u.join("");
  }
  return s;
}, hse = function(t) {
  for (var n = [{ obj: { o: t }, prop: "o" }], r = [], i = 0; i < n.length; ++i)
    for (var a = n[i], o = a.obj[a.prop], s = Object.keys(o), c = 0; c < s.length; ++c) {
      var l = s[c], u = o[l];
      typeof u == "object" && u !== null && r.indexOf(u) === -1 && (n.push({ obj: o, prop: l }), r.push(u));
    }
  return cse(n), t;
}, mse = function(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}, vse = function(t) {
  return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
}, yse = function(t, n) {
  return [].concat(t, n);
}, gse = function(t, n) {
  if (qi(t)) {
    for (var r = [], i = 0; i < t.length; i += 1)
      r.push(n(t[i]));
    return r;
  }
  return n(t);
}, U$ = {
  arrayToObject: B$,
  assign: fse,
  combine: yse,
  compact: hse,
  decode: dse,
  encode: pse,
  isBuffer: vse,
  isRegExp: mse,
  maybeMap: gse,
  merge: use
}, z$ = ase, zc = U$, cs = hg, bse = Object.prototype.hasOwnProperty, q$ = {
  brackets: function(t) {
    return t + "[]";
  },
  comma: "comma",
  indices: function(t, n) {
    return t + "[" + n + "]";
  },
  repeat: function(t) {
    return t;
  }
}, Cr = Array.isArray, wse = Array.prototype.push, W$ = function(e, t) {
  wse.apply(e, Cr(t) ? t : [t]);
}, xse = Date.prototype.toISOString, xS = cs.default, Jt = {
  addQueryPrefix: !1,
  allowDots: !1,
  allowEmptyArrays: !1,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encodeDotInKeys: !1,
  encoder: zc.encode,
  encodeValuesOnly: !1,
  format: xS,
  formatter: cs.formatters[xS],
  // deprecated
  indices: !1,
  serializeDate: function(t) {
    return xse.call(t);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, Sse = function(t) {
  return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint";
}, oh = {}, Ese = function e(t, n, r, i, a, o, s, c, l, u, f, d, p, m, h, y, v, b) {
  for (var w = t, T = b, E = 0, _ = !1; (T = T.get(oh)) !== void 0 && !_; ) {
    var $ = T.get(t);
    if (E += 1, typeof $ < "u") {
      if ($ === E)
        throw new RangeError("Cyclic object value");
      _ = !0;
    }
    typeof T.get(oh) > "u" && (E = 0);
  }
  if (typeof u == "function" ? w = u(n, w) : w instanceof Date ? w = p(w) : r === "comma" && Cr(w) && (w = zc.maybeMap(w, function(g) {
    return g instanceof Date ? p(g) : g;
  })), w === null) {
    if (o)
      return l && !y ? l(n, Jt.encoder, v, "key", m) : n;
    w = "";
  }
  if (Sse(w) || zc.isBuffer(w)) {
    if (l) {
      var B = y ? n : l(n, Jt.encoder, v, "key", m);
      return [h(B) + "=" + h(l(w, Jt.encoder, v, "value", m))];
    }
    return [h(n) + "=" + h(String(w))];
  }
  var U = [];
  if (typeof w > "u")
    return U;
  var k;
  if (r === "comma" && Cr(w))
    y && l && (w = zc.maybeMap(w, l)), k = [{ value: w.length > 0 ? w.join(",") || null : void 0 }];
  else if (Cr(u))
    k = u;
  else {
    var D = Object.keys(w);
    k = f ? D.sort(f) : D;
  }
  var q = c ? n.replace(/\./g, "%2E") : n, L = i && Cr(w) && w.length === 1 ? q + "[]" : q;
  if (a && Cr(w) && w.length === 0)
    return L + "[]";
  for (var R = 0; R < k.length; ++R) {
    var A = k[R], F = typeof A == "object" && typeof A.value < "u" ? A.value : w[A];
    if (!(s && F === null)) {
      var H = d && c ? A.replace(/\./g, "%2E") : A, V = Cr(w) ? typeof r == "function" ? r(L, H) : L : L + (d ? "." + H : "[" + H + "]");
      b.set(t, E);
      var I = z$();
      I.set(oh, b), W$(U, e(
        F,
        V,
        r,
        i,
        a,
        o,
        s,
        c,
        r === "comma" && y && Cr(w) ? null : l,
        u,
        f,
        d,
        p,
        m,
        h,
        y,
        v,
        I
      ));
    }
  }
  return U;
}, _se = function(t) {
  if (!t)
    return Jt;
  if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof t.encodeDotInKeys < "u" && typeof t.encodeDotInKeys != "boolean")
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var n = t.charset || Jt.charset;
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var r = cs.default;
  if (typeof t.format < "u") {
    if (!bse.call(cs.formatters, t.format))
      throw new TypeError("Unknown format option provided.");
    r = t.format;
  }
  var i = cs.formatters[r], a = Jt.filter;
  (typeof t.filter == "function" || Cr(t.filter)) && (a = t.filter);
  var o;
  if (t.arrayFormat in q$ ? o = t.arrayFormat : "indices" in t ? o = t.indices ? "indices" : "repeat" : o = Jt.arrayFormat, "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var s = typeof t.allowDots > "u" ? t.encodeDotInKeys === !0 ? !0 : Jt.allowDots : !!t.allowDots;
  return {
    addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : Jt.addQueryPrefix,
    allowDots: s,
    allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Jt.allowEmptyArrays,
    arrayFormat: o,
    charset: n,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Jt.charsetSentinel,
    commaRoundTrip: t.commaRoundTrip,
    delimiter: typeof t.delimiter > "u" ? Jt.delimiter : t.delimiter,
    encode: typeof t.encode == "boolean" ? t.encode : Jt.encode,
    encodeDotInKeys: typeof t.encodeDotInKeys == "boolean" ? t.encodeDotInKeys : Jt.encodeDotInKeys,
    encoder: typeof t.encoder == "function" ? t.encoder : Jt.encoder,
    encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : Jt.encodeValuesOnly,
    filter: a,
    format: r,
    formatter: i,
    serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : Jt.serializeDate,
    skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : Jt.skipNulls,
    sort: typeof t.sort == "function" ? t.sort : null,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Jt.strictNullHandling
  };
}, kse = function(e, t) {
  var n = e, r = _se(t), i, a;
  typeof r.filter == "function" ? (a = r.filter, n = a("", n)) : Cr(r.filter) && (a = r.filter, i = a);
  var o = [];
  if (typeof n != "object" || n === null)
    return "";
  var s = q$[r.arrayFormat], c = s === "comma" && r.commaRoundTrip;
  i || (i = Object.keys(n)), r.sort && i.sort(r.sort);
  for (var l = z$(), u = 0; u < i.length; ++u) {
    var f = i[u];
    r.skipNulls && n[f] === null || W$(o, Ese(
      n[f],
      f,
      s,
      c,
      r.allowEmptyArrays,
      r.strictNullHandling,
      r.skipNulls,
      r.encodeDotInKeys,
      r.encode ? r.encoder : null,
      r.filter,
      r.sort,
      r.allowDots,
      r.serializeDate,
      r.format,
      r.formatter,
      r.encodeValuesOnly,
      r.charset,
      l
    ));
  }
  var d = o.join(r.delimiter), p = r.addQueryPrefix === !0 ? "?" : "";
  return r.charsetSentinel && (r.charset === "iso-8859-1" ? p += "utf8=%26%2310003%3B&" : p += "utf8=%E2%9C%93&"), d.length > 0 ? p + d : "";
}, co = U$, jm = Object.prototype.hasOwnProperty, Tse = Array.isArray, Mt = {
  allowDots: !1,
  allowEmptyArrays: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decodeDotInKeys: !1,
  decoder: co.decode,
  delimiter: "&",
  depth: 5,
  duplicates: "combine",
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictDepth: !1,
  strictNullHandling: !1
}, Cse = function(e) {
  return e.replace(/&#(\d+);/g, function(t, n) {
    return String.fromCharCode(parseInt(n, 10));
  });
}, V$ = function(e, t) {
  return e && typeof e == "string" && t.comma && e.indexOf(",") > -1 ? e.split(",") : e;
}, Ose = "utf8=%26%2310003%3B", $se = "utf8=%E2%9C%93", Rse = function(t, n) {
  var r = { __proto__: null }, i = n.ignoreQueryPrefix ? t.replace(/^\?/, "") : t;
  i = i.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  var a = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit, o = i.split(n.delimiter, a), s = -1, c, l = n.charset;
  if (n.charsetSentinel)
    for (c = 0; c < o.length; ++c)
      o[c].indexOf("utf8=") === 0 && (o[c] === $se ? l = "utf-8" : o[c] === Ose && (l = "iso-8859-1"), s = c, c = o.length);
  for (c = 0; c < o.length; ++c)
    if (c !== s) {
      var u = o[c], f = u.indexOf("]="), d = f === -1 ? u.indexOf("=") : f + 1, p, m;
      d === -1 ? (p = n.decoder(u, Mt.decoder, l, "key"), m = n.strictNullHandling ? null : "") : (p = n.decoder(u.slice(0, d), Mt.decoder, l, "key"), m = co.maybeMap(
        V$(u.slice(d + 1), n),
        function(y) {
          return n.decoder(y, Mt.decoder, l, "value");
        }
      )), m && n.interpretNumericEntities && l === "iso-8859-1" && (m = Cse(m)), u.indexOf("[]=") > -1 && (m = Tse(m) ? [m] : m);
      var h = jm.call(r, p);
      h && n.duplicates === "combine" ? r[p] = co.combine(r[p], m) : (!h || n.duplicates === "last") && (r[p] = m);
    }
  return r;
}, Ise = function(e, t, n, r) {
  for (var i = r ? t : V$(t, n), a = e.length - 1; a >= 0; --a) {
    var o, s = e[a];
    if (s === "[]" && n.parseArrays)
      o = n.allowEmptyArrays && (i === "" || n.strictNullHandling && i === null) ? [] : [].concat(i);
    else {
      o = n.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var c = s.charAt(0) === "[" && s.charAt(s.length - 1) === "]" ? s.slice(1, -1) : s, l = n.decodeDotInKeys ? c.replace(/%2E/g, ".") : c, u = parseInt(l, 10);
      !n.parseArrays && l === "" ? o = { 0: i } : !isNaN(u) && s !== l && String(u) === l && u >= 0 && n.parseArrays && u <= n.arrayLimit ? (o = [], o[u] = i) : l !== "__proto__" && (o[l] = i);
    }
    i = o;
  }
  return i;
}, Ase = function(t, n, r, i) {
  if (t) {
    var a = r.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t, o = /(\[[^[\]]*])/, s = /(\[[^[\]]*])/g, c = r.depth > 0 && o.exec(a), l = c ? a.slice(0, c.index) : a, u = [];
    if (l) {
      if (!r.plainObjects && jm.call(Object.prototype, l) && !r.allowPrototypes)
        return;
      u.push(l);
    }
    for (var f = 0; r.depth > 0 && (c = s.exec(a)) !== null && f < r.depth; ) {
      if (f += 1, !r.plainObjects && jm.call(Object.prototype, c[1].slice(1, -1)) && !r.allowPrototypes)
        return;
      u.push(c[1]);
    }
    if (c) {
      if (r.strictDepth === !0)
        throw new RangeError("Input depth exceeded depth option of " + r.depth + " and strictDepth is true");
      u.push("[" + a.slice(c.index) + "]");
    }
    return Ise(u, n, r, i);
  }
}, Pse = function(t) {
  if (!t)
    return Mt;
  if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean")
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  if (typeof t.decodeDotInKeys < "u" && typeof t.decodeDotInKeys != "boolean")
    throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
  if (t.decoder !== null && typeof t.decoder < "u" && typeof t.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var n = typeof t.charset > "u" ? Mt.charset : t.charset, r = typeof t.duplicates > "u" ? Mt.duplicates : t.duplicates;
  if (r !== "combine" && r !== "first" && r !== "last")
    throw new TypeError("The duplicates option must be either combine, first, or last");
  var i = typeof t.allowDots > "u" ? t.decodeDotInKeys === !0 ? !0 : Mt.allowDots : !!t.allowDots;
  return {
    allowDots: i,
    allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Mt.allowEmptyArrays,
    allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : Mt.allowPrototypes,
    allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : Mt.allowSparse,
    arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : Mt.arrayLimit,
    charset: n,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Mt.charsetSentinel,
    comma: typeof t.comma == "boolean" ? t.comma : Mt.comma,
    decodeDotInKeys: typeof t.decodeDotInKeys == "boolean" ? t.decodeDotInKeys : Mt.decodeDotInKeys,
    decoder: typeof t.decoder == "function" ? t.decoder : Mt.decoder,
    delimiter: typeof t.delimiter == "string" || co.isRegExp(t.delimiter) ? t.delimiter : Mt.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : Mt.depth,
    duplicates: r,
    ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : Mt.interpretNumericEntities,
    parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : Mt.parameterLimit,
    parseArrays: t.parseArrays !== !1,
    plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : Mt.plainObjects,
    strictDepth: typeof t.strictDepth == "boolean" ? !!t.strictDepth : Mt.strictDepth,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Mt.strictNullHandling
  };
}, Dse = function(e, t) {
  var n = Pse(t);
  if (e === "" || e === null || typeof e > "u")
    return n.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var r = typeof e == "string" ? Rse(e, n) : e, i = n.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, a = Object.keys(r), o = 0; o < a.length; ++o) {
    var s = a[o], c = Ase(s, r[s], n, typeof e == "string");
    i = co.merge(i, c, n);
  }
  return n.allowSparse === !0 ? i : co.compact(i);
}, jse = kse, Nse = Dse, Mse = hg, Fse = {
  formats: Mse,
  parse: Nse,
  stringify: jse
};
const Lse = /* @__PURE__ */ Ye(Fse);
var Nm = { exports: {} };
/** @license
 * eventsource.js
 * Available under MIT License (MIT)
 * https://github.com/Yaffle/EventSource/
 */
(function(e, t) {
  (function(n) {
    var r = n.setTimeout, i = n.clearTimeout, a = n.XMLHttpRequest, o = n.XDomainRequest, s = n.ActiveXObject, c = n.EventSource, l = n.document, u = n.Promise, f = n.fetch, d = n.Response, p = n.TextDecoder, m = n.TextEncoder, h = n.AbortController;
    if (typeof window < "u" && typeof l < "u" && !("readyState" in l) && l.body == null && (l.readyState = "loading", window.addEventListener("load", function(M) {
      l.readyState = "complete";
    }, !1)), a == null && s != null && (a = function() {
      return new s("Microsoft.XMLHTTP");
    }), Object.create == null && (Object.create = function(M) {
      function re() {
      }
      return re.prototype = M, new re();
    }), Date.now || (Date.now = function() {
      return (/* @__PURE__ */ new Date()).getTime();
    }), h == null) {
      var y = f;
      f = function(M, re) {
        var le = re.signal;
        return y(M, { headers: re.headers, credentials: re.credentials, cache: re.cache }).then(function(oe) {
          var Te = oe.body.getReader();
          return le._reader = Te, le._aborted && le._reader.cancel(), {
            status: oe.status,
            statusText: oe.statusText,
            headers: oe.headers,
            body: {
              getReader: function() {
                return Te;
              }
            }
          };
        });
      }, h = function() {
        this.signal = {
          _reader: null,
          _aborted: !1
        }, this.abort = function() {
          this.signal._reader != null && this.signal._reader.cancel(), this.signal._aborted = !0;
        };
      };
    }
    function v() {
      this.bitsNeeded = 0, this.codePoint = 0;
    }
    v.prototype.decode = function(M) {
      function re(ue, z, N) {
        if (N === 1)
          return ue >= 128 >> z && ue << z <= 2047;
        if (N === 2)
          return ue >= 2048 >> z && ue << z <= 55295 || ue >= 57344 >> z && ue << z <= 65535;
        if (N === 3)
          return ue >= 65536 >> z && ue << z <= 1114111;
        throw new Error();
      }
      function le(ue, z) {
        if (ue === 6 * 1)
          return z >> 6 > 15 ? 3 : z > 31 ? 2 : 1;
        if (ue === 6 * 2)
          return z > 15 ? 3 : 2;
        if (ue === 6 * 3)
          return 3;
        throw new Error();
      }
      for (var oe = 65533, Te = "", Se = this.bitsNeeded, Re = this.codePoint, ze = 0; ze < M.length; ze += 1) {
        var ee = M[ze];
        Se !== 0 && (ee < 128 || ee > 191 || !re(Re << 6 | ee & 63, Se - 6, le(Se, Re))) && (Se = 0, Re = oe, Te += String.fromCharCode(Re)), Se === 0 ? (ee >= 0 && ee <= 127 ? (Se = 0, Re = ee) : ee >= 192 && ee <= 223 ? (Se = 6 * 1, Re = ee & 31) : ee >= 224 && ee <= 239 ? (Se = 6 * 2, Re = ee & 15) : ee >= 240 && ee <= 247 ? (Se = 6 * 3, Re = ee & 7) : (Se = 0, Re = oe), Se !== 0 && !re(Re, Se, le(Se, Re)) && (Se = 0, Re = oe)) : (Se -= 6, Re = Re << 6 | ee & 63), Se === 0 && (Re <= 65535 ? Te += String.fromCharCode(Re) : (Te += String.fromCharCode(55296 + (Re - 65535 - 1 >> 10)), Te += String.fromCharCode(56320 + (Re - 65535 - 1 & 1023))));
      }
      return this.bitsNeeded = Se, this.codePoint = Re, Te;
    };
    var b = function() {
      try {
        return new p().decode(new m().encode("test"), { stream: !0 }) === "test";
      } catch (M) {
        console.debug("TextDecoder does not support streaming option. Using polyfill instead: " + M);
      }
      return !1;
    };
    (p == null || m == null || !b()) && (p = v);
    var w = function() {
    };
    function T(M) {
      this.withCredentials = !1, this.readyState = 0, this.status = 0, this.statusText = "", this.responseText = "", this.onprogress = w, this.onload = w, this.onerror = w, this.onreadystatechange = w, this._contentType = "", this._xhr = M, this._sendTimeout = 0, this._abort = w;
    }
    T.prototype.open = function(M, re) {
      this._abort(!0);
      var le = this, oe = this._xhr, Te = 1, Se = 0;
      this._abort = function(N) {
        le._sendTimeout !== 0 && (i(le._sendTimeout), le._sendTimeout = 0), (Te === 1 || Te === 2 || Te === 3) && (Te = 4, oe.onload = w, oe.onerror = w, oe.onabort = w, oe.onprogress = w, oe.onreadystatechange = w, oe.abort(), Se !== 0 && (i(Se), Se = 0), N || (le.readyState = 4, le.onabort(null), le.onreadystatechange())), Te = 0;
      };
      var Re = function() {
        if (Te === 1) {
          var N = 0, te = "", de = void 0;
          if ("contentType" in oe)
            N = 200, te = "OK", de = oe.contentType;
          else
            try {
              N = oe.status, te = oe.statusText, de = oe.getResponseHeader("Content-Type");
            } catch {
              N = 0, te = "", de = void 0;
            }
          N !== 0 && (Te = 2, le.readyState = 2, le.status = N, le.statusText = te, le._contentType = de, le.onreadystatechange());
        }
      }, ze = function() {
        if (Re(), Te === 2 || Te === 3) {
          Te = 3;
          var N = "";
          try {
            N = oe.responseText;
          } catch {
          }
          le.readyState = 3, le.responseText = N, le.onprogress();
        }
      }, ee = function(N, te) {
        if ((te == null || te.preventDefault == null) && (te = {
          preventDefault: w
        }), ze(), Te === 1 || Te === 2 || Te === 3) {
          if (Te = 4, Se !== 0 && (i(Se), Se = 0), le.readyState = 4, N === "load")
            le.onload(te);
          else if (N === "error")
            le.onerror(te);
          else if (N === "abort")
            le.onabort(te);
          else
            throw new TypeError();
          le.onreadystatechange();
        }
      }, ue = function(N) {
        oe != null && (oe.readyState === 4 ? (!("onload" in oe) || !("onerror" in oe) || !("onabort" in oe)) && ee(oe.responseText === "" ? "error" : "load", N) : oe.readyState === 3 ? "onprogress" in oe || ze() : oe.readyState === 2 && Re());
      }, z = function() {
        Se = r(function() {
          z();
        }, 500), oe.readyState === 3 && ze();
      };
      "onload" in oe && (oe.onload = function(N) {
        ee("load", N);
      }), "onerror" in oe && (oe.onerror = function(N) {
        ee("error", N);
      }), "onabort" in oe && (oe.onabort = function(N) {
        ee("abort", N);
      }), "onprogress" in oe && (oe.onprogress = ze), "onreadystatechange" in oe && (oe.onreadystatechange = function(N) {
        ue(N);
      }), ("contentType" in oe || !("ontimeout" in a.prototype)) && (re += (re.indexOf("?") === -1 ? "?" : "&") + "padding=true"), oe.open(M, re, !0), "readyState" in oe && (Se = r(function() {
        z();
      }, 0));
    }, T.prototype.abort = function() {
      this._abort(!1);
    }, T.prototype.getResponseHeader = function(M) {
      return this._contentType;
    }, T.prototype.setRequestHeader = function(M, re) {
      var le = this._xhr;
      "setRequestHeader" in le && le.setRequestHeader(M, re);
    }, T.prototype.getAllResponseHeaders = function() {
      return this._xhr.getAllResponseHeaders != null && this._xhr.getAllResponseHeaders() || "";
    }, T.prototype.send = function() {
      if ((!("ontimeout" in a.prototype) || !("sendAsBinary" in a.prototype) && !("mozAnon" in a.prototype)) && l != null && l.readyState != null && l.readyState !== "complete") {
        var M = this;
        M._sendTimeout = r(function() {
          M._sendTimeout = 0, M.send();
        }, 4);
        return;
      }
      var re = this._xhr;
      "withCredentials" in re && (re.withCredentials = this.withCredentials);
      try {
        re.send(void 0);
      } catch (le) {
        throw le;
      }
    };
    function E(M) {
      return M.replace(/[A-Z]/g, function(re) {
        return String.fromCharCode(re.charCodeAt(0) + 32);
      });
    }
    function _(M) {
      for (var re = /* @__PURE__ */ Object.create(null), le = M.split(`\r
`), oe = 0; oe < le.length; oe += 1) {
        var Te = le[oe], Se = Te.split(": "), Re = Se.shift(), ze = Se.join(": ");
        re[E(Re)] = ze;
      }
      this._map = re;
    }
    _.prototype.get = function(M) {
      return this._map[E(M)];
    }, a != null && a.HEADERS_RECEIVED == null && (a.HEADERS_RECEIVED = 2);
    function $() {
    }
    $.prototype.open = function(M, re, le, oe, Te, Se, Re) {
      M.open("GET", Te);
      var ze = 0;
      M.onprogress = function() {
        var ue = M.responseText, z = ue.slice(ze);
        ze += z.length, le(z);
      }, M.onerror = function(ue) {
        ue.preventDefault(), oe(new Error("NetworkError"));
      }, M.onload = function() {
        oe(null);
      }, M.onabort = function() {
        oe(null);
      }, M.onreadystatechange = function() {
        if (M.readyState === a.HEADERS_RECEIVED) {
          var ue = M.status, z = M.statusText, N = M.getResponseHeader("Content-Type"), te = M.getAllResponseHeaders();
          re(ue, z, N, new _(te));
        }
      }, M.withCredentials = Se;
      for (var ee in Re)
        Object.prototype.hasOwnProperty.call(Re, ee) && M.setRequestHeader(ee, Re[ee]);
      return M.send(), M;
    };
    function B(M) {
      this._headers = M;
    }
    B.prototype.get = function(M) {
      return this._headers.get(M);
    };
    function U() {
    }
    U.prototype.open = function(M, re, le, oe, Te, Se, Re) {
      var ze = null, ee = new h(), ue = ee.signal, z = new p();
      return f(Te, {
        headers: Re,
        credentials: Se ? "include" : "same-origin",
        signal: ue,
        cache: "no-store"
      }).then(function(N) {
        return ze = N.body.getReader(), re(N.status, N.statusText, N.headers.get("Content-Type"), new B(N.headers)), new u(function(te, de) {
          var be = function() {
            ze.read().then(function(Oe) {
              if (Oe.done)
                te(void 0);
              else {
                var Ve = z.decode(Oe.value, { stream: !0 });
                le(Ve), be();
              }
            }).catch(function(Oe) {
              de(Oe);
            });
          };
          be();
        });
      }).catch(function(N) {
        if (N.name !== "AbortError")
          return N;
      }).then(function(N) {
        oe(N);
      }), {
        abort: function() {
          ze != null && ze.cancel(), ee.abort();
        }
      };
    };
    function k() {
      this._listeners = /* @__PURE__ */ Object.create(null);
    }
    function D(M) {
      r(function() {
        throw M;
      }, 0);
    }
    k.prototype.dispatchEvent = function(M) {
      M.target = this;
      var re = this._listeners[M.type];
      if (re != null)
        for (var le = re.length, oe = 0; oe < le; oe += 1) {
          var Te = re[oe];
          try {
            typeof Te.handleEvent == "function" ? Te.handleEvent(M) : Te.call(this, M);
          } catch (Se) {
            D(Se);
          }
        }
    }, k.prototype.addEventListener = function(M, re) {
      M = String(M);
      var le = this._listeners, oe = le[M];
      oe == null && (oe = [], le[M] = oe);
      for (var Te = !1, Se = 0; Se < oe.length; Se += 1)
        oe[Se] === re && (Te = !0);
      Te || oe.push(re);
    }, k.prototype.removeEventListener = function(M, re) {
      M = String(M);
      var le = this._listeners, oe = le[M];
      if (oe != null) {
        for (var Te = [], Se = 0; Se < oe.length; Se += 1)
          oe[Se] !== re && Te.push(oe[Se]);
        Te.length === 0 ? delete le[M] : le[M] = Te;
      }
    };
    function q(M) {
      this.type = M, this.target = void 0;
    }
    function L(M, re) {
      q.call(this, M), this.data = re.data, this.lastEventId = re.lastEventId;
    }
    L.prototype = Object.create(q.prototype);
    function R(M, re) {
      q.call(this, M), this.status = re.status, this.statusText = re.statusText, this.headers = re.headers;
    }
    R.prototype = Object.create(q.prototype);
    function A(M, re) {
      q.call(this, M), this.error = re.error;
    }
    A.prototype = Object.create(q.prototype);
    var F = -1, H = 0, V = 1, I = 2, g = -1, j = 0, W = 1, S = 2, Z = 3, Y = /^text\/event\-stream(;.*)?$/i, G = 1e3, X = 18e6, ie = function(M, re) {
      var le = M == null ? re : parseInt(M, 10);
      return le !== le && (le = re), ae(le);
    }, ae = function(M) {
      return Math.min(Math.max(M, G), X);
    }, J = function(M, re, le) {
      try {
        typeof re == "function" && re.call(M, le);
      } catch (oe) {
        D(oe);
      }
    };
    function Q(M, re) {
      k.call(this), re = re || {}, this.onopen = void 0, this.onmessage = void 0, this.onerror = void 0, this.url = void 0, this.readyState = void 0, this.withCredentials = void 0, this.headers = void 0, this._close = void 0, ye(this, M, re);
    }
    function K() {
      return a != null && "withCredentials" in a.prototype || o == null ? new a() : new o();
    }
    var fe = f != null && d != null && "body" in d.prototype;
    function ye(M, re, le) {
      re = String(re);
      var oe = !!le.withCredentials, Te = le.lastEventIdQueryParameterName || "lastEventId", Se = ae(1e3), Re = ie(le.heartbeatTimeout, 45e3), ze = "", ee = Se, ue = !1, z = 0, N = le.headers || {}, te = le.Transport, de = fe && te == null ? void 0 : new T(te != null ? new te() : K()), be = te != null && typeof te != "string" ? new te() : de == null ? new U() : new $(), Oe = void 0, Ve = 0, Qe = F, Ct = "", _t = "", Ue = "", kt = "", Ze = j, fn = 0, Dn = 0, Qn = function(ht, Ot, Zt, Kt) {
        if (Qe === H)
          if (ht === 200 && Zt != null && Y.test(Zt)) {
            Qe = V, ue = Date.now(), ee = Se, M.readyState = V;
            var on = new R("open", {
              status: ht,
              statusText: Ot,
              headers: Kt
            });
            M.dispatchEvent(on), J(M, M.onopen, on);
          } else {
            var Gt = "";
            ht !== 200 ? (Ot && (Ot = Ot.replace(/\s+/g, " ")), Gt = "EventSource's response has a status " + ht + " " + Ot + " that is not 200. Aborting the connection.") : Gt = "EventSource's response has a Content-Type specifying an unsupported type: " + (Zt == null ? "-" : Zt.replace(/\s+/g, " ")) + ". Aborting the connection.", er();
            var on = new R("error", {
              status: ht,
              statusText: Ot,
              headers: Kt
            });
            M.dispatchEvent(on), J(M, M.onerror, on), console.error(Gt);
          }
      }, Wr = function(ht) {
        if (Qe === V) {
          for (var Ot = -1, Zt = 0; Zt < ht.length; Zt += 1) {
            var Kt = ht.charCodeAt(Zt);
            (Kt === 10 || Kt === 13) && (Ot = Zt);
          }
          var on = (Ot !== -1 ? kt : "") + ht.slice(0, Ot + 1);
          kt = (Ot === -1 ? kt : "") + ht.slice(Ot + 1), ht !== "" && (ue = Date.now(), z += ht.length);
          for (var Gt = 0; Gt < on.length; Gt += 1) {
            var Kt = on.charCodeAt(Gt);
            if (Ze === g && Kt === 10)
              Ze = j;
            else if (Ze === g && (Ze = j), Kt === 13 || Kt === 10) {
              if (Ze !== j) {
                Ze === W && (Dn = Gt + 1);
                var zn = on.slice(fn, Dn - 1), qn = on.slice(Dn + (Dn < Gt && on.charCodeAt(Dn) === 32 ? 1 : 0), Gt);
                zn === "data" ? (Ct += `
`, Ct += qn) : zn === "id" ? _t = qn : zn === "event" ? Ue = qn : zn === "retry" ? (Se = ie(qn, Se), ee = Se) : zn === "heartbeatTimeout" && (Re = ie(qn, Re), Ve !== 0 && (i(Ve), Ve = r(function() {
                  Vr();
                }, Re)));
              }
              if (Ze === j) {
                if (Ct !== "") {
                  ze = _t, Ue === "" && (Ue = "message");
                  var li = new L(Ue, {
                    data: Ct.slice(1),
                    lastEventId: _t
                  });
                  if (M.dispatchEvent(li), Ue === "open" ? J(M, M.onopen, li) : Ue === "message" ? J(M, M.onmessage, li) : Ue === "error" && J(M, M.onerror, li), Qe === I)
                    return;
                }
                Ct = "", Ue = "";
              }
              Ze = Kt === 13 ? g : j;
            } else
              Ze === j && (fn = Gt, Ze = W), Ze === W ? Kt === 58 && (Dn = Gt + 1, Ze = S) : Ze === S && (Ze = Z);
          }
        }
      }, gr = function(ht) {
        if (Qe === V || Qe === H) {
          Qe = F, Ve !== 0 && (i(Ve), Ve = 0), Ve = r(function() {
            Vr();
          }, ee), ee = ae(Math.min(Se * 16, ee * 2)), M.readyState = H;
          var Ot = new A("error", { error: ht });
          M.dispatchEvent(Ot), J(M, M.onerror, Ot), ht != null && console.error(ht);
        }
      }, er = function() {
        Qe = I, Oe != null && (Oe.abort(), Oe = void 0), Ve !== 0 && (i(Ve), Ve = 0), M.readyState = I;
      }, Vr = function() {
        if (Ve = 0, Qe !== F) {
          if (!ue && Oe != null)
            gr(new Error("No activity within " + Re + " milliseconds. " + (Qe === H ? "No response received." : z + " chars received.") + " Reconnecting.")), Oe != null && (Oe.abort(), Oe = void 0);
          else {
            var ht = Math.max((ue || Date.now()) + Re - Date.now(), 1);
            ue = !1, Ve = r(function() {
              Vr();
            }, ht);
          }
          return;
        }
        ue = !1, z = 0, Ve = r(function() {
          Vr();
        }, Re), Qe = H, Ct = "", Ue = "", _t = ze, kt = "", fn = 0, Dn = 0, Ze = j;
        var Ot = re;
        if (re.slice(0, 5) !== "data:" && re.slice(0, 5) !== "blob:" && ze !== "") {
          var Zt = re.indexOf("?");
          Ot = Zt === -1 ? re : re.slice(0, Zt + 1) + re.slice(Zt + 1).replace(/(?:^|&)([^=&]*)(?:=[^&]*)?/g, function(qn, li) {
            return li === Te ? "" : qn;
          }), Ot += (re.indexOf("?") === -1 ? "?" : "&") + Te + "=" + encodeURIComponent(ze);
        }
        var Kt = M.withCredentials, on = {};
        on.Accept = "text/event-stream";
        var Gt = M.headers;
        if (Gt != null)
          for (var zn in Gt)
            Object.prototype.hasOwnProperty.call(Gt, zn) && (on[zn] = Gt[zn]);
        try {
          Oe = be.open(de, Qn, Wr, gr, Ot, Kt, on);
        } catch (qn) {
          throw er(), qn;
        }
      };
      M.url = re, M.readyState = H, M.withCredentials = oe, M.headers = N, M._close = er, Vr();
    }
    Q.prototype = Object.create(k.prototype), Q.prototype.CONNECTING = H, Q.prototype.OPEN = V, Q.prototype.CLOSED = I, Q.prototype.close = function() {
      this._close();
    }, Q.CONNECTING = H, Q.OPEN = V, Q.CLOSED = I, Q.prototype.withCredentials = void 0;
    var $e = c;
    a != null && (c == null || !("withCredentials" in c.prototype)) && ($e = Q), function(M) {
      {
        var re = M(t);
        re !== void 0 && (e.exports = re);
      }
    }(function(M) {
      M.EventSourcePolyfill = Q, M.NativeEventSource = c, M.EventSource = $e;
    });
  })(typeof globalThis > "u" ? typeof window < "u" ? window : typeof self < "u" ? self : yt : globalThis);
})(Nm, Nm.exports);
var Bse = Nm.exports;
const Use = /* @__PURE__ */ Ye(Bse);
var nt;
(function(e) {
  e.assertEqual = (i) => i;
  function t(i) {
  }
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (i) => {
    const a = {};
    for (const o of i)
      a[o] = o;
    return a;
  }, e.getValidEnumValues = (i) => {
    const a = e.objectKeys(i).filter((s) => typeof i[i[s]] != "number"), o = {};
    for (const s of a)
      o[s] = i[s];
    return e.objectValues(o);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(a) {
    return i[a];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const a = [];
    for (const o in i)
      Object.prototype.hasOwnProperty.call(i, o) && a.push(o);
    return a;
  }, e.find = (i, a) => {
    for (const o of i)
      if (a(o))
        return o;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function r(i, a = " | ") {
    return i.map((o) => typeof o == "string" ? `'${o}'` : o).join(a);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (i, a) => typeof a == "bigint" ? a.toString() : a;
})(nt || (nt = {}));
var Mm;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(Mm || (Mm = {}));
const xe = nt.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Gr = (e) => {
  switch (typeof e) {
    case "undefined":
      return xe.undefined;
    case "string":
      return xe.string;
    case "number":
      return isNaN(e) ? xe.nan : xe.number;
    case "boolean":
      return xe.boolean;
    case "function":
      return xe.function;
    case "bigint":
      return xe.bigint;
    case "symbol":
      return xe.symbol;
    case "object":
      return Array.isArray(e) ? xe.array : e === null ? xe.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? xe.promise : typeof Map < "u" && e instanceof Map ? xe.map : typeof Set < "u" && e instanceof Set ? xe.set : typeof Date < "u" && e instanceof Date ? xe.date : xe.object;
    default:
      return xe.unknown;
  }
}, ce = nt.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), zse = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class Ln extends Error {
  get errors() {
    return this.issues;
  }
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  format(t) {
    const n = t || function(a) {
      return a.message;
    }, r = { _errors: [] }, i = (a) => {
      for (const o of a.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(i);
        else if (o.code === "invalid_return_type")
          i(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          i(o.argumentsError);
        else if (o.path.length === 0)
          r._errors.push(n(o));
        else {
          let s = r, c = 0;
          for (; c < o.path.length; ) {
            const l = o.path[c];
            c === o.path.length - 1 ? (s[l] = s[l] || { _errors: [] }, s[l]._errors.push(n(o))) : s[l] = s[l] || { _errors: [] }, s = s[l], c++;
          }
        }
    };
    return i(this), r;
  }
  static assert(t) {
    if (!(t instanceof Ln))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, nt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const i of this.issues)
      i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
Ln.create = (e) => new Ln(e);
const uo = (e, t) => {
  let n;
  switch (e.code) {
    case ce.invalid_type:
      e.received === xe.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case ce.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, nt.jsonStringifyReplacer)}`;
      break;
    case ce.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${nt.joinValues(e.keys, ", ")}`;
      break;
    case ce.invalid_union:
      n = "Invalid input";
      break;
    case ce.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${nt.joinValues(e.options)}`;
      break;
    case ce.invalid_enum_value:
      n = `Invalid enum value. Expected ${nt.joinValues(e.options)}, received '${e.received}'`;
      break;
    case ce.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case ce.invalid_return_type:
      n = "Invalid function return type";
      break;
    case ce.invalid_date:
      n = "Invalid date";
      break;
    case ce.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : nt.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case ce.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case ce.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case ce.custom:
      n = "Invalid input";
      break;
    case ce.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case ce.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case ce.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, nt.assertNever(e);
  }
  return { message: n };
};
let H$ = uo;
function qse(e) {
  H$ = e;
}
function Pu() {
  return H$;
}
const Du = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: i } = e, a = [...n, ...i.path || []], o = {
    ...i,
    path: a
  };
  if (i.message !== void 0)
    return {
      ...i,
      path: a,
      message: i.message
    };
  let s = "";
  const c = r.filter((l) => !!l).slice().reverse();
  for (const l of c)
    s = l(o, { data: t, defaultError: s }).message;
  return {
    ...i,
    path: a,
    message: s
  };
}, Wse = [];
function ve(e, t) {
  const n = Pu(), r = Du({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      // contextual error map is first priority
      e.schemaErrorMap,
      // then schema-bound map if available
      n,
      // then global override map
      n === uo ? void 0 : uo
      // then global default map
    ].filter((i) => !!i)
  });
  e.common.issues.push(r);
}
class vn {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const i of n) {
      if (i.status === "aborted")
        return je;
      i.status === "dirty" && t.dirty(), r.push(i.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const i of n) {
      const a = await i.key, o = await i.value;
      r.push({
        key: a,
        value: o
      });
    }
    return vn.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const i of n) {
      const { key: a, value: o } = i;
      if (a.status === "aborted" || o.status === "aborted")
        return je;
      a.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), a.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (r[a.value] = o.value);
    }
    return { status: t.value, value: r };
  }
}
const je = Object.freeze({
  status: "aborted"
}), Na = (e) => ({ status: "dirty", value: e }), En = (e) => ({ status: "valid", value: e }), Fm = (e) => e.status === "aborted", Lm = (e) => e.status === "dirty", aa = (e) => e.status === "valid", zs = (e) => typeof Promise < "u" && e instanceof Promise;
function ju(e, t, n, r) {
  if (typeof t == "function" ? e !== t || !r : !t.has(e)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return t.get(e);
}
function Z$(e, t, n, r, i) {
  if (typeof t == "function" ? e !== t || !i : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return t.set(e, n), n;
}
var Ce;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(Ce || (Ce = {}));
var Xo, Qo;
class Nr {
  constructor(t, n, r, i) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const SS = (e, t) => {
  if (aa(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new Ln(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function Be(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: i } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (o, s) => {
    var c, l;
    const { message: u } = e;
    return o.code === "invalid_enum_value" ? { message: u ?? s.defaultError } : typeof s.data > "u" ? { message: (c = u ?? r) !== null && c !== void 0 ? c : s.defaultError } : o.code !== "invalid_type" ? { message: s.defaultError } : { message: (l = u ?? n) !== null && l !== void 0 ? l : s.defaultError };
  }, description: i };
}
class We {
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Gr(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: Gr(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new vn(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Gr(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (zs(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const i = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Gr(t)
    }, a = this._parseSync({ data: t, path: i.path, parent: i });
    return SS(i, a);
  }
  "~validate"(t) {
    var n, r;
    const i = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Gr(t)
    };
    if (!this["~standard"].async)
      try {
        const a = this._parseSync({ data: t, path: [], parent: i });
        return aa(a) ? {
          value: a.value
        } : {
          issues: i.common.issues
        };
      } catch (a) {
        !((r = (n = a == null ? void 0 : a.message) === null || n === void 0 ? void 0 : n.toLowerCase()) === null || r === void 0) && r.includes("encountered") && (this["~standard"].async = !0), i.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data: t, path: [], parent: i }).then((a) => aa(a) ? {
      value: a.value
    } : {
      issues: i.common.issues
    });
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Gr(t)
    }, i = this._parse({ data: t, path: r.path, parent: r }), a = await (zs(i) ? i : Promise.resolve(i));
    return SS(r, a);
  }
  refine(t, n) {
    const r = (i) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(i) : n;
    return this._refinement((i, a) => {
      const o = t(i), s = () => a.addIssue({
        code: ce.custom,
        ...r(i)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((c) => c ? !0 : (s(), !1)) : o ? !0 : (s(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, i) => t(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1));
  }
  _refinement(t) {
    return new hr({
      schema: this,
      typeName: De.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (n) => this["~validate"](n)
    };
  }
  optional() {
    return Pr.create(this, this._def);
  }
  nullable() {
    return Ai.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ur.create(this);
  }
  promise() {
    return po.create(this, this._def);
  }
  or(t) {
    return Hs.create([this, t], this._def);
  }
  and(t) {
    return Zs.create(this, t, this._def);
  }
  transform(t) {
    return new hr({
      ...Be(this._def),
      schema: this,
      typeName: De.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Xs({
      ...Be(this._def),
      innerType: this,
      defaultValue: n,
      typeName: De.ZodDefault
    });
  }
  brand() {
    return new mg({
      typeName: De.ZodBranded,
      type: this,
      ...Be(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new Qs({
      ...Be(this._def),
      innerType: this,
      catchValue: n,
      typeName: De.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Nl.create(this, t);
  }
  readonly() {
    return el.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const Vse = /^c[^\s-]{8,}$/i, Hse = /^[0-9a-z]+$/, Zse = /^[0-9A-HJKMNP-TV-Z]{26}$/i, Kse = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Gse = /^[a-z0-9_-]{21}$/i, Yse = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, Jse = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Xse = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Qse = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let sh;
const ele = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, tle = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, nle = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, rle = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, ile = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, ale = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, K$ = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", ole = new RegExp(`^${K$}$`);
function G$(e) {
  let t = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return e.precision ? t = `${t}\\.\\d{${e.precision}}` : e.precision == null && (t = `${t}(\\.\\d+)?`), t;
}
function sle(e) {
  return new RegExp(`^${G$(e)}$`);
}
function Y$(e) {
  let t = `${K$}T${G$(e)}`;
  const n = [];
  return n.push(e.local ? "Z?" : "Z"), e.offset && n.push("([+-]\\d{2}:?\\d{2})"), t = `${t}(${n.join("|")})`, new RegExp(`^${t}$`);
}
function lle(e, t) {
  return !!((t === "v4" || !t) && ele.test(e) || (t === "v6" || !t) && nle.test(e));
}
function cle(e, t) {
  if (!Yse.test(e))
    return !1;
  try {
    const [n] = e.split("."), r = n.replace(/-/g, "+").replace(/_/g, "/").padEnd(n.length + (4 - n.length % 4) % 4, "="), i = JSON.parse(atob(r));
    return !(typeof i != "object" || i === null || !i.typ || !i.alg || t && i.alg !== t);
  } catch {
    return !1;
  }
}
function ule(e, t) {
  return !!((t === "v4" || !t) && tle.test(e) || (t === "v6" || !t) && rle.test(e));
}
class sr extends We {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== xe.string) {
      const a = this._getOrReturnCtx(t);
      return ve(a, {
        code: ce.invalid_type,
        expected: xe.string,
        received: a.parsedType
      }), je;
    }
    const r = new vn();
    let i;
    for (const a of this._def.checks)
      if (a.kind === "min")
        t.data.length < a.value && (i = this._getOrReturnCtx(t, i), ve(i, {
          code: ce.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "max")
        t.data.length > a.value && (i = this._getOrReturnCtx(t, i), ve(i, {
          code: ce.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "length") {
        const o = t.data.length > a.value, s = t.data.length < a.value;
        (o || s) && (i = this._getOrReturnCtx(t, i), o ? ve(i, {
          code: ce.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : s && ve(i, {
          code: ce.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), r.dirty());
      } else if (a.kind === "email")
        Xse.test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
          validation: "email",
          code: ce.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "emoji")
        sh || (sh = new RegExp(Qse, "u")), sh.test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
          validation: "emoji",
          code: ce.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "uuid")
        Kse.test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
          validation: "uuid",
          code: ce.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "nanoid")
        Gse.test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
          validation: "nanoid",
          code: ce.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid")
        Vse.test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
          validation: "cuid",
          code: ce.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid2")
        Hse.test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
          validation: "cuid2",
          code: ce.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "ulid")
        Zse.test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
          validation: "ulid",
          code: ce.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), ve(i, {
            validation: "url",
            code: ce.invalid_string,
            message: a.message
          }), r.dirty();
        }
      else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
        validation: "regex",
        code: ce.invalid_string,
        message: a.message
      }), r.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (i = this._getOrReturnCtx(t, i), ve(i, {
        code: ce.invalid_string,
        validation: { includes: a.value, position: a.position },
        message: a.message
      }), r.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (i = this._getOrReturnCtx(t, i), ve(i, {
        code: ce.invalid_string,
        validation: { startsWith: a.value },
        message: a.message
      }), r.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (i = this._getOrReturnCtx(t, i), ve(i, {
        code: ce.invalid_string,
        validation: { endsWith: a.value },
        message: a.message
      }), r.dirty()) : a.kind === "datetime" ? Y$(a).test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
        code: ce.invalid_string,
        validation: "datetime",
        message: a.message
      }), r.dirty()) : a.kind === "date" ? ole.test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
        code: ce.invalid_string,
        validation: "date",
        message: a.message
      }), r.dirty()) : a.kind === "time" ? sle(a).test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
        code: ce.invalid_string,
        validation: "time",
        message: a.message
      }), r.dirty()) : a.kind === "duration" ? Jse.test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
        validation: "duration",
        code: ce.invalid_string,
        message: a.message
      }), r.dirty()) : a.kind === "ip" ? lle(t.data, a.version) || (i = this._getOrReturnCtx(t, i), ve(i, {
        validation: "ip",
        code: ce.invalid_string,
        message: a.message
      }), r.dirty()) : a.kind === "jwt" ? cle(t.data, a.alg) || (i = this._getOrReturnCtx(t, i), ve(i, {
        validation: "jwt",
        code: ce.invalid_string,
        message: a.message
      }), r.dirty()) : a.kind === "cidr" ? ule(t.data, a.version) || (i = this._getOrReturnCtx(t, i), ve(i, {
        validation: "cidr",
        code: ce.invalid_string,
        message: a.message
      }), r.dirty()) : a.kind === "base64" ? ile.test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
        validation: "base64",
        code: ce.invalid_string,
        message: a.message
      }), r.dirty()) : a.kind === "base64url" ? ale.test(t.data) || (i = this._getOrReturnCtx(t, i), ve(i, {
        validation: "base64url",
        code: ce.invalid_string,
        message: a.message
      }), r.dirty()) : nt.assertNever(a);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((i) => t.test(i), {
      validation: n,
      code: ce.invalid_string,
      ...Ce.errToObj(r)
    });
  }
  _addCheck(t) {
    return new sr({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...Ce.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...Ce.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...Ce.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...Ce.errToObj(t) });
  }
  nanoid(t) {
    return this._addCheck({ kind: "nanoid", ...Ce.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...Ce.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...Ce.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...Ce.errToObj(t) });
  }
  base64(t) {
    return this._addCheck({ kind: "base64", ...Ce.errToObj(t) });
  }
  base64url(t) {
    return this._addCheck({
      kind: "base64url",
      ...Ce.errToObj(t)
    });
  }
  jwt(t) {
    return this._addCheck({ kind: "jwt", ...Ce.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...Ce.errToObj(t) });
  }
  cidr(t) {
    return this._addCheck({ kind: "cidr", ...Ce.errToObj(t) });
  }
  datetime(t) {
    var n, r;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
      local: (r = t == null ? void 0 : t.local) !== null && r !== void 0 ? r : !1,
      ...Ce.errToObj(t == null ? void 0 : t.message)
    });
  }
  date(t) {
    return this._addCheck({ kind: "date", message: t });
  }
  time(t) {
    return typeof t == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: t
    }) : this._addCheck({
      kind: "time",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      ...Ce.errToObj(t == null ? void 0 : t.message)
    });
  }
  duration(t) {
    return this._addCheck({ kind: "duration", ...Ce.errToObj(t) });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...Ce.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...Ce.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...Ce.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...Ce.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...Ce.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...Ce.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...Ce.errToObj(n)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(t) {
    return this.min(1, Ce.errToObj(t));
  }
  trim() {
    return new sr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new sr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new sr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((t) => t.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((t) => t.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((t) => t.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((t) => t.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((t) => t.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((t) => t.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((t) => t.kind === "base64url");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
sr.create = (e) => {
  var t;
  return new sr({
    checks: [],
    typeName: De.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Be(e)
  });
};
function fle(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, i = n > r ? n : r, a = parseInt(e.toFixed(i).replace(".", "")), o = parseInt(t.toFixed(i).replace(".", ""));
  return a % o / Math.pow(10, i);
}
class $i extends We {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== xe.number) {
      const a = this._getOrReturnCtx(t);
      return ve(a, {
        code: ce.invalid_type,
        expected: xe.number,
        received: a.parsedType
      }), je;
    }
    let r;
    const i = new vn();
    for (const a of this._def.checks)
      a.kind === "int" ? nt.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ce.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), i.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ce.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ce.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? fle(t.data, a.value) !== 0 && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ce.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ce.not_finite,
        message: a.message
      }), i.dirty()) : nt.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, Ce.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, Ce.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, Ce.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, Ce.toString(n));
  }
  setLimit(t, n, r, i) {
    return new $i({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: Ce.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new $i({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: Ce.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: Ce.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: Ce.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: Ce.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: Ce.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Ce.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: Ce.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: Ce.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: Ce.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && nt.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
}
$i.create = (e) => new $i({
  checks: [],
  typeName: De.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Be(e)
});
class Ri extends We {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce)
      try {
        t.data = BigInt(t.data);
      } catch {
        return this._getInvalidInput(t);
      }
    if (this._getType(t) !== xe.bigint)
      return this._getInvalidInput(t);
    let r;
    const i = new vn();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ce.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ce.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), ve(r, {
        code: ce.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : nt.assertNever(a);
    return { status: i.value, value: t.data };
  }
  _getInvalidInput(t) {
    const n = this._getOrReturnCtx(t);
    return ve(n, {
      code: ce.invalid_type,
      expected: xe.bigint,
      received: n.parsedType
    }), je;
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, Ce.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, Ce.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, Ce.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, Ce.toString(n));
  }
  setLimit(t, n, r, i) {
    return new Ri({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: Ce.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Ri({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: Ce.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: Ce.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: Ce.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: Ce.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: Ce.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
Ri.create = (e) => {
  var t;
  return new Ri({
    checks: [],
    typeName: De.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...Be(e)
  });
};
class qs extends We {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== xe.boolean) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: ce.invalid_type,
        expected: xe.boolean,
        received: r.parsedType
      }), je;
    }
    return En(t.data);
  }
}
qs.create = (e) => new qs({
  typeName: De.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...Be(e)
});
class oa extends We {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== xe.date) {
      const a = this._getOrReturnCtx(t);
      return ve(a, {
        code: ce.invalid_type,
        expected: xe.date,
        received: a.parsedType
      }), je;
    }
    if (isNaN(t.data.getTime())) {
      const a = this._getOrReturnCtx(t);
      return ve(a, {
        code: ce.invalid_date
      }), je;
    }
    const r = new vn();
    let i;
    for (const a of this._def.checks)
      a.kind === "min" ? t.data.getTime() < a.value && (i = this._getOrReturnCtx(t, i), ve(i, {
        code: ce.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), r.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (i = this._getOrReturnCtx(t, i), ve(i, {
        code: ce.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), r.dirty()) : nt.assertNever(a);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new oa({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: Ce.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: Ce.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
}
oa.create = (e) => new oa({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: De.ZodDate,
  ...Be(e)
});
class Nu extends We {
  _parse(t) {
    if (this._getType(t) !== xe.symbol) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: ce.invalid_type,
        expected: xe.symbol,
        received: r.parsedType
      }), je;
    }
    return En(t.data);
  }
}
Nu.create = (e) => new Nu({
  typeName: De.ZodSymbol,
  ...Be(e)
});
class Ws extends We {
  _parse(t) {
    if (this._getType(t) !== xe.undefined) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: ce.invalid_type,
        expected: xe.undefined,
        received: r.parsedType
      }), je;
    }
    return En(t.data);
  }
}
Ws.create = (e) => new Ws({
  typeName: De.ZodUndefined,
  ...Be(e)
});
class Vs extends We {
  _parse(t) {
    if (this._getType(t) !== xe.null) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: ce.invalid_type,
        expected: xe.null,
        received: r.parsedType
      }), je;
    }
    return En(t.data);
  }
}
Vs.create = (e) => new Vs({
  typeName: De.ZodNull,
  ...Be(e)
});
class fo extends We {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return En(t.data);
  }
}
fo.create = (e) => new fo({
  typeName: De.ZodAny,
  ...Be(e)
});
class Ji extends We {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return En(t.data);
  }
}
Ji.create = (e) => new Ji({
  typeName: De.ZodUnknown,
  ...Be(e)
});
class ni extends We {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return ve(n, {
      code: ce.invalid_type,
      expected: xe.never,
      received: n.parsedType
    }), je;
  }
}
ni.create = (e) => new ni({
  typeName: De.ZodNever,
  ...Be(e)
});
class Mu extends We {
  _parse(t) {
    if (this._getType(t) !== xe.undefined) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: ce.invalid_type,
        expected: xe.void,
        received: r.parsedType
      }), je;
    }
    return En(t.data);
  }
}
Mu.create = (e) => new Mu({
  typeName: De.ZodVoid,
  ...Be(e)
});
class ur extends We {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), i = this._def;
    if (n.parsedType !== xe.array)
      return ve(n, {
        code: ce.invalid_type,
        expected: xe.array,
        received: n.parsedType
      }), je;
    if (i.exactLength !== null) {
      const o = n.data.length > i.exactLength.value, s = n.data.length < i.exactLength.value;
      (o || s) && (ve(n, {
        code: o ? ce.too_big : ce.too_small,
        minimum: s ? i.exactLength.value : void 0,
        maximum: o ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), r.dirty());
    }
    if (i.minLength !== null && n.data.length < i.minLength.value && (ve(n, {
      code: ce.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), r.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (ve(n, {
      code: ce.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((o, s) => i.type._parseAsync(new Nr(n, o, n.path, s)))).then((o) => vn.mergeArray(r, o));
    const a = [...n.data].map((o, s) => i.type._parseSync(new Nr(n, o, n.path, s)));
    return vn.mergeArray(r, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new ur({
      ...this._def,
      minLength: { value: t, message: Ce.toString(n) }
    });
  }
  max(t, n) {
    return new ur({
      ...this._def,
      maxLength: { value: t, message: Ce.toString(n) }
    });
  }
  length(t, n) {
    return new ur({
      ...this._def,
      exactLength: { value: t, message: Ce.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
ur.create = (e, t) => new ur({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: De.ZodArray,
  ...Be(t)
});
function Ra(e) {
  if (e instanceof At) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = Pr.create(Ra(r));
    }
    return new At({
      ...e._def,
      shape: () => t
    });
  } else return e instanceof ur ? new ur({
    ...e._def,
    type: Ra(e.element)
  }) : e instanceof Pr ? Pr.create(Ra(e.unwrap())) : e instanceof Ai ? Ai.create(Ra(e.unwrap())) : e instanceof Mr ? Mr.create(e.items.map((t) => Ra(t))) : e;
}
class At extends We {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = nt.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== xe.object) {
      const l = this._getOrReturnCtx(t);
      return ve(l, {
        code: ce.invalid_type,
        expected: xe.object,
        received: l.parsedType
      }), je;
    }
    const { status: r, ctx: i } = this._processInputParams(t), { shape: a, keys: o } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof ni && this._def.unknownKeys === "strip"))
      for (const l in i.data)
        o.includes(l) || s.push(l);
    const c = [];
    for (const l of o) {
      const u = a[l], f = i.data[l];
      c.push({
        key: { status: "valid", value: l },
        value: u._parse(new Nr(i, f, i.path, l)),
        alwaysSet: l in i.data
      });
    }
    if (this._def.catchall instanceof ni) {
      const l = this._def.unknownKeys;
      if (l === "passthrough")
        for (const u of s)
          c.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: i.data[u] }
          });
      else if (l === "strict")
        s.length > 0 && (ve(i, {
          code: ce.unrecognized_keys,
          keys: s
        }), r.dirty());
      else if (l !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const l = this._def.catchall;
      for (const u of s) {
        const f = i.data[u];
        c.push({
          key: { status: "valid", value: u },
          value: l._parse(
            new Nr(i, f, i.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const l = [];
      for (const u of c) {
        const f = await u.key, d = await u.value;
        l.push({
          key: f,
          value: d,
          alwaysSet: u.alwaysSet
        });
      }
      return l;
    }).then((l) => vn.mergeObjectSync(r, l)) : vn.mergeObjectSync(r, c);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return Ce.errToObj, new At({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var i, a, o, s;
          const c = (o = (a = (i = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(i, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (s = Ce.errToObj(t).message) !== null && s !== void 0 ? s : c
          } : {
            message: c
          };
        }
      } : {}
    });
  }
  strip() {
    return new At({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new At({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new At({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new At({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: De.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new At({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return nt.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new At({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return nt.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new At({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Ra(this);
  }
  partial(t) {
    const n = {};
    return nt.objectKeys(this.shape).forEach((r) => {
      const i = this.shape[r];
      t && !t[r] ? n[r] = i : n[r] = i.optional();
    }), new At({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return nt.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let a = this.shape[r];
        for (; a instanceof Pr; )
          a = a._def.innerType;
        n[r] = a;
      }
    }), new At({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return J$(nt.objectKeys(this.shape));
  }
}
At.create = (e, t) => new At({
  shape: () => e,
  unknownKeys: "strip",
  catchall: ni.create(),
  typeName: De.ZodObject,
  ...Be(t)
});
At.strictCreate = (e, t) => new At({
  shape: () => e,
  unknownKeys: "strict",
  catchall: ni.create(),
  typeName: De.ZodObject,
  ...Be(t)
});
At.lazycreate = (e, t) => new At({
  shape: e,
  unknownKeys: "strip",
  catchall: ni.create(),
  typeName: De.ZodObject,
  ...Be(t)
});
class Hs extends We {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function i(a) {
      for (const s of a)
        if (s.result.status === "valid")
          return s.result;
      for (const s of a)
        if (s.result.status === "dirty")
          return n.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((s) => new Ln(s.ctx.common.issues));
      return ve(n, {
        code: ce.invalid_union,
        unionErrors: o
      }), je;
    }
    if (n.common.async)
      return Promise.all(r.map(async (a) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(i);
    {
      let a;
      const o = [];
      for (const c of r) {
        const l = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, u = c._parseSync({
          data: n.data,
          path: n.path,
          parent: l
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !a && (a = { result: u, ctx: l }), l.common.issues.length && o.push(l.common.issues);
      }
      if (a)
        return n.common.issues.push(...a.ctx.common.issues), a.result;
      const s = o.map((c) => new Ln(c));
      return ve(n, {
        code: ce.invalid_union,
        unionErrors: s
      }), je;
    }
  }
  get options() {
    return this._def.options;
  }
}
Hs.create = (e, t) => new Hs({
  options: e,
  typeName: De.ZodUnion,
  ...Be(t)
});
const Hr = (e) => e instanceof Gs ? Hr(e.schema) : e instanceof hr ? Hr(e.innerType()) : e instanceof Ys ? [e.value] : e instanceof Ii ? e.options : e instanceof Js ? nt.objectValues(e.enum) : e instanceof Xs ? Hr(e._def.innerType) : e instanceof Ws ? [void 0] : e instanceof Vs ? [null] : e instanceof Pr ? [void 0, ...Hr(e.unwrap())] : e instanceof Ai ? [null, ...Hr(e.unwrap())] : e instanceof mg || e instanceof el ? Hr(e.unwrap()) : e instanceof Qs ? Hr(e._def.innerType) : [];
class zf extends We {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== xe.object)
      return ve(n, {
        code: ce.invalid_type,
        expected: xe.object,
        received: n.parsedType
      }), je;
    const r = this.discriminator, i = n.data[r], a = this.optionsMap.get(i);
    return a ? n.common.async ? a._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : a._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (ve(n, {
      code: ce.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), je);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const i = /* @__PURE__ */ new Map();
    for (const a of n) {
      const o = Hr(a.shape[t]);
      if (!o.length)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const s of o) {
        if (i.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        i.set(s, a);
      }
    }
    return new zf({
      typeName: De.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: i,
      ...Be(r)
    });
  }
}
function Bm(e, t) {
  const n = Gr(e), r = Gr(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === xe.object && r === xe.object) {
    const i = nt.objectKeys(t), a = nt.objectKeys(e).filter((s) => i.indexOf(s) !== -1), o = { ...e, ...t };
    for (const s of a) {
      const c = Bm(e[s], t[s]);
      if (!c.valid)
        return { valid: !1 };
      o[s] = c.data;
    }
    return { valid: !0, data: o };
  } else if (n === xe.array && r === xe.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let a = 0; a < e.length; a++) {
      const o = e[a], s = t[a], c = Bm(o, s);
      if (!c.valid)
        return { valid: !1 };
      i.push(c.data);
    }
    return { valid: !0, data: i };
  } else return n === xe.date && r === xe.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class Zs extends We {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = (a, o) => {
      if (Fm(a) || Fm(o))
        return je;
      const s = Bm(a.value, o.value);
      return s.valid ? ((Lm(a) || Lm(o)) && n.dirty(), { status: n.value, value: s.data }) : (ve(r, {
        code: ce.invalid_intersection_types
      }), je);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([a, o]) => i(a, o)) : i(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
Zs.create = (e, t, n) => new Zs({
  left: e,
  right: t,
  typeName: De.ZodIntersection,
  ...Be(n)
});
class Mr extends We {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== xe.array)
      return ve(r, {
        code: ce.invalid_type,
        expected: xe.array,
        received: r.parsedType
      }), je;
    if (r.data.length < this._def.items.length)
      return ve(r, {
        code: ce.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), je;
    !this._def.rest && r.data.length > this._def.items.length && (ve(r, {
      code: ce.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const a = [...r.data].map((o, s) => {
      const c = this._def.items[s] || this._def.rest;
      return c ? c._parse(new Nr(r, o, r.path, s)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(a).then((o) => vn.mergeArray(n, o)) : vn.mergeArray(n, a);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Mr({
      ...this._def,
      rest: t
    });
  }
}
Mr.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Mr({
    items: e,
    typeName: De.ZodTuple,
    rest: null,
    ...Be(t)
  });
};
class Ks extends We {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== xe.object)
      return ve(r, {
        code: ce.invalid_type,
        expected: xe.object,
        received: r.parsedType
      }), je;
    const i = [], a = this._def.keyType, o = this._def.valueType;
    for (const s in r.data)
      i.push({
        key: a._parse(new Nr(r, s, r.path, s)),
        value: o._parse(new Nr(r, r.data[s], r.path, s)),
        alwaysSet: s in r.data
      });
    return r.common.async ? vn.mergeObjectAsync(n, i) : vn.mergeObjectSync(n, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof We ? new Ks({
      keyType: t,
      valueType: n,
      typeName: De.ZodRecord,
      ...Be(r)
    }) : new Ks({
      keyType: sr.create(),
      valueType: t,
      typeName: De.ZodRecord,
      ...Be(n)
    });
  }
}
class Fu extends We {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== xe.map)
      return ve(r, {
        code: ce.invalid_type,
        expected: xe.map,
        received: r.parsedType
      }), je;
    const i = this._def.keyType, a = this._def.valueType, o = [...r.data.entries()].map(([s, c], l) => ({
      key: i._parse(new Nr(r, s, r.path, [l, "key"])),
      value: a._parse(new Nr(r, c, r.path, [l, "value"]))
    }));
    if (r.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const c of o) {
          const l = await c.key, u = await c.value;
          if (l.status === "aborted" || u.status === "aborted")
            return je;
          (l.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(l.value, u.value);
        }
        return { status: n.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const c of o) {
        const l = c.key, u = c.value;
        if (l.status === "aborted" || u.status === "aborted")
          return je;
        (l.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(l.value, u.value);
      }
      return { status: n.value, value: s };
    }
  }
}
Fu.create = (e, t, n) => new Fu({
  valueType: t,
  keyType: e,
  typeName: De.ZodMap,
  ...Be(n)
});
class sa extends We {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== xe.set)
      return ve(r, {
        code: ce.invalid_type,
        expected: xe.set,
        received: r.parsedType
      }), je;
    const i = this._def;
    i.minSize !== null && r.data.size < i.minSize.value && (ve(r, {
      code: ce.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), n.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (ve(r, {
      code: ce.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), n.dirty());
    const a = this._def.valueType;
    function o(c) {
      const l = /* @__PURE__ */ new Set();
      for (const u of c) {
        if (u.status === "aborted")
          return je;
        u.status === "dirty" && n.dirty(), l.add(u.value);
      }
      return { status: n.value, value: l };
    }
    const s = [...r.data.values()].map((c, l) => a._parse(new Nr(r, c, r.path, l)));
    return r.common.async ? Promise.all(s).then((c) => o(c)) : o(s);
  }
  min(t, n) {
    return new sa({
      ...this._def,
      minSize: { value: t, message: Ce.toString(n) }
    });
  }
  max(t, n) {
    return new sa({
      ...this._def,
      maxSize: { value: t, message: Ce.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
sa.create = (e, t) => new sa({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: De.ZodSet,
  ...Be(t)
});
class Va extends We {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== xe.function)
      return ve(n, {
        code: ce.invalid_type,
        expected: xe.function,
        received: n.parsedType
      }), je;
    function r(s, c) {
      return Du({
        data: s,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Pu(),
          uo
        ].filter((l) => !!l),
        issueData: {
          code: ce.invalid_arguments,
          argumentsError: c
        }
      });
    }
    function i(s, c) {
      return Du({
        data: s,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Pu(),
          uo
        ].filter((l) => !!l),
        issueData: {
          code: ce.invalid_return_type,
          returnTypeError: c
        }
      });
    }
    const a = { errorMap: n.common.contextualErrorMap }, o = n.data;
    if (this._def.returns instanceof po) {
      const s = this;
      return En(async function(...c) {
        const l = new Ln([]), u = await s._def.args.parseAsync(c, a).catch((p) => {
          throw l.addIssue(r(c, p)), l;
        }), f = await Reflect.apply(o, this, u);
        return await s._def.returns._def.type.parseAsync(f, a).catch((p) => {
          throw l.addIssue(i(f, p)), l;
        });
      });
    } else {
      const s = this;
      return En(function(...c) {
        const l = s._def.args.safeParse(c, a);
        if (!l.success)
          throw new Ln([r(c, l.error)]);
        const u = Reflect.apply(o, this, l.data), f = s._def.returns.safeParse(u, a);
        if (!f.success)
          throw new Ln([i(u, f.error)]);
        return f.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Va({
      ...this._def,
      args: Mr.create(t).rest(Ji.create())
    });
  }
  returns(t) {
    return new Va({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new Va({
      args: t || Mr.create([]).rest(Ji.create()),
      returns: n || Ji.create(),
      typeName: De.ZodFunction,
      ...Be(r)
    });
  }
}
class Gs extends We {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
Gs.create = (e, t) => new Gs({
  getter: e,
  typeName: De.ZodLazy,
  ...Be(t)
});
class Ys extends We {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return ve(n, {
        received: n.data,
        code: ce.invalid_literal,
        expected: this._def.value
      }), je;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
Ys.create = (e, t) => new Ys({
  value: e,
  typeName: De.ZodLiteral,
  ...Be(t)
});
function J$(e, t) {
  return new Ii({
    values: e,
    typeName: De.ZodEnum,
    ...Be(t)
  });
}
class Ii extends We {
  constructor() {
    super(...arguments), Xo.set(this, void 0);
  }
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return ve(n, {
        expected: nt.joinValues(r),
        received: n.parsedType,
        code: ce.invalid_type
      }), je;
    }
    if (ju(this, Xo) || Z$(this, Xo, new Set(this._def.values)), !ju(this, Xo).has(t.data)) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return ve(n, {
        received: n.data,
        code: ce.invalid_enum_value,
        options: r
      }), je;
    }
    return En(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t, n = this._def) {
    return Ii.create(t, {
      ...this._def,
      ...n
    });
  }
  exclude(t, n = this._def) {
    return Ii.create(this.options.filter((r) => !t.includes(r)), {
      ...this._def,
      ...n
    });
  }
}
Xo = /* @__PURE__ */ new WeakMap();
Ii.create = J$;
class Js extends We {
  constructor() {
    super(...arguments), Qo.set(this, void 0);
  }
  _parse(t) {
    const n = nt.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== xe.string && r.parsedType !== xe.number) {
      const i = nt.objectValues(n);
      return ve(r, {
        expected: nt.joinValues(i),
        received: r.parsedType,
        code: ce.invalid_type
      }), je;
    }
    if (ju(this, Qo) || Z$(this, Qo, new Set(nt.getValidEnumValues(this._def.values))), !ju(this, Qo).has(t.data)) {
      const i = nt.objectValues(n);
      return ve(r, {
        received: r.data,
        code: ce.invalid_enum_value,
        options: i
      }), je;
    }
    return En(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
Qo = /* @__PURE__ */ new WeakMap();
Js.create = (e, t) => new Js({
  values: e,
  typeName: De.ZodNativeEnum,
  ...Be(t)
});
class po extends We {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== xe.promise && n.common.async === !1)
      return ve(n, {
        code: ce.invalid_type,
        expected: xe.promise,
        received: n.parsedType
      }), je;
    const r = n.parsedType === xe.promise ? n.data : Promise.resolve(n.data);
    return En(r.then((i) => this._def.type.parseAsync(i, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
po.create = (e, t) => new po({
  type: e,
  typeName: De.ZodPromise,
  ...Be(t)
});
class hr extends We {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === De.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = this._def.effect || null, a = {
      addIssue: (o) => {
        ve(r, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), i.type === "preprocess") {
      const o = i.transform(r.data, a);
      if (r.common.async)
        return Promise.resolve(o).then(async (s) => {
          if (n.value === "aborted")
            return je;
          const c = await this._def.schema._parseAsync({
            data: s,
            path: r.path,
            parent: r
          });
          return c.status === "aborted" ? je : c.status === "dirty" || n.value === "dirty" ? Na(c.value) : c;
        });
      {
        if (n.value === "aborted")
          return je;
        const s = this._def.schema._parseSync({
          data: o,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? je : s.status === "dirty" || n.value === "dirty" ? Na(s.value) : s;
      }
    }
    if (i.type === "refinement") {
      const o = (s) => {
        const c = i.refinement(s, a);
        if (r.common.async)
          return Promise.resolve(c);
        if (c instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      };
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? je : (s.status === "dirty" && n.dirty(), o(s.value), { status: n.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => s.status === "aborted" ? je : (s.status === "dirty" && n.dirty(), o(s.value).then(() => ({ status: n.value, value: s.value }))));
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!aa(o))
          return o;
        const s = i.transform(o.value, a);
        if (s instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => aa(o) ? Promise.resolve(i.transform(o.value, a)).then((s) => ({ status: n.value, value: s })) : o);
    nt.assertNever(i);
  }
}
hr.create = (e, t, n) => new hr({
  schema: e,
  typeName: De.ZodEffects,
  effect: t,
  ...Be(n)
});
hr.createWithPreprocess = (e, t, n) => new hr({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: De.ZodEffects,
  ...Be(n)
});
class Pr extends We {
  _parse(t) {
    return this._getType(t) === xe.undefined ? En(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Pr.create = (e, t) => new Pr({
  innerType: e,
  typeName: De.ZodOptional,
  ...Be(t)
});
class Ai extends We {
  _parse(t) {
    return this._getType(t) === xe.null ? En(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
Ai.create = (e, t) => new Ai({
  innerType: e,
  typeName: De.ZodNullable,
  ...Be(t)
});
class Xs extends We {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === xe.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
Xs.create = (e, t) => new Xs({
  innerType: e,
  typeName: De.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...Be(t)
});
class Qs extends We {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return zs(i) ? i.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Ln(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Ln(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
Qs.create = (e, t) => new Qs({
  innerType: e,
  typeName: De.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...Be(t)
});
class Lu extends We {
  _parse(t) {
    if (this._getType(t) !== xe.nan) {
      const r = this._getOrReturnCtx(t);
      return ve(r, {
        code: ce.invalid_type,
        expected: xe.nan,
        received: r.parsedType
      }), je;
    }
    return { status: "valid", value: t.data };
  }
}
Lu.create = (e) => new Lu({
  typeName: De.ZodNaN,
  ...Be(e)
});
const dle = Symbol("zod_brand");
class mg extends We {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Nl extends We {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? je : a.status === "dirty" ? (n.dirty(), Na(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return i.status === "aborted" ? je : i.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new Nl({
      in: t,
      out: n,
      typeName: De.ZodPipeline
    });
  }
}
class el extends We {
  _parse(t) {
    const n = this._def.innerType._parse(t), r = (i) => (aa(i) && (i.value = Object.freeze(i.value)), i);
    return zs(n) ? n.then((i) => r(i)) : r(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
el.create = (e, t) => new el({
  innerType: e,
  typeName: De.ZodReadonly,
  ...Be(t)
});
function ES(e, t) {
  const n = typeof e == "function" ? e(t) : typeof e == "string" ? { message: e } : e;
  return typeof n == "string" ? { message: n } : n;
}
function X$(e, t = {}, n) {
  return e ? fo.create().superRefine((r, i) => {
    var a, o;
    const s = e(r);
    if (s instanceof Promise)
      return s.then((c) => {
        var l, u;
        if (!c) {
          const f = ES(t, r), d = (u = (l = f.fatal) !== null && l !== void 0 ? l : n) !== null && u !== void 0 ? u : !0;
          i.addIssue({ code: "custom", ...f, fatal: d });
        }
      });
    if (!s) {
      const c = ES(t, r), l = (o = (a = c.fatal) !== null && a !== void 0 ? a : n) !== null && o !== void 0 ? o : !0;
      i.addIssue({ code: "custom", ...c, fatal: l });
    }
  }) : fo.create();
}
const ple = {
  object: At.lazycreate
};
var De;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(De || (De = {}));
const hle = (e, t = {
  message: `Input not instance of ${e.name}`
}) => X$((n) => n instanceof e, t), Q$ = sr.create, eR = $i.create, mle = Lu.create, vle = Ri.create, tR = qs.create, yle = oa.create, gle = Nu.create, ble = Ws.create, wle = Vs.create, xle = fo.create, Sle = Ji.create, Ele = ni.create, _le = Mu.create, kle = ur.create, Tle = At.create, Cle = At.strictCreate, Ole = Hs.create, $le = zf.create, Rle = Zs.create, Ile = Mr.create, Ale = Ks.create, Ple = Fu.create, Dle = sa.create, jle = Va.create, Nle = Gs.create, Mle = Ys.create, Fle = Ii.create, Lle = Js.create, Ble = po.create, _S = hr.create, Ule = Pr.create, zle = Ai.create, qle = hr.createWithPreprocess, Wle = Nl.create, Vle = () => Q$().optional(), Hle = () => eR().optional(), Zle = () => tR().optional(), Kle = {
  string: (e) => sr.create({ ...e, coerce: !0 }),
  number: (e) => $i.create({ ...e, coerce: !0 }),
  boolean: (e) => qs.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Ri.create({ ...e, coerce: !0 }),
  date: (e) => oa.create({ ...e, coerce: !0 })
}, Gle = je;
var C = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: uo,
  setErrorMap: qse,
  getErrorMap: Pu,
  makeIssue: Du,
  EMPTY_PATH: Wse,
  addIssueToContext: ve,
  ParseStatus: vn,
  INVALID: je,
  DIRTY: Na,
  OK: En,
  isAborted: Fm,
  isDirty: Lm,
  isValid: aa,
  isAsync: zs,
  get util() {
    return nt;
  },
  get objectUtil() {
    return Mm;
  },
  ZodParsedType: xe,
  getParsedType: Gr,
  ZodType: We,
  datetimeRegex: Y$,
  ZodString: sr,
  ZodNumber: $i,
  ZodBigInt: Ri,
  ZodBoolean: qs,
  ZodDate: oa,
  ZodSymbol: Nu,
  ZodUndefined: Ws,
  ZodNull: Vs,
  ZodAny: fo,
  ZodUnknown: Ji,
  ZodNever: ni,
  ZodVoid: Mu,
  ZodArray: ur,
  ZodObject: At,
  ZodUnion: Hs,
  ZodDiscriminatedUnion: zf,
  ZodIntersection: Zs,
  ZodTuple: Mr,
  ZodRecord: Ks,
  ZodMap: Fu,
  ZodSet: sa,
  ZodFunction: Va,
  ZodLazy: Gs,
  ZodLiteral: Ys,
  ZodEnum: Ii,
  ZodNativeEnum: Js,
  ZodPromise: po,
  ZodEffects: hr,
  ZodTransformer: hr,
  ZodOptional: Pr,
  ZodNullable: Ai,
  ZodDefault: Xs,
  ZodCatch: Qs,
  ZodNaN: Lu,
  BRAND: dle,
  ZodBranded: mg,
  ZodPipeline: Nl,
  ZodReadonly: el,
  custom: X$,
  Schema: We,
  ZodSchema: We,
  late: ple,
  get ZodFirstPartyTypeKind() {
    return De;
  },
  coerce: Kle,
  any: xle,
  array: kle,
  bigint: vle,
  boolean: tR,
  date: yle,
  discriminatedUnion: $le,
  effect: _S,
  enum: Fle,
  function: jle,
  instanceof: hle,
  intersection: Rle,
  lazy: Nle,
  literal: Mle,
  map: Ple,
  nan: mle,
  nativeEnum: Lle,
  never: Ele,
  null: wle,
  nullable: zle,
  number: eR,
  object: Tle,
  oboolean: Zle,
  onumber: Hle,
  optional: Ule,
  ostring: Vle,
  pipeline: Wle,
  preprocess: qle,
  promise: Ble,
  record: Ale,
  set: Dle,
  strictObject: Cle,
  string: Q$,
  symbol: gle,
  transformer: _S,
  tuple: Ile,
  undefined: ble,
  union: Ole,
  unknown: Sle,
  void: _le,
  NEVER: Gle,
  ZodIssueCode: ce,
  quotelessJson: zse,
  ZodError: Ln
}), Yle = Object.defineProperty, Jle = (e, t, n) => t in e ? Yle(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, Xle = (e, t, n) => (Jle(e, t + "", n), n), Qle = {
  getRandomValues: (e) => new Uint8Array(e.map(() => Math.floor(Math.random() * 256)))
}, Um = typeof window < "u" && typeof window.document < "u" ? window.crypto : x$;
Um.getRandomValues || (Um = Qle);
var Et = class extends Error {
  constructor(t, n, r, i, a, o, s) {
    super(i);
    Ee(this, "isApiError", !0);
    this.code = t, this.description = n, this.type = r, this.message = i, this.error = a, this.id = o, this.metadata = s, this.id || (this.id = Et.generateId());
  }
  format() {
    return `[${this.type}] ${this.message} (Error ID: ${this.id})`;
  }
  toJSON() {
    return {
      id: this.id,
      code: this.code,
      type: this.type,
      message: this.message,
      metadata: this.metadata
    };
  }
  static generateId() {
    const t = this.getPrefix(), n = (/* @__PURE__ */ new Date()).toISOString().replace(/[\-:TZ]/g, "").split(".")[0], r = 4, i = Array.from(Um.getRandomValues(new Uint8Array(r))).map((a) => a.toString(16).padStart(2, "0")).join("").toUpperCase();
    return `${t}_${n}x${i}`;
  }
  static getPrefix() {
    return typeof window < "u" && typeof window.document < "u" ? "err_bwsr" : "err";
  }
}, ece = (e) => typeof e == "object" && !Array.isArray(e) && e !== null, zm = (e) => e instanceof Et || ece(e) && e.isApiError === !0, tl = class extends Et {
  constructor(e, t, n, r) {
    super(500, "An unknown error occurred", "Unknown", e, t, n, r);
  }
}, tce = class extends Et {
  constructor(e, t, n, r) {
    super(500, "An internal error occurred", "Internal", e, t, n, r);
  }
}, nce = class extends Et {
  constructor(e, t, n, r) {
    super(401, "The request requires to be authenticated.", "Unauthorized", e, t, n, r);
  }
}, rce = class extends Et {
  constructor(e, t, n, r) {
    super(403, "The requested action can't be peform by this resource.", "Forbidden", e, t, n, r);
  }
}, ice = class extends Et {
  constructor(e, t, n, r) {
    super(413, "The request payload is too large.", "PayloadTooLarge", e, t, n, r);
  }
}, ace = class extends Et {
  constructor(e, t, n, r) {
    super(400, "The request payload is invalid.", "InvalidPayload", e, t, n, r);
  }
}, oce = class extends Et {
  constructor(e, t, n, r) {
    super(415, "The request is invalid because the content-type is not supported.", "UnsupportedMediaType", e, t, n, r);
  }
}, sce = class extends Et {
  constructor(e, t, n, r) {
    super(405, "The requested method does not exist.", "MethodNotFound", e, t, n, r);
  }
}, lce = class extends Et {
  constructor(e, t, n, r) {
    super(404, "The requested resource does not exist.", "ResourceNotFound", e, t, n, r);
  }
}, cce = class extends Et {
  constructor(e, t, n, r) {
    super(400, "The provided JSON schema is invalid.", "InvalidJsonSchema", e, t, n, r);
  }
}, uce = class extends Et {
  constructor(e, t, n, r) {
    super(400, "The provided data doesn't respect the provided JSON schema.", "InvalidDataFormat", e, t, n, r);
  }
}, fce = class extends Et {
  constructor(e, t, n, r) {
    super(400, "The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.", "InvalidIdentifier", e, t, n, r);
  }
}, dce = class extends Et {
  constructor(e, t, n, r) {
    super(409, "The resource is related with a different resource that the one referenced in the request. This is usually caused when providing two resource identifiers that aren't linked together.", "RelationConflict", e, t, n, r);
  }
}, pce = class extends Et {
  constructor(e, t, n, r) {
    super(409, "The resource cannot be deleted because it's referenced by another resource", "ReferenceConstraint", e, t, n, r);
  }
}, hce = class extends Et {
  constructor(e, t, n, r) {
    super(409, "The resource is current locked and cannot be operated on until the lock is released.", "ResourceLockedConflict", e, t, n, r);
  }
}, mce = class extends Et {
  constructor(e, t, n, r) {
    super(400, "The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.", "ReferenceNotFound", e, t, n, r);
  }
}, vce = class extends Et {
  constructor(e, t, n, r) {
    super(400, "The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.", "InvalidQuery", e, t, n, r);
  }
}, yce = class extends Et {
  constructor(e, t, n, r) {
    super(400, "An error happened during the execution of a runtime (bot or integration).", "Runtime", e, t, n, r);
  }
}, gce = class extends Et {
  constructor(e, t, n, r) {
    super(409, "The record attempted to be created already exists.", "AlreadyExists", e, t, n, r);
  }
}, bce = class extends Et {
  constructor(e, t, n, r) {
    super(429, "The request has been rate limited.", "RateLimited", e, t, n, r);
  }
}, wce = class extends Et {
  constructor(e, t, n, r) {
    super(402, "A payment is required to perform this request.", "PaymentRequired", e, t, n, r);
  }
}, xce = class extends Et {
  constructor(e, t, n, r) {
    super(403, "The request exceeds the allowed quota. Quotas are a soft limit that can be increased.", "QuotaExceeded", e, t, n, r);
  }
}, Sce = class extends Et {
  constructor(e, t, n, r) {
    super(413, "The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.", "LimitExceeded", e, t, n, r);
  }
}, Ece = class extends Et {
  constructor(e, t, n, r) {
    super(400, "Request payload contains breaking changes which is not allowed for this resource without a version increment.", "BreakingChanges", e, t, n, r);
  }
}, _ce = {
  Unknown: tl,
  Internal: tce,
  Unauthorized: nce,
  Forbidden: rce,
  PayloadTooLarge: ice,
  InvalidPayload: ace,
  UnsupportedMediaType: oce,
  MethodNotFound: sce,
  ResourceNotFound: lce,
  InvalidJsonSchema: cce,
  InvalidDataFormat: uce,
  InvalidIdentifier: fce,
  RelationConflict: dce,
  ReferenceConstraint: pce,
  ResourceLockedConflict: hce,
  ReferenceNotFound: mce,
  InvalidQuery: vce,
  Runtime: yce,
  AlreadyExists: gce,
  RateLimited: bce,
  PaymentRequired: wce,
  QuotaExceeded: xce,
  LimitExceeded: Sce,
  BreakingChanges: Ece
}, kS = (e) => zm(e) ? e : e instanceof Error ? new tl(e.message, e) : typeof e == "string" ? new tl(e) : kce(e);
function kce(e) {
  if (typeof e == "object" && "code" in e && "type" in e && "id" in e && "message" in e && typeof e.type == "string" && typeof e.message == "string") {
    const t = _ce[e.type];
    return t ? new t(e.message, void 0, e.id || "UNKNOWN", e.metadata) : new tl(`An unclassified API error occurred: ${e.message} (Type: ${e.type}, Code: ${e.code})`);
  }
  return new tl("An invalid error occurred: " + JSON.stringify(e));
}
var Tce = (e) => e[1] !== void 0, jt = (e) => {
  const { method: t, path: n, query: r, headers: i, body: a } = e, o = Object.entries(i).filter(Tce), s = Object.fromEntries(o), c = Lse.stringify(r, { encode: !0, arrayFormat: "repeat", allowDots: !0 }), l = c ? [n, c].join("?") : n, u = ["put", "post", "delete", "patch"].includes(t.toLowerCase()) ? a : void 0;
  return {
    method: t,
    url: l,
    headers: s,
    data: u
  };
}, Cce = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), Oce = (e) => ({
  path: "/conversations",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { _: e._ }
}), $ce = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), Rce = (e) => ({
  path: "/conversations",
  headers: { "x-user-key": e["x-user-key"] },
  query: { nextToken: e.nextToken },
  params: {},
  body: {}
}), Ice = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/listen`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), Ace = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/messages`,
  headers: { "x-user-key": e["x-user-key"] },
  query: { nextToken: e.nextToken },
  params: { id: e.id },
  body: {}
}), Pce = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: { userId: e.userId }
}), Dce = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants/${encodeURIComponent(e.userId)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id, userId: e.userId },
  body: {}
}), jce = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants/${encodeURIComponent(e.userId)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id, userId: e.userId },
  body: {}
}), Nce = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants`,
  headers: { "x-user-key": e["x-user-key"] },
  query: { nextToken: e.nextToken },
  params: { id: e.id },
  body: {}
}), Mce = (e) => ({
  path: `/messages/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), Fce = (e) => ({
  path: "/messages",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { payload: e.payload, conversationId: e.conversationId, metadata: e.metadata, replyTo: e.replyTo }
}), Lce = (e) => ({
  path: `/messages/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: { payload: e.payload, metadata: e.metadata }
}), Bce = (e) => ({
  path: `/messages/${encodeURIComponent(e.id)}/select`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), Uce = (e) => ({
  path: `/messages/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), zce = (e) => ({
  path: "/users/me",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: {}
}), qce = (e) => ({
  path: "/users",
  headers: {},
  query: {},
  params: {},
  body: { name: e.name, pictureUrl: e.pictureUrl, userData: e.userData }
}), Wce = (e) => ({
  path: "/users/me",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { name: e.name, pictureUrl: e.pictureUrl, userData: e.userData }
}), Vce = (e) => ({
  path: "/users/me",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: {}
}), Hce = (e) => ({
  path: `/events/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), Zce = (e) => ({
  path: "/events",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { payload: e.payload, conversationId: e.conversationId, bindConversation: e.bindConversation, bindUser: e.bindUser }
}), Kce = (e) => ({
  path: "/files",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { key: e.key, size: e.size, accessPolicies: e.accessPolicies, index: e.index, contentType: e.contentType, tags: e.tags, expiresAt: e.expiresAt }
}), Gce = class {
  constructor(e, t = {}) {
    Ee(this, "getConversation", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Cce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "createConversation", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Oce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "post",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "deleteConversation", async (e) => {
      const { path: t, headers: n, query: r, body: i } = $ce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "delete",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "listConversations", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Rce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "listenConversation", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Ice(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "listConversationMessages", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Ace(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "addParticipant", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Pce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "post",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "removeParticipant", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Dce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "delete",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "getParticipant", async (e) => {
      const { path: t, headers: n, query: r, body: i } = jce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "listParticipants", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Nce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "getMessage", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Mce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "createMessage", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Fce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "post",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "updateMessage", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Lce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "put",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "selectMessage", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Bce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "put",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "deleteMessage", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Uce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "delete",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "getUser", async (e) => {
      const { path: t, headers: n, query: r, body: i } = zce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "createUser", async (e) => {
      const { path: t, headers: n, query: r, body: i } = qce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "post",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "updateUser", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Wce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "put",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "deleteUser", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Vce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "delete",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "getEvent", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Hce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "get",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "createEvent", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Zce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "post",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    Ee(this, "createFile", async (e) => {
      const { path: t, headers: n, query: r, body: i } = Kce(e), o = (this.props.toAxiosRequest ?? jt)({
        method: "post",
        path: t,
        headers: { ...n },
        query: { ...r },
        body: i
      });
      return this.axiosInstance.request(o).then((s) => s.data).catch((s) => {
        throw Nt(s);
      });
    });
    this.axiosInstance = e, this.props = t;
  }
};
function Nt(e) {
  var t;
  return Ht.isAxiosError(e) && ((t = e.response) != null && t.data) ? kS(e.response.data) : kS(e);
}
var nR = class {
  constructor() {
    Ee(this, "listeners", {});
  }
  emit(e, t) {
    const n = this.listeners[e];
    if (n)
      for (const r of [...n])
        r(t);
  }
  onceOrMore(e, t) {
    const n = (r) => {
      t(r) === "stop-listening" && this.off(e, n);
    };
    this.on(e, n);
  }
  once(e, t) {
    const n = (r) => {
      this.off(e, n), t(r);
    };
    this.on(e, n);
  }
  on(e, t) {
    this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t);
  }
  off(e, t) {
    const n = this.listeners[e];
    if (!n)
      return;
    const r = n.indexOf(t);
    r !== -1 && n.splice(r, 1);
  }
  cleanup() {
    this.listeners = {};
  }
}, Yce = (e, t) => {
  const n = new Use.EventSourcePolyfill(e, {
    headers: t.headers,
    heartbeatTimeout: t.timeout
  }), r = new nR();
  return n.onopen = (i) => r.emit("open", i), n.onmessage = (i) => r.emit("message", i), n.onerror = (i) => r.emit("error", i), {
    emitter: r,
    source: n
  };
}, Jce = async (e, t = {}) => {
  const { emitter: n, source: r } = Yce(e, t);
  return await new Promise((i, a) => {
    n.on("open", () => {
      i();
    }), n.on("error", (o) => {
      a(o);
    });
  }).finally(() => n.cleanup()), {
    on: n.on.bind(n),
    close: () => {
      n.cleanup(), r.close();
    }
  };
}, Xce = C.object({
  type: C.literal("message_created"),
  data: C.object({
    id: C.string().describe("Id of the [Message](#schema_message)"),
    createdAt: C.string().datetime().describe(
      "Creation date of the [Message](#schema_message) in ISO 8601 format"
    ),
    payload: C.union([
      C.object({ audioUrl: C.string().min(1), type: C.literal("audio") }),
      C.object({
        title: C.string().min(1),
        subtitle: C.string().min(1).optional(),
        imageUrl: C.string().min(1).optional(),
        actions: C.array(
          C.object({
            action: C.enum(["postback", "url", "say"]),
            label: C.string().min(1),
            value: C.string().min(1)
          })
        ),
        type: C.literal("card")
      }),
      C.object({
        items: C.array(
          C.object({
            title: C.string().min(1),
            subtitle: C.string().min(1).optional(),
            imageUrl: C.string().min(1).optional(),
            actions: C.array(
              C.object({
                action: C.enum(["postback", "url", "say"]),
                label: C.string().min(1),
                value: C.string().min(1)
              })
            )
          })
        ),
        type: C.literal("carousel")
      }),
      C.object({
        text: C.string().min(1),
        options: C.array(
          C.object({ label: C.string().min(1), value: C.string().min(1) })
        ),
        disableFreeText: C.boolean().optional(),
        type: C.literal("choice")
      }),
      C.object({
        text: C.string().min(1),
        options: C.array(
          C.object({ label: C.string().min(1), value: C.string().min(1) })
        ),
        disableFreeText: C.boolean().optional(),
        type: C.literal("dropdown")
      }),
      C.object({
        fileUrl: C.string().min(1),
        title: C.string().min(1).optional(),
        type: C.literal("file")
      }),
      C.object({ imageUrl: C.string().min(1), type: C.literal("image") }),
      C.object({
        latitude: C.number(),
        longitude: C.number(),
        address: C.string().optional(),
        title: C.string().optional(),
        type: C.literal("location")
      }),
      C.object({
        text: C.string().min(1),
        value: C.string().optional(),
        type: C.literal("text")
      }),
      C.object({ videoUrl: C.string().min(1), type: C.literal("video") }),
      C.object({
        items: C.array(
          C.union([
            C.object({
              type: C.literal("text"),
              payload: C.object({
                text: C.string().min(1),
                value: C.string().optional()
              })
            }),
            C.object({
              type: C.literal("markdown"),
              payload: C.object({ markdown: C.string().min(1) })
            }),
            C.object({
              type: C.literal("image"),
              payload: C.object({ imageUrl: C.string().min(1) })
            }),
            C.object({
              type: C.literal("audio"),
              payload: C.object({ audioUrl: C.string().min(1) })
            }),
            C.object({
              type: C.literal("video"),
              payload: C.object({ videoUrl: C.string().min(1) })
            }),
            C.object({
              type: C.literal("file"),
              payload: C.object({
                fileUrl: C.string().min(1),
                title: C.string().min(1).optional()
              })
            }),
            C.object({
              type: C.literal("location"),
              payload: C.object({
                latitude: C.number(),
                longitude: C.number(),
                address: C.string().optional(),
                title: C.string().optional()
              })
            })
          ])
        ),
        type: C.literal("bloc")
      }),
      C.object({
        markdown: C.string().min(1),
        type: C.literal("markdown")
      }),
      C.object({
        url: C.string(),
        name: C.string(),
        data: C.union([C.any(), C.null()]).optional(),
        type: C.literal("custom")
      }),
      C.object({ reaction: C.string(), type: C.literal("reaction") })
    ]).describe("Payload is the content of the message."),
    userId: C.string().describe("ID of the [User](#schema_user)"),
    conversationId: C.string().describe("ID of the [Conversation](#schema_conversation)"),
    metadata: C.record(C.union([C.any(), C.null()])).describe("Metadata of the message").optional(),
    replyTo: C.string().describe("ID of the message this message is replying to").optional(),
    selectedBy: C.string().describe(
      "ID of the user who selected this message. Undefined if not selected."
    ).optional()
  }).describe(
    "The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user)."
  )
}), Qce = C.object({
  type: C.literal("message_updated"),
  data: C.object({
    id: C.string().describe("Id of the [Message](#schema_message)"),
    createdAt: C.string().datetime().describe(
      "Creation date of the [Message](#schema_message) in ISO 8601 format"
    ),
    payload: C.union([
      C.object({ audioUrl: C.string().min(1), type: C.literal("audio") }),
      C.object({
        title: C.string().min(1),
        subtitle: C.string().min(1).optional(),
        imageUrl: C.string().min(1).optional(),
        actions: C.array(
          C.object({
            action: C.enum(["postback", "url", "say"]),
            label: C.string().min(1),
            value: C.string().min(1)
          })
        ),
        type: C.literal("card")
      }),
      C.object({
        items: C.array(
          C.object({
            title: C.string().min(1),
            subtitle: C.string().min(1).optional(),
            imageUrl: C.string().min(1).optional(),
            actions: C.array(
              C.object({
                action: C.enum(["postback", "url", "say"]),
                label: C.string().min(1),
                value: C.string().min(1)
              })
            )
          })
        ),
        type: C.literal("carousel")
      }),
      C.object({
        text: C.string().min(1),
        options: C.array(
          C.object({ label: C.string().min(1), value: C.string().min(1) })
        ),
        disableFreeText: C.boolean().optional(),
        type: C.literal("choice")
      }),
      C.object({
        text: C.string().min(1),
        options: C.array(
          C.object({ label: C.string().min(1), value: C.string().min(1) })
        ),
        disableFreeText: C.boolean().optional(),
        type: C.literal("dropdown")
      }),
      C.object({
        fileUrl: C.string().min(1),
        title: C.string().min(1).optional(),
        type: C.literal("file")
      }),
      C.object({ imageUrl: C.string().min(1), type: C.literal("image") }),
      C.object({
        latitude: C.number(),
        longitude: C.number(),
        address: C.string().optional(),
        title: C.string().optional(),
        type: C.literal("location")
      }),
      C.object({
        text: C.string().min(1),
        value: C.string().optional(),
        type: C.literal("text")
      }),
      C.object({ videoUrl: C.string().min(1), type: C.literal("video") }),
      C.object({
        items: C.array(
          C.union([
            C.object({
              type: C.literal("text"),
              payload: C.object({
                text: C.string().min(1),
                value: C.string().optional()
              })
            }),
            C.object({
              type: C.literal("markdown"),
              payload: C.object({ markdown: C.string().min(1) })
            }),
            C.object({
              type: C.literal("image"),
              payload: C.object({ imageUrl: C.string().min(1) })
            }),
            C.object({
              type: C.literal("audio"),
              payload: C.object({ audioUrl: C.string().min(1) })
            }),
            C.object({
              type: C.literal("video"),
              payload: C.object({ videoUrl: C.string().min(1) })
            }),
            C.object({
              type: C.literal("file"),
              payload: C.object({
                fileUrl: C.string().min(1),
                title: C.string().min(1).optional()
              })
            }),
            C.object({
              type: C.literal("location"),
              payload: C.object({
                latitude: C.number(),
                longitude: C.number(),
                address: C.string().optional(),
                title: C.string().optional()
              })
            })
          ])
        ),
        type: C.literal("bloc")
      }),
      C.object({
        markdown: C.string().min(1),
        type: C.literal("markdown")
      }),
      C.object({
        url: C.string(),
        name: C.string(),
        data: C.union([C.any(), C.null()]).optional(),
        type: C.literal("custom")
      }),
      C.object({ reaction: C.string(), type: C.literal("reaction") })
    ]).describe("Payload is the content of the message."),
    userId: C.string().describe("ID of the [User](#schema_user)"),
    conversationId: C.string().describe("ID of the [Conversation](#schema_conversation)"),
    metadata: C.record(C.union([C.any(), C.null()])).describe("Metadata of the message").optional(),
    replyTo: C.string().describe("ID of the message this message is replying to").optional(),
    selectedBy: C.string().describe(
      "ID of the user who selected this message. Undefined if not selected."
    ).optional()
  }).describe(
    "The Message object represents a message in a [Conversation](#schema_conversation) for a specific [User](#schema_user)."
  )
}), eue = C.object({
  type: C.literal("webchat_visibility"),
  data: C.object({
    visibility: C.union([
      C.literal("show"),
      C.literal("hide"),
      C.literal("toggle")
    ])
  })
}), tue = C.object({
  type: C.literal("webchat_config"),
  data: C.object({ config: C.record(C.union([C.any(), C.null()])) })
}), nue = C.object({
  type: C.literal("custom"),
  data: C.object({ event: C.record(C.union([C.any(), C.null()])) })
}), rue = C.object({
  type: C.literal("typing_started"),
  data: C.object({ timeout: C.number().optional() })
}), iue = C.object({ type: C.literal("typing_stopped"), data: C.record(C.never()) }), aue = {
  messageCreated: Xce,
  messageUpdated: Qce,
  webchatVisibility: eue,
  webchatConfig: tue,
  custom: nue,
  typingStarted: rue,
  typingStopped: iue
}, TS = "unknown error", rR = class extends nR {
  constructor(t) {
    super();
    Ee(this, "_state", { status: "disconnected" });
    Ee(this, "connect", async () => {
      if (this._state.status === "connected")
        return;
      if (this._state.status === "connecting") {
        await this._state.connectionPromise;
        return;
      }
      const t = this._connect();
      this._state = { status: "connecting", connectionPromise: t }, await t;
    });
    Ee(this, "disconnect", async () => {
      if (this._state.status === "disconnected")
        return;
      let t;
      this._state.status === "connecting" ? t = await this._state.connectionPromise : t = this._state.source, this._disconnectSync(t);
    });
    Ee(this, "_connect", async () => {
      const t = await Jce(`${this._props.url}/conversations/${this._props.conversationId}/listen`, {
        headers: { "x-user-key": this._props.userKey },
        timeout: this._props.timeout
      });
      return t.on("message", this._handleMessage), t.on("error", this._handleError(t)), this._state = { status: "connected", source: t }, t;
    });
    Ee(this, "_disconnectSync", (t) => {
      t.close(), this._state = { status: "disconnected" };
    });
    Ee(this, "_handleMessage", (t) => {
      const n = this._parseSignal(t.data);
      this.emit(n.type, n.data);
    });
    Ee(this, "_handleError", (t) => (n) => {
      this._disconnectSync(t);
      const r = this._toError(n);
      this.emit("error", r);
    });
    Ee(this, "_parseSignal", (t) => {
      for (const n of Object.values(aue)) {
        const r = this._safeJsonParse(t), i = n.safeParse(r);
        if (i.success)
          return i.data;
      }
      return {
        type: "unknown",
        data: t
      };
    });
    Ee(this, "_safeJsonParse", (t) => {
      try {
        return JSON.parse(t);
      } catch {
        return t;
      }
    });
    Ee(this, "_toError", (t) => {
      if (t instanceof Error)
        return t;
      if (typeof t == "string")
        return new Error(t);
      if (t === null)
        return new Error(TS);
      if (typeof t == "object" && "message" in t)
        return this._toError(t.message);
      try {
        const n = JSON.stringify(t);
        return new Error(n);
      } catch {
        return new Error(TS);
      }
    });
    this._props = t;
  }
  get status() {
    return this._state.status;
  }
}, iR = rR;
Xle(iR, "listen", async (e) => {
  const t = new rR(e);
  return await t.connect(), t;
});
var aR = 100 * 1024 * 1024, oue = aR, sue = aR, lue = 6e4, oR = class {
  constructor(e) {
    Ee(this, "_auto");
    Ee(this, "createConversation", (e) => this._auto.createConversation(e));
    Ee(this, "getConversation", (e) => this._auto.getConversation(e));
    Ee(this, "deleteConversation", (e) => this._auto.deleteConversation(e));
    Ee(this, "listConversations", (e) => this._auto.listConversations(e));
    Ee(this, "listConversationMessages", (e) => this._auto.listConversationMessages(e));
    Ee(this, "addParticipant", (e) => this._auto.addParticipant(e));
    Ee(this, "removeParticipant", (e) => this._auto.removeParticipant(e));
    Ee(this, "getParticipant", (e) => this._auto.getParticipant(e));
    Ee(this, "listParticipants", (e) => this._auto.listParticipants(e));
    Ee(this, "createMessage", (e) => this._auto.createMessage(e));
    Ee(this, "updateMessage", (e) => this._auto.updateMessage(e));
    Ee(this, "selectMessage", (e) => this._auto.selectMessage(e));
    Ee(this, "getMessage", (e) => this._auto.getMessage(e));
    Ee(this, "deleteMessage", (e) => this._auto.deleteMessage(e));
    Ee(this, "createFile", (e) => this._auto.createFile(e));
    Ee(this, "createUser", (e) => this._auto.createUser(e));
    Ee(this, "getUser", (e) => this._auto.getUser(e));
    Ee(this, "updateUser", (e) => this._auto.updateUser(e));
    Ee(this, "deleteUser", (e) => this._auto.deleteUser(e));
    Ee(this, "createEvent", (e) => this._auto.createEvent(e));
    Ee(this, "getEvent", (e) => this._auto.getEvent(e));
    Ee(this, "listenConversation", async ({
      id: e,
      "x-user-key": t
    }) => await iR.listen({
      url: this.props.apiUrl,
      conversationId: e,
      userKey: t,
      timeout: this.props.sseTimeout
    }));
    this.props = e;
    const { apiUrl: t } = e, n = {
      ...e.headers
    }, r = this.props.timeout ?? lue, i = Ht.create({
      baseURL: t,
      headers: n,
      withCredentials: !0,
      timeout: r,
      maxBodyLength: oue,
      maxContentLength: sue
    });
    this._auto = new Gce(i);
  }
};
const cue = 6e4;
function uue({ apiUrl: e, clientId: t, sseTimeout: n = cue }) {
  const r = new oR({
    apiUrl: `${e}/${t}`,
    sseTimeout: n
  });
  return {
    sendMessage: async (i) => {
      const { message: a } = await r.createMessage(i);
      return Vi(a);
    },
    getMessage: async (i) => {
      const { message: a } = await r.getMessage(i);
      return Vi(a);
    },
    listConversationMessages: async (i) => {
      const { messages: a, meta: o } = await r.listConversationMessages(i);
      return {
        messages: a.map(Vi),
        meta: o
      };
    },
    createMessage: async (i) => {
      const { message: a } = await r.createMessage(i);
      return Vi(a);
    },
    addParticipant: r.addParticipant.bind(r),
    createConversation: r.createConversation.bind(r),
    createEvent: r.createEvent.bind(r),
    createFile: r.createFile.bind(r),
    createUser: r.createUser.bind(r),
    deleteConversation: r.deleteConversation.bind(r),
    deleteMessage: r.deleteMessage.bind(r),
    deleteUser: r.deleteUser.bind(r),
    getConversation: r.getConversation.bind(r),
    getEvent: r.getEvent.bind(r),
    getParticipant: r.getParticipant.bind(r),
    getUser: r.getUser.bind(r),
    listConversations: r.listConversations.bind(r),
    removeParticipant: r.removeParticipant.bind(r),
    updateUser: r.updateUser.bind(r),
    listenConversation: r.listenConversation.bind(r)
  };
}
const Bu = {
  disconnected: 0,
  user_creating: 1,
  user_created: 2,
  conversation_creating: 3,
  conversation_created: 4
}, kn = (e, t) => e.status === t, Er = (e, t) => Bu[e.status] < Bu[t], CS = (e, t) => Bu[e.status] >= Bu[t];
class _r extends Error {
  constructor(t) {
    super(`Unexpected state: ${t.status}`), this.state = t;
  }
}
const fue = ["audio", "file", "image", "video"], vg = (e) => fue.includes(e), due = 6e4;
class pue extends Wu {
  constructor(n) {
    super();
    Ee(this, "_client");
    Ee(this, "_webhookId");
    Ee(this, "_apiUrl");
    Ee(this, "_state", { status: "disconnected" });
    Ee(this, "mode", "pushpin");
    Ee(this, "_initialConnect", async ({ data: n, name: r, pictureUrl: i }) => {
      if (CS(this._state, "user_created"))
        throw new Error("Client is already connected. Please disconnect first.");
      if (kn(this._state, "user_creating"))
        return;
      this._state = {
        status: "user_creating"
      };
      const {
        user: { id: a },
        key: o
      } = await this._client.createUser({
        name: r,
        pictureUrl: i,
        userData: n
      });
      return this._state = {
        status: "user_created",
        userId: a,
        userKey: o
      }, {
        userId: a,
        userToken: o
      };
    });
    Ee(this, "_reConnect", async (n, { data: r, name: i, pictureUrl: a }) => {
      if (CS(this._state, "user_created")) {
        if (this._state.userId !== n.userId)
          throw new Error("Client is already connected. Please disconnect first.");
        return n;
      }
      return kn(this._state, "user_creating") || (this._state = {
        status: "user_created",
        userId: n.userId,
        userKey: n.userToken
      }, await this._client.updateUser({
        "x-user-key": n.userToken,
        name: i,
        pictureUrl: a,
        userData: r
      })), n;
    });
    Ee(this, "_mapMessage", (n) => {
      const { metadata: r } = n, { payload: i, disableInput: a } = __(n.payload);
      return {
        id: n.id,
        conversationId: n.conversationId,
        authorId: n.userId,
        sentOn: new Date(n.createdAt),
        payload: i,
        disableInput: a,
        metadata: r
      };
    });
    const r = `${n.apiUrl}/${n.clientId}`;
    this._webhookId = n.clientId, this._apiUrl = r, this._client = new oR({
      apiUrl: r,
      sseTimeout: due
    });
  }
  get apiUrl() {
    return this._apiUrl;
  }
  get clientId() {
    return this._webhookId;
  }
  get userId() {
    if (!Er(this._state, "user_created"))
      return this._state.userId;
  }
  async getUser() {
    if (Er(this._state, "user_created"))
      throw new _r(this._state);
    const { user: n } = await this._client.getUser({ "x-user-key": this._state.userKey });
    return { data: n.data };
  }
  async updateUser(n) {
    if (Er(this._state, "user_created"))
      throw new _r(this._state);
    const { user: r } = await this._client.updateUser({
      "x-user-key": this._state.userKey,
      name: n.name,
      pictureUrl: n.pictureUrl,
      userData: n.data
    });
    return r;
  }
  get conversationId() {
    if (!Er(this._state, "conversation_created"))
      return this._state.conversationId;
  }
  async connect(n, r, i = {}) {
    const a = { data: r, ...i };
    return n ? await this.userExists(n) ? this._reConnect(n, a) : this._initialConnect(a) : this._initialConnect(a);
  }
  async disconnect() {
    kn(this._state, "conversation_created") ? this._state.signalEmitter.cleanup() : kn(this._state, "conversation_creating") && console.warn("zombie conversation..."), this._state = { status: "disconnected" };
  }
  async sendFile(n) {
    if (Er(this._state, "user_created"))
      throw new _r(this._state);
    if (kn(this._state, "conversation_creating"))
      throw new _r(this._state);
    let r;
    kn(this._state, "conversation_created") ? r = this._state : (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, r = await this._createNewConversation(this._state));
    const { size: i, name: a } = n, s = await ((m) => new Promise((h, y) => {
      const v = new FileReader();
      v.onload = (b) => {
        var w;
        return h((w = b.target) == null ? void 0 : w.result);
      }, v.onerror = (b) => {
        var w;
        return y((w = b.target) == null ? void 0 : w.error);
      }, v.readAsArrayBuffer(m);
    }))(n), {
      file: { uploadUrl: c, contentType: l, url: u }
    } = await this._client.createFile({
      "x-user-key": r.userKey,
      size: i,
      key: a,
      accessPolicies: ["public_content"],
      index: !1,
      tags: { source: "integration", integrationName: "webchat" }
    });
    await fetch(c, {
      method: "PUT",
      headers: {
        "x-amz-tagging": "public=true"
      },
      body: s
    });
    const f = l.split("/").shift() ?? "", d = vg(f) ? f : "file", p = d === "image" ? { type: d, imageUrl: u } : d === "audio" ? { type: d, audioUrl: u } : d === "video" ? { type: d, videoUrl: u } : { type: d, fileUrl: u };
    return await this._client.createMessage({
      "x-user-key": r.userKey,
      conversationId: r.conversationId,
      payload: p
    }), this.emit("messageSent", p), { fileUrl: u, name: a, type: d };
  }
  async sendMessage(n) {
    if (Er(this._state, "user_created"))
      throw new _r(this._state);
    if (kn(this._state, "conversation_creating"))
      throw new _r(this._state);
    let r;
    kn(this._state, "conversation_created") ? r = this._state : (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, r = await this._createNewConversation(this._state)), await this._client.createMessage({
      "x-user-key": r.userKey,
      conversationId: r.conversationId,
      payload: n
    }), this.emit("messageSent", n);
  }
  async sendEvent(n) {
    if (Er(this._state, "user_created"))
      throw new _r(this._state);
    if (kn(this._state, "conversation_creating"))
      throw new _r(this._state);
    let r;
    kn(this._state, "conversation_created") ? r = this._state : (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, r = await this._createNewConversation(this._state)), await this._client.createEvent({
      "x-user-key": r.userKey,
      conversationId: r.conversationId,
      payload: {
        type: "custom",
        data: n
      }
    });
  }
  async switchConversation(n) {
    if (Er(this._state, "user_created"))
      throw new _r(this._state);
    kn(this._state, "conversation_created") && this._state.conversationId === n || kn(this._state, "conversation_creating") || (this._state = {
      status: "conversation_creating",
      userId: this._state.userId,
      userKey: this._state.userKey
    }, await this._connectConversation(this._state, n));
  }
  async conversationExists(n) {
    if (Er(this._state, "user_created"))
      return !1;
    try {
      return await this._client.getConversation({
        "x-user-key": this._state.userKey,
        id: n
      }), !0;
    } catch (r) {
      if (zm(r) && r.code === 404)
        return !1;
      throw r;
    }
  }
  async userExists({ userToken: n }) {
    try {
      return await this._client.getUser({
        "x-user-key": n
      }), !0;
    } catch (r) {
      const i = (a) => a.code === 404 || a.code === 401;
      if (zm(r) && i(r))
        return !1;
      throw r;
    }
  }
  async newConversation() {
    if (Er(this._state, "user_created"))
      throw new _r(this._state);
    kn(this._state, "conversation_creating") || (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, await this._createNewConversation(this._state));
  }
  async _createNewConversation(n) {
    const {
      conversation: { id: r }
    } = await this._client.createConversation({ "x-user-key": n.userKey }), i = await this._connectConversation(n, r);
    return await this._client.createEvent({
      "x-user-key": n.userKey,
      conversationId: r,
      payload: { type: "conversation_started", data: {} }
    }), i;
  }
  async listMessages() {
    if (!kn(this._state, "conversation_created"))
      return [];
    const { conversationId: n, userKey: r } = this._state, i = [];
    let a;
    do {
      const o = await this._client.listConversationMessages({ id: n, "x-user-key": r, nextToken: a });
      i.push(...o.messages), a = o.meta.nextToken;
    } while (a);
    return i.map(this._mapMessage);
  }
  async _connectConversation(n, r) {
    const i = await this._client.listenConversation({ id: r, "x-user-key": n.userKey });
    return i.on("unknown", (a) => {
      typeof a == "string" && a === "ping" || console.debug("unknown event", a);
    }), i.on("message_created", (a) => {
      a.userId, n.userId;
    }), i.on("error", (a) => {
      this._state = { status: "user_created", userId: n.userId, userKey: n.userKey }, this.emit("error", new Error(`Connection to conversation lost: ${a.message}`));
    }), i.on("webchat_visibility", (a) => {
      this.emit("webchatVisibility", a.visibility);
    }), i.on("webchat_config", (a) => {
      this.emit("webchatConfig", a.config);
    }), i.on("typing_started", (a) => {
      this.emit("isTyping", { isTyping: !0, timeout: a.timeout ?? 5e3 });
    }), i.on("typing_stopped", () => {
      this.emit("isTyping", { isTyping: !1, timeout: 0 });
    }), i.on("custom", (a) => {
      this.emit("customEvent", a.event);
    }), this.emit("conversation", r), this._state = {
      status: "conversation_created",
      userId: n.userId,
      userKey: n.userKey,
      conversationId: r,
      signalEmitter: i
    }, this._state;
  }
}
const hue = ({ clientId: e, apiUrl: t = "https://webchat.botpress.cloud" }) => new pue({
  apiUrl: t,
  clientId: e
}), yde = ({ clientId: e, apiUrl: t = "https://webchat.botpress.cloud" }) => {
  const [n] = He(hue({ clientId: e, apiUrl: t }));
  return n;
};
function sR() {
  const [e, t] = He(!1), n = Tt(null);
  return {
    isTyping: e,
    setIsTyping: (r, i) => {
      if (t(r), !r)
        return () => {
        };
      if (n.current = /* @__PURE__ */ new Date(), !i)
        return () => {
        };
      const a = setTimeout(() => {
        const o = n.current;
        o && (/* @__PURE__ */ new Date()).getTime() - o.getTime() > i && t(!1);
      }, i + 100);
      return () => clearTimeout(a);
    }
  };
}
var mue = Object.defineProperty, vue = (e, t, n) => t in e ? mue(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, yue = (e, t, n) => vue(e, t + "", n), gue = async (e, t) => {
  let n = typeof t == "function" ? await t(e) : t;
  if (n) return e.scheme === "bearer" ? `Bearer ${n}` : e.scheme === "basic" ? `Basic ${btoa(n)}` : n;
}, bue = { bodySerializer: (e) => JSON.stringify(e, (t, n) => typeof n == "bigint" ? n.toString() : n) }, wue = (e) => {
  switch (e) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
}, xue = (e) => {
  switch (e) {
    case "form":
      return ",";
    case "pipeDelimited":
      return "|";
    case "spaceDelimited":
      return "%20";
    default:
      return ",";
  }
}, Sue = (e) => {
  switch (e) {
    case "label":
      return ".";
    case "matrix":
      return ";";
    case "simple":
      return ",";
    default:
      return "&";
  }
}, lR = ({ allowReserved: e, explode: t, name: n, style: r, value: i }) => {
  if (!t) {
    let s = (e ? i : i.map((c) => encodeURIComponent(c))).join(xue(r));
    switch (r) {
      case "label":
        return `.${s}`;
      case "matrix":
        return `;${n}=${s}`;
      case "simple":
        return s;
      default:
        return `${n}=${s}`;
    }
  }
  let a = wue(r), o = i.map((s) => r === "label" || r === "simple" ? e ? s : encodeURIComponent(s) : qf({ allowReserved: e, name: n, value: s })).join(a);
  return r === "label" || r === "matrix" ? a + o : o;
}, qf = ({ allowReserved: e, name: t, value: n }) => {
  if (n == null) return "";
  if (typeof n == "object") throw new Error("Deeply-nested arrays/objects aren’t supported. Provide your own `querySerializer()` to handle these.");
  return `${t}=${e ? n : encodeURIComponent(n)}`;
}, cR = ({ allowReserved: e, explode: t, name: n, style: r, value: i }) => {
  if (i instanceof Date) return `${n}=${i.toISOString()}`;
  if (r !== "deepObject" && !t) {
    let s = [];
    Object.entries(i).forEach(([l, u]) => {
      s = [...s, l, e ? u : encodeURIComponent(u)];
    });
    let c = s.join(",");
    switch (r) {
      case "form":
        return `${n}=${c}`;
      case "label":
        return `.${c}`;
      case "matrix":
        return `;${n}=${c}`;
      default:
        return c;
    }
  }
  let a = Sue(r), o = Object.entries(i).map(([s, c]) => qf({ allowReserved: e, name: r === "deepObject" ? `${n}[${s}]` : s, value: c })).join(a);
  return r === "label" || r === "matrix" ? a + o : o;
}, Eue = /\{[^{}]+\}/g, _ue = ({ path: e, url: t }) => {
  let n = t, r = t.match(Eue);
  if (r) for (let i of r) {
    let a = !1, o = i.substring(1, i.length - 1), s = "simple";
    o.endsWith("*") && (a = !0, o = o.substring(0, o.length - 1)), o.startsWith(".") ? (o = o.substring(1), s = "label") : o.startsWith(";") && (o = o.substring(1), s = "matrix");
    let c = e[o];
    if (c == null) continue;
    if (Array.isArray(c)) {
      n = n.replace(i, lR({ explode: a, name: o, style: s, value: c }));
      continue;
    }
    if (typeof c == "object") {
      n = n.replace(i, cR({ explode: a, name: o, style: s, value: c }));
      continue;
    }
    if (s === "matrix") {
      n = n.replace(i, `;${qf({ name: o, value: c })}`);
      continue;
    }
    let l = encodeURIComponent(s === "label" ? `.${c}` : c);
    n = n.replace(i, l);
  }
  return n;
}, uR = ({ allowReserved: e, array: t, object: n } = {}) => (r) => {
  let i = [];
  if (r && typeof r == "object") for (let a in r) {
    let o = r[a];
    if (o != null) {
      if (Array.isArray(o)) {
        i = [...i, lR({ allowReserved: e, explode: !0, name: a, style: "form", value: o, ...t })];
        continue;
      }
      if (typeof o == "object") {
        i = [...i, cR({ allowReserved: e, explode: !0, name: a, style: "deepObject", value: o, ...n })];
        continue;
      }
      i = [...i, qf({ allowReserved: e, name: a, value: o })];
    }
  }
  return i.join("&");
}, kue = (e) => {
  var t;
  if (!e) return "stream";
  let n = (t = e.split(";")[0]) == null ? void 0 : t.trim();
  if (n) {
    if (n.startsWith("application/json") || n.endsWith("+json")) return "json";
    if (n === "multipart/form-data") return "formData";
    if (["application/", "audio/", "image/", "video/"].some((r) => n.startsWith(r))) return "blob";
    if (n.startsWith("text/")) return "text";
  }
}, Tue = async ({ security: e, ...t }) => {
  for (let n of e) {
    let r = await gue(n, t.auth);
    if (!r) continue;
    let i = n.name ?? "Authorization";
    switch (n.in) {
      case "query":
        t.query || (t.query = {}), t.query[i] = r;
        break;
      case "cookie":
        t.headers.append("Cookie", `${i}=${r}`);
        break;
      case "header":
      default:
        t.headers.set(i, r);
        break;
    }
    return;
  }
}, OS = (e) => Cue({ baseUrl: e.baseUrl, path: e.path, query: e.query, querySerializer: typeof e.querySerializer == "function" ? e.querySerializer : uR(e.querySerializer), url: e.url }), Cue = ({ baseUrl: e, path: t, query: n, querySerializer: r, url: i }) => {
  let a = i.startsWith("/") ? i : `/${i}`, o = (e ?? "") + a;
  t && (o = _ue({ path: t, url: o }));
  let s = n ? r(n) : "";
  return s.startsWith("?") && (s = s.substring(1)), s && (o += `?${s}`), o;
}, $S = (e, t) => {
  var n;
  let r = { ...e, ...t };
  return (n = r.baseUrl) != null && n.endsWith("/") && (r.baseUrl = r.baseUrl.substring(0, r.baseUrl.length - 1)), r.headers = fR(e.headers, t.headers), r;
}, fR = (...e) => {
  let t = new Headers();
  for (let n of e) {
    if (!n || typeof n != "object") continue;
    let r = n instanceof Headers ? n.entries() : Object.entries(n);
    for (let [i, a] of r) if (a === null) t.delete(i);
    else if (Array.isArray(a)) for (let o of a) t.append(i, o);
    else a !== void 0 && t.set(i, typeof a == "object" ? JSON.stringify(a) : a);
  }
  return t;
}, lh = class {
  constructor() {
    yue(this, "_fns"), this._fns = [];
  }
  clear() {
    this._fns = [];
  }
  exists(t) {
    return this._fns.indexOf(t) !== -1;
  }
  eject(t) {
    let n = this._fns.indexOf(t);
    n !== -1 && (this._fns = [...this._fns.slice(0, n), ...this._fns.slice(n + 1)]);
  }
  use(t) {
    this._fns = [...this._fns, t];
  }
}, Oue = () => ({ error: new lh(), request: new lh(), response: new lh() }), $ue = /* @__PURE__ */ uR({ allowReserved: !1, array: { explode: !0, style: "form" }, object: { explode: !0, style: "deepObject" } }), Rue = { "Content-Type": "application/json" }, dR = (e = {}) => ({ ...bue, headers: Rue, parseAs: "auto", querySerializer: $ue, ...e }), Iue = (e = {}) => {
  let t = $S(dR(), e), n = () => ({ ...t }), r = (o) => (t = $S(t, o), n()), i = Oue(), a = async (o) => {
    let s = { ...t, ...o, fetch: o.fetch ?? t.fetch ?? globalThis.fetch, headers: fR(t.headers, o.headers) };
    s.security && await Tue({ ...s, security: s.security }), s.body && s.bodySerializer && (s.body = s.bodySerializer(s.body)), (s.body === void 0 || s.body === "") && s.headers.delete("Content-Type");
    let c = OS(s), l = { redirect: "follow", ...s }, u = new Request(c, l);
    for (let y of i.request._fns) u = await y(u, s);
    let f = s.fetch, d = await f(u);
    for (let y of i.response._fns) d = await y(d, u, s);
    let p = { request: u, response: d };
    if (d.ok) {
      if (d.status === 204 || d.headers.get("Content-Length") === "0") return { data: {}, ...p };
      let y = (s.parseAs === "auto" ? kue(d.headers.get("Content-Type")) : s.parseAs) ?? "json";
      if (y === "stream") return { data: d.body, ...p };
      let v = await d[y]();
      return y === "json" && (s.responseValidator && await s.responseValidator(v), s.responseTransformer && (v = await s.responseTransformer(v))), { data: v, ...p };
    }
    let m = await d.text();
    try {
      m = JSON.parse(m);
    } catch {
    }
    let h = m;
    for (let y of i.error._fns) h = await y(m, d, u, s);
    if (h = h || {}, s.throwOnError) throw h;
    return { error: h, ...p };
  };
  return { buildUrl: OS, connect: (o) => a({ ...o, method: "CONNECT" }), delete: (o) => a({ ...o, method: "DELETE" }), get: (o) => a({ ...o, method: "GET" }), getConfig: n, head: (o) => a({ ...o, method: "HEAD" }), interceptors: i, options: (o) => a({ ...o, method: "OPTIONS" }), patch: (o) => a({ ...o, method: "PATCH" }), post: (o) => a({ ...o, method: "POST" }), put: (o) => a({ ...o, method: "PUT" }), request: a, setConfig: r, trace: (o) => a({ ...o, method: "TRACE" }) };
}, Aue = Iue, Pue = dR;
const Due = (e) => ({
  ...e,
  withCredentials: !0,
  timeout: 6e4,
  maxBodyLength: 104857600,
  maxContentLength: 104857600,
  throwOnError: !0
}), Lt = /* @__PURE__ */ Aue(/* @__PURE__ */ Due(/* @__PURE__ */ Pue({
  baseUrl: "https://webchat.botpress.cloud/"
}))), jue = (e) => (e.client ?? Lt).delete({
  url: "/conversations/{id}",
  ...e
}), Nue = (e) => (e.client ?? Lt).get({
  url: "/conversations/{id}",
  ...e
}), Mue = (e) => (e.client ?? Lt).get({
  url: "/conversations",
  ...e
}), Fue = (e) => (e.client ?? Lt).post({
  url: "/conversations",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), Lue = (e) => (e.client ?? Lt).get({
  url: "/conversations/{id}/messages",
  ...e
}), Bue = (e) => (e.client ?? Lt).get({
  url: "/conversations/{id}/participants",
  ...e
}), Uue = (e) => (e.client ?? Lt).post({
  url: "/conversations/{id}/participants",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), zue = (e) => (e.client ?? Lt).delete({
  url: "/conversations/{id}/participants/{userId}",
  ...e
}), que = (e) => (e.client ?? Lt).get({
  url: "/conversations/{id}/participants/{userId}",
  ...e
}), Wue = (e) => (e.client ?? Lt).delete({
  url: "/messages/{id}",
  ...e
}), Vue = (e) => (e.client ?? Lt).get({
  url: "/messages/{id}",
  ...e
}), Hue = (e) => (e.client ?? Lt).put({
  url: "/messages/{id}",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), Zue = (e) => (e.client ?? Lt).post({
  url: "/messages",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), Kue = (e) => (e.client ?? Lt).delete({
  url: "/users/me",
  ...e
}), Gue = (e) => (e.client ?? Lt).get({
  url: "/users/me",
  ...e
}), Yue = (e) => (e.client ?? Lt).put({
  url: "/users/me",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), pR = (e) => ((e == null ? void 0 : e.client) ?? Lt).post({
  url: "/users",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), Jue = (e) => (e.client ?? Lt).get({
  url: "/events/{id}",
  ...e
}), Xue = (e) => (e.client ?? Lt).post({
  url: "/events",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
}), Que = (e) => (e.client ?? Lt).post({
  url: "/files",
  ...e,
  headers: {
    "Content-Type": "application/json",
    ...e == null ? void 0 : e.headers
  }
});
let RS = class extends Error {
  constructor(t, n) {
    super(t), this.name = "ParseError", this.type = n.type, this.field = n.field, this.value = n.value, this.line = n.line;
  }
};
function ch(e) {
}
function efe(e) {
  if (typeof e == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent: t = ch, onError: n = ch, onRetry: r = ch, onComment: i } = e;
  let a = "", o = !0, s, c = "", l = "";
  function u(h) {
    const y = o ? h.replace(/^\xEF\xBB\xBF/, "") : h, [v, b] = tfe(`${a}${y}`);
    for (const w of v)
      f(w);
    a = b, o = !1;
  }
  function f(h) {
    if (h === "") {
      p();
      return;
    }
    if (h.startsWith(":")) {
      i && i(h.slice(h.startsWith(": ") ? 2 : 1));
      return;
    }
    const y = h.indexOf(":");
    if (y !== -1) {
      const v = h.slice(0, y), b = h[y + 1] === " " ? 2 : 1, w = h.slice(y + b);
      d(v, w, h);
      return;
    }
    d(h, "", h);
  }
  function d(h, y, v) {
    switch (h) {
      case "event":
        l = y;
        break;
      case "data":
        c = `${c}${y}
`;
        break;
      case "id":
        s = y.includes("\0") ? void 0 : y;
        break;
      case "retry":
        /^\d+$/.test(y) ? r(parseInt(y, 10)) : n(
          new RS(`Invalid \`retry\` value: "${y}"`, {
            type: "invalid-retry",
            value: y,
            line: v
          })
        );
        break;
      default:
        n(
          new RS(
            `Unknown field "${h.length > 20 ? `${h.slice(0, 20)}…` : h}"`,
            { type: "unknown-field", field: h, value: y, line: v }
          )
        );
        break;
    }
  }
  function p() {
    c.length > 0 && t({
      id: s,
      event: l || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: c.endsWith(`
`) ? c.slice(0, -1) : c
    }), s = void 0, c = "", l = "";
  }
  function m(h = {}) {
    a && h.consume && f(a), o = !0, s = void 0, c = "", l = "", a = "";
  }
  return { feed: u, reset: m };
}
function tfe(e) {
  const t = [];
  let n = "", r = 0;
  for (; r < e.length; ) {
    const i = e.indexOf("\r", r), a = e.indexOf(`
`, r);
    let o = -1;
    if (i !== -1 && a !== -1 ? o = Math.min(i, a) : i !== -1 ? o = i : a !== -1 && (o = a), o === -1) {
      n = e.slice(r);
      break;
    } else {
      const s = e.slice(r, o);
      t.push(s), r = o + 1, e[r - 1] === "\r" && e[r] === `
` && r++;
    }
  }
  return [t, n];
}
class IS extends Event {
  /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */
  constructor(t, n) {
    var r, i;
    super(t), this.code = (r = n == null ? void 0 : n.code) != null ? r : void 0, this.message = (i = n == null ? void 0 : n.message) != null ? i : void 0;
  }
  /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */
  [Symbol.for("nodejs.util.inspect.custom")](t, n, r) {
    return r(AS(this), n);
  }
  /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */
  [Symbol.for("Deno.customInspect")](t, n) {
    return t(AS(this), n);
  }
}
function nfe(e) {
  const t = globalThis.DOMException;
  return typeof t == "function" ? new t(e, "SyntaxError") : new SyntaxError(e);
}
function qm(e) {
  return e instanceof Error ? "errors" in e && Array.isArray(e.errors) ? e.errors.map(qm).join(", ") : "cause" in e && e.cause instanceof Error ? `${e}: ${qm(e.cause)}` : e.message : `${e}`;
}
function AS(e) {
  return {
    type: e.type,
    message: e.message,
    code: e.code,
    defaultPrevented: e.defaultPrevented,
    cancelable: e.cancelable,
    timeStamp: e.timeStamp
  };
}
var hR = (e) => {
  throw TypeError(e);
}, yg = (e, t, n) => t.has(e) || hR("Cannot " + n), Ke = (e, t, n) => (yg(e, t, "read from private field"), n ? n.call(e) : t.get(e)), Yt = (e, t, n) => t.has(e) ? hR("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), $t = (e, t, n, r) => (yg(e, t, "write to private field"), t.set(e, n), n), Zr = (e, t, n) => (yg(e, t, "access private method"), n), On, Wi, Ia, qc, Uu, us, Ma, fs, vi, Aa, Ha, Pa, es, nr, Wm, Vm, Hm, PS, Zm, Km, ts, Gm, Ym;
class Wc extends EventTarget {
  constructor(t, n) {
    var r, i;
    super(), Yt(this, nr), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, Yt(this, On), Yt(this, Wi), Yt(this, Ia), Yt(this, qc), Yt(this, Uu), Yt(this, us), Yt(this, Ma), Yt(this, fs, null), Yt(this, vi), Yt(this, Aa), Yt(this, Ha, null), Yt(this, Pa, null), Yt(this, es, null), Yt(this, Vm, async (a) => {
      var o;
      Ke(this, Aa).reset();
      const { body: s, redirected: c, status: l, headers: u } = a;
      if (l === 204) {
        Zr(this, nr, ts).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
        return;
      }
      if (c ? $t(this, Ia, new URL(a.url)) : $t(this, Ia, void 0), l !== 200) {
        Zr(this, nr, ts).call(this, `Non-200 status code (${l})`, l);
        return;
      }
      if (!(u.get("content-type") || "").startsWith("text/event-stream")) {
        Zr(this, nr, ts).call(this, 'Invalid content type, expected "text/event-stream"', l);
        return;
      }
      if (Ke(this, On) === this.CLOSED)
        return;
      $t(this, On, this.OPEN);
      const f = new Event("open");
      if ((o = Ke(this, es)) == null || o.call(this, f), this.dispatchEvent(f), typeof s != "object" || !s || !("getReader" in s)) {
        Zr(this, nr, ts).call(this, "Invalid response body, expected a web ReadableStream", l), this.close();
        return;
      }
      const d = new TextDecoder(), p = s.getReader();
      let m = !0;
      do {
        const { done: h, value: y } = await p.read();
        y && Ke(this, Aa).feed(d.decode(y, { stream: !h })), h && (m = !1, Ke(this, Aa).reset(), Zr(this, nr, Gm).call(this));
      } while (m);
    }), Yt(this, Hm, (a) => {
      $t(this, vi, void 0), !(a.name === "AbortError" || a.type === "aborted") && Zr(this, nr, Gm).call(this, qm(a));
    }), Yt(this, Zm, (a) => {
      typeof a.id == "string" && $t(this, fs, a.id);
      const o = new MessageEvent(a.event || "message", {
        data: a.data,
        origin: Ke(this, Ia) ? Ke(this, Ia).origin : Ke(this, Wi).origin,
        lastEventId: a.id || ""
      });
      Ke(this, Pa) && (!a.event || a.event === "message") && Ke(this, Pa).call(this, o), this.dispatchEvent(o);
    }), Yt(this, Km, (a) => {
      $t(this, us, a);
    }), Yt(this, Ym, () => {
      $t(this, Ma, void 0), Ke(this, On) === this.CONNECTING && Zr(this, nr, Wm).call(this);
    });
    try {
      if (t instanceof URL)
        $t(this, Wi, t);
      else if (typeof t == "string")
        $t(this, Wi, new URL(t, rfe()));
      else
        throw new Error("Invalid URL");
    } catch {
      throw nfe("An invalid or illegal string was specified");
    }
    $t(this, Aa, efe({
      onEvent: Ke(this, Zm),
      onRetry: Ke(this, Km)
    })), $t(this, On, this.CONNECTING), $t(this, us, 3e3), $t(this, Uu, (r = n == null ? void 0 : n.fetch) != null ? r : globalThis.fetch), $t(this, qc, (i = n == null ? void 0 : n.withCredentials) != null ? i : !1), Zr(this, nr, Wm).call(this);
  }
  /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */
  get readyState() {
    return Ke(this, On);
  }
  /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */
  get url() {
    return Ke(this, Wi).href;
  }
  /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */
  get withCredentials() {
    return Ke(this, qc);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
  get onerror() {
    return Ke(this, Ha);
  }
  set onerror(t) {
    $t(this, Ha, t);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
  get onmessage() {
    return Ke(this, Pa);
  }
  set onmessage(t) {
    $t(this, Pa, t);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
  get onopen() {
    return Ke(this, es);
  }
  set onopen(t) {
    $t(this, es, t);
  }
  addEventListener(t, n, r) {
    const i = n;
    super.addEventListener(t, i, r);
  }
  removeEventListener(t, n, r) {
    const i = n;
    super.removeEventListener(t, i, r);
  }
  /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */
  close() {
    Ke(this, Ma) && clearTimeout(Ke(this, Ma)), Ke(this, On) !== this.CLOSED && (Ke(this, vi) && Ke(this, vi).abort(), $t(this, On, this.CLOSED), $t(this, vi, void 0));
  }
}
On = /* @__PURE__ */ new WeakMap(), Wi = /* @__PURE__ */ new WeakMap(), Ia = /* @__PURE__ */ new WeakMap(), qc = /* @__PURE__ */ new WeakMap(), Uu = /* @__PURE__ */ new WeakMap(), us = /* @__PURE__ */ new WeakMap(), Ma = /* @__PURE__ */ new WeakMap(), fs = /* @__PURE__ */ new WeakMap(), vi = /* @__PURE__ */ new WeakMap(), Aa = /* @__PURE__ */ new WeakMap(), Ha = /* @__PURE__ */ new WeakMap(), Pa = /* @__PURE__ */ new WeakMap(), es = /* @__PURE__ */ new WeakMap(), nr = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/
Wm = function() {
  $t(this, On, this.CONNECTING), $t(this, vi, new AbortController()), Ke(this, Uu)(Ke(this, Wi), Zr(this, nr, PS).call(this)).then(Ke(this, Vm)).catch(Ke(this, Hm));
}, Vm = /* @__PURE__ */ new WeakMap(), Hm = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/
PS = function() {
  var e;
  const t = {
    // [spec] Let `corsAttributeState` be `Anonymous`…
    // [spec] …will have their mode set to "cors"…
    mode: "cors",
    redirect: "follow",
    headers: { Accept: "text/event-stream", ...Ke(this, fs) ? { "Last-Event-ID": Ke(this, fs) } : void 0 },
    cache: "no-store",
    signal: (e = Ke(this, vi)) == null ? void 0 : e.signal
  };
  return "window" in globalThis && (t.credentials = this.withCredentials ? "include" : "same-origin"), t;
}, Zm = /* @__PURE__ */ new WeakMap(), Km = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
ts = function(e, t) {
  var n;
  Ke(this, On) !== this.CLOSED && $t(this, On, this.CLOSED);
  const r = new IS("error", { code: t, message: e });
  (n = Ke(this, Ha)) == null || n.call(this, r), this.dispatchEvent(r);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
Gm = function(e, t) {
  var n;
  if (Ke(this, On) === this.CLOSED)
    return;
  $t(this, On, this.CONNECTING);
  const r = new IS("error", { code: t, message: e });
  (n = Ke(this, Ha)) == null || n.call(this, r), this.dispatchEvent(r), $t(this, Ma, setTimeout(Ke(this, Ym), Ke(this, us)));
}, Ym = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/
Wc.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/
Wc.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/
Wc.CLOSED = 2;
function rfe() {
  const e = "document" in globalThis ? globalThis.document : void 0;
  return e && typeof e == "object" && "baseURI" in e && typeof e.baseURI == "string" ? e.baseURI : void 0;
}
class ife {
  constructor() {
    this.eventMap = {};
  }
  on(t, n) {
    var r;
    return this.eventMap[t] || (this.eventMap[t] = /* @__PURE__ */ new Set()), (r = this.eventMap[t]) == null || r.add(n), () => {
      var i;
      (i = this.eventMap[t]) == null || i.delete(n);
    };
  }
  emit(t, n) {
    var r, i;
    (r = this.eventMap[t]) == null || r.forEach((a) => {
      a(n);
    }), (i = this.eventMap["*"]) == null || i.forEach((a) => {
      a({ type: t, payload: n });
    });
  }
}
const Ut = (e) => e.data, mR = {
  throwOnError: !0
}, afe = ({ clientId: e, apiUrl: t }) => {
  const n = `${t || Lt.getConfig().baseUrl}/${e}`, r = {
    ...mR,
    baseUrl: n
  };
  return pR({ ...r, body: {} }).then(Ut);
}, DS = ({
  userKey: e,
  clientId: t,
  apiUrl: n
}) => {
  const r = {
    "x-user-key": e
  }, i = `${n || Lt.getConfig().baseUrl}/${t}`, a = {
    ...mR,
    baseUrl: i
  };
  return {
    createConversation: () => Fue({ ...a, headers: r, body: {} }).then(Ut),
    getConversation: ({ conversationId: o }) => Nue({ ...a, headers: r, path: { id: o } }).then(Ut),
    deleteConversation: ({ conversationId: o }) => jue({ ...a, headers: r, path: { id: o } }).then(Ut),
    listConversations: ({ nextToken: o }) => Mue({ ...a, headers: r, query: { nextToken: o } }).then(Ut),
    listConversationMessages: ({ conversationId: o, nextToken: s }) => Lue({
      ...a,
      headers: r,
      path: { id: o },
      query: { nextToken: s }
    }).then(Ut),
    addParticipant: ({ conversationId: o, userId: s }) => Uue({ ...a, headers: r, path: { id: o }, body: { userId: s } }).then(Ut),
    removeParticipant: ({ conversationId: o, userId: s }) => zue({ ...a, headers: r, path: { id: o, userId: s } }).then(Ut),
    getParticipant: ({ conversationId: o, userId: s }) => que({ ...a, headers: r, path: { id: o, userId: s } }).then(Ut),
    listParticipants: ({ conversationId: o, nextToken: s }) => Bue({ ...a, headers: r, path: { id: o }, query: { nextToken: s } }).then(Ut),
    createMessage: (o) => Zue({ ...a, headers: r, body: o }).then(Ut),
    updateMessage: ({ messageId: o, ...s }) => Hue({ ...a, headers: r, path: { id: o }, body: s }).then(Ut),
    getMessage: ({ messageId: o }) => Vue({ ...a, headers: r, path: { id: o } }).then(Ut),
    deleteMessage: ({ messageId: o }) => Wue({ ...a, headers: r, path: { id: o } }).then(Ut),
    createFile: (o) => Que({ ...a, headers: r, body: o }).then(Ut),
    createUser: (o) => pR({ ...a, headers: r, body: o }).then(Ut),
    getUser: () => Gue({ ...a, headers: r }).then(Ut),
    updateUser: (o) => Yue({ ...a, headers: r, body: o }).then(Ut),
    deleteUser: () => Kue({ ...a, headers: r }).then(Ut),
    createEvent: (o) => Xue({ ...a, headers: r, body: o }).then(Ut),
    getEvent: ({ eventId: o }) => Jue({ ...a, headers: r, path: { id: o } }).then(Ut),
    listenConversation: ({ conversationId: o }) => {
      let s = 0, c = null;
      const l = new ife(), u = () => {
        c && c.close();
        const f = `${i}/conversations/${o}/listen`;
        c = new Wc(f, {
          fetch: (d, p) => fetch(d, {
            ...p,
            headers: {
              ...p == null ? void 0 : p.headers,
              ...r,
              timeout: "60_000"
            }
          })
        }), c.onopen = () => l.emit("open"), c.onerror = (d) => {
          l.emit("error", d), s < 10 && (s++, setTimeout(() => u(), 3e3));
        }, c.onmessage = (d) => {
          const p = ofe(d.data);
          l.emit(p.type, p.data);
        };
      };
      return u(), l.on.bind(l);
    }
  };
}, ofe = (e) => {
  try {
    return JSON.parse(e);
  } catch {
    return e;
  }
};
async function sfe({
  conversationId: e,
  userCredentials: t,
  clientId: n,
  apiUrl: r
}) {
  let i = t, a = e, o;
  if (i) {
    if (o = DS({
      userKey: i.userToken,
      clientId: n,
      apiUrl: r
    }), !a) {
      const { conversation: s } = await o.createConversation();
      a = s.id;
    }
  } else {
    const { key: s, user: c } = await afe({ clientId: n, apiUrl: r });
    i = { userId: c.id, userToken: s }, o = DS({
      userKey: i.userToken,
      clientId: n,
      apiUrl: r
    });
    const { conversation: l } = await o.createConversation();
    a = l.id;
  }
  return {
    client: o,
    conversationId: a,
    userCredentials: i
  };
}
function lfe({
  apiUrl: e = "https://webchat.botpress.cloud",
  clientId: t,
  storageKey: n,
  storageLocation: r,
  ...i
}) {
  const a = P_(n, r), o = a((R) => R.conversationId), s = a((R) => R.user), c = a((R) => R.setConversationId), l = a((R) => R.setUser), u = Rr((R) => R.messages), f = Rr((R) => R.addMessage), d = Rr((R) => R.fetchMessages), p = Rr((R) => R.setMessages), m = Rr((R) => R.isFetching), [h, y] = He("connecting"), { isTyping: v, setIsTyping: b } = sR(), w = zt(() => new Wu(), []), [T, E] = He(!!i.conversationId || !!o), [_, $] = He(i.conversationId), [B, U] = He(i.user), [k, D] = He(void 0);
  if (Pt(() => {
    async function R() {
      try {
        const A = i.conversationId || o;
        A && E(!0);
        const { client: F, conversationId: H, userCredentials: V } = await sfe({
          clientId: t,
          apiUrl: e,
          userCredentials: i.user || s,
          conversationId: A
        });
        D(F), $(H), U(V), l(V), c(H), y("connected"), !A && w.emit("conversation", H);
      } catch (A) {
        console.error("Failed to initialize webchat:", A), y("error");
      }
    }
    R();
  }, [i.user, i.conversationId]), Pt(() => {
    async function R() {
      if (T && k && _) {
        const A = await d({ client: k, conversationId: _ });
        p(A), E(!1);
      }
    }
    R();
  }, [T, k, _]), Pt(() => {
    if (!k || !_) return;
    const R = k.listenConversation({ conversationId: _ }), A = [
      R("open", () => y("connected")),
      R("error", (F) => {
        w.emit("error", new Error(`Connection to conversation lost: ${F.message}`)), y("error");
      }),
      R("message_created", (F) => {
        const H = Dh(F);
        f(H), w.emit("message", H), b(!1), (B == null ? void 0 : B.userId) !== H.authorId ? b(!1) : setTimeout(() => b(!0, 5e3), 500);
      }),
      R("webchat_visibility", (F) => w.emit("webchatVisibility", F.visibility)),
      R("webchat_config", (F) => w.emit("webchatConfig", F.config)),
      R("typing_started", (F) => {
        const H = F.timeout ?? 5e3;
        b(!0, H), w.emit("isTyping", { isTyping: !0, timeout: H });
      }),
      R("typing_stopped", () => {
        b(!1), w.emit("isTyping", { isTyping: !1, timeout: 0 });
      }),
      R("custom", (F) => w.emit("customEvent", F.event))
    ];
    return () => {
      A.forEach((F) => F());
    };
  }, [_, k]), h === "connecting" || !B || !_ || !k)
    return {
      clientState: "connecting",
      on: w.on.bind(w),
      client: void 0,
      messages: [],
      conversationId: void 0,
      newConversation: () => {
      },
      user: void 0,
      isTyping: void 0,
      isFetchingMessages: m
    };
  const q = async () => {
    const { conversation: R } = await k.createConversation();
    return a.setState({ conversationId: R.id }), $(R.id), await k.createEvent({
      conversationId: R.id,
      payload: {
        type: "conversation_started",
        data: {}
      }
    }), R.id;
  }, L = {
    sendMessage: async (R) => {
      const A = ng();
      f(
        Dh({
          id: A,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          userId: B.userId,
          conversationId: _,
          payload: R,
          metadata: {
            clientMessageId: A,
            delivered: !1
          }
        })
      ), await k.createMessage({
        conversationId: _,
        payload: R,
        metadata: {
          clientMessageId: A
        }
      }).catch((F) => w.emit("error", F));
    },
    updateUser: async (R) => {
      const { user: A } = await k.updateUser({
        name: R.name,
        pictureUrl: R.pictureUrl,
        userData: R.data
      });
      return A;
    },
    sendEvent: async (R) => {
      await k.createEvent({
        conversationId: _,
        payload: {
          type: "custom",
          data: R
        }
      });
    },
    uploadFile: async (R) => {
      const { size: A, name: F } = R, V = await ((Y) => new Promise((G, X) => {
        const ie = new FileReader();
        ie.onload = (ae) => {
          var J;
          return G((J = ae.target) == null ? void 0 : J.result);
        }, ie.onerror = (ae) => {
          var J;
          return X((J = ae.target) == null ? void 0 : J.error);
        }, ie.readAsArrayBuffer(Y);
      }))(R), I = /* @__PURE__ */ new Date();
      I.setDate(I.getDate() + 30);
      const {
        file: { uploadUrl: g, contentType: j, url: W }
      } = await k.createFile({
        size: A,
        key: F,
        accessPolicies: ["public_content"],
        index: !1,
        tags: { source: "integration", integrationName: "webchat" },
        expiresAt: I.toISOString()
      });
      await fetch(g, {
        method: "PUT",
        headers: {
          "x-amz-tagging": "public=true"
        },
        body: V
      });
      const S = j.split("/").shift() ?? "", Z = vg(S) ? S : "file";
      return { fileUrl: W, name: F, type: Z };
    },
    getUser: async () => {
      const { user: R } = await k.getUser({ userId: B.userId });
      return R;
    }
  };
  return {
    clientState: h,
    on: w.on.bind(w),
    client: L,
    messages: u,
    conversationId: _,
    newConversation: () => {
      p([]), q().then(c);
    },
    user: s,
    isTyping: v,
    isFetchingMessages: m
  };
}
var vR = {}, gg = {}, zu = yt && yt.__assign || function() {
  return zu = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, zu.apply(this, arguments);
};
Object.defineProperty(gg, "__esModule", { value: !0 });
var cfe = {
  delayFirstAttempt: !1,
  jitter: "none",
  maxDelay: 1 / 0,
  numOfAttempts: 10,
  retry: function() {
    return !0;
  },
  startingDelay: 100,
  timeMultiple: 2
};
function ufe(e) {
  var t = zu(zu({}, cfe), e);
  return t.numOfAttempts < 1 && (t.numOfAttempts = 1), t;
}
gg.getSanitizedOptions = ufe;
var bg = {}, wg = {}, Wf = {}, xg = {}, Sg = {};
Object.defineProperty(Sg, "__esModule", { value: !0 });
function ffe(e) {
  var t = Math.random() * e;
  return Math.round(t);
}
Sg.fullJitter = ffe;
var Eg = {};
Object.defineProperty(Eg, "__esModule", { value: !0 });
function dfe(e) {
  return e;
}
Eg.noJitter = dfe;
Object.defineProperty(xg, "__esModule", { value: !0 });
var pfe = Sg, hfe = Eg;
function mfe(e) {
  switch (e.jitter) {
    case "full":
      return pfe.fullJitter;
    case "none":
    default:
      return hfe.noJitter;
  }
}
xg.JitterFactory = mfe;
Object.defineProperty(Wf, "__esModule", { value: !0 });
var vfe = xg, yfe = (
  /** @class */
  function() {
    function e(t) {
      this.options = t, this.attempt = 0;
    }
    return e.prototype.apply = function() {
      var t = this;
      return new Promise(function(n) {
        return setTimeout(n, t.jitteredDelay);
      });
    }, e.prototype.setAttemptNumber = function(t) {
      this.attempt = t;
    }, Object.defineProperty(e.prototype, "jitteredDelay", {
      get: function() {
        var t = vfe.JitterFactory(this.options);
        return t(this.delay);
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "delay", {
      get: function() {
        var t = this.options.startingDelay, n = this.options.timeMultiple, r = this.numOfDelayedAttempts, i = t * Math.pow(n, r);
        return Math.min(i, this.options.maxDelay);
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(e.prototype, "numOfDelayedAttempts", {
      get: function() {
        return this.attempt;
      },
      enumerable: !0,
      configurable: !0
    }), e;
  }()
);
Wf.Delay = yfe;
var gfe = yt && yt.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var a in i) i.hasOwnProperty(a) && (r[a] = i[a]);
    }, e(t, n);
  };
  return function(t, n) {
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), bfe = yt && yt.__awaiter || function(e, t, n, r) {
  function i(a) {
    return a instanceof n ? a : new n(function(o) {
      o(a);
    });
  }
  return new (n || (n = Promise))(function(a, o) {
    function s(u) {
      try {
        l(r.next(u));
      } catch (f) {
        o(f);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (f) {
        o(f);
      }
    }
    function l(u) {
      u.done ? a(u.value) : i(u.value).then(s, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
}, wfe = yt && yt.__generator || function(e, t) {
  var n = { label: 0, sent: function() {
    if (a[0] & 1) throw a[1];
    return a[1];
  }, trys: [], ops: [] }, r, i, a, o;
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, i && (a = l[0] & 2 ? i.return : l[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, l[1])).done) return a;
      switch (i = 0, a && (l = [l[0] & 2, a.value]), l[0]) {
        case 0:
        case 1:
          a = l;
          break;
        case 4:
          return n.label++, { value: l[1], done: !1 };
        case 5:
          n.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (a = n.trys, !(a = a.length > 0 && a[a.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            n = 0;
            continue;
          }
          if (l[0] === 3 && (!a || l[1] > a[0] && l[1] < a[3])) {
            n.label = l[1];
            break;
          }
          if (l[0] === 6 && n.label < a[1]) {
            n.label = a[1], a = l;
            break;
          }
          if (a && n.label < a[2]) {
            n.label = a[2], n.ops.push(l);
            break;
          }
          a[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      l = t.call(e, n);
    } catch (u) {
      l = [6, u], i = 0;
    } finally {
      r = a = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
};
Object.defineProperty(wg, "__esModule", { value: !0 });
var xfe = Wf, Sfe = (
  /** @class */
  function(e) {
    gfe(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.apply = function() {
      return bfe(this, void 0, void 0, function() {
        return wfe(this, function(n) {
          return [2, this.isFirstAttempt ? !0 : e.prototype.apply.call(this)];
        });
      });
    }, Object.defineProperty(t.prototype, "isFirstAttempt", {
      get: function() {
        return this.attempt === 0;
      },
      enumerable: !0,
      configurable: !0
    }), Object.defineProperty(t.prototype, "numOfDelayedAttempts", {
      get: function() {
        return this.attempt - 1;
      },
      enumerable: !0,
      configurable: !0
    }), t;
  }(xfe.Delay)
);
wg.SkipFirstDelay = Sfe;
var _g = {}, Efe = yt && yt.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var a in i) i.hasOwnProperty(a) && (r[a] = i[a]);
    }, e(t, n);
  };
  return function(t, n) {
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}();
Object.defineProperty(_g, "__esModule", { value: !0 });
var _fe = Wf, kfe = (
  /** @class */
  function(e) {
    Efe(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t;
  }(_fe.Delay)
);
_g.AlwaysDelay = kfe;
Object.defineProperty(bg, "__esModule", { value: !0 });
var Tfe = wg, Cfe = _g;
function Ofe(e, t) {
  var n = $fe(e);
  return n.setAttemptNumber(t), n;
}
bg.DelayFactory = Ofe;
function $fe(e) {
  return e.delayFirstAttempt ? new Cfe.AlwaysDelay(e) : new Tfe.SkipFirstDelay(e);
}
var Jm = yt && yt.__awaiter || function(e, t, n, r) {
  function i(a) {
    return a instanceof n ? a : new n(function(o) {
      o(a);
    });
  }
  return new (n || (n = Promise))(function(a, o) {
    function s(u) {
      try {
        l(r.next(u));
      } catch (f) {
        o(f);
      }
    }
    function c(u) {
      try {
        l(r.throw(u));
      } catch (f) {
        o(f);
      }
    }
    function l(u) {
      u.done ? a(u.value) : i(u.value).then(s, c);
    }
    l((r = r.apply(e, t || [])).next());
  });
}, Xm = yt && yt.__generator || function(e, t) {
  var n = { label: 0, sent: function() {
    if (a[0] & 1) throw a[1];
    return a[1];
  }, trys: [], ops: [] }, r, i, a, o;
  return o = { next: s(0), throw: s(1), return: s(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function s(l) {
    return function(u) {
      return c([l, u]);
    };
  }
  function c(l) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, i && (a = l[0] & 2 ? i.return : l[0] ? i.throw || ((a = i.return) && a.call(i), 0) : i.next) && !(a = a.call(i, l[1])).done) return a;
      switch (i = 0, a && (l = [l[0] & 2, a.value]), l[0]) {
        case 0:
        case 1:
          a = l;
          break;
        case 4:
          return n.label++, { value: l[1], done: !1 };
        case 5:
          n.label++, i = l[1], l = [0];
          continue;
        case 7:
          l = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (a = n.trys, !(a = a.length > 0 && a[a.length - 1]) && (l[0] === 6 || l[0] === 2)) {
            n = 0;
            continue;
          }
          if (l[0] === 3 && (!a || l[1] > a[0] && l[1] < a[3])) {
            n.label = l[1];
            break;
          }
          if (l[0] === 6 && n.label < a[1]) {
            n.label = a[1], a = l;
            break;
          }
          if (a && n.label < a[2]) {
            n.label = a[2], n.ops.push(l);
            break;
          }
          a[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      l = t.call(e, n);
    } catch (u) {
      l = [6, u], i = 0;
    } finally {
      r = a = 0;
    }
    if (l[0] & 5) throw l[1];
    return { value: l[0] ? l[1] : void 0, done: !0 };
  }
};
Object.defineProperty(vR, "__esModule", { value: !0 });
var Rfe = gg, Ife = bg;
function Afe(e, t) {
  return t === void 0 && (t = {}), Jm(this, void 0, void 0, function() {
    var n, r;
    return Xm(this, function(i) {
      switch (i.label) {
        case 0:
          return n = Rfe.getSanitizedOptions(t), r = new Dfe(e, n), [4, r.execute()];
        case 1:
          return [2, i.sent()];
      }
    });
  });
}
var Pfe = vR.backOff = Afe, Dfe = (
  /** @class */
  function() {
    function e(t, n) {
      this.request = t, this.options = n, this.attemptNumber = 0;
    }
    return e.prototype.execute = function() {
      return Jm(this, void 0, void 0, function() {
        var t, n;
        return Xm(this, function(r) {
          switch (r.label) {
            case 0:
              if (this.attemptLimitReached) return [3, 7];
              r.label = 1;
            case 1:
              return r.trys.push([1, 4, , 6]), [4, this.applyDelay()];
            case 2:
              return r.sent(), [4, this.request()];
            case 3:
              return [2, r.sent()];
            case 4:
              return t = r.sent(), this.attemptNumber++, [4, this.options.retry(t, this.attemptNumber)];
            case 5:
              if (n = r.sent(), !n || this.attemptLimitReached)
                throw t;
              return [3, 6];
            case 6:
              return [3, 0];
            case 7:
              throw new Error("Something went wrong.");
          }
        });
      });
    }, Object.defineProperty(e.prototype, "attemptLimitReached", {
      get: function() {
        return this.attemptNumber >= this.options.numOfAttempts;
      },
      enumerable: !0,
      configurable: !0
    }), e.prototype.applyDelay = function() {
      return Jm(this, void 0, void 0, function() {
        var t;
        return Xm(this, function(n) {
          switch (n.label) {
            case 0:
              return t = Ife.DelayFactory(this.options, this.attemptNumber), [4, t.apply()];
            case 1:
              return n.sent(), [
                2
                /*return*/
              ];
          }
        });
      });
    }, e;
  }()
);
function wde({
  apiUrl: e = "https://webchat.botpress.cloud",
  clientId: t,
  storageKey: n,
  storageLocation: r,
  ...i
}) {
  const [a, o] = He(), s = Rr((k) => k.messages), c = Rr((k) => k.addMessage), l = Rr((k) => k.fetchMessagesLegacy), u = Rr((k) => k.setMessages), f = Rr((k) => k.isFetching), [d, p] = He("connecting"), { isTyping: m, setIsTyping: h } = sR(), y = zt(() => new Wu(), []), v = P_(n, r), b = zt(() => uue({ apiUrl: e, clientId: t }), [e, t]), w = Tt(null), [T, E] = He(i.userKey), [_, $] = He(i.conversationId);
  async function B(k) {
    const { conversation: D } = await b.createConversation({ "x-user-key": k });
    return v.setState({ conversationId: D.id }), await b.createEvent({
      "x-user-key": k,
      conversationId: D.id,
      payload: {
        type: "conversation_started",
        data: {}
      }
    }), D.id;
  }
  if (Pt(() => {
    let k = !0;
    async function D({ userKey: q, conversationId: L }) {
      let R, A = i.userKey ?? q, F = i.conversationId ?? L;
      if (p("connecting"), !A) {
        const I = v.getState().user;
        A = I == null ? void 0 : I.userToken;
      }
      if (!A) {
        const { key: I, user: g } = await b.createUser({});
        R = g, A = I, v.setState({ user: { userId: g.id, userToken: A } });
      }
      if (!R) {
        const { user: I } = await b.getUser({ "x-user-key": A });
        R = I;
      }
      F || (F = v.getState().conversationId), F || (F = await B(A));
      const [H, V] = await Promise.all([
        b.listenConversation({
          "x-user-key": A,
          id: F
        }),
        l({
          client: b,
          conversationId: F,
          userKey: A
        })
      ]);
      y.emit("conversation", F), jS({ emitter: y, signalEmitter: H }), k && (w.current = H, E(A), $(F), o(R), u(V), p("connected"));
    }
    return D({ userKey: T, conversationId: _ }).catch((q) => {
      console.error(q);
    }), () => {
      w.current && (w.current.cleanup(), w.current = null), k = !1;
    };
  }, [T, _, b, y, i.conversationId, i.userKey]), Pt(() => {
    var D;
    if (!T || !_)
      return;
    async function k({ userKey: q, conversationId: L }) {
      const R = await b.listenConversation({ "x-user-key": q, id: L });
      w.current = R, jS({ emitter: y, signalEmitter: R });
    }
    d === "error" && ((D = w.current) == null || D.cleanup(), Pfe(() => k({ conversationId: _, userKey: T }), {
      startingDelay: 2e3,
      maxDelay: 1e4,
      numOfAttempts: 1 / 0
    }), p("connected"));
  }, [d, T, _]), Pt(() => {
    const k = [
      y.on("message", (D) => ((a == null ? void 0 : a.id) !== D.authorId && y.emit("isTyping", { isTyping: !1, timeout: 0 }), c(D))),
      y.on("isTyping", ({ isTyping: D, timeout: q }) => {
        h(D, q);
      }),
      y.on("error", () => {
        p("error");
      })
    ];
    return () => {
      k.forEach((D) => D());
    };
  }, []), d === "connecting" || !T || !_)
    return {
      clientState: "connecting",
      on: y.on.bind(y),
      client: void 0,
      messages: [],
      conversationId: void 0,
      newConversation: () => {
      },
      user: void 0,
      isTyping: void 0,
      isFetchingMessages: f
    };
  const U = {
    sendMessage: async (k) => {
      const D = ng();
      c(
        Vi({
          id: D,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          userId: (a == null ? void 0 : a.id) ?? "",
          conversationId: _,
          payload: k,
          metadata: {
            clientMessageId: D,
            delivered: !1
          }
        })
      ), await b.createMessage({
        "x-user-key": T,
        conversationId: _,
        payload: k,
        metadata: {
          clientMessageId: D
        }
      }).catch((q) => y.emit("error", q));
    },
    updateUser: async (k) => {
      const { user: D } = await b.updateUser({
        "x-user-key": T,
        name: k.name,
        pictureUrl: k.pictureUrl,
        userData: k.data
      });
      return D;
    },
    sendEvent: async (k) => {
      await b.createEvent({
        "x-user-key": T,
        conversationId: _,
        payload: {
          type: "custom",
          data: k
        }
      });
    },
    uploadFile: async (k) => {
      const { size: D, name: q } = k, R = await ((j) => new Promise((W, S) => {
        const Z = new FileReader();
        Z.onload = (Y) => {
          var G;
          return W((G = Y.target) == null ? void 0 : G.result);
        }, Z.onerror = (Y) => {
          var G;
          return S((G = Y.target) == null ? void 0 : G.error);
        }, Z.readAsArrayBuffer(j);
      }))(k), A = /* @__PURE__ */ new Date();
      A.setDate(A.getDate() + 30);
      const {
        file: { uploadUrl: F, contentType: H, url: V }
      } = await b.createFile({
        "x-user-key": T,
        size: D,
        key: q,
        accessPolicies: ["public_content"],
        index: !1,
        tags: { source: "integration", integrationName: "webchat" },
        expiresAt: A.toISOString()
      });
      await fetch(F, {
        method: "PUT",
        headers: {
          "x-amz-tagging": "public=true"
        },
        body: R
      });
      const I = H.split("/").shift() ?? "", g = vg(I) ? I : "file";
      return { fileUrl: V, name: q, type: g };
    },
    getUser: async () => {
      const { user: k } = await b.getUser({ "x-user-key": T });
      return k;
    }
  };
  return {
    clientState: d,
    on: y.on.bind(y),
    client: U,
    messages: s,
    conversationId: _,
    newConversation: () => {
      u([]), B(T).then($);
    },
    user: a,
    isTyping: m,
    isFetchingMessages: f
  };
}
function jS({
  emitter: e,
  signalEmitter: t
}) {
  t.on("unknown", (n) => {
  }), t.on("message_created", (n) => {
    e.emit("message", Vi(n));
  }), t.on("error", (n) => {
    e.emit("error", new Error(`Connection to conversation lost: ${n.message}`));
  }), t.on("webchat_visibility", (n) => {
    e.emit("webchatVisibility", n.visibility);
  }), t.on("webchat_config", (n) => {
    e.emit("webchatConfig", n.config);
  }), t.on("typing_started", (n) => {
    e.emit("isTyping", { isTyping: !0, timeout: n.timeout ?? 5e3 });
  }), t.on("typing_stopped", () => {
    e.emit("isTyping", { isTyping: !1, timeout: 0 });
  }), t.on("custom", (n) => {
    e.emit("customEvent", n.event);
  });
}
const xde = ({
  clientId: e,
  storageKey: t,
  configuration: n,
  allowFileUpload: r,
  apiUrl: i,
  user: a,
  conversationId: o,
  ...s
}) => {
  const c = t || `bp-webchat-${e}`, {
    clientState: l,
    client: u,
    isFetchingMessages: f,
    isTyping: d,
    newConversation: p,
    messages: m,
    user: h
  } = lfe({
    clientId: e,
    apiUrl: i,
    conversationId: o,
    user: a,
    storageKey: c,
    storageLocation: n == null ? void 0 : n.storageLocation
  }), { sendMessage: y, uploadFile: v } = u ?? {};
  return /* @__PURE__ */ O.jsx(
    eie,
    {
      configuration: n ?? {},
      user: h != null && h.userId ? { id: h == null ? void 0 : h.userId } : void 0,
      isLoading: f || l === "connecting",
      isTyping: d,
      connected: l === "connected" ? !0 : l === "disconnected" ? !1 : void 0,
      messages: m,
      sendMessage: y,
      uploadFile: v,
      allowFileUpload: r,
      restartConversation: p,
      ...s
    }
  );
};
export {
  av as Avatar,
  dl as Block,
  eie as Chat,
  TB as Composer,
  vT as Container,
  o7 as Fab,
  h7 as Header,
  Xw as Message,
  t$ as MessageList,
  ra as Modal,
  Mw as ModalProvider,
  d7 as RestartConversationButton,
  $3 as StylesheetProvider,
  m7 as TypingIndicator,
  xde as Webchat,
  cE as WebchatThemeSchema,
  Zf as avatarThemeSchema,
  kA as blockThemeSchema,
  $A as configPropsSchema,
  SA as configurationSchema,
  _A as cssStyleSchema,
  No as descriptionItemSchema,
  fue as fileTypes,
  RA as generateThemeStylesheet,
  uue as getClient,
  P_ as getUseWebchatClientStore,
  dde as initPropsSchema,
  __ as integrationMessagePayloadToBlockPayload,
  Vi as integrationMessageToBlockMessage,
  vg as isFileType,
  EA as markdownTypeSchema,
  tB as renderers,
  CA as statePropsSchema,
  me as styleOptionSchema,
  TA as themeSchema,
  yde as useClient,
  lfe as useWebchat,
  wde as useWebchatClient,
  _v as useWebchatStore,
  OA as userPropsSchema,
  ut as webchatClasses
};
