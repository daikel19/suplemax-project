var fA = Object.defineProperty;
var pA = (e, t, n) => t in e ? fA(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var _ = (e, t, n) => (pA(e, typeof t != "symbol" ? t + "" : t, n), n);
import * as A from "react";
import Jt, { createContext as _r, useMemo as va, createElement as Ue, useContext as Er, useRef as Xe, useEffect as Be, useLayoutEffect as sl, useCallback as nn, forwardRef as ze, Children as io, isValidElement as Rs, cloneElement as wd, Fragment as Di, useState as De, useId as hA, useDebugValue as mA, memo as Bo, useReducer as A0 } from "react";
import * as gA from "react-dom";
import { flushSync as $0, createPortal as yA } from "react-dom";
var Je = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ki(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function _m(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var Qp = { exports: {} }, ls = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ty;
function vA() {
  if (Ty)
    return ls;
  Ty = 1;
  var e = Jt, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, a = { key: !0, ref: !0, __self: !0, __source: !0 };
  function o(s, l, c) {
    var u, d = {}, p = null, f = null;
    c !== void 0 && (p = "" + c), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (f = l.ref);
    for (u in l)
      r.call(l, u) && !a.hasOwnProperty(u) && (d[u] = l[u]);
    if (s && s.defaultProps)
      for (u in l = s.defaultProps, l)
        d[u] === void 0 && (d[u] = l[u]);
    return { $$typeof: t, type: s, key: p, ref: f, props: d, _owner: i.current };
  }
  return ls.Fragment = n, ls.jsx = o, ls.jsxs = o, ls;
}
var cs = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cy;
function bA() {
  return Cy || (Cy = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Jt, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), a = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), u = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), h = Symbol.iterator, m = "@@iterator";
    function y($) {
      if ($ === null || typeof $ != "object")
        return null;
      var fe = h && $[h] || $[m];
      return typeof fe == "function" ? fe : null;
    }
    var g = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function v($) {
      {
        for (var fe = arguments.length, Ee = new Array(fe > 1 ? fe - 1 : 0), at = 1; at < fe; at++)
          Ee[at - 1] = arguments[at];
        b("error", $, Ee);
      }
    }
    function b($, fe, Ee) {
      {
        var at = g.ReactDebugCurrentFrame, Tt = at.getStackAddendum();
        Tt !== "" && (fe += "%s", Ee = Ee.concat([Tt]));
        var $t = Ee.map(function(wt) {
          return String(wt);
        });
        $t.unshift("Warning: " + fe), Function.prototype.apply.call(console[$], console, $t);
      }
    }
    var T = !1, O = !1, S = !1, P = !1, M = !1, L;
    L = Symbol.for("react.module.reference");
    function k($) {
      return !!(typeof $ == "string" || typeof $ == "function" || $ === r || $ === a || M || $ === i || $ === c || $ === u || P || $ === f || T || O || S || typeof $ == "object" && $ !== null && ($.$$typeof === p || $.$$typeof === d || $.$$typeof === o || $.$$typeof === s || $.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      $.$$typeof === L || $.getModuleId !== void 0));
    }
    function I($, fe, Ee) {
      var at = $.displayName;
      if (at)
        return at;
      var Tt = fe.displayName || fe.name || "";
      return Tt !== "" ? Ee + "(" + Tt + ")" : Ee;
    }
    function B($) {
      return $.displayName || "Context";
    }
    function U($) {
      if ($ == null)
        return null;
      if (typeof $.tag == "number" && v("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof $ == "function")
        return $.displayName || $.name || null;
      if (typeof $ == "string")
        return $;
      switch ($) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case a:
          return "Profiler";
        case i:
          return "StrictMode";
        case c:
          return "Suspense";
        case u:
          return "SuspenseList";
      }
      if (typeof $ == "object")
        switch ($.$$typeof) {
          case s:
            var fe = $;
            return B(fe) + ".Consumer";
          case o:
            var Ee = $;
            return B(Ee._context) + ".Provider";
          case l:
            return I($, $.render, "ForwardRef");
          case d:
            var at = $.displayName || null;
            return at !== null ? at : U($.type) || "Memo";
          case p: {
            var Tt = $, $t = Tt._payload, wt = Tt._init;
            try {
              return U(wt($t));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, D = 0, j, V, W, de, x, ie, ve;
    function E() {
    }
    E.__reactDisabledLog = !0;
    function ke() {
      {
        if (D === 0) {
          j = console.log, V = console.info, W = console.warn, de = console.error, x = console.group, ie = console.groupCollapsed, ve = console.groupEnd;
          var $ = {
            configurable: !0,
            enumerable: !0,
            value: E,
            writable: !0
          };
          Object.defineProperties(console, {
            info: $,
            log: $,
            warn: $,
            error: $,
            group: $,
            groupCollapsed: $,
            groupEnd: $
          });
        }
        D++;
      }
    }
    function Ze() {
      {
        if (D--, D === 0) {
          var $ = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, $, {
              value: j
            }),
            info: z({}, $, {
              value: V
            }),
            warn: z({}, $, {
              value: W
            }),
            error: z({}, $, {
              value: de
            }),
            group: z({}, $, {
              value: x
            }),
            groupCollapsed: z({}, $, {
              value: ie
            }),
            groupEnd: z({}, $, {
              value: ve
            })
          });
        }
        D < 0 && v("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Pe = g.ReactCurrentDispatcher, qe;
    function rt($, fe, Ee) {
      {
        if (qe === void 0)
          try {
            throw Error();
          } catch (Tt) {
            var at = Tt.stack.trim().match(/\n( *(at )?)/);
            qe = at && at[1] || "";
          }
        return `
` + qe + $;
      }
    }
    var Ve = !1, be;
    {
      var he = typeof WeakMap == "function" ? WeakMap : Map;
      be = new he();
    }
    function Oe($, fe) {
      if (!$ || Ve)
        return "";
      {
        var Ee = be.get($);
        if (Ee !== void 0)
          return Ee;
      }
      var at;
      Ve = !0;
      var Tt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var $t;
      $t = Pe.current, Pe.current = null, ke();
      try {
        if (fe) {
          var wt = function() {
            throw Error();
          };
          if (Object.defineProperty(wt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(wt, []);
            } catch (Jr) {
              at = Jr;
            }
            Reflect.construct($, [], wt);
          } else {
            try {
              wt.call();
            } catch (Jr) {
              at = Jr;
            }
            $.call(wt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Jr) {
            at = Jr;
          }
          $();
        }
      } catch (Jr) {
        if (Jr && at && typeof Jr.stack == "string") {
          for (var yt = Jr.stack.split(`
`), Mn = at.stack.split(`
`), Ht = yt.length - 1, Xt = Mn.length - 1; Ht >= 1 && Xt >= 0 && yt[Ht] !== Mn[Xt]; )
            Xt--;
          for (; Ht >= 1 && Xt >= 0; Ht--, Xt--)
            if (yt[Ht] !== Mn[Xt]) {
              if (Ht !== 1 || Xt !== 1)
                do
                  if (Ht--, Xt--, Xt < 0 || yt[Ht] !== Mn[Xt]) {
                    var ir = `
` + yt[Ht].replace(" at new ", " at ");
                    return $.displayName && ir.includes("<anonymous>") && (ir = ir.replace("<anonymous>", $.displayName)), typeof $ == "function" && be.set($, ir), ir;
                  }
                while (Ht >= 1 && Xt >= 0);
              break;
            }
        }
      } finally {
        Ve = !1, Pe.current = $t, Ze(), Error.prepareStackTrace = Tt;
      }
      var Fa = $ ? $.displayName || $.name : "", ky = Fa ? rt(Fa) : "";
      return typeof $ == "function" && be.set($, ky), ky;
    }
    function we($, fe, Ee) {
      return Oe($, !1);
    }
    function Fe($) {
      var fe = $.prototype;
      return !!(fe && fe.isReactComponent);
    }
    function st($, fe, Ee) {
      if ($ == null)
        return "";
      if (typeof $ == "function")
        return Oe($, Fe($));
      if (typeof $ == "string")
        return rt($);
      switch ($) {
        case c:
          return rt("Suspense");
        case u:
          return rt("SuspenseList");
      }
      if (typeof $ == "object")
        switch ($.$$typeof) {
          case l:
            return we($.render);
          case d:
            return st($.type, fe, Ee);
          case p: {
            var at = $, Tt = at._payload, $t = at._init;
            try {
              return st($t(Tt), fe, Ee);
            } catch {
            }
          }
        }
      return "";
    }
    var N = Object.prototype.hasOwnProperty, le = {}, pe = g.ReactDebugCurrentFrame;
    function ue($) {
      if ($) {
        var fe = $._owner, Ee = st($.type, $._source, fe ? fe.type : null);
        pe.setExtraStackFrame(Ee);
      } else
        pe.setExtraStackFrame(null);
    }
    function Le($, fe, Ee, at, Tt) {
      {
        var $t = Function.call.bind(N);
        for (var wt in $)
          if ($t($, wt)) {
            var yt = void 0;
            try {
              if (typeof $[wt] != "function") {
                var Mn = Error((at || "React class") + ": " + Ee + " type `" + wt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof $[wt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Mn.name = "Invariant Violation", Mn;
              }
              yt = $[wt](fe, wt, at, Ee, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ht) {
              yt = Ht;
            }
            yt && !(yt instanceof Error) && (ue(Tt), v("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", at || "React class", Ee, wt, typeof yt), ue(null)), yt instanceof Error && !(yt.message in le) && (le[yt.message] = !0, ue(Tt), v("Failed %s type: %s", Ee, yt.message), ue(null));
          }
      }
    }
    var Me = Array.isArray;
    function Ke($) {
      return Me($);
    }
    function gt($) {
      {
        var fe = typeof Symbol == "function" && Symbol.toStringTag, Ee = fe && $[Symbol.toStringTag] || $.constructor.name || "Object";
        return Ee;
      }
    }
    function tt($) {
      try {
        return Z($), !1;
      } catch {
        return !0;
      }
    }
    function Z($) {
      return "" + $;
    }
    function J($) {
      if (tt($))
        return v("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", gt($)), Z($);
    }
    var ce = g.ReactCurrentOwner, Ne = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, it, zt, At;
    At = {};
    function Ct($) {
      if (N.call($, "ref")) {
        var fe = Object.getOwnPropertyDescriptor($, "ref").get;
        if (fe && fe.isReactWarning)
          return !1;
      }
      return $.ref !== void 0;
    }
    function Zt($) {
      if (N.call($, "key")) {
        var fe = Object.getOwnPropertyDescriptor($, "key").get;
        if (fe && fe.isReactWarning)
          return !1;
      }
      return $.key !== void 0;
    }
    function Sn($, fe) {
      if (typeof $.ref == "string" && ce.current && fe && ce.current.stateNode !== fe) {
        var Ee = U(ce.current.type);
        At[Ee] || (v('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', U(ce.current.type), $.ref), At[Ee] = !0);
      }
    }
    function qt($, fe) {
      {
        var Ee = function() {
          it || (it = !0, v("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", fe));
        };
        Ee.isReactWarning = !0, Object.defineProperty($, "key", {
          get: Ee,
          configurable: !0
        });
      }
    }
    function Yt($, fe) {
      {
        var Ee = function() {
          zt || (zt = !0, v("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", fe));
        };
        Ee.isReactWarning = !0, Object.defineProperty($, "ref", {
          get: Ee,
          configurable: !0
        });
      }
    }
    var fn = function($, fe, Ee, at, Tt, $t, wt) {
      var yt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: $,
        key: fe,
        ref: Ee,
        props: wt,
        // Record the component responsible for creating this element.
        _owner: $t
      };
      return yt._store = {}, Object.defineProperty(yt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(yt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: at
      }), Object.defineProperty(yt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Tt
      }), Object.freeze && (Object.freeze(yt.props), Object.freeze(yt)), yt;
    };
    function an($, fe, Ee, at, Tt) {
      {
        var $t, wt = {}, yt = null, Mn = null;
        Ee !== void 0 && (J(Ee), yt = "" + Ee), Zt(fe) && (J(fe.key), yt = "" + fe.key), Ct(fe) && (Mn = fe.ref, Sn(fe, Tt));
        for ($t in fe)
          N.call(fe, $t) && !Ne.hasOwnProperty($t) && (wt[$t] = fe[$t]);
        if ($ && $.defaultProps) {
          var Ht = $.defaultProps;
          for ($t in Ht)
            wt[$t] === void 0 && (wt[$t] = Ht[$t]);
        }
        if (yt || Mn) {
          var Xt = typeof $ == "function" ? $.displayName || $.name || "Unknown" : $;
          yt && qt(wt, Xt), Mn && Yt(wt, Xt);
        }
        return fn($, yt, Mn, Tt, at, ce.current, wt);
      }
    }
    var Gr = g.ReactCurrentOwner, rr = g.ReactDebugCurrentFrame;
    function Cr($) {
      if ($) {
        var fe = $._owner, Ee = st($.type, $._source, fe ? fe.type : null);
        rr.setExtraStackFrame(Ee);
      } else
        rr.setExtraStackFrame(null);
    }
    var ea;
    ea = !1;
    function C($) {
      return typeof $ == "object" && $ !== null && $.$$typeof === t;
    }
    function _e() {
      {
        if (Gr.current) {
          var $ = U(Gr.current.type);
          if ($)
            return `

Check the render method of \`` + $ + "`.";
        }
        return "";
      }
    }
    function Ae($) {
      {
        if ($ !== void 0) {
          var fe = $.fileName.replace(/^.*[\\\/]/, ""), Ee = $.lineNumber;
          return `

Check your code at ` + fe + ":" + Ee + ".";
        }
        return "";
      }
    }
    var je = {};
    function Se($) {
      {
        var fe = _e();
        if (!fe) {
          var Ee = typeof $ == "string" ? $ : $.displayName || $.name;
          Ee && (fe = `

Check the top-level render call using <` + Ee + ">.");
        }
        return fe;
      }
    }
    function $e($, fe) {
      {
        if (!$._store || $._store.validated || $.key != null)
          return;
        $._store.validated = !0;
        var Ee = Se(fe);
        if (je[Ee])
          return;
        je[Ee] = !0;
        var at = "";
        $ && $._owner && $._owner !== Gr.current && (at = " It was passed a child from " + U($._owner.type) + "."), Cr($), v('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ee, at), Cr(null);
      }
    }
    function lt($, fe) {
      {
        if (typeof $ != "object")
          return;
        if (Ke($))
          for (var Ee = 0; Ee < $.length; Ee++) {
            var at = $[Ee];
            C(at) && $e(at, fe);
          }
        else if (C($))
          $._store && ($._store.validated = !0);
        else if ($) {
          var Tt = y($);
          if (typeof Tt == "function" && Tt !== $.entries)
            for (var $t = Tt.call($), wt; !(wt = $t.next()).done; )
              C(wt.value) && $e(wt.value, fe);
        }
      }
    }
    function ht($) {
      {
        var fe = $.type;
        if (fe == null || typeof fe == "string")
          return;
        var Ee;
        if (typeof fe == "function")
          Ee = fe.propTypes;
        else if (typeof fe == "object" && (fe.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        fe.$$typeof === d))
          Ee = fe.propTypes;
        else
          return;
        if (Ee) {
          var at = U(fe);
          Le(Ee, $.props, "prop", at, $);
        } else if (fe.PropTypes !== void 0 && !ea) {
          ea = !0;
          var Tt = U(fe);
          v("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Tt || "Unknown");
        }
        typeof fe.getDefaultProps == "function" && !fe.getDefaultProps.isReactClassApproved && v("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Dt($) {
      {
        for (var fe = Object.keys($.props), Ee = 0; Ee < fe.length; Ee++) {
          var at = fe[Ee];
          if (at !== "children" && at !== "key") {
            Cr($), v("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", at), Cr(null);
            break;
          }
        }
        $.ref !== null && (Cr($), v("Invalid attribute `ref` supplied to `React.Fragment`."), Cr(null));
      }
    }
    function Vt($, fe, Ee, at, Tt, $t) {
      {
        var wt = k($);
        if (!wt) {
          var yt = "";
          ($ === void 0 || typeof $ == "object" && $ !== null && Object.keys($).length === 0) && (yt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Mn = Ae(Tt);
          Mn ? yt += Mn : yt += _e();
          var Ht;
          $ === null ? Ht = "null" : Ke($) ? Ht = "array" : $ !== void 0 && $.$$typeof === t ? (Ht = "<" + (U($.type) || "Unknown") + " />", yt = " Did you accidentally export a JSX literal instead of a component?") : Ht = typeof $, v("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ht, yt);
        }
        var Xt = an($, fe, Ee, Tt, $t);
        if (Xt == null)
          return Xt;
        if (wt) {
          var ir = fe.children;
          if (ir !== void 0)
            if (at)
              if (Ke(ir)) {
                for (var Fa = 0; Fa < ir.length; Fa++)
                  lt(ir[Fa], $);
                Object.freeze && Object.freeze(ir);
              } else
                v("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              lt(ir, $);
        }
        return $ === r ? Dt(Xt) : ht(Xt), Xt;
      }
    }
    function Fn($, fe, Ee) {
      return Vt($, fe, Ee, !0);
    }
    function fr($, fe, Ee) {
      return Vt($, fe, Ee, !1);
    }
    var zf = fr, dA = Fn;
    cs.Fragment = r, cs.jsx = zf, cs.jsxs = dA;
  }()), cs;
}
process.env.NODE_ENV === "production" ? Qp.exports = vA() : Qp.exports = bA();
var F = Qp.exports;
function ut() {
  return ut = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ut.apply(this, arguments);
}
function xd(e, t = []) {
  let n = [];
  function r(a, o) {
    const s = /* @__PURE__ */ _r(o), l = n.length;
    n = [
      ...n,
      o
    ];
    function c(d) {
      const { scope: p, children: f, ...h } = d, m = (p == null ? void 0 : p[e][l]) || s, y = va(
        () => h,
        Object.values(h)
      );
      return /* @__PURE__ */ Ue(m.Provider, {
        value: y
      }, f);
    }
    function u(d, p) {
      const f = (p == null ? void 0 : p[e][l]) || s, h = Er(f);
      if (h)
        return h;
      if (o !== void 0)
        return o;
      throw new Error(`\`${d}\` must be used within \`${a}\``);
    }
    return c.displayName = a + "Provider", [
      c,
      u
    ];
  }
  const i = () => {
    const a = n.map((o) => /* @__PURE__ */ _r(o));
    return function(s) {
      const l = (s == null ? void 0 : s[e]) || a;
      return va(
        () => ({
          [`__scope${e}`]: {
            ...s,
            [e]: l
          }
        }),
        [
          s,
          l
        ]
      );
    };
  };
  return i.scopeName = e, [
    r,
    wA(i, ...t)
  ];
}
function wA(...e) {
  const t = e[0];
  if (e.length === 1)
    return t;
  const n = () => {
    const r = e.map(
      (i) => ({
        useScope: i(),
        scopeName: i.scopeName
      })
    );
    return function(a) {
      const o = r.reduce((s, { useScope: l, scopeName: c }) => {
        const d = l(a)[`__scope${c}`];
        return {
          ...s,
          ...d
        };
      }, {});
      return va(
        () => ({
          [`__scope${t.scopeName}`]: o
        }),
        [
          o
        ]
      );
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Nn(e) {
  const t = Xe(e);
  return Be(() => {
    t.current = e;
  }), va(
    () => (...n) => {
      var r;
      return (r = t.current) === null || r === void 0 ? void 0 : r.call(t, ...n);
    },
    []
  );
}
const go = globalThis != null && globalThis.document ? sl : () => {
};
function xA(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function R0(...e) {
  return (t) => e.forEach(
    (n) => xA(n, t)
  );
}
function nr(...e) {
  return nn(R0(...e), e);
}
const Sm = /* @__PURE__ */ ze((e, t) => {
  const { children: n, ...r } = e, i = io.toArray(n), a = i.find(SA);
  if (a) {
    const o = a.props.children, s = i.map((l) => l === a ? io.count(o) > 1 ? io.only(null) : /* @__PURE__ */ Rs(o) ? o.props.children : null : l);
    return /* @__PURE__ */ Ue(eh, ut({}, r, {
      ref: t
    }), /* @__PURE__ */ Rs(o) ? /* @__PURE__ */ wd(o, void 0, s) : null);
  }
  return /* @__PURE__ */ Ue(eh, ut({}, r, {
    ref: t
  }), n);
});
Sm.displayName = "Slot";
const eh = /* @__PURE__ */ ze((e, t) => {
  const { children: n, ...r } = e;
  return /* @__PURE__ */ Rs(n) ? /* @__PURE__ */ wd(n, {
    ...EA(r, n.props),
    ref: t ? R0(t, n.ref) : n.ref
  }) : io.count(n) > 1 ? io.only(null) : null;
});
eh.displayName = "SlotClone";
const _A = ({ children: e }) => /* @__PURE__ */ Ue(Di, null, e);
function SA(e) {
  return /* @__PURE__ */ Rs(e) && e.type === _A;
}
function EA(e, t) {
  const n = {
    ...t
  };
  for (const r in t) {
    const i = e[r], a = t[r];
    /^on[A-Z]/.test(r) ? i && a ? n[r] = (...s) => {
      a(...s), i(...s);
    } : i && (n[r] = i) : r === "style" ? n[r] = {
      ...i,
      ...a
    } : r === "className" && (n[r] = [
      i,
      a
    ].filter(Boolean).join(" "));
  }
  return {
    ...e,
    ...n
  };
}
const kA = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], _n = kA.reduce((e, t) => {
  const n = /* @__PURE__ */ ze((r, i) => {
    const { asChild: a, ...o } = r, s = a ? Sm : t;
    return Be(() => {
      window[Symbol.for("radix-ui")] = !0;
    }, []), /* @__PURE__ */ Ue(s, ut({}, o, {
      ref: i
    }));
  });
  return n.displayName = `Primitive.${t}`, {
    ...e,
    [t]: n
  };
}, {});
function TA(e, t) {
  e && $0(
    () => e.dispatchEvent(t)
  );
}
const P0 = "Avatar", [CA, Ode] = xd(P0), [OA, I0] = CA(P0), M0 = /* @__PURE__ */ ze((e, t) => {
  const { __scopeAvatar: n, ...r } = e, [i, a] = De("idle");
  return /* @__PURE__ */ Ue(OA, {
    scope: n,
    imageLoadingStatus: i,
    onImageLoadingStatusChange: a
  }, /* @__PURE__ */ Ue(_n.span, ut({}, r, {
    ref: t
  })));
}), AA = "AvatarImage", N0 = /* @__PURE__ */ ze((e, t) => {
  const { __scopeAvatar: n, src: r, onLoadingStatusChange: i = () => {
  }, ...a } = e, o = I0(AA, n), s = RA(r), l = Nn((c) => {
    i(c), o.onImageLoadingStatusChange(c);
  });
  return go(() => {
    s !== "idle" && l(s);
  }, [
    s,
    l
  ]), s === "loaded" ? /* @__PURE__ */ Ue(_n.img, ut({}, a, {
    ref: t,
    src: r
  })) : null;
}), $A = "AvatarFallback", D0 = /* @__PURE__ */ ze((e, t) => {
  const { __scopeAvatar: n, delayMs: r, ...i } = e, a = I0($A, n), [o, s] = De(r === void 0);
  return Be(() => {
    if (r !== void 0) {
      const l = window.setTimeout(
        () => s(!0),
        r
      );
      return () => window.clearTimeout(l);
    }
  }, [
    r
  ]), o && a.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ Ue(_n.span, ut({}, i, {
    ref: t
  })) : null;
});
function RA(e) {
  const [t, n] = De("idle");
  return Be(() => {
    if (!e) {
      n("error");
      return;
    }
    let r = !0;
    const i = new window.Image(), a = (o) => () => {
      r && n(o);
    };
    return n("loading"), i.onload = a("loaded"), i.onerror = a("error"), i.src = e, () => {
      r = !1;
    };
  }, [
    e
  ]), t;
}
let Em = class {
  constructor() {
    _(this, "eventMap");
    this.eventMap = {};
  }
  on(t, n) {
    var r;
    return this.eventMap[t] || (this.eventMap[t] = /* @__PURE__ */ new Set()), (r = this.eventMap[t]) == null || r.add(n), () => {
      var i;
      (i = this.eventMap[t]) == null || i.delete(n);
    };
  }
  emit(t, n) {
    var r, i;
    (r = this.eventMap[t]) == null || r.forEach((a) => {
      a(n);
    }), (i = this.eventMap["*"]) == null || i.forEach((a) => {
      a({ type: t, payload: n });
    });
  }
};
const PA = new Em();
function L0(e, t) {
  let n = 0;
  if (e.length == 0)
    return n;
  for (let r = 0; r < e.length; r++) {
    const i = e.charCodeAt(r);
    n = (n << 5) - n + i, n = n & n;
  }
  return Math.abs(n) % t;
}
const j0 = ze(
  ({ userId: e, src: t, container: n, image: r, fallback: i, ...a }, o) => {
    const s = L0(e ?? "", 15);
    return /* @__PURE__ */ F.jsxs(M0, { ref: o, "data-color": s, ...n, ...a, children: [
      /* @__PURE__ */ F.jsx(N0, { src: t, ...r }),
      /* @__PURE__ */ F.jsx(D0, { ...i, children: typeof a.children == "string" ? a.children[0] : a.children })
    ] });
  }
);
function IA(e, t) {
  const n = t || {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const MA = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, NA = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, DA = {};
function Oy(e, t) {
  return ((t || DA).jsx ? NA : MA).test(e);
}
const LA = /[ \t\n\f\r]/g;
function jA(e) {
  return typeof e == "object" ? e.type === "text" ? Ay(e.value) : !1 : Ay(e);
}
function Ay(e) {
  return e.replace(LA, "") === "";
}
class ll {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
ll.prototype.property = {};
ll.prototype.normal = {};
ll.prototype.space = null;
function U0(e, t) {
  const n = {}, r = {};
  let i = -1;
  for (; ++i < e.length; )
    Object.assign(n, e[i].property), Object.assign(r, e[i].normal);
  return new ll(n, r, t);
}
function th(e) {
  return e.toLowerCase();
}
class ur {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
ur.prototype.space = null;
ur.prototype.boolean = !1;
ur.prototype.booleanish = !1;
ur.prototype.overloadedBoolean = !1;
ur.prototype.number = !1;
ur.prototype.commaSeparated = !1;
ur.prototype.spaceSeparated = !1;
ur.prototype.commaOrSpaceSeparated = !1;
ur.prototype.mustUseProperty = !1;
ur.prototype.defined = !1;
let UA = 0;
const ft = Pa(), tn = Pa(), F0 = Pa(), me = Pa(), Lt = Pa(), ao = Pa(), Kn = Pa();
function Pa() {
  return 2 ** ++UA;
}
const nh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: ft,
  booleanish: tn,
  commaOrSpaceSeparated: Kn,
  commaSeparated: ao,
  number: me,
  overloadedBoolean: F0,
  spaceSeparated: Lt
}, Symbol.toStringTag, { value: "Module" })), Zf = Object.keys(nh);
class km extends ur {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, i) {
    let a = -1;
    if (super(t, n), $y(this, "space", i), typeof r == "number")
      for (; ++a < Zf.length; ) {
        const o = Zf[a];
        $y(this, Zf[a], (r & nh[o]) === nh[o]);
      }
  }
}
km.prototype.defined = !0;
function $y(e, t, n) {
  n && (e[t] = n);
}
const FA = {}.hasOwnProperty;
function zo(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (FA.call(e.properties, r)) {
      const i = e.properties[r], a = new km(
        r,
        e.transform(e.attributes || {}, r),
        i,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (a.mustUseProperty = !0), t[r] = a, n[th(r)] = r, n[th(a.attribute)] = r;
    }
  return new ll(t, n, e.space);
}
const B0 = zo({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), z0 = zo({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Z0(e, t) {
  return t in e ? e[t] : t;
}
function q0(e, t) {
  return Z0(e, t.toLowerCase());
}
const W0 = zo({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: q0,
  properties: { xmlns: null, xmlnsXLink: null }
}), V0 = zo({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: tn,
    ariaAutoComplete: null,
    ariaBusy: tn,
    ariaChecked: tn,
    ariaColCount: me,
    ariaColIndex: me,
    ariaColSpan: me,
    ariaControls: Lt,
    ariaCurrent: null,
    ariaDescribedBy: Lt,
    ariaDetails: null,
    ariaDisabled: tn,
    ariaDropEffect: Lt,
    ariaErrorMessage: null,
    ariaExpanded: tn,
    ariaFlowTo: Lt,
    ariaGrabbed: tn,
    ariaHasPopup: null,
    ariaHidden: tn,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Lt,
    ariaLevel: me,
    ariaLive: null,
    ariaModal: tn,
    ariaMultiLine: tn,
    ariaMultiSelectable: tn,
    ariaOrientation: null,
    ariaOwns: Lt,
    ariaPlaceholder: null,
    ariaPosInSet: me,
    ariaPressed: tn,
    ariaReadOnly: tn,
    ariaRelevant: null,
    ariaRequired: tn,
    ariaRoleDescription: Lt,
    ariaRowCount: me,
    ariaRowIndex: me,
    ariaRowSpan: me,
    ariaSelected: tn,
    ariaSetSize: me,
    ariaSort: null,
    ariaValueMax: me,
    ariaValueMin: me,
    ariaValueNow: me,
    ariaValueText: null,
    role: null
  }
}), BA = zo({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: q0,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: ao,
    acceptCharset: Lt,
    accessKey: Lt,
    action: null,
    allow: null,
    allowFullScreen: ft,
    allowPaymentRequest: ft,
    allowUserMedia: ft,
    alt: null,
    as: null,
    async: ft,
    autoCapitalize: null,
    autoComplete: Lt,
    autoFocus: ft,
    autoPlay: ft,
    capture: ft,
    charSet: null,
    checked: ft,
    cite: null,
    className: Lt,
    cols: me,
    colSpan: null,
    content: null,
    contentEditable: tn,
    controls: ft,
    controlsList: Lt,
    coords: me | ao,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: ft,
    defer: ft,
    dir: null,
    dirName: null,
    disabled: ft,
    download: F0,
    draggable: tn,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: ft,
    formTarget: null,
    headers: Lt,
    height: me,
    hidden: ft,
    high: me,
    href: null,
    hrefLang: null,
    htmlFor: Lt,
    httpEquiv: Lt,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: ft,
    itemId: null,
    itemProp: Lt,
    itemRef: Lt,
    itemScope: ft,
    itemType: Lt,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: ft,
    low: me,
    manifest: null,
    max: null,
    maxLength: me,
    media: null,
    method: null,
    min: null,
    minLength: me,
    multiple: ft,
    muted: ft,
    name: null,
    nonce: null,
    noModule: ft,
    noValidate: ft,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: ft,
    optimum: me,
    pattern: null,
    ping: Lt,
    placeholder: null,
    playsInline: ft,
    poster: null,
    preload: null,
    readOnly: ft,
    referrerPolicy: null,
    rel: Lt,
    required: ft,
    reversed: ft,
    rows: me,
    rowSpan: me,
    sandbox: Lt,
    scope: null,
    scoped: ft,
    seamless: ft,
    selected: ft,
    shape: null,
    size: me,
    sizes: null,
    slot: null,
    span: me,
    spellCheck: tn,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: me,
    step: null,
    style: null,
    tabIndex: me,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: ft,
    useMap: null,
    value: tn,
    width: me,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Lt,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: me,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: me,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: ft,
    // Lists. Use CSS to reduce space between items instead
    declare: ft,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: me,
    // `<img>` and `<object>`
    leftMargin: me,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: me,
    // `<body>`
    marginWidth: me,
    // `<body>`
    noResize: ft,
    // `<frame>`
    noHref: ft,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: ft,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: ft,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: me,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: tn,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: me,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: me,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: ft,
    disableRemotePlayback: ft,
    prefix: null,
    property: null,
    results: me,
    security: null,
    unselectable: null
  }
}), zA = zo({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Z0,
  properties: {
    about: Kn,
    accentHeight: me,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: me,
    amplitude: me,
    arabicForm: null,
    ascent: me,
    attributeName: null,
    attributeType: null,
    azimuth: me,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: me,
    by: null,
    calcMode: null,
    capHeight: me,
    className: Lt,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: me,
    diffuseConstant: me,
    direction: null,
    display: null,
    dur: null,
    divisor: me,
    dominantBaseline: null,
    download: ft,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: me,
    enableBackground: null,
    end: null,
    event: null,
    exponent: me,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: me,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: ao,
    g2: ao,
    glyphName: ao,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: me,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: me,
    horizOriginX: me,
    horizOriginY: me,
    id: null,
    ideographic: me,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: me,
    k: me,
    k1: me,
    k2: me,
    k3: me,
    k4: me,
    kernelMatrix: Kn,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: me,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: me,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: me,
    overlineThickness: me,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: me,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Lt,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: me,
    pointsAtY: me,
    pointsAtZ: me,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Kn,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Kn,
    rev: Kn,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Kn,
    requiredFeatures: Kn,
    requiredFonts: Kn,
    requiredFormats: Kn,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: me,
    specularExponent: me,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: me,
    strikethroughThickness: me,
    string: null,
    stroke: null,
    strokeDashArray: Kn,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: me,
    strokeOpacity: me,
    strokeWidth: null,
    style: null,
    surfaceScale: me,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Kn,
    tabIndex: me,
    tableValues: null,
    target: null,
    targetX: me,
    targetY: me,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Kn,
    to: null,
    transform: null,
    u1: null,
    u2: null,
    underlinePosition: me,
    underlineThickness: me,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: me,
    values: null,
    vAlphabetic: me,
    vMathematical: me,
    vectorEffect: null,
    vHanging: me,
    vIdeographic: me,
    version: null,
    vertAdvY: me,
    vertOriginX: me,
    vertOriginY: me,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: me,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), ZA = /^data[-\w.:]+$/i, Ry = /-[a-z]/g, qA = /[A-Z]/g;
function WA(e, t) {
  const n = th(t);
  let r = t, i = ur;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && ZA.test(t)) {
    if (t.charAt(4) === "-") {
      const a = t.slice(5).replace(Ry, HA);
      r = "data" + a.charAt(0).toUpperCase() + a.slice(1);
    } else {
      const a = t.slice(4);
      if (!Ry.test(a)) {
        let o = a.replace(qA, VA);
        o.charAt(0) !== "-" && (o = "-" + o), t = "data" + o;
      }
    }
    i = km;
  }
  return new i(r, t);
}
function VA(e) {
  return "-" + e.toLowerCase();
}
function HA(e) {
  return e.charAt(1).toUpperCase();
}
const KA = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, GA = U0([z0, B0, W0, V0, BA], "html"), Tm = U0([z0, B0, W0, V0, zA], "svg");
function JA(e) {
  return e.join(" ").trim();
}
var H0 = {}, Py = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, YA = /\n/g, XA = /^\s*/, QA = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, e$ = /^:\s*/, t$ = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, n$ = /^[;\s]*/, r$ = /^\s+|\s+$/g, i$ = `
`, Iy = "/", My = "*", sa = "", a$ = "comment", o$ = "declaration", s$ = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  t = t || {};
  var n = 1, r = 1;
  function i(h) {
    var m = h.match(YA);
    m && (n += m.length);
    var y = h.lastIndexOf(i$);
    r = ~y ? h.length - y : r + h.length;
  }
  function a() {
    var h = { line: n, column: r };
    return function(m) {
      return m.position = new o(h), c(), m;
    };
  }
  function o(h) {
    this.start = h, this.end = { line: n, column: r }, this.source = t.source;
  }
  o.prototype.content = e;
  function s(h) {
    var m = new Error(
      t.source + ":" + n + ":" + r + ": " + h
    );
    if (m.reason = h, m.filename = t.source, m.line = n, m.column = r, m.source = e, !t.silent)
      throw m;
  }
  function l(h) {
    var m = h.exec(e);
    if (m) {
      var y = m[0];
      return i(y), e = e.slice(y.length), m;
    }
  }
  function c() {
    l(XA);
  }
  function u(h) {
    var m;
    for (h = h || []; m = d(); )
      m !== !1 && h.push(m);
    return h;
  }
  function d() {
    var h = a();
    if (!(Iy != e.charAt(0) || My != e.charAt(1))) {
      for (var m = 2; sa != e.charAt(m) && (My != e.charAt(m) || Iy != e.charAt(m + 1)); )
        ++m;
      if (m += 2, sa === e.charAt(m - 1))
        return s("End of comment missing");
      var y = e.slice(2, m - 2);
      return r += 2, i(y), e = e.slice(m), r += 2, h({
        type: a$,
        comment: y
      });
    }
  }
  function p() {
    var h = a(), m = l(QA);
    if (m) {
      if (d(), !l(e$))
        return s("property missing ':'");
      var y = l(t$), g = h({
        type: o$,
        property: Ny(m[0].replace(Py, sa)),
        value: y ? Ny(y[0].replace(Py, sa)) : sa
      });
      return l(n$), g;
    }
  }
  function f() {
    var h = [];
    u(h);
    for (var m; m = p(); )
      m !== !1 && (h.push(m), u(h));
    return h;
  }
  return c(), f();
};
function Ny(e) {
  return e ? e.replace(r$, sa) : sa;
}
var l$ = Je && Je.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(H0, "__esModule", { value: !0 });
var c$ = l$(s$);
function u$(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, c$.default)(e), i = typeof t == "function";
  return r.forEach(function(a) {
    if (a.type === "declaration") {
      var o = a.property, s = a.value;
      i ? t(o, s, a) : s && (n = n || {}, n[o] = s);
    }
  }), n;
}
var Dy = H0.default = u$;
const d$ = Dy.default || Dy, K0 = G0("end"), Cm = G0("start");
function G0(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function f$(e) {
  const t = Cm(e), n = K0(e);
  if (t && n)
    return { start: t, end: n };
}
function _s(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? Ly(e.position) : "start" in e || "end" in e ? Ly(e) : "line" in e || "column" in e ? rh(e) : "";
}
function rh(e) {
  return jy(e && e.line) + ":" + jy(e && e.column);
}
function Ly(e) {
  return rh(e && e.start) + "-" + rh(e && e.end);
}
function jy(e) {
  return e && typeof e == "number" ? e : 1;
}
class In extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let i = "", a = {}, o = !1;
    if (n && ("line" in n && "column" in n ? a = { place: n } : "start" in n && "end" in n ? a = { place: n } : "type" in n ? a = {
      ancestors: [n],
      place: n.position
    } : a = { ...n }), typeof t == "string" ? i = t : !a.cause && t && (o = !0, i = t.message, a.cause = t), !a.ruleId && !a.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? a.ruleId = r : (a.source = r.slice(0, l), a.ruleId = r.slice(l + 1));
    }
    if (!a.place && a.ancestors && a.ancestors) {
      const l = a.ancestors[a.ancestors.length - 1];
      l && (a.place = l.position);
    }
    const s = a.place && "start" in a.place ? a.place.start : a.place;
    this.ancestors = a.ancestors || void 0, this.cause = a.cause || void 0, this.column = s ? s.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = s ? s.line : void 0, this.name = _s(a.place) || "1:1", this.place = a.place || void 0, this.reason = this.message, this.ruleId = a.ruleId || void 0, this.source = a.source || void 0, this.stack = o && a.cause && typeof a.cause.stack == "string" ? a.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
In.prototype.file = "";
In.prototype.name = "";
In.prototype.reason = "";
In.prototype.message = "";
In.prototype.stack = "";
In.prototype.column = void 0;
In.prototype.line = void 0;
In.prototype.ancestors = void 0;
In.prototype.cause = void 0;
In.prototype.fatal = void 0;
In.prototype.place = void 0;
In.prototype.ruleId = void 0;
In.prototype.source = void 0;
const Om = {}.hasOwnProperty, p$ = /* @__PURE__ */ new Map(), h$ = /[A-Z]/g, m$ = /-([a-z])/g, g$ = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), y$ = /* @__PURE__ */ new Set(["td", "th"]), J0 = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function v$(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = T$(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = k$(n, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? Tm : GA,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, a = Y0(i, e, void 0);
  return a && typeof a != "string" ? a : i.create(
    e,
    i.Fragment,
    { children: a || void 0 },
    void 0
  );
}
function Y0(e, t, n) {
  if (t.type === "element")
    return b$(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return w$(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return _$(e, t, n);
  if (t.type === "mdxjsEsm")
    return x$(e, t);
  if (t.type === "root")
    return S$(e, t, n);
  if (t.type === "text")
    return E$(e, t);
}
function b$(e, t, n) {
  const r = e.schema;
  let i = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = Tm, e.schema = i), e.ancestors.push(t);
  const a = Q0(e, t.tagName, !1), o = C$(e, t);
  let s = $m(e, t);
  return g$.has(t.tagName) && (s = s.filter(function(l) {
    return typeof l == "string" ? !jA(l) : !0;
  })), X0(e, o, a, t), Am(o, s), e.ancestors.pop(), e.schema = r, e.create(t, a, o, n);
}
function w$(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  Ps(e, t.position);
}
function x$(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Ps(e, t.position);
}
function _$(e, t, n) {
  const r = e.schema;
  let i = r;
  t.name === "svg" && r.space === "html" && (i = Tm, e.schema = i), e.ancestors.push(t);
  const a = t.name === null ? e.Fragment : Q0(e, t.name, !0), o = O$(e, t), s = $m(e, t);
  return X0(e, o, a, t), Am(o, s), e.ancestors.pop(), e.schema = r, e.create(t, a, o, n);
}
function S$(e, t, n) {
  const r = {};
  return Am(r, $m(e, t)), e.create(t, e.Fragment, r, n);
}
function E$(e, t) {
  return t.value;
}
function X0(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function Am(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function k$(e, t, n) {
  return r;
  function r(i, a, o, s) {
    const c = Array.isArray(o.children) ? n : t;
    return s ? c(a, o, s) : c(a, o);
  }
}
function T$(e, t) {
  return n;
  function n(r, i, a, o) {
    const s = Array.isArray(a.children), l = Cm(r);
    return t(
      i,
      a,
      o,
      s,
      {
        columnNumber: l ? l.column - 1 : void 0,
        fileName: e,
        lineNumber: l ? l.line : void 0
      },
      void 0
    );
  }
}
function C$(e, t) {
  const n = {};
  let r, i;
  for (i in t.properties)
    if (i !== "children" && Om.call(t.properties, i)) {
      const a = A$(e, i, t.properties[i]);
      if (a) {
        const [o, s] = a;
        e.tableCellAlignToStyle && o === "align" && typeof s == "string" && y$.has(t.tagName) ? r = s : n[o] = s;
      }
    }
  if (r) {
    const a = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    a[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function O$(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const a = r.data.estree.body[0];
        a.type;
        const o = a.expression;
        o.type;
        const s = o.properties[0];
        s.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(s.argument)
        );
      } else
        Ps(e, t.position);
    else {
      const i = r.name;
      let a;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const s = r.value.data.estree.body[0];
          s.type, a = e.evaluater.evaluateExpression(s.expression);
        } else
          Ps(e, t.position);
      else
        a = r.value === null ? !0 : r.value;
      n[i] = /** @type {Props[keyof Props]} */
      a;
    }
  return n;
}
function $m(e, t) {
  const n = [];
  let r = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : p$;
  for (; ++r < t.children.length; ) {
    const a = t.children[r];
    let o;
    if (e.passKeys) {
      const l = a.type === "element" ? a.tagName : a.type === "mdxJsxFlowElement" || a.type === "mdxJsxTextElement" ? a.name : void 0;
      if (l) {
        const c = i.get(l) || 0;
        o = l + "-" + c, i.set(l, c + 1);
      }
    }
    const s = Y0(e, a, o);
    s !== void 0 && n.push(s);
  }
  return n;
}
function A$(e, t, n) {
  const r = WA(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? IA(n) : JA(n)), r.property === "style") {
      let i = typeof n == "object" ? n : $$(e, String(n));
      return e.stylePropertyNameCase === "css" && (i = R$(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? KA[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function $$(e, t) {
  const n = {};
  try {
    d$(t, r);
  } catch (i) {
    if (!e.ignoreInvalidStyle) {
      const a = (
        /** @type {Error} */
        i
      ), o = new In("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: a,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw o.file = e.filePath || void 0, o.url = J0 + "#cannot-parse-style-attribute", o;
    }
  }
  return n;
  function r(i, a) {
    let o = i;
    o.slice(0, 2) !== "--" && (o.slice(0, 4) === "-ms-" && (o = "ms-" + o.slice(4)), o = o.replace(m$, I$)), n[o] = a;
  }
}
function Q0(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let a = -1, o;
    for (; ++a < i.length; ) {
      const s = Oy(i[a]) ? { type: "Identifier", name: i[a] } : { type: "Literal", value: i[a] };
      o = o ? {
        type: "MemberExpression",
        object: o,
        property: s,
        computed: !!(a && s.type === "Literal"),
        optional: !1
      } : s;
    }
    r = o;
  } else
    r = Oy(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const i = (
      /** @type {keyof JSX.IntrinsicElements} */
      r.value
    );
    return Om.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Ps(e);
}
function Ps(e, t) {
  const n = new In(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = J0 + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function R$(e) {
  const t = {};
  let n;
  for (n in e)
    Om.call(e, n) && (t[P$(n)] = e[n]);
  return t;
}
function P$(e) {
  let t = e.replace(h$, M$);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function I$(e, t) {
  return t.toUpperCase();
}
function M$(e) {
  return "-" + e.toLowerCase();
}
const qf = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, N$ = {};
function Rm(e, t) {
  const n = t || N$, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return ex(e, r, i);
}
function ex(e, t, n) {
  if (D$(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Uy(e.children, t, n);
  }
  return Array.isArray(e) ? Uy(e, t, n) : "";
}
function Uy(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; )
    r[i] = ex(e[i], t, n);
  return r.join("");
}
function D$(e) {
  return !!(e && typeof e == "object");
}
const Fy = document.createElement("i");
function Pm(e) {
  const t = "&" + e + ";";
  Fy.innerHTML = t;
  const n = Fy.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function Qn(e, t, n, r) {
  const i = e.length;
  let a = 0, o;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4)
    o = Array.from(r), o.unshift(t, n), e.splice(...o);
  else
    for (n && e.splice(t, n); a < r.length; )
      o = r.slice(a, a + 1e4), o.unshift(t, 0), e.splice(...o), a += 1e4, t += 1e4;
}
function or(e, t) {
  return e.length > 0 ? (Qn(e, e.length, 0, t), e) : t;
}
const By = {}.hasOwnProperty;
function tx(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    L$(t, e[n]);
  return t;
}
function L$(e, t) {
  let n;
  for (n in t) {
    const i = (By.call(e, n) ? e[n] : void 0) || (e[n] = {}), a = t[n];
    let o;
    if (a)
      for (o in a) {
        By.call(i, o) || (i[o] = []);
        const s = a[o];
        j$(
          // @ts-expect-error Looks like a list.
          i[o],
          Array.isArray(s) ? s : s ? [s] : []
        );
      }
  }
}
function j$(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Qn(e, 0, 0, r);
}
function nx(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function yr(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Dn = Gi(/[A-Za-z]/), Cn = Gi(/[\dA-Za-z]/), U$ = Gi(/[#-'*+\--9=?A-Z^-~]/);
function Kc(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const ih = Gi(/\d/), F$ = Gi(/[\dA-Fa-f]/), B$ = Gi(/[!-/:-@[-`{-~]/);
function Ge(e) {
  return e !== null && e < -2;
}
function Rt(e) {
  return e !== null && (e < 0 || e === 32);
}
function mt(e) {
  return e === -2 || e === -1 || e === 32;
}
const _d = Gi(/\p{P}|\p{S}/u), ba = Gi(/\s/);
function Gi(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function Zo(e) {
  const t = [];
  let n = -1, r = 0, i = 0;
  for (; ++n < e.length; ) {
    const a = e.charCodeAt(n);
    let o = "";
    if (a === 37 && Cn(e.charCodeAt(n + 1)) && Cn(e.charCodeAt(n + 2)))
      i = 2;
    else if (a < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(a)) || (o = String.fromCharCode(a));
    else if (a > 55295 && a < 57344) {
      const s = e.charCodeAt(n + 1);
      a < 56320 && s > 56319 && s < 57344 ? (o = String.fromCharCode(a, s), i = 1) : o = "";
    } else
      o = String.fromCharCode(a);
    o && (t.push(e.slice(r, n), encodeURIComponent(o)), r = n + i + 1, o = ""), i && (n += i, i = 0);
  }
  return t.join("") + e.slice(r);
}
function _t(e, t, n, r) {
  const i = r ? r - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return o;
  function o(l) {
    return mt(l) ? (e.enter(n), s(l)) : t(l);
  }
  function s(l) {
    return mt(l) && a++ < i ? (e.consume(l), s) : (e.exit(n), t(l));
  }
}
const z$ = {
  tokenize: Z$
};
function Z$(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    i
  );
  let n;
  return t;
  function r(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), _t(e, t, "linePrefix");
  }
  function i(s) {
    return e.enter("paragraph"), a(s);
  }
  function a(s) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, o(s);
  }
  function o(s) {
    if (s === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(s);
      return;
    }
    return Ge(s) ? (e.consume(s), e.exit("chunkText"), a) : (e.consume(s), o);
  }
}
const q$ = {
  tokenize: W$
}, zy = {
  tokenize: V$
};
function W$(e) {
  const t = this, n = [];
  let r = 0, i, a, o;
  return s;
  function s(b) {
    if (r < n.length) {
      const T = n[r];
      return t.containerState = T[1], e.attempt(
        T[0].continuation,
        l,
        c
      )(b);
    }
    return c(b);
  }
  function l(b) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && v();
      const T = t.events.length;
      let O = T, S;
      for (; O--; )
        if (t.events[O][0] === "exit" && t.events[O][1].type === "chunkFlow") {
          S = t.events[O][1].end;
          break;
        }
      g(r);
      let P = T;
      for (; P < t.events.length; )
        t.events[P][1].end = Object.assign({}, S), P++;
      return Qn(
        t.events,
        O + 1,
        0,
        t.events.slice(T)
      ), t.events.length = P, c(b);
    }
    return s(b);
  }
  function c(b) {
    if (r === n.length) {
      if (!i)
        return p(b);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return h(b);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      zy,
      u,
      d
    )(b);
  }
  function u(b) {
    return i && v(), g(r), p(b);
  }
  function d(b) {
    return t.parser.lazy[t.now().line] = r !== n.length, o = t.now().offset, h(b);
  }
  function p(b) {
    return t.containerState = {}, e.attempt(
      zy,
      f,
      h
    )(b);
  }
  function f(b) {
    return r++, n.push([t.currentConstruct, t.containerState]), p(b);
  }
  function h(b) {
    if (b === null) {
      i && v(), g(0), e.consume(b);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: a,
      _tokenizer: i
    }), m(b);
  }
  function m(b) {
    if (b === null) {
      y(e.exit("chunkFlow"), !0), g(0), e.consume(b);
      return;
    }
    return Ge(b) ? (e.consume(b), y(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, s) : (e.consume(b), m);
  }
  function y(b, T) {
    const O = t.sliceStream(b);
    if (T && O.push(null), b.previous = a, a && (a.next = b), a = b, i.defineSkip(b.start), i.write(O), t.parser.lazy[b.start.line]) {
      let S = i.events.length;
      for (; S--; )
        if (
          // The token starts before the line ending
          i.events[S][1].start.offset < o && // and either is not ended yet
          (!i.events[S][1].end || // or ends after it.
          i.events[S][1].end.offset > o)
        )
          return;
      const P = t.events.length;
      let M = P, L, k;
      for (; M--; )
        if (t.events[M][0] === "exit" && t.events[M][1].type === "chunkFlow") {
          if (L) {
            k = t.events[M][1].end;
            break;
          }
          L = !0;
        }
      for (g(r), S = P; S < t.events.length; )
        t.events[S][1].end = Object.assign({}, k), S++;
      Qn(
        t.events,
        M + 1,
        0,
        t.events.slice(P)
      ), t.events.length = S;
    }
  }
  function g(b) {
    let T = n.length;
    for (; T-- > b; ) {
      const O = n[T];
      t.containerState = O[1], O[0].exit.call(t, e);
    }
    n.length = b;
  }
  function v() {
    i.write([null]), a = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function V$(e, t, n) {
  return _t(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function Gc(e) {
  if (e === null || Rt(e) || ba(e))
    return 1;
  if (_d(e))
    return 2;
}
function Sd(e, t, n) {
  const r = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const a = e[i].resolveAll;
    a && !r.includes(a) && (t = a(t, n), r.push(a));
  }
  return t;
}
const ah = {
  name: "attention",
  tokenize: K$,
  resolveAll: H$
};
function H$(e, t) {
  let n = -1, r, i, a, o, s, l, c, u;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          l = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const d = Object.assign({}, e[r][1].end), p = Object.assign({}, e[n][1].start);
          Zy(d, -l), Zy(p, l), o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: d,
            end: Object.assign({}, e[r][1].end)
          }, s = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: p
          }, a = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, i = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, o.start),
            end: Object.assign({}, s.end)
          }, e[r][1].end = Object.assign({}, o.start), e[n][1].start = Object.assign({}, s.end), c = [], e[r][1].end.offset - e[r][1].start.offset && (c = or(c, [
            ["enter", e[r][1], t],
            ["exit", e[r][1], t]
          ])), c = or(c, [
            ["enter", i, t],
            ["enter", o, t],
            ["exit", o, t],
            ["enter", a, t]
          ]), c = or(
            c,
            Sd(
              t.parser.constructs.insideSpan.null,
              e.slice(r + 1, n),
              t
            )
          ), c = or(c, [
            ["exit", a, t],
            ["enter", s, t],
            ["exit", s, t],
            ["exit", i, t]
          ]), e[n][1].end.offset - e[n][1].start.offset ? (u = 2, c = or(c, [
            ["enter", e[n][1], t],
            ["exit", e[n][1], t]
          ])) : u = 0, Qn(e, r - 1, n - r + 3, c), n = r + c.length - u - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function K$(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = Gc(r);
  let a;
  return o;
  function o(l) {
    return a = l, e.enter("attentionSequence"), s(l);
  }
  function s(l) {
    if (l === a)
      return e.consume(l), s;
    const c = e.exit("attentionSequence"), u = Gc(l), d = !u || u === 2 && i || n.includes(l), p = !i || i === 2 && u || n.includes(r);
    return c._open = !!(a === 42 ? d : d && (i || !p)), c._close = !!(a === 42 ? p : p && (u || !d)), t(l);
  }
}
function Zy(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const G$ = {
  name: "autolink",
  tokenize: J$
};
function J$(e, t, n) {
  let r = 0;
  return i;
  function i(f) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), a;
  }
  function a(f) {
    return Dn(f) ? (e.consume(f), o) : c(f);
  }
  function o(f) {
    return f === 43 || f === 45 || f === 46 || Cn(f) ? (r = 1, s(f)) : c(f);
  }
  function s(f) {
    return f === 58 ? (e.consume(f), r = 0, l) : (f === 43 || f === 45 || f === 46 || Cn(f)) && r++ < 32 ? (e.consume(f), s) : (r = 0, c(f));
  }
  function l(f) {
    return f === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.exit("autolink"), t) : f === null || f === 32 || f === 60 || Kc(f) ? n(f) : (e.consume(f), l);
  }
  function c(f) {
    return f === 64 ? (e.consume(f), u) : U$(f) ? (e.consume(f), c) : n(f);
  }
  function u(f) {
    return Cn(f) ? d(f) : n(f);
  }
  function d(f) {
    return f === 46 ? (e.consume(f), r = 0, u) : f === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.exit("autolink"), t) : p(f);
  }
  function p(f) {
    if ((f === 45 || Cn(f)) && r++ < 63) {
      const h = f === 45 ? p : d;
      return e.consume(f), h;
    }
    return n(f);
  }
}
const cl = {
  tokenize: Y$,
  partial: !0
};
function Y$(e, t, n) {
  return r;
  function r(a) {
    return mt(a) ? _t(e, i, "linePrefix")(a) : i(a);
  }
  function i(a) {
    return a === null || Ge(a) ? t(a) : n(a);
  }
}
const rx = {
  name: "blockQuote",
  tokenize: X$,
  continuation: {
    tokenize: Q$
  },
  exit: eR
};
function X$(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    if (o === 62) {
      const s = r.containerState;
      return s.open || (e.enter("blockQuote", {
        _container: !0
      }), s.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(o), e.exit("blockQuoteMarker"), a;
    }
    return n(o);
  }
  function a(o) {
    return mt(o) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(o), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(o));
  }
}
function Q$(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return mt(o) ? _t(
      e,
      a,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(o) : a(o);
  }
  function a(o) {
    return e.attempt(rx, t, n)(o);
  }
}
function eR(e) {
  e.exit("blockQuote");
}
const ix = {
  name: "characterEscape",
  tokenize: tR
};
function tR(e, t, n) {
  return r;
  function r(a) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(a), e.exit("escapeMarker"), i;
  }
  function i(a) {
    return B$(a) ? (e.enter("characterEscapeValue"), e.consume(a), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(a);
  }
}
const ax = {
  name: "characterReference",
  tokenize: nR
};
function nR(e, t, n) {
  const r = this;
  let i = 0, a, o;
  return s;
  function s(d) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), l;
  }
  function l(d) {
    return d === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(d), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("characterReferenceValue"), a = 31, o = Cn, u(d));
  }
  function c(d) {
    return d === 88 || d === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(d), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), a = 6, o = F$, u) : (e.enter("characterReferenceValue"), a = 7, o = ih, u(d));
  }
  function u(d) {
    if (d === 59 && i) {
      const p = e.exit("characterReferenceValue");
      return o === Cn && !Pm(r.sliceSerialize(p)) ? n(d) : (e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return o(d) && i++ < a ? (e.consume(d), u) : n(d);
  }
}
const qy = {
  tokenize: iR,
  partial: !0
}, Wy = {
  name: "codeFenced",
  tokenize: rR,
  concrete: !0
};
function rR(e, t, n) {
  const r = this, i = {
    tokenize: O,
    partial: !0
  };
  let a = 0, o = 0, s;
  return l;
  function l(S) {
    return c(S);
  }
  function c(S) {
    const P = r.events[r.events.length - 1];
    return a = P && P[1].type === "linePrefix" ? P[2].sliceSerialize(P[1], !0).length : 0, s = S, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), u(S);
  }
  function u(S) {
    return S === s ? (o++, e.consume(S), u) : o < 3 ? n(S) : (e.exit("codeFencedFenceSequence"), mt(S) ? _t(e, d, "whitespace")(S) : d(S));
  }
  function d(S) {
    return S === null || Ge(S) ? (e.exit("codeFencedFence"), r.interrupt ? t(S) : e.check(qy, m, T)(S)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), p(S));
  }
  function p(S) {
    return S === null || Ge(S) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), d(S)) : mt(S) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), _t(e, f, "whitespace")(S)) : S === 96 && S === s ? n(S) : (e.consume(S), p);
  }
  function f(S) {
    return S === null || Ge(S) ? d(S) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), h(S));
  }
  function h(S) {
    return S === null || Ge(S) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), d(S)) : S === 96 && S === s ? n(S) : (e.consume(S), h);
  }
  function m(S) {
    return e.attempt(i, T, y)(S);
  }
  function y(S) {
    return e.enter("lineEnding"), e.consume(S), e.exit("lineEnding"), g;
  }
  function g(S) {
    return a > 0 && mt(S) ? _t(
      e,
      v,
      "linePrefix",
      a + 1
    )(S) : v(S);
  }
  function v(S) {
    return S === null || Ge(S) ? e.check(qy, m, T)(S) : (e.enter("codeFlowValue"), b(S));
  }
  function b(S) {
    return S === null || Ge(S) ? (e.exit("codeFlowValue"), v(S)) : (e.consume(S), b);
  }
  function T(S) {
    return e.exit("codeFenced"), t(S);
  }
  function O(S, P, M) {
    let L = 0;
    return k;
    function k(D) {
      return S.enter("lineEnding"), S.consume(D), S.exit("lineEnding"), I;
    }
    function I(D) {
      return S.enter("codeFencedFence"), mt(D) ? _t(
        S,
        B,
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(D) : B(D);
    }
    function B(D) {
      return D === s ? (S.enter("codeFencedFenceSequence"), U(D)) : M(D);
    }
    function U(D) {
      return D === s ? (L++, S.consume(D), U) : L >= o ? (S.exit("codeFencedFenceSequence"), mt(D) ? _t(S, z, "whitespace")(D) : z(D)) : M(D);
    }
    function z(D) {
      return D === null || Ge(D) ? (S.exit("codeFencedFence"), P(D)) : M(D);
    }
  }
}
function iR(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return o === null ? n(o) : (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), a);
  }
  function a(o) {
    return r.parser.lazy[r.now().line] ? n(o) : t(o);
  }
}
const Wf = {
  name: "codeIndented",
  tokenize: oR
}, aR = {
  tokenize: sR,
  partial: !0
};
function oR(e, t, n) {
  const r = this;
  return i;
  function i(c) {
    return e.enter("codeIndented"), _t(e, a, "linePrefix", 4 + 1)(c);
  }
  function a(c) {
    const u = r.events[r.events.length - 1];
    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? o(c) : n(c);
  }
  function o(c) {
    return c === null ? l(c) : Ge(c) ? e.attempt(aR, o, l)(c) : (e.enter("codeFlowValue"), s(c));
  }
  function s(c) {
    return c === null || Ge(c) ? (e.exit("codeFlowValue"), o(c)) : (e.consume(c), s);
  }
  function l(c) {
    return e.exit("codeIndented"), t(c);
  }
}
function sR(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return r.parser.lazy[r.now().line] ? n(o) : Ge(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), i) : _t(e, a, "linePrefix", 4 + 1)(o);
  }
  function a(o) {
    const s = r.events[r.events.length - 1];
    return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(o) : Ge(o) ? i(o) : n(o);
  }
}
const lR = {
  name: "codeText",
  tokenize: dR,
  resolve: cR,
  previous: uR
};
function cR(e) {
  let t = e.length - 4, n = 3, r, i;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0);
  return e;
}
function uR(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function dR(e, t, n) {
  let r = 0, i, a;
  return o;
  function o(d) {
    return e.enter("codeText"), e.enter("codeTextSequence"), s(d);
  }
  function s(d) {
    return d === 96 ? (e.consume(d), r++, s) : (e.exit("codeTextSequence"), l(d));
  }
  function l(d) {
    return d === null ? n(d) : d === 32 ? (e.enter("space"), e.consume(d), e.exit("space"), l) : d === 96 ? (a = e.enter("codeTextSequence"), i = 0, u(d)) : Ge(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), l) : (e.enter("codeTextData"), c(d));
  }
  function c(d) {
    return d === null || d === 32 || d === 96 || Ge(d) ? (e.exit("codeTextData"), l(d)) : (e.consume(d), c);
  }
  function u(d) {
    return d === 96 ? (e.consume(d), i++, u) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(d)) : (a.type = "codeTextData", c(d));
  }
}
function ox(e) {
  const t = {};
  let n = -1, r, i, a, o, s, l, c;
  for (; ++n < e.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = e[n], n && r[1].type === "chunkFlow" && e[n - 1][1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, a = 0, a < l.length && l[a][1].type === "lineEndingBlank" && (a += 2), a < l.length && l[a][1].type === "content"))
      for (; ++a < l.length && l[a][1].type !== "content"; )
        l[a][1].type === "chunkText" && (l[a][1]._isInFirstContentOfListItem = !0, a++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, fR(e, n)), n = t[n], c = !0);
    else if (r[1]._container) {
      for (a = n, i = void 0; a-- && (o = e[a], o[1].type === "lineEnding" || o[1].type === "lineEndingBlank"); )
        o[0] === "enter" && (i && (e[i][1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = a);
      i && (r[1].end = Object.assign({}, e[i][1].start), s = e.slice(i, n), s.unshift(r), Qn(e, i, n - i + 1, s));
    }
  }
  return !c;
}
function fR(e, t) {
  const n = e[t][1], r = e[t][2];
  let i = t - 1;
  const a = [], o = n._tokenizer || r.parser[n.contentType](n.start), s = o.events, l = [], c = {};
  let u, d, p = -1, f = n, h = 0, m = 0;
  const y = [m];
  for (; f; ) {
    for (; e[++i][1] !== f; )
      ;
    a.push(i), f._tokenizer || (u = r.sliceStream(f), f.next || u.push(null), d && o.defineSkip(f.start), f._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), f._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), d = f, f = f.next;
  }
  for (f = n; ++p < s.length; )
    // Find a void token that includes a break.
    s[p][0] === "exit" && s[p - 1][0] === "enter" && s[p][1].type === s[p - 1][1].type && s[p][1].start.line !== s[p][1].end.line && (m = p + 1, y.push(m), f._tokenizer = void 0, f.previous = void 0, f = f.next);
  for (o.events = [], f ? (f._tokenizer = void 0, f.previous = void 0) : y.pop(), p = y.length; p--; ) {
    const g = s.slice(y[p], y[p + 1]), v = a.pop();
    l.unshift([v, v + g.length - 1]), Qn(e, v, 2, g);
  }
  for (p = -1; ++p < l.length; )
    c[h + l[p][0]] = h + l[p][1], h += l[p][1] - l[p][0] - 1;
  return c;
}
const pR = {
  tokenize: gR,
  resolve: mR
}, hR = {
  tokenize: yR,
  partial: !0
};
function mR(e) {
  return ox(e), e;
}
function gR(e, t) {
  let n;
  return r;
  function r(s) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), i(s);
  }
  function i(s) {
    return s === null ? a(s) : Ge(s) ? e.check(
      hR,
      o,
      a
    )(s) : (e.consume(s), i);
  }
  function a(s) {
    return e.exit("chunkContent"), e.exit("content"), t(s);
  }
  function o(s) {
    return e.consume(s), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, i;
  }
}
function yR(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), _t(e, a, "linePrefix");
  }
  function a(o) {
    if (o === null || Ge(o))
      return n(o);
    const s = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(o) : e.interrupt(r.parser.constructs.flow, n, t)(o);
  }
}
function sx(e, t, n, r, i, a, o, s, l) {
  const c = l || Number.POSITIVE_INFINITY;
  let u = 0;
  return d;
  function d(g) {
    return g === 60 ? (e.enter(r), e.enter(i), e.enter(a), e.consume(g), e.exit(a), p) : g === null || g === 32 || g === 41 || Kc(g) ? n(g) : (e.enter(r), e.enter(o), e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), m(g));
  }
  function p(g) {
    return g === 62 ? (e.enter(a), e.consume(g), e.exit(a), e.exit(i), e.exit(r), t) : (e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), f(g));
  }
  function f(g) {
    return g === 62 ? (e.exit("chunkString"), e.exit(s), p(g)) : g === null || g === 60 || Ge(g) ? n(g) : (e.consume(g), g === 92 ? h : f);
  }
  function h(g) {
    return g === 60 || g === 62 || g === 92 ? (e.consume(g), f) : f(g);
  }
  function m(g) {
    return !u && (g === null || g === 41 || Rt(g)) ? (e.exit("chunkString"), e.exit(s), e.exit(o), e.exit(r), t(g)) : u < c && g === 40 ? (e.consume(g), u++, m) : g === 41 ? (e.consume(g), u--, m) : g === null || g === 32 || g === 40 || Kc(g) ? n(g) : (e.consume(g), g === 92 ? y : m);
  }
  function y(g) {
    return g === 40 || g === 41 || g === 92 ? (e.consume(g), m) : m(g);
  }
}
function lx(e, t, n, r, i, a) {
  const o = this;
  let s = 0, l;
  return c;
  function c(f) {
    return e.enter(r), e.enter(i), e.consume(f), e.exit(i), e.enter(a), u;
  }
  function u(f) {
    return s > 999 || f === null || f === 91 || f === 93 && !l || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    f === 94 && !s && "_hiddenFootnoteSupport" in o.parser.constructs ? n(f) : f === 93 ? (e.exit(a), e.enter(i), e.consume(f), e.exit(i), e.exit(r), t) : Ge(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), u) : (e.enter("chunkString", {
      contentType: "string"
    }), d(f));
  }
  function d(f) {
    return f === null || f === 91 || f === 93 || Ge(f) || s++ > 999 ? (e.exit("chunkString"), u(f)) : (e.consume(f), l || (l = !mt(f)), f === 92 ? p : d);
  }
  function p(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), s++, d) : d(f);
  }
}
function cx(e, t, n, r, i, a) {
  let o;
  return s;
  function s(p) {
    return p === 34 || p === 39 || p === 40 ? (e.enter(r), e.enter(i), e.consume(p), e.exit(i), o = p === 40 ? 41 : p, l) : n(p);
  }
  function l(p) {
    return p === o ? (e.enter(i), e.consume(p), e.exit(i), e.exit(r), t) : (e.enter(a), c(p));
  }
  function c(p) {
    return p === o ? (e.exit(a), l(o)) : p === null ? n(p) : Ge(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), _t(e, c, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), u(p));
  }
  function u(p) {
    return p === o || p === null || Ge(p) ? (e.exit("chunkString"), c(p)) : (e.consume(p), p === 92 ? d : u);
  }
  function d(p) {
    return p === o || p === 92 ? (e.consume(p), u) : u(p);
  }
}
function Ss(e, t) {
  let n;
  return r;
  function r(i) {
    return Ge(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : mt(i) ? _t(
      e,
      r,
      n ? "linePrefix" : "lineSuffix"
    )(i) : t(i);
  }
}
const vR = {
  name: "definition",
  tokenize: wR
}, bR = {
  tokenize: xR,
  partial: !0
};
function wR(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(f) {
    return e.enter("definition"), o(f);
  }
  function o(f) {
    return lx.call(
      r,
      e,
      s,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(f);
  }
  function s(f) {
    return i = yr(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), f === 58 ? (e.enter("definitionMarker"), e.consume(f), e.exit("definitionMarker"), l) : n(f);
  }
  function l(f) {
    return Rt(f) ? Ss(e, c)(f) : c(f);
  }
  function c(f) {
    return sx(
      e,
      u,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(f);
  }
  function u(f) {
    return e.attempt(bR, d, d)(f);
  }
  function d(f) {
    return mt(f) ? _t(e, p, "whitespace")(f) : p(f);
  }
  function p(f) {
    return f === null || Ge(f) ? (e.exit("definition"), r.parser.defined.push(i), t(f)) : n(f);
  }
}
function xR(e, t, n) {
  return r;
  function r(s) {
    return Rt(s) ? Ss(e, i)(s) : n(s);
  }
  function i(s) {
    return cx(
      e,
      a,
      n,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(s);
  }
  function a(s) {
    return mt(s) ? _t(e, o, "whitespace")(s) : o(s);
  }
  function o(s) {
    return s === null || Ge(s) ? t(s) : n(s);
  }
}
const _R = {
  name: "hardBreakEscape",
  tokenize: SR
};
function SR(e, t, n) {
  return r;
  function r(a) {
    return e.enter("hardBreakEscape"), e.consume(a), i;
  }
  function i(a) {
    return Ge(a) ? (e.exit("hardBreakEscape"), t(a)) : n(a);
  }
}
const ER = {
  name: "headingAtx",
  tokenize: TR,
  resolve: kR
};
function kR(e, t) {
  let n = e.length - 2, r = 3, i, a;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, a = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Qn(e, r, n - r + 1, [
    ["enter", i, t],
    ["enter", a, t],
    ["exit", a, t],
    ["exit", i, t]
  ])), e;
}
function TR(e, t, n) {
  let r = 0;
  return i;
  function i(u) {
    return e.enter("atxHeading"), a(u);
  }
  function a(u) {
    return e.enter("atxHeadingSequence"), o(u);
  }
  function o(u) {
    return u === 35 && r++ < 6 ? (e.consume(u), o) : u === null || Rt(u) ? (e.exit("atxHeadingSequence"), s(u)) : n(u);
  }
  function s(u) {
    return u === 35 ? (e.enter("atxHeadingSequence"), l(u)) : u === null || Ge(u) ? (e.exit("atxHeading"), t(u)) : mt(u) ? _t(e, s, "whitespace")(u) : (e.enter("atxHeadingText"), c(u));
  }
  function l(u) {
    return u === 35 ? (e.consume(u), l) : (e.exit("atxHeadingSequence"), s(u));
  }
  function c(u) {
    return u === null || u === 35 || Rt(u) ? (e.exit("atxHeadingText"), s(u)) : (e.consume(u), c);
  }
}
const CR = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Vy = ["pre", "script", "style", "textarea"], OR = {
  name: "htmlFlow",
  tokenize: PR,
  resolveTo: RR,
  concrete: !0
}, AR = {
  tokenize: MR,
  partial: !0
}, $R = {
  tokenize: IR,
  partial: !0
};
function RR(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function PR(e, t, n) {
  const r = this;
  let i, a, o, s, l;
  return c;
  function c(E) {
    return u(E);
  }
  function u(E) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(E), d;
  }
  function d(E) {
    return E === 33 ? (e.consume(E), p) : E === 47 ? (e.consume(E), a = !0, m) : E === 63 ? (e.consume(E), i = 3, r.interrupt ? t : x) : Dn(E) ? (e.consume(E), o = String.fromCharCode(E), y) : n(E);
  }
  function p(E) {
    return E === 45 ? (e.consume(E), i = 2, f) : E === 91 ? (e.consume(E), i = 5, s = 0, h) : Dn(E) ? (e.consume(E), i = 4, r.interrupt ? t : x) : n(E);
  }
  function f(E) {
    return E === 45 ? (e.consume(E), r.interrupt ? t : x) : n(E);
  }
  function h(E) {
    const ke = "CDATA[";
    return E === ke.charCodeAt(s++) ? (e.consume(E), s === ke.length ? r.interrupt ? t : B : h) : n(E);
  }
  function m(E) {
    return Dn(E) ? (e.consume(E), o = String.fromCharCode(E), y) : n(E);
  }
  function y(E) {
    if (E === null || E === 47 || E === 62 || Rt(E)) {
      const ke = E === 47, Ze = o.toLowerCase();
      return !ke && !a && Vy.includes(Ze) ? (i = 1, r.interrupt ? t(E) : B(E)) : CR.includes(o.toLowerCase()) ? (i = 6, ke ? (e.consume(E), g) : r.interrupt ? t(E) : B(E)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(E) : a ? v(E) : b(E));
    }
    return E === 45 || Cn(E) ? (e.consume(E), o += String.fromCharCode(E), y) : n(E);
  }
  function g(E) {
    return E === 62 ? (e.consume(E), r.interrupt ? t : B) : n(E);
  }
  function v(E) {
    return mt(E) ? (e.consume(E), v) : k(E);
  }
  function b(E) {
    return E === 47 ? (e.consume(E), k) : E === 58 || E === 95 || Dn(E) ? (e.consume(E), T) : mt(E) ? (e.consume(E), b) : k(E);
  }
  function T(E) {
    return E === 45 || E === 46 || E === 58 || E === 95 || Cn(E) ? (e.consume(E), T) : O(E);
  }
  function O(E) {
    return E === 61 ? (e.consume(E), S) : mt(E) ? (e.consume(E), O) : b(E);
  }
  function S(E) {
    return E === null || E === 60 || E === 61 || E === 62 || E === 96 ? n(E) : E === 34 || E === 39 ? (e.consume(E), l = E, P) : mt(E) ? (e.consume(E), S) : M(E);
  }
  function P(E) {
    return E === l ? (e.consume(E), l = null, L) : E === null || Ge(E) ? n(E) : (e.consume(E), P);
  }
  function M(E) {
    return E === null || E === 34 || E === 39 || E === 47 || E === 60 || E === 61 || E === 62 || E === 96 || Rt(E) ? O(E) : (e.consume(E), M);
  }
  function L(E) {
    return E === 47 || E === 62 || mt(E) ? b(E) : n(E);
  }
  function k(E) {
    return E === 62 ? (e.consume(E), I) : n(E);
  }
  function I(E) {
    return E === null || Ge(E) ? B(E) : mt(E) ? (e.consume(E), I) : n(E);
  }
  function B(E) {
    return E === 45 && i === 2 ? (e.consume(E), j) : E === 60 && i === 1 ? (e.consume(E), V) : E === 62 && i === 4 ? (e.consume(E), ie) : E === 63 && i === 3 ? (e.consume(E), x) : E === 93 && i === 5 ? (e.consume(E), de) : Ge(E) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(
      AR,
      ve,
      U
    )(E)) : E === null || Ge(E) ? (e.exit("htmlFlowData"), U(E)) : (e.consume(E), B);
  }
  function U(E) {
    return e.check(
      $R,
      z,
      ve
    )(E);
  }
  function z(E) {
    return e.enter("lineEnding"), e.consume(E), e.exit("lineEnding"), D;
  }
  function D(E) {
    return E === null || Ge(E) ? U(E) : (e.enter("htmlFlowData"), B(E));
  }
  function j(E) {
    return E === 45 ? (e.consume(E), x) : B(E);
  }
  function V(E) {
    return E === 47 ? (e.consume(E), o = "", W) : B(E);
  }
  function W(E) {
    if (E === 62) {
      const ke = o.toLowerCase();
      return Vy.includes(ke) ? (e.consume(E), ie) : B(E);
    }
    return Dn(E) && o.length < 8 ? (e.consume(E), o += String.fromCharCode(E), W) : B(E);
  }
  function de(E) {
    return E === 93 ? (e.consume(E), x) : B(E);
  }
  function x(E) {
    return E === 62 ? (e.consume(E), ie) : E === 45 && i === 2 ? (e.consume(E), x) : B(E);
  }
  function ie(E) {
    return E === null || Ge(E) ? (e.exit("htmlFlowData"), ve(E)) : (e.consume(E), ie);
  }
  function ve(E) {
    return e.exit("htmlFlow"), t(E);
  }
}
function IR(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return Ge(o) ? (e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), a) : n(o);
  }
  function a(o) {
    return r.parser.lazy[r.now().line] ? n(o) : t(o);
  }
}
function MR(e, t, n) {
  return r;
  function r(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(cl, t, n);
  }
}
const NR = {
  name: "htmlText",
  tokenize: DR
};
function DR(e, t, n) {
  const r = this;
  let i, a, o;
  return s;
  function s(x) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(x), l;
  }
  function l(x) {
    return x === 33 ? (e.consume(x), c) : x === 47 ? (e.consume(x), O) : x === 63 ? (e.consume(x), b) : Dn(x) ? (e.consume(x), M) : n(x);
  }
  function c(x) {
    return x === 45 ? (e.consume(x), u) : x === 91 ? (e.consume(x), a = 0, h) : Dn(x) ? (e.consume(x), v) : n(x);
  }
  function u(x) {
    return x === 45 ? (e.consume(x), f) : n(x);
  }
  function d(x) {
    return x === null ? n(x) : x === 45 ? (e.consume(x), p) : Ge(x) ? (o = d, V(x)) : (e.consume(x), d);
  }
  function p(x) {
    return x === 45 ? (e.consume(x), f) : d(x);
  }
  function f(x) {
    return x === 62 ? j(x) : x === 45 ? p(x) : d(x);
  }
  function h(x) {
    const ie = "CDATA[";
    return x === ie.charCodeAt(a++) ? (e.consume(x), a === ie.length ? m : h) : n(x);
  }
  function m(x) {
    return x === null ? n(x) : x === 93 ? (e.consume(x), y) : Ge(x) ? (o = m, V(x)) : (e.consume(x), m);
  }
  function y(x) {
    return x === 93 ? (e.consume(x), g) : m(x);
  }
  function g(x) {
    return x === 62 ? j(x) : x === 93 ? (e.consume(x), g) : m(x);
  }
  function v(x) {
    return x === null || x === 62 ? j(x) : Ge(x) ? (o = v, V(x)) : (e.consume(x), v);
  }
  function b(x) {
    return x === null ? n(x) : x === 63 ? (e.consume(x), T) : Ge(x) ? (o = b, V(x)) : (e.consume(x), b);
  }
  function T(x) {
    return x === 62 ? j(x) : b(x);
  }
  function O(x) {
    return Dn(x) ? (e.consume(x), S) : n(x);
  }
  function S(x) {
    return x === 45 || Cn(x) ? (e.consume(x), S) : P(x);
  }
  function P(x) {
    return Ge(x) ? (o = P, V(x)) : mt(x) ? (e.consume(x), P) : j(x);
  }
  function M(x) {
    return x === 45 || Cn(x) ? (e.consume(x), M) : x === 47 || x === 62 || Rt(x) ? L(x) : n(x);
  }
  function L(x) {
    return x === 47 ? (e.consume(x), j) : x === 58 || x === 95 || Dn(x) ? (e.consume(x), k) : Ge(x) ? (o = L, V(x)) : mt(x) ? (e.consume(x), L) : j(x);
  }
  function k(x) {
    return x === 45 || x === 46 || x === 58 || x === 95 || Cn(x) ? (e.consume(x), k) : I(x);
  }
  function I(x) {
    return x === 61 ? (e.consume(x), B) : Ge(x) ? (o = I, V(x)) : mt(x) ? (e.consume(x), I) : L(x);
  }
  function B(x) {
    return x === null || x === 60 || x === 61 || x === 62 || x === 96 ? n(x) : x === 34 || x === 39 ? (e.consume(x), i = x, U) : Ge(x) ? (o = B, V(x)) : mt(x) ? (e.consume(x), B) : (e.consume(x), z);
  }
  function U(x) {
    return x === i ? (e.consume(x), i = void 0, D) : x === null ? n(x) : Ge(x) ? (o = U, V(x)) : (e.consume(x), U);
  }
  function z(x) {
    return x === null || x === 34 || x === 39 || x === 60 || x === 61 || x === 96 ? n(x) : x === 47 || x === 62 || Rt(x) ? L(x) : (e.consume(x), z);
  }
  function D(x) {
    return x === 47 || x === 62 || Rt(x) ? L(x) : n(x);
  }
  function j(x) {
    return x === 62 ? (e.consume(x), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(x);
  }
  function V(x) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(x), e.exit("lineEnding"), W;
  }
  function W(x) {
    return mt(x) ? _t(
      e,
      de,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(x) : de(x);
  }
  function de(x) {
    return e.enter("htmlTextData"), o(x);
  }
}
const Im = {
  name: "labelEnd",
  tokenize: zR,
  resolveTo: BR,
  resolveAll: FR
}, LR = {
  tokenize: ZR
}, jR = {
  tokenize: qR
}, UR = {
  tokenize: WR
};
function FR(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function BR(e, t) {
  let n = e.length, r = 0, i, a, o, s;
  for (; n--; )
    if (i = e[n][1], a) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (o) {
      if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (a = n, i.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else
      i.type === "labelEnd" && (o = n);
  const l = {
    type: e[a][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, c = {
    type: "label",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[o][1].end)
  }, u = {
    type: "labelText",
    start: Object.assign({}, e[a + r + 2][1].end),
    end: Object.assign({}, e[o - 2][1].start)
  };
  return s = [
    ["enter", l, t],
    ["enter", c, t]
  ], s = or(s, e.slice(a + 1, a + r + 3)), s = or(s, [["enter", u, t]]), s = or(
    s,
    Sd(
      t.parser.constructs.insideSpan.null,
      e.slice(a + r + 4, o - 3),
      t
    )
  ), s = or(s, [
    ["exit", u, t],
    e[o - 2],
    e[o - 1],
    ["exit", c, t]
  ]), s = or(s, e.slice(o + 1)), s = or(s, [["exit", l, t]]), Qn(e, a, e.length, s), e;
}
function zR(e, t, n) {
  const r = this;
  let i = r.events.length, a, o;
  for (; i--; )
    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {
      a = r.events[i][1];
      break;
    }
  return s;
  function s(p) {
    return a ? a._inactive ? d(p) : (o = r.parser.defined.includes(
      yr(
        r.sliceSerialize({
          start: a.end,
          end: r.now()
        })
      )
    ), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(p), e.exit("labelMarker"), e.exit("labelEnd"), l) : n(p);
  }
  function l(p) {
    return p === 40 ? e.attempt(
      LR,
      u,
      o ? u : d
    )(p) : p === 91 ? e.attempt(
      jR,
      u,
      o ? c : d
    )(p) : o ? u(p) : d(p);
  }
  function c(p) {
    return e.attempt(
      UR,
      u,
      d
    )(p);
  }
  function u(p) {
    return t(p);
  }
  function d(p) {
    return a._balanced = !0, n(p);
  }
}
function ZR(e, t, n) {
  return r;
  function r(d) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), i;
  }
  function i(d) {
    return Rt(d) ? Ss(e, a)(d) : a(d);
  }
  function a(d) {
    return d === 41 ? u(d) : sx(
      e,
      o,
      s,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(d);
  }
  function o(d) {
    return Rt(d) ? Ss(e, l)(d) : u(d);
  }
  function s(d) {
    return n(d);
  }
  function l(d) {
    return d === 34 || d === 39 || d === 40 ? cx(
      e,
      c,
      n,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(d) : u(d);
  }
  function c(d) {
    return Rt(d) ? Ss(e, u)(d) : u(d);
  }
  function u(d) {
    return d === 41 ? (e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), e.exit("resource"), t) : n(d);
  }
}
function qR(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return lx.call(
      r,
      e,
      a,
      o,
      "reference",
      "referenceMarker",
      "referenceString"
    )(s);
  }
  function a(s) {
    return r.parser.defined.includes(
      yr(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(s) : n(s);
  }
  function o(s) {
    return n(s);
  }
}
function WR(e, t, n) {
  return r;
  function r(a) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), i;
  }
  function i(a) {
    return a === 93 ? (e.enter("referenceMarker"), e.consume(a), e.exit("referenceMarker"), e.exit("reference"), t) : n(a);
  }
}
const VR = {
  name: "labelStartImage",
  tokenize: HR,
  resolveAll: Im.resolveAll
};
function HR(e, t, n) {
  const r = this;
  return i;
  function i(s) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(s), e.exit("labelImageMarker"), a;
  }
  function a(s) {
    return s === 91 ? (e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelImage"), o) : n(s);
  }
  function o(s) {
    return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s);
  }
}
const KR = {
  name: "labelStartLink",
  tokenize: GR,
  resolveAll: Im.resolveAll
};
function GR(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelLink"), a;
  }
  function a(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const Vf = {
  name: "lineEnding",
  tokenize: JR
};
function JR(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), _t(e, t, "linePrefix");
  }
}
const bc = {
  name: "thematicBreak",
  tokenize: YR
};
function YR(e, t, n) {
  let r = 0, i;
  return a;
  function a(c) {
    return e.enter("thematicBreak"), o(c);
  }
  function o(c) {
    return i = c, s(c);
  }
  function s(c) {
    return c === i ? (e.enter("thematicBreakSequence"), l(c)) : r >= 3 && (c === null || Ge(c)) ? (e.exit("thematicBreak"), t(c)) : n(c);
  }
  function l(c) {
    return c === i ? (e.consume(c), r++, l) : (e.exit("thematicBreakSequence"), mt(c) ? _t(e, s, "whitespace")(c) : s(c));
  }
}
const zn = {
  name: "list",
  tokenize: eP,
  continuation: {
    tokenize: tP
  },
  exit: rP
}, XR = {
  tokenize: iP,
  partial: !0
}, QR = {
  tokenize: nP,
  partial: !0
};
function eP(e, t, n) {
  const r = this, i = r.events[r.events.length - 1];
  let a = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;
  return s;
  function s(f) {
    const h = r.containerState.type || (f === 42 || f === 43 || f === 45 ? "listUnordered" : "listOrdered");
    if (h === "listUnordered" ? !r.containerState.marker || f === r.containerState.marker : ih(f)) {
      if (r.containerState.type || (r.containerState.type = h, e.enter(h, {
        _container: !0
      })), h === "listUnordered")
        return e.enter("listItemPrefix"), f === 42 || f === 45 ? e.check(bc, n, c)(f) : c(f);
      if (!r.interrupt || f === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(f);
    }
    return n(f);
  }
  function l(f) {
    return ih(f) && ++o < 10 ? (e.consume(f), l) : (!r.interrupt || o < 2) && (r.containerState.marker ? f === r.containerState.marker : f === 41 || f === 46) ? (e.exit("listItemValue"), c(f)) : n(f);
  }
  function c(f) {
    return e.enter("listItemMarker"), e.consume(f), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || f, e.check(
      cl,
      // Cant be empty when interrupting.
      r.interrupt ? n : u,
      e.attempt(
        XR,
        p,
        d
      )
    );
  }
  function u(f) {
    return r.containerState.initialBlankLine = !0, a++, p(f);
  }
  function d(f) {
    return mt(f) ? (e.enter("listItemPrefixWhitespace"), e.consume(f), e.exit("listItemPrefixWhitespace"), p) : n(f);
  }
  function p(f) {
    return r.containerState.size = a + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(f);
  }
}
function tP(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(cl, i, a);
  function i(s) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, _t(
      e,
      t,
      "listItemIndent",
      r.containerState.size + 1
    )(s);
  }
  function a(s) {
    return r.containerState.furtherBlankLines || !mt(s) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(s)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(QR, t, o)(s));
  }
  function o(s) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, _t(
      e,
      e.attempt(zn, t, n),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(s);
  }
}
function nP(e, t, n) {
  const r = this;
  return _t(
    e,
    i,
    "listItemIndent",
    r.containerState.size + 1
  );
  function i(a) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? t(a) : n(a);
  }
}
function rP(e) {
  e.exit(this.containerState.type);
}
function iP(e, t, n) {
  const r = this;
  return _t(
    e,
    i,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1
  );
  function i(a) {
    const o = r.events[r.events.length - 1];
    return !mt(a) && o && o[1].type === "listItemPrefixWhitespace" ? t(a) : n(a);
  }
}
const Hy = {
  name: "setextUnderline",
  tokenize: oP,
  resolveTo: aP
};
function aP(e, t) {
  let n = e.length, r, i, a;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (i = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !a && e[n][1].type === "definition" && (a = n);
  const o = {
    type: "setextHeading",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[i][1].type = "setextHeadingText", a ? (e.splice(i, 0, ["enter", o, t]), e.splice(a + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[a][1].end)) : e[r][1] = o, e.push(["exit", o, t]), e;
}
function oP(e, t, n) {
  const r = this;
  let i;
  return a;
  function a(c) {
    let u = r.events.length, d;
    for (; u--; )
      if (r.events[u][1].type !== "lineEnding" && r.events[u][1].type !== "linePrefix" && r.events[u][1].type !== "content") {
        d = r.events[u][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || d) ? (e.enter("setextHeadingLine"), i = c, o(c)) : n(c);
  }
  function o(c) {
    return e.enter("setextHeadingLineSequence"), s(c);
  }
  function s(c) {
    return c === i ? (e.consume(c), s) : (e.exit("setextHeadingLineSequence"), mt(c) ? _t(e, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || Ge(c) ? (e.exit("setextHeadingLine"), t(c)) : n(c);
  }
}
const sP = {
  tokenize: lP
};
function lP(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    cl,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      i,
      _t(
        e,
        e.attempt(
          this.parser.constructs.flow,
          i,
          e.attempt(pR, i)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(a), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function i(a) {
    if (a === null) {
      e.consume(a);
      return;
    }
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const cP = {
  resolveAll: dx()
}, uP = ux("string"), dP = ux("text");
function ux(e) {
  return {
    tokenize: t,
    resolveAll: dx(
      e === "text" ? fP : void 0
    )
  };
  function t(n) {
    const r = this, i = this.parser.constructs[e], a = n.attempt(i, o, s);
    return o;
    function o(u) {
      return c(u) ? a(u) : s(u);
    }
    function s(u) {
      if (u === null) {
        n.consume(u);
        return;
      }
      return n.enter("data"), n.consume(u), l;
    }
    function l(u) {
      return c(u) ? (n.exit("data"), a(u)) : (n.consume(u), l);
    }
    function c(u) {
      if (u === null)
        return !0;
      const d = i[u];
      let p = -1;
      if (d)
        for (; ++p < d.length; ) {
          const f = d[p];
          if (!f.previous || f.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function dx(e) {
  return t;
  function t(n, r) {
    let i = -1, a;
    for (; ++i <= n.length; )
      a === void 0 ? n[i] && n[i][1].type === "data" && (a = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== a + 2 && (n[a][1].end = n[i - 1][1].end, n.splice(a + 2, i - a - 2), i = a + 2), a = void 0);
    return e ? e(n, r) : n;
  }
}
function fP(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], i = t.sliceStream(r);
      let a = i.length, o = -1, s = 0, l;
      for (; a--; ) {
        const c = i[a];
        if (typeof c == "string") {
          for (o = c.length; c.charCodeAt(o - 1) === 32; )
            s++, o--;
          if (o)
            break;
          o = -1;
        } else if (c === -2)
          l = !0, s++;
        else if (c !== -1) {
          a++;
          break;
        }
      }
      if (s) {
        const c = {
          type: n === e.length || l || s < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - s,
            offset: r.end.offset - s,
            _index: r.start._index + a,
            _bufferIndex: a ? o : r.start._bufferIndex + o
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, c.start), r.start.offset === r.end.offset ? Object.assign(r, c) : (e.splice(
          n,
          0,
          ["enter", c, t],
          ["exit", c, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function pP(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, a = [];
  let o = [], s = [];
  const l = {
    consume: v,
    enter: b,
    exit: T,
    attempt: P(O),
    check: P(S),
    interrupt: P(S, {
      interrupt: !0
    })
  }, c = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: f,
    sliceSerialize: p,
    now: h,
    defineSkip: m,
    write: d
  };
  let u = t.tokenize.call(c, l);
  return t.resolveAll && a.push(t), c;
  function d(I) {
    return o = or(o, I), y(), o[o.length - 1] !== null ? [] : (M(t, 0), c.events = Sd(a, c.events, c), c.events);
  }
  function p(I, B) {
    return mP(f(I), B);
  }
  function f(I) {
    return hP(o, I);
  }
  function h() {
    const { line: I, column: B, offset: U, _index: z, _bufferIndex: D } = r;
    return {
      line: I,
      column: B,
      offset: U,
      _index: z,
      _bufferIndex: D
    };
  }
  function m(I) {
    i[I.line] = I.column, k();
  }
  function y() {
    let I;
    for (; r._index < o.length; ) {
      const B = o[r._index];
      if (typeof B == "string")
        for (I = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === I && r._bufferIndex < B.length; )
          g(B.charCodeAt(r._bufferIndex));
      else
        g(B);
    }
  }
  function g(I) {
    u = u(I);
  }
  function v(I) {
    Ge(I) ? (r.line++, r.column = 1, r.offset += I === -3 ? 2 : 1, k()) : I !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = I;
  }
  function b(I, B) {
    const U = B || {};
    return U.type = I, U.start = h(), c.events.push(["enter", U, c]), s.push(U), U;
  }
  function T(I) {
    const B = s.pop();
    return B.end = h(), c.events.push(["exit", B, c]), B;
  }
  function O(I, B) {
    M(I, B.from);
  }
  function S(I, B) {
    B.restore();
  }
  function P(I, B) {
    return U;
    function U(z, D, j) {
      let V, W, de, x;
      return Array.isArray(z) ? ve(z) : "tokenize" in z ? (
        // @ts-expect-error Looks like a construct.
        ve([z])
      ) : ie(z);
      function ie(Pe) {
        return qe;
        function qe(rt) {
          const Ve = rt !== null && Pe[rt], be = rt !== null && Pe.null, he = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Ve) ? Ve : Ve ? [Ve] : [],
            ...Array.isArray(be) ? be : be ? [be] : []
          ];
          return ve(he)(rt);
        }
      }
      function ve(Pe) {
        return V = Pe, W = 0, Pe.length === 0 ? j : E(Pe[W]);
      }
      function E(Pe) {
        return qe;
        function qe(rt) {
          return x = L(), de = Pe, Pe.partial || (c.currentConstruct = Pe), Pe.name && c.parser.constructs.disable.null.includes(Pe.name) ? Ze() : Pe.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            B ? Object.assign(Object.create(c), B) : c,
            l,
            ke,
            Ze
          )(rt);
        }
      }
      function ke(Pe) {
        return I(de, x), D;
      }
      function Ze(Pe) {
        return x.restore(), ++W < V.length ? E(V[W]) : j;
      }
    }
  }
  function M(I, B) {
    I.resolveAll && !a.includes(I) && a.push(I), I.resolve && Qn(
      c.events,
      B,
      c.events.length - B,
      I.resolve(c.events.slice(B), c)
    ), I.resolveTo && (c.events = I.resolveTo(c.events, c));
  }
  function L() {
    const I = h(), B = c.previous, U = c.currentConstruct, z = c.events.length, D = Array.from(s);
    return {
      restore: j,
      from: z
    };
    function j() {
      r = I, c.previous = B, c.currentConstruct = U, c.events.length = z, s = D, k();
    }
  }
  function k() {
    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);
  }
}
function hP(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, a = t.end._bufferIndex;
  let o;
  if (n === i)
    o = [e[n].slice(r, a)];
  else {
    if (o = e.slice(n, i), r > -1) {
      const s = o[0];
      typeof s == "string" ? o[0] = s.slice(r) : o.shift();
    }
    a > 0 && o.push(e[i].slice(0, a));
  }
  return o;
}
function mP(e, t) {
  let n = -1;
  const r = [];
  let i;
  for (; ++n < e.length; ) {
    const a = e[n];
    let o;
    if (typeof a == "string")
      o = a;
    else
      switch (a) {
        case -5: {
          o = "\r";
          break;
        }
        case -4: {
          o = `
`;
          break;
        }
        case -3: {
          o = `\r
`;
          break;
        }
        case -2: {
          o = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i)
            continue;
          o = " ";
          break;
        }
        default:
          o = String.fromCharCode(a);
      }
    i = a === -2, r.push(o);
  }
  return r.join("");
}
const gP = {
  42: zn,
  43: zn,
  45: zn,
  48: zn,
  49: zn,
  50: zn,
  51: zn,
  52: zn,
  53: zn,
  54: zn,
  55: zn,
  56: zn,
  57: zn,
  62: rx
}, yP = {
  91: vR
}, vP = {
  [-2]: Wf,
  [-1]: Wf,
  32: Wf
}, bP = {
  35: ER,
  42: bc,
  45: [Hy, bc],
  60: OR,
  61: Hy,
  95: bc,
  96: Wy,
  126: Wy
}, wP = {
  38: ax,
  92: ix
}, xP = {
  [-5]: Vf,
  [-4]: Vf,
  [-3]: Vf,
  33: VR,
  38: ax,
  42: ah,
  60: [G$, NR],
  91: KR,
  92: [_R, ix],
  93: Im,
  95: ah,
  96: lR
}, _P = {
  null: [ah, cP]
}, SP = {
  null: [42, 95]
}, EP = {
  null: []
}, kP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: SP,
  contentInitial: yP,
  disable: EP,
  document: gP,
  flow: bP,
  flowInitial: vP,
  insideSpan: _P,
  string: wP,
  text: xP
}, Symbol.toStringTag, { value: "Module" }));
function TP(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    tx([kP, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: i(z$),
    document: i(q$),
    flow: i(sP),
    string: i(uP),
    text: i(dP)
  };
  return r;
  function i(a) {
    return o;
    function o(s) {
      return pP(r, a, s);
    }
  }
}
function CP(e) {
  for (; !ox(e); )
    ;
  return e;
}
const Ky = /[\0\t\n\r]/g;
function OP() {
  let e = 1, t = "", n = !0, r;
  return i;
  function i(a, o, s) {
    const l = [];
    let c, u, d, p, f;
    for (a = t + (typeof a == "string" ? a.toString() : new TextDecoder(o || void 0).decode(a)), d = 0, t = "", n && (a.charCodeAt(0) === 65279 && d++, n = void 0); d < a.length; ) {
      if (Ky.lastIndex = d, c = Ky.exec(a), p = c && c.index !== void 0 ? c.index : a.length, f = a.charCodeAt(p), !c) {
        t = a.slice(d);
        break;
      }
      if (f === 10 && d === p && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), d < p && (l.push(a.slice(d, p)), e += p - d), f) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (u = Math.ceil(e / 4) * 4, l.push(-2); e++ < u; )
              l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      d = p + 1;
    }
    return s && (r && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const AP = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function $P(e) {
  return e.replace(AP, RP);
}
function RP(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const i = n.charCodeAt(1), a = i === 120 || i === 88;
    return nx(n.slice(a ? 2 : 1), a ? 16 : 10);
  }
  return Pm(n) || e;
}
const fx = {}.hasOwnProperty;
function PP(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), IP(n)(
    CP(
      TP(n).document().write(OP()(e, t, !0))
    )
  );
}
function IP(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: a(pe),
      autolinkProtocol: L,
      autolinkEmail: L,
      atxHeading: a(Fe),
      blockQuote: a(Ve),
      characterEscape: L,
      characterReference: L,
      codeFenced: a(be),
      codeFencedFenceInfo: o,
      codeFencedFenceMeta: o,
      codeIndented: a(be, o),
      codeText: a(he, o),
      codeTextData: L,
      data: L,
      codeFlowValue: L,
      definition: a(Oe),
      definitionDestinationString: o,
      definitionLabelString: o,
      definitionTitleString: o,
      emphasis: a(we),
      hardBreakEscape: a(st),
      hardBreakTrailing: a(st),
      htmlFlow: a(N, o),
      htmlFlowData: L,
      htmlText: a(N, o),
      htmlTextData: L,
      image: a(le),
      label: o,
      link: a(pe),
      listItem: a(Le),
      listItemValue: p,
      listOrdered: a(ue, d),
      listUnordered: a(ue),
      paragraph: a(Me),
      reference: E,
      referenceString: o,
      resourceDestinationString: o,
      resourceTitleString: o,
      setextHeading: a(Fe),
      strong: a(Ke),
      thematicBreak: a(tt)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: O,
      autolink: l(),
      autolinkEmail: rt,
      autolinkProtocol: qe,
      blockQuote: l(),
      characterEscapeValue: k,
      characterReferenceMarkerHexadecimal: Ze,
      characterReferenceMarkerNumeric: Ze,
      characterReferenceValue: Pe,
      codeFenced: l(y),
      codeFencedFence: m,
      codeFencedFenceInfo: f,
      codeFencedFenceMeta: h,
      codeFlowValue: k,
      codeIndented: l(g),
      codeText: l(D),
      codeTextData: k,
      data: k,
      definition: l(),
      definitionDestinationString: T,
      definitionLabelString: v,
      definitionTitleString: b,
      emphasis: l(),
      hardBreakEscape: l(B),
      hardBreakTrailing: l(B),
      htmlFlow: l(U),
      htmlFlowData: k,
      htmlText: l(z),
      htmlTextData: k,
      image: l(V),
      label: de,
      labelText: W,
      lineEnding: I,
      link: l(j),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: ke,
      resourceDestinationString: x,
      resourceTitleString: ie,
      resource: ve,
      setextHeading: l(M),
      setextHeadingLineSequence: P,
      setextHeadingText: S,
      strong: l(),
      thematicBreak: l()
    }
  };
  px(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(Z) {
    let J = {
      type: "root",
      children: []
    };
    const ce = {
      stack: [J],
      tokenStack: [],
      config: t,
      enter: s,
      exit: c,
      buffer: o,
      resume: u,
      data: n
    }, Ne = [];
    let it = -1;
    for (; ++it < Z.length; )
      if (Z[it][1].type === "listOrdered" || Z[it][1].type === "listUnordered")
        if (Z[it][0] === "enter")
          Ne.push(it);
        else {
          const zt = Ne.pop();
          it = i(Z, zt, it);
        }
    for (it = -1; ++it < Z.length; ) {
      const zt = t[Z[it][0]];
      fx.call(zt, Z[it][1].type) && zt[Z[it][1].type].call(
        Object.assign(
          {
            sliceSerialize: Z[it][2].sliceSerialize
          },
          ce
        ),
        Z[it][1]
      );
    }
    if (ce.tokenStack.length > 0) {
      const zt = ce.tokenStack[ce.tokenStack.length - 1];
      (zt[1] || Gy).call(ce, void 0, zt[0]);
    }
    for (J.position = {
      start: _i(
        Z.length > 0 ? Z[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: _i(
        Z.length > 0 ? Z[Z.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, it = -1; ++it < t.transforms.length; )
      J = t.transforms[it](J) || J;
    return J;
  }
  function i(Z, J, ce) {
    let Ne = J - 1, it = -1, zt = !1, At, Ct, Zt, Sn;
    for (; ++Ne <= ce; ) {
      const qt = Z[Ne];
      switch (qt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          qt[0] === "enter" ? it++ : it--, Sn = void 0;
          break;
        }
        case "lineEndingBlank": {
          qt[0] === "enter" && (At && !Sn && !it && !Zt && (Zt = Ne), Sn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Sn = void 0;
      }
      if (!it && qt[0] === "enter" && qt[1].type === "listItemPrefix" || it === -1 && qt[0] === "exit" && (qt[1].type === "listUnordered" || qt[1].type === "listOrdered")) {
        if (At) {
          let Yt = Ne;
          for (Ct = void 0; Yt--; ) {
            const fn = Z[Yt];
            if (fn[1].type === "lineEnding" || fn[1].type === "lineEndingBlank") {
              if (fn[0] === "exit")
                continue;
              Ct && (Z[Ct][1].type = "lineEndingBlank", zt = !0), fn[1].type = "lineEnding", Ct = Yt;
            } else if (!(fn[1].type === "linePrefix" || fn[1].type === "blockQuotePrefix" || fn[1].type === "blockQuotePrefixWhitespace" || fn[1].type === "blockQuoteMarker" || fn[1].type === "listItemIndent"))
              break;
          }
          Zt && (!Ct || Zt < Ct) && (At._spread = !0), At.end = Object.assign(
            {},
            Ct ? Z[Ct][1].start : qt[1].end
          ), Z.splice(Ct || Ne, 0, ["exit", At, qt[2]]), Ne++, ce++;
        }
        if (qt[1].type === "listItemPrefix") {
          const Yt = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, qt[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          At = Yt, Z.splice(Ne, 0, ["enter", Yt, qt[2]]), Ne++, ce++, Zt = void 0, Sn = !0;
        }
      }
    }
    return Z[J][1]._spread = zt, ce;
  }
  function a(Z, J) {
    return ce;
    function ce(Ne) {
      s.call(this, Z(Ne), Ne), J && J.call(this, Ne);
    }
  }
  function o() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function s(Z, J, ce) {
    this.stack[this.stack.length - 1].children.push(Z), this.stack.push(Z), this.tokenStack.push([J, ce]), Z.position = {
      start: _i(J.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(Z) {
    return J;
    function J(ce) {
      Z && Z.call(this, ce), c.call(this, ce);
    }
  }
  function c(Z, J) {
    const ce = this.stack.pop(), Ne = this.tokenStack.pop();
    if (Ne)
      Ne[0].type !== Z.type && (J ? J.call(this, Z, Ne[0]) : (Ne[1] || Gy).call(this, Z, Ne[0]));
    else
      throw new Error(
        "Cannot close `" + Z.type + "` (" + _s({
          start: Z.start,
          end: Z.end
        }) + "): its not open"
      );
    ce.position.end = _i(Z.end);
  }
  function u() {
    return Rm(this.stack.pop());
  }
  function d() {
    this.data.expectingFirstListItemValue = !0;
  }
  function p(Z) {
    if (this.data.expectingFirstListItemValue) {
      const J = this.stack[this.stack.length - 2];
      J.start = Number.parseInt(this.sliceSerialize(Z), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function f() {
    const Z = this.resume(), J = this.stack[this.stack.length - 1];
    J.lang = Z;
  }
  function h() {
    const Z = this.resume(), J = this.stack[this.stack.length - 1];
    J.meta = Z;
  }
  function m() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function y() {
    const Z = this.resume(), J = this.stack[this.stack.length - 1];
    J.value = Z.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function g() {
    const Z = this.resume(), J = this.stack[this.stack.length - 1];
    J.value = Z.replace(/(\r?\n|\r)$/g, "");
  }
  function v(Z) {
    const J = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.label = J, ce.identifier = yr(
      this.sliceSerialize(Z)
    ).toLowerCase();
  }
  function b() {
    const Z = this.resume(), J = this.stack[this.stack.length - 1];
    J.title = Z;
  }
  function T() {
    const Z = this.resume(), J = this.stack[this.stack.length - 1];
    J.url = Z;
  }
  function O(Z) {
    const J = this.stack[this.stack.length - 1];
    if (!J.depth) {
      const ce = this.sliceSerialize(Z).length;
      J.depth = ce;
    }
  }
  function S() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function P(Z) {
    const J = this.stack[this.stack.length - 1];
    J.depth = this.sliceSerialize(Z).codePointAt(0) === 61 ? 1 : 2;
  }
  function M() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function L(Z) {
    const ce = this.stack[this.stack.length - 1].children;
    let Ne = ce[ce.length - 1];
    (!Ne || Ne.type !== "text") && (Ne = gt(), Ne.position = {
      start: _i(Z.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, ce.push(Ne)), this.stack.push(Ne);
  }
  function k(Z) {
    const J = this.stack.pop();
    J.value += this.sliceSerialize(Z), J.position.end = _i(Z.end);
  }
  function I(Z) {
    const J = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const ce = J.children[J.children.length - 1];
      ce.position.end = _i(Z.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(J.type) && (L.call(this, Z), k.call(this, Z));
  }
  function B() {
    this.data.atHardBreak = !0;
  }
  function U() {
    const Z = this.resume(), J = this.stack[this.stack.length - 1];
    J.value = Z;
  }
  function z() {
    const Z = this.resume(), J = this.stack[this.stack.length - 1];
    J.value = Z;
  }
  function D() {
    const Z = this.resume(), J = this.stack[this.stack.length - 1];
    J.value = Z;
  }
  function j() {
    const Z = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const J = this.data.referenceType || "shortcut";
      Z.type += "Reference", Z.referenceType = J, delete Z.url, delete Z.title;
    } else
      delete Z.identifier, delete Z.label;
    this.data.referenceType = void 0;
  }
  function V() {
    const Z = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const J = this.data.referenceType || "shortcut";
      Z.type += "Reference", Z.referenceType = J, delete Z.url, delete Z.title;
    } else
      delete Z.identifier, delete Z.label;
    this.data.referenceType = void 0;
  }
  function W(Z) {
    const J = this.sliceSerialize(Z), ce = this.stack[this.stack.length - 2];
    ce.label = $P(J), ce.identifier = yr(J).toLowerCase();
  }
  function de() {
    const Z = this.stack[this.stack.length - 1], J = this.resume(), ce = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, ce.type === "link") {
      const Ne = Z.children;
      ce.children = Ne;
    } else
      ce.alt = J;
  }
  function x() {
    const Z = this.resume(), J = this.stack[this.stack.length - 1];
    J.url = Z;
  }
  function ie() {
    const Z = this.resume(), J = this.stack[this.stack.length - 1];
    J.title = Z;
  }
  function ve() {
    this.data.inReference = void 0;
  }
  function E() {
    this.data.referenceType = "collapsed";
  }
  function ke(Z) {
    const J = this.resume(), ce = this.stack[this.stack.length - 1];
    ce.label = J, ce.identifier = yr(
      this.sliceSerialize(Z)
    ).toLowerCase(), this.data.referenceType = "full";
  }
  function Ze(Z) {
    this.data.characterReferenceType = Z.type;
  }
  function Pe(Z) {
    const J = this.sliceSerialize(Z), ce = this.data.characterReferenceType;
    let Ne;
    ce ? (Ne = nx(
      J,
      ce === "characterReferenceMarkerNumeric" ? 10 : 16
    ), this.data.characterReferenceType = void 0) : Ne = Pm(J);
    const it = this.stack.pop();
    it.value += Ne, it.position.end = _i(Z.end);
  }
  function qe(Z) {
    k.call(this, Z);
    const J = this.stack[this.stack.length - 1];
    J.url = this.sliceSerialize(Z);
  }
  function rt(Z) {
    k.call(this, Z);
    const J = this.stack[this.stack.length - 1];
    J.url = "mailto:" + this.sliceSerialize(Z);
  }
  function Ve() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function be() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function he() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Oe() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function we() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Fe() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function st() {
    return {
      type: "break"
    };
  }
  function N() {
    return {
      type: "html",
      value: ""
    };
  }
  function le() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function pe() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function ue(Z) {
    return {
      type: "list",
      ordered: Z.type === "listOrdered",
      start: null,
      spread: Z._spread,
      children: []
    };
  }
  function Le(Z) {
    return {
      type: "listItem",
      spread: Z._spread,
      checked: null,
      children: []
    };
  }
  function Me() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Ke() {
    return {
      type: "strong",
      children: []
    };
  }
  function gt() {
    return {
      type: "text",
      value: ""
    };
  }
  function tt() {
    return {
      type: "thematicBreak"
    };
  }
}
function _i(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function px(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? px(e, r) : MP(e, r);
  }
}
function MP(e, t) {
  let n;
  for (n in t)
    if (fx.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function Gy(e, t) {
  throw e ? new Error(
    "Cannot close `" + e.type + "` (" + _s({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + _s({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + _s({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function NP(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return PP(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function DP(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function LP(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function jP(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function UP(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function FP(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function BP(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = Zo(r.toLowerCase()), a = e.footnoteOrder.indexOf(r);
  let o, s = e.footnoteCounts.get(r);
  s === void 0 ? (s = 0, e.footnoteOrder.push(r), o = e.footnoteOrder.length) : o = a + 1, s += 1, e.footnoteCounts.set(r, s);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + i,
      id: n + "fnref-" + i + (s > 1 ? "-" + s : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(o) }]
  };
  e.patch(t, l);
  const c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, c), e.applyData(t, c);
}
function zP(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function ZP(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function hx(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const i = e.all(t), a = i[0];
  a && a.type === "text" ? a.value = "[" + a.value : i.unshift({ type: "text", value: "[" });
  const o = i[i.length - 1];
  return o && o.type === "text" ? o.value += r : i.push({ type: "text", value: r }), i;
}
function qP(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return hx(e, t);
  const i = { src: Zo(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, a), e.applyData(t, a);
}
function WP(e, t) {
  const n = { src: Zo(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function VP(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function HP(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return hx(e, t);
  const i = { href: Zo(r.url || "") };
  r.title !== null && r.title !== void 0 && (i.title = r.title);
  const a = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function KP(e, t) {
  const n = { href: Zo(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function GP(e, t, n) {
  const r = e.all(t), i = n ? JP(n) : mx(t), a = {}, o = [];
  if (typeof t.checked == "boolean") {
    const u = r[0];
    let d;
    u && u.type === "element" && u.tagName === "p" ? d = u : (d = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(d)), d.children.length > 0 && d.children.unshift({ type: "text", value: " " }), d.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), a.className = ["task-list-item"];
  }
  let s = -1;
  for (; ++s < r.length; ) {
    const u = r[s];
    (i || s !== 0 || u.type !== "element" || u.tagName !== "p") && o.push({ type: "text", value: `
` }), u.type === "element" && u.tagName === "p" && !i ? o.push(...u.children) : o.push(u);
  }
  const l = r[r.length - 1];
  l && (i || l.type !== "element" || l.tagName !== "p") && o.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: a, children: o };
  return e.patch(t, c), e.applyData(t, c);
}
function JP(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = mx(n[r]);
  }
  return t;
}
function mx(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function YP(e, t) {
  const n = {}, r = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length; ) {
    const o = r[i];
    if (o.type === "element" && o.tagName === "li" && o.properties && Array.isArray(o.properties.className) && o.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const a = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function XP(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function QP(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function eI(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function tI(e, t) {
  const n = e.all(t), r = n.shift(), i = [];
  if (r) {
    const o = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], o), i.push(o);
  }
  if (n.length > 0) {
    const o = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, s = Cm(t.children[1]), l = K0(t.children[t.children.length - 1]);
    s && l && (o.position = { start: s, end: l }), i.push(o);
  }
  const a = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, a), e.applyData(t, a);
}
function nI(e, t, n) {
  const r = n ? n.children : void 0, a = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", o = n && n.type === "table" ? n.align : void 0, s = o ? o.length : t.children.length;
  let l = -1;
  const c = [];
  for (; ++l < s; ) {
    const d = t.children[l], p = {}, f = o ? o[l] : void 0;
    f && (p.align = f);
    let h = { type: "element", tagName: a, properties: p, children: [] };
    d && (h.children = e.all(d), e.patch(d, h), h = e.applyData(d, h)), c.push(h);
  }
  const u = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function rI(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const Jy = 9, Yy = 32;
function iI(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), i = 0;
  const a = [];
  for (; r; )
    a.push(
      Xy(t.slice(i, r.index), i > 0, !0),
      r[0]
    ), i = r.index + r[0].length, r = n.exec(t);
  return a.push(Xy(t.slice(i), i > 0, !1)), a.join("");
}
function Xy(e, t, n) {
  let r = 0, i = e.length;
  if (t) {
    let a = e.codePointAt(r);
    for (; a === Jy || a === Yy; )
      r++, a = e.codePointAt(r);
  }
  if (n) {
    let a = e.codePointAt(i - 1);
    for (; a === Jy || a === Yy; )
      i--, a = e.codePointAt(i - 1);
  }
  return i > r ? e.slice(r, i) : "";
}
function aI(e, t) {
  const n = { type: "text", value: iI(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function oI(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const sI = {
  blockquote: DP,
  break: LP,
  code: jP,
  delete: UP,
  emphasis: FP,
  footnoteReference: BP,
  heading: zP,
  html: ZP,
  imageReference: qP,
  image: WP,
  inlineCode: VP,
  linkReference: HP,
  link: KP,
  listItem: GP,
  list: YP,
  paragraph: XP,
  // @ts-expect-error: root is different, but hard to type.
  root: QP,
  strong: eI,
  table: tI,
  tableCell: rI,
  tableRow: nI,
  text: aI,
  thematicBreak: oI,
  toml: Gl,
  yaml: Gl,
  definition: Gl,
  footnoteDefinition: Gl
};
function Gl() {
}
const gx = -1, Ed = 0, Jc = 1, Yc = 2, Mm = 3, Nm = 4, Dm = 5, Lm = 6, yx = 7, vx = 8, Qy = typeof self == "object" ? self : globalThis, lI = (e, t) => {
  const n = (i, a) => (e.set(a, i), i), r = (i) => {
    if (e.has(i))
      return e.get(i);
    const [a, o] = t[i];
    switch (a) {
      case Ed:
      case gx:
        return n(o, i);
      case Jc: {
        const s = n([], i);
        for (const l of o)
          s.push(r(l));
        return s;
      }
      case Yc: {
        const s = n({}, i);
        for (const [l, c] of o)
          s[r(l)] = r(c);
        return s;
      }
      case Mm:
        return n(new Date(o), i);
      case Nm: {
        const { source: s, flags: l } = o;
        return n(new RegExp(s, l), i);
      }
      case Dm: {
        const s = n(/* @__PURE__ */ new Map(), i);
        for (const [l, c] of o)
          s.set(r(l), r(c));
        return s;
      }
      case Lm: {
        const s = n(/* @__PURE__ */ new Set(), i);
        for (const l of o)
          s.add(r(l));
        return s;
      }
      case yx: {
        const { name: s, message: l } = o;
        return n(new Qy[s](l), i);
      }
      case vx:
        return n(BigInt(o), i);
      case "BigInt":
        return n(Object(BigInt(o)), i);
    }
    return n(new Qy[a](o), i);
  };
  return r;
}, ev = (e) => lI(/* @__PURE__ */ new Map(), e)(0), Ba = "", { toString: cI } = {}, { keys: uI } = Object, us = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [Ed, t];
  const n = cI.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [Jc, Ba];
    case "Object":
      return [Yc, Ba];
    case "Date":
      return [Mm, Ba];
    case "RegExp":
      return [Nm, Ba];
    case "Map":
      return [Dm, Ba];
    case "Set":
      return [Lm, Ba];
  }
  return n.includes("Array") ? [Jc, n] : n.includes("Error") ? [yx, n] : [Yc, n];
}, Jl = ([e, t]) => e === Ed && (t === "function" || t === "symbol"), dI = (e, t, n, r) => {
  const i = (o, s) => {
    const l = r.push(o) - 1;
    return n.set(s, l), l;
  }, a = (o) => {
    if (n.has(o))
      return n.get(o);
    let [s, l] = us(o);
    switch (s) {
      case Ed: {
        let u = o;
        switch (l) {
          case "bigint":
            s = vx, u = o.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            u = null;
            break;
          case "undefined":
            return i([gx], o);
        }
        return i([s, u], o);
      }
      case Jc: {
        if (l)
          return i([l, [...o]], o);
        const u = [], d = i([s, u], o);
        for (const p of o)
          u.push(a(p));
        return d;
      }
      case Yc: {
        if (l)
          switch (l) {
            case "BigInt":
              return i([l, o.toString()], o);
            case "Boolean":
            case "Number":
            case "String":
              return i([l, o.valueOf()], o);
          }
        if (t && "toJSON" in o)
          return a(o.toJSON());
        const u = [], d = i([s, u], o);
        for (const p of uI(o))
          (e || !Jl(us(o[p]))) && u.push([a(p), a(o[p])]);
        return d;
      }
      case Mm:
        return i([s, o.toISOString()], o);
      case Nm: {
        const { source: u, flags: d } = o;
        return i([s, { source: u, flags: d }], o);
      }
      case Dm: {
        const u = [], d = i([s, u], o);
        for (const [p, f] of o)
          (e || !(Jl(us(p)) || Jl(us(f)))) && u.push([a(p), a(f)]);
        return d;
      }
      case Lm: {
        const u = [], d = i([s, u], o);
        for (const p of o)
          (e || !Jl(us(p))) && u.push(a(p));
        return d;
      }
    }
    const { message: c } = o;
    return i([s, { name: l, message: c }], o);
  };
  return a;
}, tv = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return dI(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, Xc = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? ev(tv(e, t)) : structuredClone(e)
) : (e, t) => ev(tv(e, t));
function fI(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function pI(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function hI(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || fI, r = e.options.footnoteBackLabel || pI, i = e.options.footnoteLabel || "Footnotes", a = e.options.footnoteLabelTagName || "h2", o = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, s = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const c = e.footnoteById.get(e.footnoteOrder[l]);
    if (!c)
      continue;
    const u = e.all(c), d = String(c.identifier).toUpperCase(), p = Zo(d.toLowerCase());
    let f = 0;
    const h = [], m = e.footnoteCounts.get(d);
    for (; m !== void 0 && ++f <= m; ) {
      h.length > 0 && h.push({ type: "text", value: " " });
      let v = typeof n == "string" ? n : n(l, f);
      typeof v == "string" && (v = { type: "text", value: v }), h.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + p + (f > 1 ? "-" + f : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, f),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(v) ? v : [v]
      });
    }
    const y = u[u.length - 1];
    if (y && y.type === "element" && y.tagName === "p") {
      const v = y.children[y.children.length - 1];
      v && v.type === "text" ? v.value += " " : y.children.push({ type: "text", value: " " }), y.children.push(...h);
    } else
      u.push(...h);
    const g = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + p },
      children: e.wrap(u, !0)
    };
    e.patch(c, g), s.push(g);
  }
  if (s.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: a,
          properties: {
            ...Xc(o),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(s, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const kd = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return vI;
    if (typeof e == "function")
      return Td(e);
    if (typeof e == "object")
      return Array.isArray(e) ? mI(e) : gI(e);
    if (typeof e == "string")
      return yI(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function mI(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = kd(e[n]);
  return Td(r);
  function r(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i))
        return !0;
    return !1;
  }
}
function gI(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Td(n);
  function n(r) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let a;
    for (a in e)
      if (i[a] !== t[a])
        return !1;
    return !0;
  }
}
function yI(e) {
  return Td(t);
  function t(n) {
    return n && n.type === e;
  }
}
function Td(e) {
  return t;
  function t(n, r, i) {
    return !!(bI(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      i || void 0
    ));
  }
}
function vI() {
  return !0;
}
function bI(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const bx = [], wI = !0, oh = !1, xI = "skip";
function wx(e, t, n, r) {
  let i;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t;
  const a = kd(i), o = r ? -1 : 1;
  s(e, void 0, [])();
  function s(l, c, u) {
    const d = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof d.type == "string") {
      const f = (
        // `hast`
        typeof d.tagName == "string" ? d.tagName : (
          // `xast`
          typeof d.name == "string" ? d.name : void 0
        )
      );
      Object.defineProperty(p, "name", {
        value: "node (" + (l.type + (f ? "<" + f + ">" : "")) + ")"
      });
    }
    return p;
    function p() {
      let f = bx, h, m, y;
      if ((!t || a(l, c, u[u.length - 1] || void 0)) && (f = _I(n(l, u)), f[0] === oh))
        return f;
      if ("children" in l && l.children) {
        const g = (
          /** @type {UnistParent} */
          l
        );
        if (g.children && f[0] !== xI)
          for (m = (r ? g.children.length : -1) + o, y = u.concat(g); m > -1 && m < g.children.length; ) {
            const v = g.children[m];
            if (h = s(v, m, y)(), h[0] === oh)
              return h;
            m = typeof h[1] == "number" ? h[1] : m + o;
          }
      }
      return f;
    }
  }
}
function _I(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [wI, e] : e == null ? bx : [e];
}
function jm(e, t, n, r) {
  let i, a, o;
  typeof t == "function" && typeof n != "function" ? (a = void 0, o = t, i = n) : (a = t, o = n, i = r), wx(e, a, s, i);
  function s(l, c) {
    const u = c[c.length - 1], d = u ? u.children.indexOf(l) : void 0;
    return o(l, d, u);
  }
}
const sh = {}.hasOwnProperty, SI = {};
function EI(e, t) {
  const n = t || SI, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), o = { ...sI, ...n.handlers }, s = {
    all: c,
    applyData: TI,
    definitionById: r,
    footnoteById: i,
    footnoteCounts: a,
    footnoteOrder: [],
    handlers: o,
    one: l,
    options: n,
    patch: kI,
    wrap: OI
  };
  return jm(e, function(u) {
    if (u.type === "definition" || u.type === "footnoteDefinition") {
      const d = u.type === "definition" ? r : i, p = String(u.identifier).toUpperCase();
      d.has(p) || d.set(p, u);
    }
  }), s;
  function l(u, d) {
    const p = u.type, f = s.handlers[p];
    if (sh.call(s.handlers, p) && f)
      return f(s, u, d);
    if (s.options.passThrough && s.options.passThrough.includes(p)) {
      if ("children" in u) {
        const { children: m, ...y } = u, g = Xc(y);
        return g.children = s.all(u), g;
      }
      return Xc(u);
    }
    return (s.options.unknownHandler || CI)(s, u, d);
  }
  function c(u) {
    const d = [];
    if ("children" in u) {
      const p = u.children;
      let f = -1;
      for (; ++f < p.length; ) {
        const h = s.one(p[f], u);
        if (h) {
          if (f && p[f - 1].type === "break" && (!Array.isArray(h) && h.type === "text" && (h.value = nv(h.value)), !Array.isArray(h) && h.type === "element")) {
            const m = h.children[0];
            m && m.type === "text" && (m.value = nv(m.value));
          }
          Array.isArray(h) ? d.push(...h) : d.push(h);
        }
      }
    }
    return d;
  }
}
function kI(e, t) {
  e.position && (t.position = f$(e));
}
function TI(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, i = e.data.hChildren, a = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const o = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: o };
      }
    n.type === "element" && a && Object.assign(n.properties, Xc(a)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i);
  }
  return n;
}
function CI(e, t) {
  const n = t.data || {}, r = "value" in t && !(sh.call(n, "hProperties") || sh.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function OI(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function nv(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function rv(e, t) {
  const n = EI(e, t), r = n.one(e, void 0), i = hI(n), a = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return i && a.children.push({ type: "text", value: `
` }, i), a;
}
function AI(e, t) {
  return e && "run" in e ? async function(n, r) {
    const i = (
      /** @type {HastRoot} */
      rv(n, { file: r, ...t })
    );
    await e.run(i, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      rv(n, { file: r, ...t || e })
    );
  };
}
function iv(e) {
  if (e)
    throw e;
}
var wc = Object.prototype.hasOwnProperty, xx = Object.prototype.toString, av = Object.defineProperty, ov = Object.getOwnPropertyDescriptor, sv = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : xx.call(t) === "[object Array]";
}, lv = function(t) {
  if (!t || xx.call(t) !== "[object Object]")
    return !1;
  var n = wc.call(t, "constructor"), r = t.constructor && t.constructor.prototype && wc.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || wc.call(t, i);
}, cv = function(t, n) {
  av && n.name === "__proto__" ? av(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, uv = function(t, n) {
  if (n === "__proto__")
    if (wc.call(t, n)) {
      if (ov)
        return ov(t, n).value;
    } else
      return;
  return t[n];
}, $I = function e() {
  var t, n, r, i, a, o, s = arguments[0], l = 1, c = arguments.length, u = !1;
  for (typeof s == "boolean" && (u = s, s = arguments[1] || {}, l = 2), (s == null || typeof s != "object" && typeof s != "function") && (s = {}); l < c; ++l)
    if (t = arguments[l], t != null)
      for (n in t)
        r = uv(s, n), i = uv(t, n), s !== i && (u && i && (lv(i) || (a = sv(i))) ? (a ? (a = !1, o = r && sv(r) ? r : []) : o = r && lv(r) ? r : {}, cv(s, { name: n, newValue: e(u, o, i) })) : typeof i < "u" && cv(s, { name: n, newValue: i }));
  return s;
};
const Hf = /* @__PURE__ */ Ki($I);
function lh(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function RI() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...i) {
    let a = -1;
    const o = i.pop();
    if (typeof o != "function")
      throw new TypeError("Expected function as last argument, not " + o);
    s(null, ...i);
    function s(l, ...c) {
      const u = e[++a];
      let d = -1;
      if (l) {
        o(l);
        return;
      }
      for (; ++d < i.length; )
        (c[d] === null || c[d] === void 0) && (c[d] = i[d]);
      i = c, u ? PI(u, s)(...c) : o(null, ...c);
    }
  }
  function r(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function PI(e, t) {
  let n;
  return r;
  function r(...o) {
    const s = e.length > o.length;
    let l;
    s && o.push(i);
    try {
      l = e.apply(this, o);
    } catch (c) {
      const u = (
        /** @type {Error} */
        c
      );
      if (s && n)
        throw u;
      return i(u);
    }
    s || (l instanceof Promise ? l.then(a, i) : l instanceof Error ? i(l) : a(l));
  }
  function i(o, ...s) {
    n || (n = !0, t(o, ...s));
  }
  function a(o) {
    i(null, o);
  }
}
const Ar = { basename: II, dirname: MI, extname: NI, join: DI, sep: "/" };
function II(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  ul(e);
  let n = 0, r = -1, i = e.length, a;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (a) {
          n = i + 1;
          break;
        }
      } else
        r < 0 && (a = !0, r = i + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let o = -1, s = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (a) {
        n = i + 1;
        break;
      }
    } else
      o < 0 && (a = !0, o = i + 1), s > -1 && (e.codePointAt(i) === t.codePointAt(s--) ? s < 0 && (r = i) : (s = -1, r = o));
  return n === r ? r = o : r < 0 && (r = e.length), e.slice(n, r);
}
function MI(e) {
  if (ul(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else
      r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function NI(e) {
  ul(e);
  let t = e.length, n = -1, r = 0, i = -1, a = 0, o;
  for (; t--; ) {
    const s = e.codePointAt(t);
    if (s === 47) {
      if (o) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (o = !0, n = t + 1), s === 46 ? i < 0 ? i = t : a !== 1 && (a = 1) : i > -1 && (a = -1);
  }
  return i < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  a === 0 || // The (right-most) trimmed path component is exactly `..`.
  a === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n);
}
function DI(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    ul(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : LI(n);
}
function LI(e) {
  ul(e);
  const t = e.codePointAt(0) === 47;
  let n = jI(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function jI(e, t) {
  let n = "", r = 0, i = -1, a = 0, o = -1, s, l;
  for (; ++o <= e.length; ) {
    if (o < e.length)
      s = e.codePointAt(o);
    else {
      if (s === 47)
        break;
      s = 47;
    }
    if (s === 47) {
      if (!(i === o - 1 || a === 1))
        if (i !== o - 1 && a === 2) {
          if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
            if (n.length > 2) {
              if (l = n.lastIndexOf("/"), l !== n.length - 1) {
                l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), i = o, a = 0;
                continue;
              }
            } else if (n.length > 0) {
              n = "", r = 0, i = o, a = 0;
              continue;
            }
          }
          t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
        } else
          n.length > 0 ? n += "/" + e.slice(i + 1, o) : n = e.slice(i + 1, o), r = o - i - 1;
      i = o, a = 0;
    } else
      s === 46 && a > -1 ? a++ : a = -1;
  }
  return n;
}
function ul(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const UI = { cwd: FI };
function FI() {
  return "/";
}
function ch(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function BI(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!ch(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return zI(e);
}
function zI(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const Kf = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class _x {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? ch(t) ? n = { path: t } : typeof t == "string" || ZI(t) ? n = { value: t } : n = t : n = {}, this.cwd = UI.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Kf.length; ) {
      const a = Kf[r];
      a in n && n[a] !== void 0 && n[a] !== null && (this[a] = a === "history" ? [...n[a]] : n[a]);
    }
    let i;
    for (i in n)
      Kf.includes(i) || (this[i] = n[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Ar.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    Jf(t, "basename"), Gf(t, "basename"), this.path = Ar.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Ar.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    dv(this.basename, "dirname"), this.path = Ar.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Ar.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (Gf(t, "extname"), dv(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Ar.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    ch(t) && (t = BI(t)), Jf(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Ar.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    Jf(t, "stem"), Gf(t, "stem"), this.path = Ar.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const i = this.message(t, n, r);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const i = this.message(t, n, r);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const i = new In(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function Gf(e, t) {
  if (e && e.includes(Ar.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Ar.sep + "`"
    );
}
function Jf(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function dv(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function ZI(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const qI = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = r[e], a = function() {
      return i.apply(a, arguments);
    };
    Object.setPrototypeOf(a, r);
    const o = Object.getOwnPropertyNames(i);
    for (const s of o) {
      const l = Object.getOwnPropertyDescriptor(i, s);
      l && Object.defineProperty(a, s, l);
    }
    return a;
  }
), WI = {}.hasOwnProperty;
class Um extends qI {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = RI();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Um()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(Hf(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * >  **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * >  **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (Qf("data", this.frozen), this.namespace[t] = n, this) : WI.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Qf("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const i = n.call(t, ...r);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * >  **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = Yl(t), r = this.parser || this.Parser;
    return Yf("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * >  **Note**: `process` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), Yf("process", this.parser || this.Parser), Xf("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i);
    function i(a, o) {
      const s = Yl(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(s)
      );
      r.run(l, s, function(u, d, p) {
        if (u || !d || !p)
          return c(u);
        const f = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          d
        ), h = r.stringify(f, p);
        KI(h) ? p.value = h : p.result = h, c(
          u,
          /** @type {VFileWithOutput<CompileResult>} */
          p
        );
      });
      function c(u, d) {
        u || !d ? o(u) : a ? a(d) : n(void 0, d);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), Yf("processSync", this.parser || this.Parser), Xf("processSync", this.compiler || this.Compiler), this.process(t, i), pv("processSync", "process", n), r;
    function i(a, o) {
      n = !0, iv(a), r = o;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * >  **Note**: `run` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    fv(t), this.freeze();
    const i = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? a(void 0, r) : new Promise(a);
    function a(o, s) {
      const l = Yl(n);
      i.run(t, l, c);
      function c(u, d, p) {
        const f = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          d || t
        );
        u ? s(u) : o ? o(f) : r(void 0, f, p);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, i;
    return this.run(t, n, a), pv("runSync", "run", r), i;
    function a(o, s) {
      iv(o), i = s, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * >  **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = Yl(n), i = this.compiler || this.Compiler;
    return Xf("stringify", i), fv(t), i(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * >  **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, i = this.namespace;
    if (Qf("use", this.frozen), t != null)
      if (typeof t == "function")
        l(t, n);
      else if (typeof t == "object")
        Array.isArray(t) ? s(t) : o(t);
      else
        throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function a(c) {
      if (typeof c == "function")
        l(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [u, ...d] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          l(u, d);
        } else
          o(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function o(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      s(c.plugins), c.settings && (i.settings = Hf(!0, i.settings, c.settings));
    }
    function s(c) {
      let u = -1;
      if (c != null)
        if (Array.isArray(c))
          for (; ++u < c.length; ) {
            const d = c[u];
            a(d);
          }
        else
          throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function l(c, u) {
      let d = -1, p = -1;
      for (; ++d < r.length; )
        if (r[d][0] === c) {
          p = d;
          break;
        }
      if (p === -1)
        r.push([c, ...u]);
      else if (u.length > 0) {
        let [f, ...h] = u;
        const m = r[p][1];
        lh(m) && lh(f) && (f = Hf(!0, m, f)), r[p] = [c, f, ...h];
      }
    }
  }
}
const VI = new Um().freeze();
function Yf(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function Xf(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function Qf(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function fv(e) {
  if (!lh(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function pv(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Yl(e) {
  return HI(e) ? e : new _x(e);
}
function HI(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function KI(e) {
  return typeof e == "string" || GI(e);
}
function GI(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const JI = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", hv = [], mv = { allowDangerousHtml: !0 }, YI = /^(https?|ircs?|mailto|xmpp)$/i, XI = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function QI(e) {
  const t = e.allowedElements, n = e.allowElement, r = e.children || "", i = e.className, a = e.components, o = e.disallowedElements, s = e.rehypePlugins || hv, l = e.remarkPlugins || hv, c = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...mv } : mv, u = e.skipHtml, d = e.unwrapDisallowed, p = e.urlTransform || eM, f = VI().use(NP).use(l).use(AI, c).use(s), h = new _x();
  typeof r == "string" && (h.value = r);
  for (const v of XI)
    Object.hasOwn(e, v.from) && ("" + v.from + (v.to ? "use `" + v.to + "` instead" : "remove it") + JI + v.id, void 0);
  const m = f.parse(h);
  let y = f.runSync(m, h);
  return i && (y = {
    type: "element",
    tagName: "div",
    properties: { className: i },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      y.type === "root" ? y.children : [y]
    )
  }), jm(y, g), v$(y, {
    Fragment: F.Fragment,
    components: a,
    ignoreInvalidStyle: !0,
    jsx: F.jsx,
    jsxs: F.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function g(v, b, T) {
    if (v.type === "raw" && T && typeof b == "number")
      return u ? T.children.splice(b, 1) : T.children[b] = { type: "text", value: v.value }, b;
    if (v.type === "element") {
      let O;
      for (O in qf)
        if (Object.hasOwn(qf, O) && Object.hasOwn(v.properties, O)) {
          const S = v.properties[O], P = qf[O];
          (P === null || P.includes(v.tagName)) && (v.properties[O] = p(String(S || ""), O, v));
        }
    }
    if (v.type === "element") {
      let O = t ? !t.includes(v.tagName) : o ? o.includes(v.tagName) : !1;
      if (!O && n && typeof b == "number" && (O = !n(v, b, T)), O && T && typeof b == "number")
        return d && v.children ? T.children.splice(b, 1, ...v.children) : T.children.splice(b, 1), b;
    }
  }
}
function eM(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    i > -1 && t > i || n > -1 && t > n || r > -1 && t > r || // It is a protocol, it should be allowed.
    YI.test(e.slice(0, t)) ? e : ""
  );
}
function tM(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Sx(e, t, n) {
  const i = kd((n || {}).ignore || []), a = nM(t);
  let o = -1;
  for (; ++o < a.length; )
    wx(e, "text", s);
  function s(c, u) {
    let d = -1, p;
    for (; ++d < u.length; ) {
      const f = u[d], h = p ? p.children : void 0;
      if (i(
        f,
        h ? h.indexOf(f) : void 0,
        p
      ))
        return;
      p = f;
    }
    if (p)
      return l(c, u);
  }
  function l(c, u) {
    const d = u[u.length - 1], p = a[o][0], f = a[o][1];
    let h = 0;
    const y = d.children.indexOf(c);
    let g = !1, v = [];
    p.lastIndex = 0;
    let b = p.exec(c.value);
    for (; b; ) {
      const T = b.index, O = {
        index: b.index,
        input: b.input,
        stack: [...u, c]
      };
      let S = f(...b, O);
      if (typeof S == "string" && (S = S.length > 0 ? { type: "text", value: S } : void 0), S === !1 ? p.lastIndex = T + 1 : (h !== T && v.push({
        type: "text",
        value: c.value.slice(h, T)
      }), Array.isArray(S) ? v.push(...S) : S && v.push(S), h = T + b[0].length, g = !0), !p.global)
        break;
      b = p.exec(c.value);
    }
    return g ? (h < c.value.length && v.push({ type: "text", value: c.value.slice(h) }), d.children.splice(y, 1, ...v)) : v = [c], y + v.length;
  }
}
function nM(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const i = n[r];
    t.push([rM(i[0]), iM(i[1])]);
  }
  return t;
}
function rM(e) {
  return typeof e == "string" ? new RegExp(tM(e), "g") : e;
}
function iM(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
function aM(e) {
  Sx(e, [/\r?\n|\r/g, oM]);
}
function oM() {
  return { type: "break" };
}
function sM() {
  return function(e) {
    aM(e);
  };
}
function gv(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, i = n.indexOf(t);
  for (; i !== -1; )
    r++, i = n.indexOf(t, i + t.length);
  return r;
}
const ep = "phrasing", tp = ["autolink", "link", "image", "label"];
function lM() {
  return {
    transforms: [mM],
    enter: {
      literalAutolink: uM,
      literalAutolinkEmail: np,
      literalAutolinkHttp: np,
      literalAutolinkWww: np
    },
    exit: {
      literalAutolink: hM,
      literalAutolinkEmail: pM,
      literalAutolinkHttp: dM,
      literalAutolinkWww: fM
    }
  };
}
function cM() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: ep,
        notInConstruct: tp
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: ep,
        notInConstruct: tp
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: ep,
        notInConstruct: tp
      }
    ]
  };
}
function uM(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function np(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function dM(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function fM(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function pM(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function hM(e) {
  this.exit(e);
}
function mM(e) {
  Sx(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, gM],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, yM]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function gM(e, t, n, r, i) {
  let a = "";
  if (!Ex(i) || (/^w/i.test(t) && (n = t + n, t = "", a = "http://"), !vM(n)))
    return !1;
  const o = bM(n + r);
  if (!o[0])
    return !1;
  const s = {
    type: "link",
    title: null,
    url: a + t + o[0],
    children: [{ type: "text", value: t + o[0] }]
  };
  return o[1] ? [s, { type: "text", value: o[1] }] : s;
}
function yM(e, t, n, r) {
  return (
    // Not an expected previous character.
    !Ex(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function vM(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function bM(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const i = gv(e, "(");
  let a = gv(e, ")");
  for (; r !== -1 && i > a; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), a++;
  return [e, n];
}
function Ex(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || ba(n) || _d(n)) && (!t || n !== 47);
}
kx.peek = $M;
function wM() {
  return {
    enter: {
      gfmFootnoteDefinition: _M,
      gfmFootnoteDefinitionLabelString: SM,
      gfmFootnoteCall: TM,
      gfmFootnoteCallString: CM
    },
    exit: {
      gfmFootnoteDefinition: kM,
      gfmFootnoteDefinitionLabelString: EM,
      gfmFootnoteCall: AM,
      gfmFootnoteCallString: OM
    }
  };
}
function xM() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: RM, footnoteReference: kx }
  };
}
function _M(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function SM() {
  this.buffer();
}
function EM(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = yr(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function kM(e) {
  this.exit(e);
}
function TM(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function CM() {
  this.buffer();
}
function OM(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = yr(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function AM(e) {
  this.exit(e);
}
function kx(e, t, n, r) {
  const i = n.createTracker(r);
  let a = i.move("[^");
  const o = n.enter("footnoteReference"), s = n.enter("reference");
  return a += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: a,
      after: "]"
    })
  ), s(), o(), a += i.move("]"), a;
}
function $M() {
  return "[";
}
function RM(e, t, n, r) {
  const i = n.createTracker(r);
  let a = i.move("[^");
  const o = n.enter("footnoteDefinition"), s = n.enter("label");
  return a += i.move(
    n.safe(n.associationId(e), {
      ...i.current(),
      before: a,
      after: "]"
    })
  ), s(), a += i.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), i.shift(4), a += i.move(
    n.indentLines(n.containerFlow(e, i.current()), PM)
  ), o(), a;
}
function PM(e, t, n) {
  return t === 0 ? e : (n ? "" : "    ") + e;
}
const IM = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
Tx.peek = jM;
function MM() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: DM },
    exit: { strikethrough: LM }
  };
}
function NM() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: IM
      }
    ],
    handlers: { delete: Tx }
  };
}
function DM(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function LM(e) {
  this.exit(e);
}
function Tx(e, t, n, r) {
  const i = n.createTracker(r), a = n.enter("strikethrough");
  let o = i.move("~~");
  return o += n.containerPhrasing(e, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), a(), o;
}
function jM() {
  return "~";
}
function UM(e, t = {}) {
  const n = (t.align || []).concat(), r = t.stringLength || BM, i = [], a = [], o = [], s = [];
  let l = 0, c = -1;
  for (; ++c < e.length; ) {
    const h = [], m = [];
    let y = -1;
    for (e[c].length > l && (l = e[c].length); ++y < e[c].length; ) {
      const g = FM(e[c][y]);
      if (t.alignDelimiters !== !1) {
        const v = r(g);
        m[y] = v, (s[y] === void 0 || v > s[y]) && (s[y] = v);
      }
      h.push(g);
    }
    a[c] = h, o[c] = m;
  }
  let u = -1;
  if (typeof n == "object" && "length" in n)
    for (; ++u < l; )
      i[u] = yv(n[u]);
  else {
    const h = yv(n);
    for (; ++u < l; )
      i[u] = h;
  }
  u = -1;
  const d = [], p = [];
  for (; ++u < l; ) {
    const h = i[u];
    let m = "", y = "";
    h === 99 ? (m = ":", y = ":") : h === 108 ? m = ":" : h === 114 && (y = ":");
    let g = t.alignDelimiters === !1 ? 1 : Math.max(
      1,
      s[u] - m.length - y.length
    );
    const v = m + "-".repeat(g) + y;
    t.alignDelimiters !== !1 && (g = m.length + g + y.length, g > s[u] && (s[u] = g), p[u] = g), d[u] = v;
  }
  a.splice(1, 0, d), o.splice(1, 0, p), c = -1;
  const f = [];
  for (; ++c < a.length; ) {
    const h = a[c], m = o[c];
    u = -1;
    const y = [];
    for (; ++u < l; ) {
      const g = h[u] || "";
      let v = "", b = "";
      if (t.alignDelimiters !== !1) {
        const T = s[u] - (m[u] || 0), O = i[u];
        O === 114 ? v = " ".repeat(T) : O === 99 ? T % 2 ? (v = " ".repeat(T / 2 + 0.5), b = " ".repeat(T / 2 - 0.5)) : (v = " ".repeat(T / 2), b = v) : b = " ".repeat(T);
      }
      t.delimiterStart !== !1 && !u && y.push("|"), t.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(t.alignDelimiters === !1 && g === "") && (t.delimiterStart !== !1 || u) && y.push(" "), t.alignDelimiters !== !1 && y.push(v), y.push(g), t.alignDelimiters !== !1 && y.push(b), t.padding !== !1 && y.push(" "), (t.delimiterEnd !== !1 || u !== l - 1) && y.push("|");
    }
    f.push(
      t.delimiterEnd === !1 ? y.join("").replace(/ +$/, "") : y.join("")
    );
  }
  return f.join(`
`);
}
function FM(e) {
  return e == null ? "" : String(e);
}
function BM(e) {
  return e.length;
}
function yv(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function zM(e, t, n, r) {
  const i = n.enter("blockquote"), a = n.createTracker(r);
  a.move("> "), a.shift(2);
  const o = n.indentLines(
    n.containerFlow(e, a.current()),
    ZM
  );
  return i(), o;
}
function ZM(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function qM(e, t) {
  return vv(e, t.inConstruct, !0) && !vv(e, t.notInConstruct, !1);
}
function vv(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function bv(e, t, n, r) {
  let i = -1;
  for (; ++i < n.unsafe.length; )
    if (n.unsafe[i].character === `
` && qM(n.stack, n.unsafe[i]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function WM(e, t) {
  const n = String(e);
  let r = n.indexOf(t), i = r, a = 0, o = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === i ? ++a > o && (o = a) : a = 1, i = r + t.length, r = n.indexOf(t, i);
  return o;
}
function VM(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function HM(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function KM(e, t, n, r) {
  const i = HM(n), a = e.value || "", o = i === "`" ? "GraveAccent" : "Tilde";
  if (VM(e, n)) {
    const d = n.enter("codeIndented"), p = n.indentLines(a, GM);
    return d(), p;
  }
  const s = n.createTracker(r), l = i.repeat(Math.max(WM(a, i) + 1, 3)), c = n.enter("codeFenced");
  let u = s.move(l);
  if (e.lang) {
    const d = n.enter(`codeFencedLang${o}`);
    u += s.move(
      n.safe(e.lang, {
        before: u,
        after: " ",
        encode: ["`"],
        ...s.current()
      })
    ), d();
  }
  if (e.lang && e.meta) {
    const d = n.enter(`codeFencedMeta${o}`);
    u += s.move(" "), u += s.move(
      n.safe(e.meta, {
        before: u,
        after: `
`,
        encode: ["`"],
        ...s.current()
      })
    ), d();
  }
  return u += s.move(`
`), a && (u += s.move(a + `
`)), u += s.move(l), c(), u;
}
function GM(e, t, n) {
  return (n ? "" : "    ") + e;
}
function Fm(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function JM(e, t, n, r) {
  const i = Fm(n), a = i === '"' ? "Quote" : "Apostrophe", o = n.enter("definition");
  let s = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("[");
  return c += l.move(
    n.safe(n.associationId(e), {
      before: c,
      after: "]",
      ...l.current()
    })
  ), c += l.move("]: "), s(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (s = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : `
`,
      ...l.current()
    })
  )), s(), e.title && (s = n.enter(`title${a}`), c += l.move(" " + i), c += l.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...l.current()
    })
  ), c += l.move(i), s()), o(), c;
}
function YM(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
Cx.peek = XM;
function Cx(e, t, n, r) {
  const i = YM(n), a = n.enter("emphasis"), o = n.createTracker(r);
  let s = o.move(i);
  return s += o.move(
    n.containerPhrasing(e, {
      before: s,
      after: i,
      ...o.current()
    })
  ), s += o.move(i), a(), s;
}
function XM(e, t, n) {
  return n.options.emphasis || "*";
}
function QM(e, t) {
  let n = !1;
  return jm(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, oh;
  }), !!((!e.depth || e.depth < 3) && Rm(e) && (t.options.setext || n));
}
function eN(e, t, n, r) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), a = n.createTracker(r);
  if (QM(e, n)) {
    const u = n.enter("headingSetext"), d = n.enter("phrasing"), p = n.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return d(), u(), p + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size
      p.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(p.lastIndexOf("\r"), p.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(i), s = n.enter("headingAtx"), l = n.enter("phrasing");
  a.move(o + " ");
  let c = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(c) && (c = "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";" + c.slice(1)), c = c ? o + " " + c : o, n.options.closeAtx && (c += " " + o), l(), s(), c;
}
Ox.peek = tN;
function Ox(e) {
  return e.value || "";
}
function tN() {
  return "<";
}
Ax.peek = nN;
function Ax(e, t, n, r) {
  const i = Fm(n), a = i === '"' ? "Quote" : "Apostrophe", o = n.enter("image");
  let s = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("![");
  return c += l.move(
    n.safe(e.alt, { before: c, after: "]", ...l.current() })
  ), c += l.move("]("), s(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (s = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (s = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), s(), e.title && (s = n.enter(`title${a}`), c += l.move(" " + i), c += l.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...l.current()
    })
  ), c += l.move(i), s()), c += l.move(")"), o(), c;
}
function nN() {
  return "!";
}
$x.peek = rN;
function $x(e, t, n, r) {
  const i = e.referenceType, a = n.enter("imageReference");
  let o = n.enter("label");
  const s = n.createTracker(r);
  let l = s.move("![");
  const c = n.safe(e.alt, {
    before: l,
    after: "]",
    ...s.current()
  });
  l += s.move(c + "]["), o();
  const u = n.stack;
  n.stack = [], o = n.enter("reference");
  const d = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...s.current()
  });
  return o(), n.stack = u, a(), i === "full" || !c || c !== d ? l += s.move(d + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += s.move("]"), l;
}
function rN() {
  return "!";
}
Rx.peek = iN;
function Rx(e, t, n) {
  let r = e.value || "", i = "`", a = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); )
    i += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++a < n.unsafe.length; ) {
    const o = n.unsafe[a], s = n.compilePattern(o);
    let l;
    if (o.atBreak)
      for (; l = s.exec(r); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(l.index + 1);
      }
  }
  return i + r + i;
}
function iN() {
  return "`";
}
function Px(e, t) {
  const n = Rm(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
Ix.peek = aN;
function Ix(e, t, n, r) {
  const i = Fm(n), a = i === '"' ? "Quote" : "Apostrophe", o = n.createTracker(r);
  let s, l;
  if (Px(e, n)) {
    const u = n.stack;
    n.stack = [], s = n.enter("autolink");
    let d = o.move("<");
    return d += o.move(
      n.containerPhrasing(e, {
        before: d,
        after: ">",
        ...o.current()
      })
    ), d += o.move(">"), s(), n.stack = u, d;
  }
  s = n.enter("link"), l = n.enter("label");
  let c = o.move("[");
  return c += o.move(
    n.containerPhrasing(e, {
      before: c,
      after: "](",
      ...o.current()
    })
  ), c += o.move("]("), l(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += o.move("<"), c += o.move(
    n.safe(e.url, { before: c, after: ">", ...o.current() })
  ), c += o.move(">")) : (l = n.enter("destinationRaw"), c += o.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...o.current()
    })
  )), l(), e.title && (l = n.enter(`title${a}`), c += o.move(" " + i), c += o.move(
    n.safe(e.title, {
      before: c,
      after: i,
      ...o.current()
    })
  ), c += o.move(i), l()), c += o.move(")"), s(), c;
}
function aN(e, t, n) {
  return Px(e, n) ? "<" : "[";
}
Mx.peek = oN;
function Mx(e, t, n, r) {
  const i = e.referenceType, a = n.enter("linkReference");
  let o = n.enter("label");
  const s = n.createTracker(r);
  let l = s.move("[");
  const c = n.containerPhrasing(e, {
    before: l,
    after: "]",
    ...s.current()
  });
  l += s.move(c + "]["), o();
  const u = n.stack;
  n.stack = [], o = n.enter("reference");
  const d = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...s.current()
  });
  return o(), n.stack = u, a(), i === "full" || !c || c !== d ? l += s.move(d + "]") : i === "shortcut" ? l = l.slice(0, -1) : l += s.move("]"), l;
}
function oN() {
  return "[";
}
function Bm(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function sN(e) {
  const t = Bm(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function lN(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function Nx(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function cN(e, t, n, r) {
  const i = n.enter("list"), a = n.bulletCurrent;
  let o = e.ordered ? lN(n) : Bm(n);
  const s = e.ordered ? o === "." ? ")" : "." : sN(n);
  let l = t && n.bulletLastUsed ? o === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const u = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      u && (!u.children || !u.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), Nx(n) === o && u
    ) {
      let d = -1;
      for (; ++d < e.children.length; ) {
        const p = e.children[d];
        if (p && p.type === "listItem" && p.children && p.children[0] && p.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (o = s), n.bulletCurrent = o;
  const c = n.containerFlow(e, r);
  return n.bulletLastUsed = o, n.bulletCurrent = a, i(), c;
}
function uN(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function dN(e, t, n, r) {
  const i = uN(n);
  let a = n.bulletCurrent || Bm(n);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let o = a.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (o = Math.ceil(o / 4) * 4);
  const s = n.createTracker(r);
  s.move(a + " ".repeat(o - a.length)), s.shift(o);
  const l = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(e, s.current()),
    u
  );
  return l(), c;
  function u(d, p, f) {
    return p ? (f ? "" : " ".repeat(o)) + d : (f ? a : a + " ".repeat(o - a.length)) + d;
  }
}
function fN(e, t, n, r) {
  const i = n.enter("paragraph"), a = n.enter("phrasing"), o = n.containerPhrasing(e, r);
  return a(), i(), o;
}
const pN = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  kd([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function hN(e, t, n, r) {
  return (e.children.some(function(o) {
    return pN(o);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function mN(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
Dx.peek = gN;
function Dx(e, t, n, r) {
  const i = mN(n), a = n.enter("strong"), o = n.createTracker(r);
  let s = o.move(i + i);
  return s += o.move(
    n.containerPhrasing(e, {
      before: s,
      after: i,
      ...o.current()
    })
  ), s += o.move(i + i), a(), s;
}
function gN(e, t, n) {
  return n.options.strong || "*";
}
function yN(e, t, n, r) {
  return n.safe(e.value, r);
}
function vN(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function bN(e, t, n) {
  const r = (Nx(n) + (n.options.ruleSpaces ? " " : "")).repeat(vN(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Lx = {
  blockquote: zM,
  break: bv,
  code: KM,
  definition: JM,
  emphasis: Cx,
  hardBreak: bv,
  heading: eN,
  html: Ox,
  image: Ax,
  imageReference: $x,
  inlineCode: Rx,
  link: Ix,
  linkReference: Mx,
  list: cN,
  listItem: dN,
  paragraph: fN,
  root: hN,
  strong: Dx,
  text: yN,
  thematicBreak: bN
};
function wN() {
  return {
    enter: {
      table: xN,
      tableData: wv,
      tableHeader: wv,
      tableRow: SN
    },
    exit: {
      codeText: EN,
      table: _N,
      tableData: rp,
      tableHeader: rp,
      tableRow: rp
    }
  };
}
function xN(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function _N(e) {
  this.exit(e), this.data.inTable = void 0;
}
function SN(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function rp(e) {
  this.exit(e);
}
function wv(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function EN(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, kN));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function kN(e, t) {
  return t === "|" ? t : e;
}
function TN(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, a = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: p,
      table: o,
      tableCell: l,
      tableRow: s
    }
  };
  function o(f, h, m, y) {
    return c(u(f, m, y), f.align);
  }
  function s(f, h, m, y) {
    const g = d(f, m, y), v = c([g]);
    return v.slice(0, v.indexOf(`
`));
  }
  function l(f, h, m, y) {
    const g = m.enter("tableCell"), v = m.enter("phrasing"), b = m.containerPhrasing(f, {
      ...y,
      before: a,
      after: a
    });
    return v(), g(), b;
  }
  function c(f, h) {
    return UM(f, {
      align: h,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function u(f, h, m) {
    const y = f.children;
    let g = -1;
    const v = [], b = h.enter("table");
    for (; ++g < y.length; )
      v[g] = d(y[g], h, m);
    return b(), v;
  }
  function d(f, h, m) {
    const y = f.children;
    let g = -1;
    const v = [], b = h.enter("tableRow");
    for (; ++g < y.length; )
      v[g] = l(y[g], f, h, m);
    return b(), v;
  }
  function p(f, h, m) {
    let y = Lx.inlineCode(f, h, m);
    return m.stack.includes("tableCell") && (y = y.replace(/\|/g, "\\$&")), y;
  }
}
function CN() {
  return {
    exit: {
      taskListCheckValueChecked: xv,
      taskListCheckValueUnchecked: xv,
      paragraph: AN
    }
  };
}
function ON() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: $N }
  };
}
function xv(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function AN(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const i = t.children;
      let a = -1, o;
      for (; ++a < i.length; ) {
        const s = i[a];
        if (s.type === "paragraph") {
          o = s;
          break;
        }
      }
      o === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function $N(e, t, n, r) {
  const i = e.children[0], a = typeof e.checked == "boolean" && i && i.type === "paragraph", o = "[" + (e.checked ? "x" : " ") + "] ", s = n.createTracker(r);
  a && s.move(o);
  let l = Lx.listItem(e, t, n, {
    ...r,
    ...s.current()
  });
  return a && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l;
  function c(u) {
    return u + o;
  }
}
function RN() {
  return [
    lM(),
    wM(),
    MM(),
    wN(),
    CN()
  ];
}
function PN(e) {
  return {
    extensions: [
      cM(),
      xM(),
      NM(),
      TN(e),
      ON()
    ]
  };
}
const IN = {
  tokenize: UN,
  partial: !0
}, jx = {
  tokenize: FN,
  partial: !0
}, Ux = {
  tokenize: BN,
  partial: !0
}, Fx = {
  tokenize: zN,
  partial: !0
}, MN = {
  tokenize: ZN,
  partial: !0
}, Bx = {
  tokenize: LN,
  previous: Zx
}, zx = {
  tokenize: jN,
  previous: qx
}, yi = {
  tokenize: DN,
  previous: Wx
}, Br = {};
function NN() {
  return {
    text: Br
  };
}
let ta = 48;
for (; ta < 123; )
  Br[ta] = yi, ta++, ta === 58 ? ta = 65 : ta === 91 && (ta = 97);
Br[43] = yi;
Br[45] = yi;
Br[46] = yi;
Br[95] = yi;
Br[72] = [yi, zx];
Br[104] = [yi, zx];
Br[87] = [yi, Bx];
Br[119] = [yi, Bx];
function DN(e, t, n) {
  const r = this;
  let i, a;
  return o;
  function o(d) {
    return !uh(d) || !Wx.call(r, r.previous) || zm(r.events) ? n(d) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), s(d));
  }
  function s(d) {
    return uh(d) ? (e.consume(d), s) : d === 64 ? (e.consume(d), l) : n(d);
  }
  function l(d) {
    return d === 46 ? e.check(
      MN,
      u,
      c
    )(d) : d === 45 || d === 95 || Cn(d) ? (a = !0, e.consume(d), l) : u(d);
  }
  function c(d) {
    return e.consume(d), i = !0, l;
  }
  function u(d) {
    return a && i && Dn(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(d)) : n(d);
  }
}
function LN(e, t, n) {
  const r = this;
  return i;
  function i(o) {
    return o !== 87 && o !== 119 || !Zx.call(r, r.previous) || zm(r.events) ? n(o) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(
      IN,
      e.attempt(jx, e.attempt(Ux, a), n),
      n
    )(o));
  }
  function a(o) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(o);
  }
}
function jN(e, t, n) {
  const r = this;
  let i = "", a = !1;
  return o;
  function o(d) {
    return (d === 72 || d === 104) && qx.call(r, r.previous) && !zm(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(d), e.consume(d), s) : n(d);
  }
  function s(d) {
    if (Dn(d) && i.length < 5)
      return i += String.fromCodePoint(d), e.consume(d), s;
    if (d === 58) {
      const p = i.toLowerCase();
      if (p === "http" || p === "https")
        return e.consume(d), l;
    }
    return n(d);
  }
  function l(d) {
    return d === 47 ? (e.consume(d), a ? c : (a = !0, l)) : n(d);
  }
  function c(d) {
    return d === null || Kc(d) || Rt(d) || ba(d) || _d(d) ? n(d) : e.attempt(jx, e.attempt(Ux, u), n)(d);
  }
  function u(d) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(d);
  }
}
function UN(e, t, n) {
  let r = 0;
  return i;
  function i(o) {
    return (o === 87 || o === 119) && r < 3 ? (r++, e.consume(o), i) : o === 46 && r === 3 ? (e.consume(o), a) : n(o);
  }
  function a(o) {
    return o === null ? n(o) : t(o);
  }
}
function FN(e, t, n) {
  let r, i, a;
  return o;
  function o(c) {
    return c === 46 || c === 95 ? e.check(Fx, l, s)(c) : c === null || Rt(c) || ba(c) || c !== 45 && _d(c) ? l(c) : (a = !0, e.consume(c), o);
  }
  function s(c) {
    return c === 95 ? r = !0 : (i = r, r = void 0), e.consume(c), o;
  }
  function l(c) {
    return i || r || !a ? n(c) : t(c);
  }
}
function BN(e, t) {
  let n = 0, r = 0;
  return i;
  function i(o) {
    return o === 40 ? (n++, e.consume(o), i) : o === 41 && r < n ? a(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? e.check(Fx, t, a)(o) : o === null || Rt(o) || ba(o) ? t(o) : (e.consume(o), i);
  }
  function a(o) {
    return o === 41 && r++, e.consume(o), i;
  }
}
function zN(e, t, n) {
  return r;
  function r(s) {
    return s === 33 || s === 34 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 63 || s === 95 || s === 126 ? (e.consume(s), r) : s === 38 ? (e.consume(s), a) : s === 93 ? (e.consume(s), i) : (
      // `<` is an end.
      s === 60 || // So is whitespace.
      s === null || Rt(s) || ba(s) ? t(s) : n(s)
    );
  }
  function i(s) {
    return s === null || s === 40 || s === 91 || Rt(s) || ba(s) ? t(s) : r(s);
  }
  function a(s) {
    return Dn(s) ? o(s) : n(s);
  }
  function o(s) {
    return s === 59 ? (e.consume(s), r) : Dn(s) ? (e.consume(s), o) : n(s);
  }
}
function ZN(e, t, n) {
  return r;
  function r(a) {
    return e.consume(a), i;
  }
  function i(a) {
    return Cn(a) ? n(a) : t(a);
  }
}
function Zx(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || Rt(e);
}
function qx(e) {
  return !Dn(e);
}
function Wx(e) {
  return !(e === 47 || uh(e));
}
function uh(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || Cn(e);
}
function zm(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const qN = {
  tokenize: XN,
  partial: !0
};
function WN() {
  return {
    document: {
      91: {
        tokenize: GN,
        continuation: {
          tokenize: JN
        },
        exit: YN
      }
    },
    text: {
      91: {
        tokenize: KN
      },
      93: {
        add: "after",
        tokenize: VN,
        resolveTo: HN
      }
    }
  };
}
function VN(e, t, n) {
  const r = this;
  let i = r.events.length;
  const a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let o;
  for (; i--; ) {
    const l = r.events[i][1];
    if (l.type === "labelImage") {
      o = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return s;
  function s(l) {
    if (!o || !o._balanced)
      return n(l);
    const c = yr(
      r.sliceSerialize({
        start: o.end,
        end: r.now()
      })
    );
    return c.codePointAt(0) !== 94 || !a.includes(c.slice(1)) ? n(l) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l));
  }
}
function HN(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, o = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, s = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", o, t],
    ["exit", o, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...s), e;
}
function KN(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a = 0, o;
  return s;
  function s(d) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(d) {
    return d !== 94 ? n(d) : (e.enter("gfmFootnoteCallMarker"), e.consume(d), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", c);
  }
  function c(d) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      d === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      d === null || d === 91 || Rt(d)
    )
      return n(d);
    if (d === 93) {
      e.exit("chunkString");
      const p = e.exit("gfmFootnoteCallString");
      return i.includes(yr(r.sliceSerialize(p))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(d);
    }
    return Rt(d) || (o = !0), a++, e.consume(d), d === 92 ? u : c;
  }
  function u(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), a++, c) : c(d);
  }
}
function GN(e, t, n) {
  const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let a, o = 0, s;
  return l;
  function l(h) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(h) {
    return h === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", u) : n(h);
  }
  function u(h) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      h === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || Rt(h)
    )
      return n(h);
    if (h === 93) {
      e.exit("chunkString");
      const m = e.exit("gfmFootnoteDefinitionLabelString");
      return a = yr(r.sliceSerialize(m)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), p;
    }
    return Rt(h) || (s = !0), o++, e.consume(h), h === 92 ? d : u;
  }
  function d(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), o++, u) : u(h);
  }
  function p(h) {
    return h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), i.includes(a) || i.push(a), _t(
      e,
      f,
      "gfmFootnoteDefinitionWhitespace"
    )) : n(h);
  }
  function f(h) {
    return t(h);
  }
}
function JN(e, t, n) {
  return e.check(cl, t, e.attempt(qN, t, n));
}
function YN(e) {
  e.exit("gfmFootnoteDefinition");
}
function XN(e, t, n) {
  const r = this;
  return _t(
    e,
    i,
    "gfmFootnoteDefinitionIndent",
    4 + 1
  );
  function i(a) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? t(a) : n(a);
  }
}
function QN(e) {
  let n = (e || {}).singleTilde;
  const r = {
    tokenize: a,
    resolveAll: i
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(o, s) {
    let l = -1;
    for (; ++l < o.length; )
      if (o[l][0] === "enter" && o[l][1].type === "strikethroughSequenceTemporary" && o[l][1]._close) {
        let c = l;
        for (; c--; )
          if (o[c][0] === "exit" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._open && // If the sizes are the same:
          o[l][1].end.offset - o[l][1].start.offset === o[c][1].end.offset - o[c][1].start.offset) {
            o[l][1].type = "strikethroughSequence", o[c][1].type = "strikethroughSequence";
            const u = {
              type: "strikethrough",
              start: Object.assign({}, o[c][1].start),
              end: Object.assign({}, o[l][1].end)
            }, d = {
              type: "strikethroughText",
              start: Object.assign({}, o[c][1].end),
              end: Object.assign({}, o[l][1].start)
            }, p = [
              ["enter", u, s],
              ["enter", o[c][1], s],
              ["exit", o[c][1], s],
              ["enter", d, s]
            ], f = s.parser.constructs.insideSpan.null;
            f && Qn(
              p,
              p.length,
              0,
              Sd(f, o.slice(c + 1, l), s)
            ), Qn(p, p.length, 0, [
              ["exit", d, s],
              ["enter", o[l][1], s],
              ["exit", o[l][1], s],
              ["exit", u, s]
            ]), Qn(o, c - 1, l - c + 3, p), l = c + p.length - 2;
            break;
          }
      }
    for (l = -1; ++l < o.length; )
      o[l][1].type === "strikethroughSequenceTemporary" && (o[l][1].type = "data");
    return o;
  }
  function a(o, s, l) {
    const c = this.previous, u = this.events;
    let d = 0;
    return p;
    function p(h) {
      return c === 126 && u[u.length - 1][1].type !== "characterEscape" ? l(h) : (o.enter("strikethroughSequenceTemporary"), f(h));
    }
    function f(h) {
      const m = Gc(c);
      if (h === 126)
        return d > 1 ? l(h) : (o.consume(h), d++, f);
      if (d < 2 && !n)
        return l(h);
      const y = o.exit("strikethroughSequenceTemporary"), g = Gc(h);
      return y._open = !g || g === 2 && !!m, y._close = !m || m === 2 && !!g, s(h);
    }
  }
}
class eD {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    tD(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, o) {
      return a[0] - o[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(
        t.slice(this.map[n][0] + this.map[n][1]),
        this.map[n][2]
      ), t.length = this.map[n][0];
    r.push([...t]), t.length = 0;
    let i = r.pop();
    for (; i; )
      t.push(...i), i = r.pop();
    this.map.length = 0;
  }
}
function tD(e, t, n, r) {
  let i = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += n, e.map[i][2].push(...r);
        return;
      }
      i += 1;
    }
    e.map.push([t, n, r]);
  }
}
function nD(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (n) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && r.push(
          e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
        );
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = r.length - 1;
          r[a] = r[a] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else
      i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function rD() {
  return {
    flow: {
      null: {
        tokenize: iD,
        resolveAll: aD
      }
    }
  };
}
function iD(e, t, n) {
  const r = this;
  let i = 0, a = 0, o;
  return s;
  function s(k) {
    let I = r.events.length - 1;
    for (; I > -1; ) {
      const z = r.events[I][1].type;
      if (z === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      z === "linePrefix")
        I--;
      else
        break;
    }
    const B = I > -1 ? r.events[I][1].type : null, U = B === "tableHead" || B === "tableRow" ? S : l;
    return U === S && r.parser.lazy[r.now().line] ? n(k) : U(k);
  }
  function l(k) {
    return e.enter("tableHead"), e.enter("tableRow"), c(k);
  }
  function c(k) {
    return k === 124 || (o = !0, a += 1), u(k);
  }
  function u(k) {
    return k === null ? n(k) : Ge(k) ? a > 1 ? (a = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(k), e.exit("lineEnding"), f) : n(k) : mt(k) ? _t(e, u, "whitespace")(k) : (a += 1, o && (o = !1, i += 1), k === 124 ? (e.enter("tableCellDivider"), e.consume(k), e.exit("tableCellDivider"), o = !0, u) : (e.enter("data"), d(k)));
  }
  function d(k) {
    return k === null || k === 124 || Rt(k) ? (e.exit("data"), u(k)) : (e.consume(k), k === 92 ? p : d);
  }
  function p(k) {
    return k === 92 || k === 124 ? (e.consume(k), d) : d(k);
  }
  function f(k) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(k) : (e.enter("tableDelimiterRow"), o = !1, mt(k) ? _t(
      e,
      h,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(k) : h(k));
  }
  function h(k) {
    return k === 45 || k === 58 ? y(k) : k === 124 ? (o = !0, e.enter("tableCellDivider"), e.consume(k), e.exit("tableCellDivider"), m) : O(k);
  }
  function m(k) {
    return mt(k) ? _t(e, y, "whitespace")(k) : y(k);
  }
  function y(k) {
    return k === 58 ? (a += 1, o = !0, e.enter("tableDelimiterMarker"), e.consume(k), e.exit("tableDelimiterMarker"), g) : k === 45 ? (a += 1, g(k)) : k === null || Ge(k) ? T(k) : O(k);
  }
  function g(k) {
    return k === 45 ? (e.enter("tableDelimiterFiller"), v(k)) : O(k);
  }
  function v(k) {
    return k === 45 ? (e.consume(k), v) : k === 58 ? (o = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(k), e.exit("tableDelimiterMarker"), b) : (e.exit("tableDelimiterFiller"), b(k));
  }
  function b(k) {
    return mt(k) ? _t(e, T, "whitespace")(k) : T(k);
  }
  function T(k) {
    return k === 124 ? h(k) : k === null || Ge(k) ? !o || i !== a ? O(k) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(k)) : O(k);
  }
  function O(k) {
    return n(k);
  }
  function S(k) {
    return e.enter("tableRow"), P(k);
  }
  function P(k) {
    return k === 124 ? (e.enter("tableCellDivider"), e.consume(k), e.exit("tableCellDivider"), P) : k === null || Ge(k) ? (e.exit("tableRow"), t(k)) : mt(k) ? _t(e, P, "whitespace")(k) : (e.enter("data"), M(k));
  }
  function M(k) {
    return k === null || k === 124 || Rt(k) ? (e.exit("data"), P(k)) : (e.consume(k), k === 92 ? L : M);
  }
  function L(k) {
    return k === 92 || k === 124 ? (e.consume(k), M) : M(k);
  }
}
function aD(e, t) {
  let n = -1, r = !0, i = 0, a = [0, 0, 0, 0], o = [0, 0, 0, 0], s = !1, l = 0, c, u, d;
  const p = new eD();
  for (; ++n < e.length; ) {
    const f = e[n], h = f[1];
    f[0] === "enter" ? h.type === "tableHead" ? (s = !1, l !== 0 && (_v(p, t, l, c, u), u = void 0, l = 0), c = {
      type: "table",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, p.add(n, 0, [["enter", c, t]])) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (r = !0, d = void 0, a = [0, 0, 0, 0], o = [0, n + 1, 0, 0], s && (s = !1, u = {
      type: "tableBody",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, p.add(n, 0, [["enter", u, t]])), i = h.type === "tableDelimiterRow" ? 2 : u ? 3 : 1) : i && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") ? (r = !1, o[2] === 0 && (a[1] !== 0 && (o[0] = o[1], d = Xl(
      p,
      t,
      a,
      i,
      void 0,
      d
    ), a = [0, 0, 0, 0]), o[2] = n)) : h.type === "tableCellDivider" && (r ? r = !1 : (a[1] !== 0 && (o[0] = o[1], d = Xl(
      p,
      t,
      a,
      i,
      void 0,
      d
    )), a = o, o = [a[1], n, 0, 0])) : h.type === "tableHead" ? (s = !0, l = n) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (l = n, a[1] !== 0 ? (o[0] = o[1], d = Xl(
      p,
      t,
      a,
      i,
      n,
      d
    )) : o[1] !== 0 && (d = Xl(p, t, o, i, n, d)), i = 0) : i && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") && (o[3] = n);
  }
  for (l !== 0 && _v(p, t, l, c, u), p.consume(t.events), n = -1; ++n < t.events.length; ) {
    const f = t.events[n];
    f[0] === "enter" && f[1].type === "table" && (f[1]._align = nD(t.events, n));
  }
  return e;
}
function Xl(e, t, n, r, i, a) {
  const o = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", s = "tableContent";
  n[0] !== 0 && (a.end = Object.assign({}, Ha(t.events, n[0])), e.add(n[0], 0, [["exit", a, t]]));
  const l = Ha(t.events, n[1]);
  if (a = {
    type: o,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, e.add(n[1], 0, [["enter", a, t]]), n[2] !== 0) {
    const c = Ha(t.events, n[2]), u = Ha(t.events, n[3]), d = {
      type: s,
      start: Object.assign({}, c),
      end: Object.assign({}, u)
    };
    if (e.add(n[2], 0, [["enter", d, t]]), r !== 2) {
      const p = t.events[n[2]], f = t.events[n[3]];
      if (p[1].end = Object.assign({}, f[1].end), p[1].type = "chunkText", p[1].contentType = "text", n[3] > n[2] + 1) {
        const h = n[2] + 1, m = n[3] - n[2] - 1;
        e.add(h, m, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", d, t]]);
  }
  return i !== void 0 && (a.end = Object.assign({}, Ha(t.events, i)), e.add(i, 0, [["exit", a, t]]), a = void 0), a;
}
function _v(e, t, n, r, i) {
  const a = [], o = Ha(t.events, n);
  i && (i.end = Object.assign({}, o), a.push(["exit", i, t])), r.end = Object.assign({}, o), a.push(["exit", r, t]), e.add(n + 1, 0, a);
}
function Ha(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const oD = {
  tokenize: lD
};
function sD() {
  return {
    text: {
      91: oD
    }
  };
}
function lD(e, t, n) {
  const r = this;
  return i;
  function i(l) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(l) {
    return Rt(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), o) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), o) : n(l);
  }
  function o(l) {
    return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), s) : n(l);
  }
  function s(l) {
    return Ge(l) ? t(l) : mt(l) ? e.check(
      {
        tokenize: cD
      },
      t,
      n
    )(l) : n(l);
  }
}
function cD(e, t, n) {
  return _t(e, r, "whitespace");
  function r(i) {
    return i === null ? n(i) : t(i);
  }
}
function uD(e) {
  return tx([
    NN(),
    WN(),
    QN(e),
    rD(),
    sD()
  ]);
}
const dD = {};
function fD(e) {
  const t = (
    /** @type {Processor} */
    this
  ), n = e || dD, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), a = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), o = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  i.push(uD(n)), a.push(RN()), o.push(PN(n));
}
const pD = ({ text: e, type: t, styles: n }) => {
  const r = n == null ? void 0 : n[t], i = {
    h1: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("h1", { ...o, ...r == null ? void 0 : r.heading1 }),
    h2: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("h2", { ...o, ...r == null ? void 0 : r.heading2 }),
    h3: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("h3", { ...o, ...r == null ? void 0 : r.heading3 }),
    h4: "h3",
    h5: "h3",
    h6: "h3",
    em: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("em", { ...o, ...r == null ? void 0 : r.italic }),
    strong: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("strong", { ...o, ...r == null ? void 0 : r.bold }),
    p: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("p", { ...o, ...r == null ? void 0 : r.text }),
    hr: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("hr", { ...o, ...r == null ? void 0 : r.horizontalRule }),
    a: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("a", { ...o, ...r == null ? void 0 : r.link, target: "_blank" }),
    ol: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("ol", { ...o, ...r == null ? void 0 : r.orderedList }),
    ul: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("ul", { ...o, ...r == null ? void 0 : r.unorderedList }),
    li: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("li", { ...o, ...r == null ? void 0 : r.listItem }),
    br: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("br", { ...o, ...r == null ? void 0 : r.lineBreak }),
    img: () => null,
    pre: ({ node: a, ...o }) => /* @__PURE__ */ F.jsx("pre", { ...o, ...r == null ? void 0 : r.pre })
  };
  return /* @__PURE__ */ F.jsx(QI, { components: i, remarkPlugins: [fD, sM], children: e });
}, Vx = _r(null);
function Hx() {
  const e = Er(Vx);
  if (!e)
    throw new Error("useComposerContext must be used within a Message");
  return e;
}
const Kx = _r(null);
function hD() {
  const e = Er(Kx);
  if (!e)
    throw new Error("useMessageContext must be used within a Message");
  return e;
}
const Gx = _r(null);
function Jx() {
  const e = Er(Gx);
  if (!e)
    throw new Error("useModalContext must be used within a ModalProvider");
  return e;
}
const Yx = _r(null);
function It() {
  const e = Er(Yx);
  if (!e)
    throw new Error("useWebchatContext must be used within a WebchatProvider");
  return e;
}
const mD = ({ text: e, buttonValue: t, type: n, styles: r, variant: i, groupId: a, reusable: o, ...s }) => {
  const { eventEmitter: l, client: c } = It(), [u, d] = De(!1), [p, f] = De(!1), [h, m] = De(!1), { state: y } = It();
  Be(() => {
    if (a)
      return l.on(`button-group-${a}-click`, () => {
        f(!0), o || m(!0);
      });
  }, [l, a, o]);
  function g() {
    a && l.emit(`button-group-${a}-click`), d(!0), o || m(!0), i !== "link" && (c == null || c.sendMessage(t));
  }
  return /* @__PURE__ */ F.jsx(
    gD,
    {
      ...s,
      variant: i,
      onClick: g,
      disabled: h || y.isReadOnly,
      "data-activated": u ? "" : void 0,
      "data-group-activated": p ? "" : void 0,
      "data-type": i,
      value: t,
      ...r == null ? void 0 : r[n],
      children: e
    }
  );
}, gD = (e) => {
  if (e.variant === "link") {
    const { value: r, variant: i, ...a } = e;
    return /* @__PURE__ */ F.jsx("a", { ...a, href: r, target: "_blank", rel: "noopener noreferrer" });
  }
  const { variant: t, ...n } = e;
  return /* @__PURE__ */ F.jsx("button", { ...n });
}, yD = ze(({ block: e, styles: t, type: n, ...r }, i) => /* @__PURE__ */ F.jsx("div", { ...r, ...t == null ? void 0 : t[n], ref: i, children: /* @__PURE__ */ F.jsx(yl, { styles: t, block: e }) }));
function vD(e, t) {
  const n = t ? `The ${t} has been copied to your clipboard.` : "Copied to clipboard.";
  return navigator.clipboard.writeText(e).then(() => M2({ title: n, type: "success" }));
}
const bD = (e, t = {}) => new Promise((n, r) => {
  if (typeof window > "u")
    return r("Window is not defined");
  if (!e)
    return r("Url is not defined");
  let i = null;
  const a = new Image();
  a.addEventListener("load", () => {
    i && clearTimeout(i), n({ width: a.naturalWidth, height: a.naturalHeight });
  }), a.addEventListener("error", (o) => {
    i && clearTimeout(i), r(`${o.type}: ${o.message}`);
  }), a.src = e, t.timeout && (i = setTimeout(() => r("Timeout"), t.timeout));
});
let wD = { data: "" }, xD = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || wD, _D = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, SD = /\/\*[^]*?\*\/|  +/g, Sv = /\n+/g, Ri = (e, t) => {
  let n = "", r = "", i = "";
  for (let a in e) {
    let o = e[a];
    a[0] == "@" ? a[1] == "i" ? n = a + " " + o + ";" : r += a[1] == "f" ? Ri(o, a) : a + "{" + Ri(o, a[1] == "k" ? "" : t) + "}" : typeof o == "object" ? r += Ri(o, t ? t.replace(/([^,])+/g, (s) => a.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : a) : o != null && (a = /^--/.test(a) ? a : a.replace(/[A-Z]/g, "-$&").toLowerCase(), i += Ri.p ? Ri.p(a, o) : a + ":" + o + ";");
  }
  return n + (t && i ? t + "{" + i + "}" : i) + r;
}, Yr = {}, Xx = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e)
      t += n + Xx(e[n]);
    return t;
  }
  return e;
}, ED = (e, t, n, r, i) => {
  let a = Xx(e), o = Yr[a] || (Yr[a] = ((l) => {
    let c = 0, u = 11;
    for (; c < l.length; )
      u = 101 * u + l.charCodeAt(c++) >>> 0;
    return "go" + u;
  })(a));
  if (!Yr[o]) {
    let l = a !== e ? e : ((c) => {
      let u, d, p = [{}];
      for (; u = _D.exec(c.replace(SD, "")); )
        u[4] ? p.shift() : u[3] ? (d = u[3].replace(Sv, " ").trim(), p.unshift(p[0][d] = p[0][d] || {})) : p[0][u[1]] = u[2].replace(Sv, " ").trim();
      return p[0];
    })(e);
    Yr[o] = Ri(i ? { ["@keyframes " + o]: l } : l, n ? "" : "." + o);
  }
  let s = n && Yr.g ? Yr.g : null;
  return n && (Yr.g = Yr[o]), ((l, c, u, d) => {
    d ? c.data = c.data.replace(d, l) : c.data.indexOf(l) === -1 && (c.data = u ? l + c.data : c.data + l);
  })(Yr[o], t, r, s), o;
}, kD = (e, t, n) => e.reduce((r, i, a) => {
  let o = t[a];
  if (o && o.call) {
    let s = o(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    o = l ? "." + l : s && typeof s == "object" ? s.props ? "" : Ri(s, "") : s === !1 ? "" : s;
  }
  return r + i + (o ?? "");
}, "");
function Cd(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return ED(n.unshift ? n.raw ? kD(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, i) => Object.assign(r, i && i.call ? i(t.p) : i), {}) : n, xD(t.target), t.g, t.o, t.k);
}
let Qx, dh, fh;
Cd.bind({ g: 1 });
let fi = Cd.bind({ k: 1 });
function TD(e, t, n, r) {
  Ri.p = t, Qx = e, dh = n, fh = r;
}
function Ji(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function i(a, o) {
      let s = Object.assign({}, a), l = s.className || i.className;
      n.p = Object.assign({ theme: dh && dh() }, s), n.o = / *go\d+/.test(l), s.className = Cd.apply(n, r) + (l ? " " + l : ""), t && (s.ref = o);
      let c = e;
      return e[0] && (c = s.as || e, delete s.as), fh && c[0] && fh(s), Qx(c, s);
    }
    return t ? t(i) : i;
  };
}
var CD = (e) => typeof e == "function", Qc = (e, t) => CD(e) ? e(t) : e, OD = (() => {
  let e = 0;
  return () => (++e).toString();
})(), e_ = (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), AD = 20, xc = /* @__PURE__ */ new Map(), $D = 1e3, Ev = (e) => {
  if (xc.has(e))
    return;
  let t = setTimeout(() => {
    xc.delete(e), Ia({ type: 4, toastId: e });
  }, $D);
  xc.set(e, t);
}, RD = (e) => {
  let t = xc.get(e);
  t && clearTimeout(t);
}, ph = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, AD) };
    case 1:
      return t.toast.id && RD(t.toast.id), { ...e, toasts: e.toasts.map((a) => a.id === t.toast.id ? { ...a, ...t.toast } : a) };
    case 2:
      let { toast: n } = t;
      return e.toasts.find((a) => a.id === n.id) ? ph(e, { type: 1, toast: n }) : ph(e, { type: 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return r ? Ev(r) : e.toasts.forEach((a) => {
        Ev(a.id);
      }), { ...e, toasts: e.toasts.map((a) => a.id === r || r === void 0 ? { ...a, visible: !1 } : a) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((a) => a.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let i = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((a) => ({ ...a, pauseDuration: a.pauseDuration + i })) };
  }
}, _c = [], Sc = { toasts: [], pausedAt: void 0 }, Ia = (e) => {
  Sc = ph(Sc, e), _c.forEach((t) => {
    t(Sc);
  });
}, PD = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, ID = (e = {}) => {
  let [t, n] = De(Sc);
  Be(() => (_c.push(n), () => {
    let i = _c.indexOf(n);
    i > -1 && _c.splice(i, 1);
  }), [t]);
  let r = t.toasts.map((i) => {
    var a, o;
    return { ...e, ...e[i.type], ...i, duration: i.duration || ((a = e[i.type]) == null ? void 0 : a.duration) || (e == null ? void 0 : e.duration) || PD[i.type], style: { ...e.style, ...(o = e[i.type]) == null ? void 0 : o.style, ...i.style } };
  });
  return { ...t, toasts: r };
}, MD = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || OD() }), dl = (e) => (t, n) => {
  let r = MD(t, e, n);
  return Ia({ type: 2, toast: r }), r.id;
}, Vn = (e, t) => dl("blank")(e, t);
Vn.error = dl("error");
Vn.success = dl("success");
Vn.loading = dl("loading");
Vn.custom = dl("custom");
Vn.dismiss = (e) => {
  Ia({ type: 3, toastId: e });
};
Vn.remove = (e) => Ia({ type: 4, toastId: e });
Vn.promise = (e, t, n) => {
  let r = Vn.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return e.then((i) => (Vn.success(Qc(t.success, i), { id: r, ...n, ...n == null ? void 0 : n.success }), i)).catch((i) => {
    Vn.error(Qc(t.error, i), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), e;
};
var ND = (e, t) => {
  Ia({ type: 1, toast: { id: e, height: t } });
}, DD = () => {
  Ia({ type: 5, time: Date.now() });
}, LD = (e) => {
  let { toasts: t, pausedAt: n } = ID(e);
  Be(() => {
    if (n)
      return;
    let a = Date.now(), o = t.map((s) => {
      if (s.duration === 1 / 0)
        return;
      let l = (s.duration || 0) + s.pauseDuration - (a - s.createdAt);
      if (l < 0) {
        s.visible && Vn.dismiss(s.id);
        return;
      }
      return setTimeout(() => Vn.dismiss(s.id), l);
    });
    return () => {
      o.forEach((s) => s && clearTimeout(s));
    };
  }, [t, n]);
  let r = nn(() => {
    n && Ia({ type: 6, time: Date.now() });
  }, [n]), i = nn((a, o) => {
    let { reverseOrder: s = !1, gutter: l = 8, defaultPosition: c } = o || {}, u = t.filter((f) => (f.position || c) === (a.position || c) && f.height), d = u.findIndex((f) => f.id === a.id), p = u.filter((f, h) => h < d && f.visible).length;
    return u.filter((f) => f.visible).slice(...s ? [p + 1] : [0, p]).reduce((f, h) => f + (h.height || 0) + l, 0);
  }, [t]);
  return { toasts: t, handlers: { updateHeight: ND, startPause: DD, endPause: r, calculateOffset: i } };
}, jD = fi`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, UD = fi`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, FD = fi`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, BD = Ji("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${jD} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${UD} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${FD} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, zD = fi`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, ZD = Ji("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${zD} 1s linear infinite;
`, qD = fi`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, WD = fi`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, VD = Ji("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${qD} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${WD} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, HD = Ji("div")`
  position: absolute;
`, KD = Ji("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, GD = fi`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, JD = Ji("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${GD} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, YD = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? A.createElement(JD, null, t) : t : n === "blank" ? null : A.createElement(KD, null, A.createElement(ZD, { ...r }), n !== "loading" && A.createElement(HD, null, n === "error" ? A.createElement(BD, { ...r }) : A.createElement(VD, { ...r })));
}, XD = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, QD = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, e2 = "0%{opacity:0;} 100%{opacity:1;}", t2 = "0%{opacity:1;} 100%{opacity:0;}", n2 = Ji("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, r2 = Ji("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, i2 = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, i] = e_() ? [e2, t2] : [XD(n), QD(n)];
  return { animation: t ? `${fi(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${fi(i)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, a2 = A.memo(({ toast: e, position: t, style: n, children: r }) => {
  let i = e.height ? i2(e.position || t || "top-center", e.visible) : { opacity: 0 }, a = A.createElement(YD, { toast: e }), o = A.createElement(r2, { ...e.ariaProps }, Qc(e.message, e));
  return A.createElement(n2, { className: e.className, style: { ...i, ...n, ...e.style } }, typeof r == "function" ? r({ icon: a, message: o }) : A.createElement(A.Fragment, null, a, o));
});
TD(A.createElement);
var o2 = ({ id: e, className: t, style: n, onHeightUpdate: r, children: i }) => {
  let a = A.useCallback((o) => {
    if (o) {
      let s = () => {
        let l = o.getBoundingClientRect().height;
        r(e, l);
      };
      s(), new MutationObserver(s).observe(o, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return A.createElement("div", { ref: a, className: t, style: n }, i);
}, s2 = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, i = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: e_() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...i };
}, l2 = Cd`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, Ql = 16, c2 = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: i, containerStyle: a, containerClassName: o }) => {
  let { toasts: s, handlers: l } = LD(n);
  return A.createElement("div", { style: { position: "fixed", zIndex: 9999, top: Ql, left: Ql, right: Ql, bottom: Ql, pointerEvents: "none", ...a }, className: o, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, s.map((c) => {
    let u = c.position || t, d = l.calculateOffset(c, { reverseOrder: e, gutter: r, defaultPosition: t }), p = s2(u, d);
    return A.createElement(o2, { id: c.id, key: c.id, onHeightUpdate: l.updateHeight, className: c.visible ? l2 : "", style: p }, c.type === "custom" ? Qc(c.message, c) : i ? i(c) : A.createElement(a2, { toast: c, position: u }));
  }));
}, u2 = Object.defineProperty, d2 = (e, t, n) => t in e ? u2(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, ip = (e, t, n) => (d2(e, typeof t != "symbol" ? t + "" : t, n), n);
let f2 = class {
  constructor() {
    ip(this, "current", this.detect()), ip(this, "handoffState", "pending"), ip(this, "currentId", 0);
  }
  set(t) {
    this.current !== t && (this.handoffState = "pending", this.currentId = 0, this.current = t);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, Es = new f2(), Od = (e, t) => {
  Es.isServer ? Be(e, t) : sl(e, t);
};
function oo(e) {
  let t = Xe(e);
  return Od(() => {
    t.current = e;
  }, [e]), t;
}
function p2(e) {
  typeof queueMicrotask == "function" ? queueMicrotask(e) : Promise.resolve().then(e).catch((t) => setTimeout(() => {
    throw t;
  }));
}
function Ad() {
  let e = [], t = [], n = { enqueue(r) {
    t.push(r);
  }, addEventListener(r, i, a, o) {
    return r.addEventListener(i, a, o), n.add(() => r.removeEventListener(i, a, o));
  }, requestAnimationFrame(...r) {
    let i = requestAnimationFrame(...r);
    return n.add(() => cancelAnimationFrame(i));
  }, nextFrame(...r) {
    return n.requestAnimationFrame(() => n.requestAnimationFrame(...r));
  }, setTimeout(...r) {
    let i = setTimeout(...r);
    return n.add(() => clearTimeout(i));
  }, microTask(...r) {
    let i = { current: !0 };
    return p2(() => {
      i.current && r[0]();
    }), n.add(() => {
      i.current = !1;
    });
  }, add(r) {
    return e.push(r), () => {
      let i = e.indexOf(r);
      if (i >= 0) {
        let [a] = e.splice(i, 1);
        a();
      }
    };
  }, dispose() {
    for (let r of e.splice(0))
      r();
  }, async workQueue() {
    for (let r of t.splice(0))
      await r();
  }, style(r, i, a) {
    let o = r.style.getPropertyValue(i);
    return Object.assign(r.style, { [i]: a }), this.add(() => {
      Object.assign(r.style, { [i]: o });
    });
  } };
  return n;
}
function t_() {
  let [e] = De(Ad);
  return Be(() => () => e.dispose(), [e]), e;
}
let fa = function(e) {
  let t = oo(e);
  return Jt.useCallback((...n) => t.current(...n), [t]);
};
function n_() {
  let [e, t] = De(Es.isHandoffComplete);
  return e && Es.isHandoffComplete === !1 && t(!1), Be(() => {
    e !== !0 && t(!0);
  }, [e]), Be(() => Es.handoff(), []), e;
}
function Pr(e, t, ...n) {
  if (e in t) {
    let i = t[e];
    return typeof i == "function" ? i(...n) : i;
  }
  let r = new Error(`Tried to handle "${e}" but there is no handler defined. Only defined handlers are: ${Object.keys(t).map((i) => `"${i}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(r, Pr), r;
}
let h2 = Symbol();
function r_(...e) {
  let t = Xe(e);
  Be(() => {
    t.current = e;
  }, [e]);
  let n = fa((r) => {
    for (let i of t.current)
      i != null && (typeof i == "function" ? i(r) : i.current = r);
  });
  return e.every((r) => r == null || (r == null ? void 0 : r[h2])) ? void 0 : n;
}
function i_(...e) {
  return e.filter(Boolean).join(" ");
}
var a_ = ((e) => (e[e.None = 0] = "None", e[e.RenderStrategy = 1] = "RenderStrategy", e[e.Static = 2] = "Static", e))(a_ || {}), ai = ((e) => (e[e.Unmount = 0] = "Unmount", e[e.Hidden = 1] = "Hidden", e))(ai || {});
function o_({ ourProps: e, theirProps: t, slot: n, defaultTag: r, features: i, visible: a = !0, name: o }) {
  let s = s_(t, e);
  if (a)
    return ec(s, n, r, o);
  let l = i ?? 0;
  if (l & 2) {
    let { static: c = !1, ...u } = s;
    if (c)
      return ec(u, n, r, o);
  }
  if (l & 1) {
    let { unmount: c = !0, ...u } = s;
    return Pr(c ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return ec({ ...u, hidden: !0, style: { display: "none" } }, n, r, o);
    } });
  }
  return ec(s, n, r, o);
}
function ec(e, t = {}, n, r) {
  var i;
  let { as: a = n, children: o, refName: s = "ref", ...l } = ap(e, ["unmount", "static"]), c = e.ref !== void 0 ? { [s]: e.ref } : {}, u = typeof o == "function" ? o(t) : o;
  l.className && typeof l.className == "function" && (l.className = l.className(t));
  let d = {};
  if (t) {
    let p = !1, f = [];
    for (let [h, m] of Object.entries(t))
      typeof m == "boolean" && (p = !0), m === !0 && f.push(h);
    p && (d["data-headlessui-state"] = f.join(" "));
  }
  if (a === Di && Object.keys(kv(l)).length > 0) {
    if (!Rs(u) || Array.isArray(u) && u.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${r} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(l).map((h) => `  - ${h}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((h) => `  - ${h}`).join(`
`)].join(`
`));
    let p = i_((i = u.props) == null ? void 0 : i.className, l.className), f = p ? { className: p } : {};
    return wd(u, Object.assign({}, s_(u.props, kv(ap(l, ["ref"]))), d, c, m2(u.ref, c.ref), f));
  }
  return Ue(a, Object.assign({}, ap(l, ["ref"]), a !== Di && c, a !== Di && d), u);
}
function m2(...e) {
  return { ref: e.every((t) => t == null) ? void 0 : (t) => {
    for (let n of e)
      n != null && (typeof n == "function" ? n(t) : n.current = t);
  } };
}
function s_(...e) {
  if (e.length === 0)
    return {};
  if (e.length === 1)
    return e[0];
  let t = {}, n = {};
  for (let r of e)
    for (let i in r)
      i.startsWith("on") && typeof r[i] == "function" ? (n[i] != null || (n[i] = []), n[i].push(r[i])) : t[i] = r[i];
  if (t.disabled || t["aria-disabled"])
    return Object.assign(t, Object.fromEntries(Object.keys(n).map((r) => [r, void 0])));
  for (let r in n)
    Object.assign(t, { [r](i, ...a) {
      let o = n[r];
      for (let s of o) {
        if ((i instanceof Event || (i == null ? void 0 : i.nativeEvent) instanceof Event) && i.defaultPrevented)
          return;
        s(i, ...a);
      }
    } });
  return t;
}
function Zm(e) {
  var t;
  return Object.assign(ze(e), { displayName: (t = e.displayName) != null ? t : e.name });
}
function kv(e) {
  let t = Object.assign({}, e);
  for (let n in t)
    t[n] === void 0 && delete t[n];
  return t;
}
function ap(e, t = []) {
  let n = Object.assign({}, e);
  for (let r of t)
    r in n && delete n[r];
  return n;
}
let qm = _r(null);
qm.displayName = "OpenClosedContext";
var ni = ((e) => (e[e.Open = 1] = "Open", e[e.Closed = 2] = "Closed", e[e.Closing = 4] = "Closing", e[e.Opening = 8] = "Opening", e))(ni || {});
function l_() {
  return Er(qm);
}
function g2({ value: e, children: t }) {
  return Jt.createElement(qm.Provider, { value: e }, t);
}
function c_() {
  let e = Xe(!1);
  return Od(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e;
}
function y2(e = 0) {
  let [t, n] = De(e), r = nn((s) => n((l) => l | s), [t]), i = nn((s) => !!(t & s), [t]), a = nn((s) => n((l) => l & ~s), [n]), o = nn((s) => n((l) => l ^ s), [n]);
  return { flags: t, addFlag: r, hasFlag: i, removeFlag: a, toggleFlag: o };
}
function v2(e) {
  let t = { called: !1 };
  return (...n) => {
    if (!t.called)
      return t.called = !0, e(...n);
  };
}
function op(e, ...t) {
  e && t.length > 0 && e.classList.add(...t);
}
function sp(e, ...t) {
  e && t.length > 0 && e.classList.remove(...t);
}
function b2(e, t) {
  let n = Ad();
  if (!e)
    return n.dispose;
  let { transitionDuration: r, transitionDelay: i } = getComputedStyle(e), [a, o] = [r, i].map((s) => {
    let [l = 0] = s.split(",").filter(Boolean).map((c) => c.includes("ms") ? parseFloat(c) : parseFloat(c) * 1e3).sort((c, u) => u - c);
    return l;
  });
  if (a + o !== 0) {
    let s = n.addEventListener(e, "transitionend", (l) => {
      l.target === l.currentTarget && (t(), s());
    });
  } else
    t();
  return n.add(() => t()), n.dispose;
}
function w2(e, t, n, r) {
  let i = n ? "enter" : "leave", a = Ad(), o = r !== void 0 ? v2(r) : () => {
  };
  i === "enter" && (e.removeAttribute("hidden"), e.style.display = "");
  let s = Pr(i, { enter: () => t.enter, leave: () => t.leave }), l = Pr(i, { enter: () => t.enterTo, leave: () => t.leaveTo }), c = Pr(i, { enter: () => t.enterFrom, leave: () => t.leaveFrom });
  return sp(e, ...t.enter, ...t.enterTo, ...t.enterFrom, ...t.leave, ...t.leaveFrom, ...t.leaveTo, ...t.entered), op(e, ...s, ...c), a.nextFrame(() => {
    sp(e, ...c), op(e, ...l), b2(e, () => (sp(e, ...s), op(e, ...t.entered), o()));
  }), a.dispose;
}
function x2({ container: e, direction: t, classes: n, onStart: r, onStop: i }) {
  let a = c_(), o = t_(), s = oo(t);
  Od(() => {
    let l = Ad();
    o.add(l.dispose);
    let c = e.current;
    if (c && s.current !== "idle" && a.current)
      return l.dispose(), r.current(s.current), l.add(w2(c, n.current, s.current === "enter", () => {
        l.dispose(), i.current(s.current);
      })), l.dispose;
  }, [t]);
}
function na(e = "") {
  return e.split(" ").filter((t) => t.trim().length > 1);
}
let $d = _r(null);
$d.displayName = "TransitionContext";
var _2 = ((e) => (e.Visible = "visible", e.Hidden = "hidden", e))(_2 || {});
function S2() {
  let e = Er($d);
  if (e === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e;
}
function E2() {
  let e = Er(Rd);
  if (e === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return e;
}
let Rd = _r(null);
Rd.displayName = "NestingContext";
function Pd(e) {
  return "children" in e ? Pd(e.children) : e.current.filter(({ el: t }) => t.current !== null).filter(({ state: t }) => t === "visible").length > 0;
}
function u_(e, t) {
  let n = oo(e), r = Xe([]), i = c_(), a = t_(), o = fa((f, h = ai.Hidden) => {
    let m = r.current.findIndex(({ el: y }) => y === f);
    m !== -1 && (Pr(h, { [ai.Unmount]() {
      r.current.splice(m, 1);
    }, [ai.Hidden]() {
      r.current[m].state = "hidden";
    } }), a.microTask(() => {
      var y;
      !Pd(r) && i.current && ((y = n.current) == null || y.call(n));
    }));
  }), s = fa((f) => {
    let h = r.current.find(({ el: m }) => m === f);
    return h ? h.state !== "visible" && (h.state = "visible") : r.current.push({ el: f, state: "visible" }), () => o(f, ai.Unmount);
  }), l = Xe([]), c = Xe(Promise.resolve()), u = Xe({ enter: [], leave: [], idle: [] }), d = fa((f, h, m) => {
    l.current.splice(0), t && (t.chains.current[h] = t.chains.current[h].filter(([y]) => y !== f)), t == null || t.chains.current[h].push([f, new Promise((y) => {
      l.current.push(y);
    })]), t == null || t.chains.current[h].push([f, new Promise((y) => {
      Promise.all(u.current[h].map(([g, v]) => v)).then(() => y());
    })]), h === "enter" ? c.current = c.current.then(() => t == null ? void 0 : t.wait.current).then(() => m(h)) : m(h);
  }), p = fa((f, h, m) => {
    Promise.all(u.current[h].splice(0).map(([y, g]) => g)).then(() => {
      var y;
      (y = l.current.shift()) == null || y();
    }).then(() => m(h));
  });
  return va(() => ({ children: r, register: s, unregister: o, onStart: d, onStop: p, wait: c, chains: u }), [s, o, r, d, p, u, c]);
}
function k2() {
}
let T2 = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function Tv(e) {
  var t;
  let n = {};
  for (let r of T2)
    n[r] = (t = e[r]) != null ? t : k2;
  return n;
}
function C2(e) {
  let t = Xe(Tv(e));
  return Be(() => {
    t.current = Tv(e);
  }, [e]), t;
}
let O2 = "div", d_ = a_.RenderStrategy, f_ = Zm(function(e, t) {
  let { beforeEnter: n, afterEnter: r, beforeLeave: i, afterLeave: a, enter: o, enterFrom: s, enterTo: l, entered: c, leave: u, leaveFrom: d, leaveTo: p, ...f } = e, h = Xe(null), m = r_(h, t), y = f.unmount ? ai.Unmount : ai.Hidden, { show: g, appear: v, initial: b } = S2(), [T, O] = De(g ? "visible" : "hidden"), S = E2(), { register: P, unregister: M } = S, L = Xe(null);
  Be(() => P(h), [P, h]), Be(() => {
    if (y === ai.Hidden && h.current) {
      if (g && T !== "visible") {
        O("visible");
        return;
      }
      return Pr(T, { hidden: () => M(h), visible: () => P(h) });
    }
  }, [T, h, P, M, g, y]);
  let k = oo({ enter: na(o), enterFrom: na(s), enterTo: na(l), entered: na(c), leave: na(u), leaveFrom: na(d), leaveTo: na(p) }), I = C2({ beforeEnter: n, afterEnter: r, beforeLeave: i, afterLeave: a }), B = n_();
  Be(() => {
    if (B && T === "visible" && h.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [h, T, B]);
  let U = b && !v, z = (() => !B || U || L.current === g ? "idle" : g ? "enter" : "leave")(), D = y2(0), j = fa((ie) => Pr(ie, { enter: () => {
    D.addFlag(ni.Opening), I.current.beforeEnter();
  }, leave: () => {
    D.addFlag(ni.Closing), I.current.beforeLeave();
  }, idle: () => {
  } })), V = fa((ie) => Pr(ie, { enter: () => {
    D.removeFlag(ni.Opening), I.current.afterEnter();
  }, leave: () => {
    D.removeFlag(ni.Closing), I.current.afterLeave();
  }, idle: () => {
  } })), W = u_(() => {
    O("hidden"), M(h);
  }, S);
  x2({ container: h, classes: k, direction: z, onStart: oo((ie) => {
    W.onStart(h, ie, j);
  }), onStop: oo((ie) => {
    W.onStop(h, ie, V), ie === "leave" && !Pd(W) && (O("hidden"), M(h));
  }) }), Be(() => {
    !U || (y === ai.Hidden ? L.current = null : L.current = g);
  }, [g, U, T]);
  let de = f, x = { ref: m };
  return v && g && Es.isServer && (de = { ...de, className: i_(f.className, ...k.current.enter, ...k.current.enterFrom) }), Jt.createElement(Rd.Provider, { value: W }, Jt.createElement(g2, { value: Pr(T, { visible: ni.Open, hidden: ni.Closed }) | D.flags }, o_({ ourProps: x, theirProps: de, defaultTag: O2, features: d_, visible: T === "visible", name: "Transition.Child" })));
}), hh = Zm(function(e, t) {
  let { show: n, appear: r = !1, unmount: i, ...a } = e, o = Xe(null), s = r_(o, t);
  n_();
  let l = l_();
  if (n === void 0 && l !== null && (n = (l & ni.Open) === ni.Open), ![!0, !1].includes(n))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [c, u] = De(n ? "visible" : "hidden"), d = u_(() => {
    u("hidden");
  }), [p, f] = De(!0), h = Xe([n]);
  Od(() => {
    p !== !1 && h.current[h.current.length - 1] !== n && (h.current.push(n), f(!1));
  }, [h, n]);
  let m = va(() => ({ show: n, appear: r, initial: p }), [n, r, p]);
  Be(() => {
    if (n)
      u("visible");
    else if (!Pd(d))
      u("hidden");
    else {
      let g = o.current;
      if (!g)
        return;
      let v = g.getBoundingClientRect();
      v.x === 0 && v.y === 0 && v.width === 0 && v.height === 0 && u("hidden");
    }
  }, [n, d]);
  let y = { unmount: i };
  return Jt.createElement(Rd.Provider, { value: d }, Jt.createElement($d.Provider, { value: m }, o_({ ourProps: { ...y, as: Di, children: Jt.createElement(f_, { ref: s, ...y, ...a }) }, theirProps: {}, defaultTag: Di, features: d_, visible: c === "visible", name: "Transition" })));
}), A2 = Zm(function(e, t) {
  let n = Er($d) !== null, r = l_() !== null;
  return Jt.createElement(Jt.Fragment, null, !n && r ? Jt.createElement(hh, { ref: t, ...e }) : Jt.createElement(f_, { ref: t, ...e }));
}), $2 = Object.assign(hh, { Child: A2, Root: hh });
const R2 = (e) => /* @__PURE__ */ A.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, ...e }, /* @__PURE__ */ A.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "m7.5 12 3 3 6-6m5.5 3c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Z" })), P2 = (e) => /* @__PURE__ */ A.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, fill: "none", viewBox: "0 0 24 24", ...e }, /* @__PURE__ */ A.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "M18 6 6 18M6 6l12 12" })), I2 = (e) => /* @__PURE__ */ A.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, fill: "none", viewBox: "0 0 24 24", strokeWidth: 1.5, ...e }, /* @__PURE__ */ A.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "m15 9-6 6m0-6 6 6m7-3c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2s10 4.477 10 10Z" }));
function M2(e) {
  return Vn.custom((t) => /* @__PURE__ */ F.jsx(D2, { type: e.type, show: t.visible, children: e.type === "custom" ? e.content : /* @__PURE__ */ F.jsx(N2, { ...e, toastId: t.id }) }));
}
const N2 = ({ icon: e, type: t, title: n, description: r, toastId: i }) => {
  const {
    theme: { notification: a }
  } = It();
  return /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
    e ? /* @__PURE__ */ F.jsx(e, { ...a == null ? void 0 : a.icon }) : /* @__PURE__ */ F.jsx(L2, { ...a == null ? void 0 : a.icon, type: t }),
    /* @__PURE__ */ F.jsx("p", { ...a == null ? void 0 : a.title, children: n }),
    r ? /* @__PURE__ */ F.jsx("p", { ...a == null ? void 0 : a.description, children: r }) : null,
    /* @__PURE__ */ F.jsx(P2, { ...a == null ? void 0 : a.closeIcon, onClick: () => Vn.dismiss(i) })
  ] });
}, D2 = ({ type: e, ...t }) => {
  const {
    theme: { notification: n }
  } = It();
  return /* @__PURE__ */ F.jsx($2, { ...t, ...n == null ? void 0 : n.container, appear: !0, "data-type": e ?? "neutral" });
}, L2 = ({ type: e, className: t }) => {
  switch (e) {
    case "success":
      return /* @__PURE__ */ F.jsx(R2, { className: t });
    case "error":
      return /* @__PURE__ */ F.jsx(I2, { className: t });
    default:
      return null;
  }
}, j2 = ze(
  ({ url: e, type: t, styles: n, orientation: r = "auto", ...i }, a) => {
    var p, f;
    const o = hA(), { setIsLoading: s } = hD(), [l, c] = De(r), [u, d] = De(!1);
    return sl(() => {
      s((h) => [...h, o]);
    }, []), Be(() => {
      e && l === "auto" && bD(e).then(({ width: h, height: m }) => {
        c(U2(h, m)), s((y) => y.filter((g) => g !== o));
      });
    }, [e]), /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
      u ? null : /* @__PURE__ */ F.jsx("div", { "data-orientation": l, ...(p = n == null ? void 0 : n[t]) == null ? void 0 : p.placeholder }),
      /* @__PURE__ */ F.jsx(
        "img",
        {
          "data-orientation": l,
          "data-loaded": u,
          ...i,
          ...(f = n == null ? void 0 : n[t]) == null ? void 0 : f.image,
          src: e,
          alt: "",
          ref: a,
          loading: "lazy",
          onLoad: () => {
            d(!0);
          }
        }
      )
    ] });
  }
);
function U2(e, t) {
  const n = {
    square: 1,
    portrait: 0.75,
    landscape: 1.3333333333333333
  }, r = e / t;
  return Object.keys(n).reduce((a, o) => Math.abs(n[o] - r) < Math.abs(n[a] - r) ? o : a);
}
const F2 = ze(({ url: e, type: t, styles: n, ...r }, i) => /* @__PURE__ */ F.jsx("div", { children: /* @__PURE__ */ F.jsx("video", { ...r, controls: !0, src: e, ...n == null ? void 0 : n[t], ref: i }) })), B2 = ze(({ url: e, type: t, styles: n, ...r }, i) => /* @__PURE__ */ F.jsx("div", { children: /* @__PURE__ */ F.jsx("audio", { ...r, controls: !0, src: e, ...n == null ? void 0 : n[t], ref: i }) }));
function z2({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    fillRule: "evenodd",
    d: "M10 3a.75.75 0 01.75.75v10.638l3.96-4.158a.75.75 0 111.08 1.04l-5.25 5.5a.75.75 0 01-1.08 0l-5.25-5.5a.75.75 0 111.08-1.04l3.96 4.158V3.75A.75.75 0 0110 3z",
    clipRule: "evenodd"
  }));
}
const Z2 = A.forwardRef(z2), q2 = Z2;
function W2({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    fillRule: "evenodd",
    d: "M15.312 11.424a5.5 5.5 0 01-9.201 2.466l-.312-.311h2.433a.75.75 0 000-1.5H3.989a.75.75 0 00-.75.75v4.242a.75.75 0 001.5 0v-2.43l.31.31a7 7 0 0011.712-3.138.75.75 0 00-1.449-.39zm1.23-3.723a.75.75 0 00.219-.53V2.929a.75.75 0 00-1.5 0V5.36l-.31-.31A7 7 0 003.239 8.188a.75.75 0 101.448.389A5.5 5.5 0 0113.89 6.11l.311.31h-2.432a.75.75 0 000 1.5h4.243a.75.75 0 00.53-.219z",
    clipRule: "evenodd"
  }));
}
const V2 = A.forwardRef(W2), H2 = V2;
function K2({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm-.75-4.75a.75.75 0 001.5 0V8.66l1.95 2.1a.75.75 0 101.1-1.02l-3.25-3.5a.75.75 0 00-1.1 0L6.2 9.74a.75.75 0 101.1 1.02l1.95-2.1v4.59z",
    clipRule: "evenodd"
  }));
}
const G2 = A.forwardRef(K2), J2 = G2;
function Y2({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    fillRule: "evenodd",
    d: "M5.23 7.21a.75.75 0 011.06.02L10 11.168l3.71-3.938a.75.75 0 111.08 1.04l-4.25 4.5a.75.75 0 01-1.08 0l-4.25-4.5a.75.75 0 01.02-1.06z",
    clipRule: "evenodd"
  }));
}
const X2 = A.forwardRef(Y2), Q2 = X2;
function eL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    fillRule: "evenodd",
    d: "M4.5 2A1.5 1.5 0 003 3.5v13A1.5 1.5 0 004.5 18h11a1.5 1.5 0 001.5-1.5V7.621a1.5 1.5 0 00-.44-1.06l-4.12-4.122A1.5 1.5 0 0011.378 2H4.5zm4.75 6.75a.75.75 0 011.5 0v2.546l.943-1.048a.75.75 0 011.114 1.004l-2.25 2.5a.75.75 0 01-1.114 0l-2.25-2.5a.75.75 0 111.114-1.004l.943 1.048V8.75z",
    clipRule: "evenodd"
  }));
}
const tL = A.forwardRef(eL), nL = tL;
function rL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    fillRule: "evenodd",
    d: "M9.69 18.933l.003.001C9.89 19.02 10 19 10 19s.11.02.308-.066l.002-.001.006-.003.018-.008a5.741 5.741 0 00.281-.14c.186-.096.446-.24.757-.433.62-.384 1.445-.966 2.274-1.765C15.302 14.988 17 12.493 17 9A7 7 0 103 9c0 3.492 1.698 5.988 3.355 7.584a13.731 13.731 0 002.273 1.765 11.842 11.842 0 00.976.544l.062.029.018.008.006.003zM10 11.25a2.25 2.25 0 100-4.5 2.25 2.25 0 000 4.5z",
    clipRule: "evenodd"
  }));
}
const iL = A.forwardRef(rL), aL = iL, oL = ze(
  ({ type: e, latitude: t, longitude: n, title: r, styles: i, ...a }, o) => {
    var l, c, u;
    const s = `https://www.google.com/maps/search/?api=1&query=${t},${n}`;
    return /* @__PURE__ */ F.jsxs("a", { ...a, ...(l = i == null ? void 0 : i[e]) == null ? void 0 : l.container, href: s, type: "_blank", rel: "noopener", ref: o, children: [
      /* @__PURE__ */ F.jsx("p", { ...(c = i == null ? void 0 : i[e]) == null ? void 0 : c.title, children: r }),
      /* @__PURE__ */ F.jsx(aL, { ...(u = i == null ? void 0 : i[e]) == null ? void 0 : u.icon })
    ] });
  }
), sL = ze(
  ({ blocks: e, styles: t, type: n, horizontalAlignment: r, verticalAlignment: i, ...a }, o) => /* @__PURE__ */ F.jsx(
    "div",
    {
      "data-horizontal": r,
      "data-vertical": i,
      ...a,
      ...t == null ? void 0 : t[n],
      ref: o,
      children: e.map((s, l) => /* @__PURE__ */ F.jsx(yl, { styles: t, block: s }, l))
    }
  )
), lL = ze(
  ({ blocks: e, styles: t, type: n, horizontalAlignment: r, verticalAlignment: i, ...a }, o) => /* @__PURE__ */ F.jsx(
    "div",
    {
      "data-horizontal": r,
      "data-vertical": i,
      ...a,
      ...t == null ? void 0 : t[n],
      ref: o,
      children: e.map((s, l) => /* @__PURE__ */ F.jsx(yl, { styles: t, block: s }, l))
    }
  )
);
function cL(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Cv(e) {
  return cL(e) || Array.isArray(e);
}
function uL() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function Wm(e, t) {
  const n = Object.keys(e), r = Object.keys(t);
  if (n.length !== r.length)
    return !1;
  const i = JSON.stringify(Object.keys(e.breakpoints || {})), a = JSON.stringify(Object.keys(t.breakpoints || {}));
  return i !== a ? !1 : n.every((o) => {
    const s = e[o], l = t[o];
    return typeof s == "function" ? `${s}` == `${l}` : !Cv(s) || !Cv(l) ? s === l : Wm(s, l);
  });
}
function Ov(e) {
  return e.concat().sort((t, n) => t.name > n.name ? 1 : -1).map((t) => t.options);
}
function dL(e, t) {
  if (e.length !== t.length)
    return !1;
  const n = Ov(e), r = Ov(t);
  return n.every((i, a) => {
    const o = r[a];
    return Wm(i, o);
  });
}
function Vm(e) {
  return typeof e == "number";
}
function Av(e) {
  return typeof e == "string";
}
function Hm(e) {
  return typeof e == "boolean";
}
function $v(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Wt(e) {
  return Math.abs(e);
}
function Km(e) {
  return Math.sign(e);
}
function Ec(e, t) {
  return Wt(e - t);
}
function fL(e, t) {
  if (e === 0 || t === 0 || Wt(e) <= Wt(t))
    return 0;
  const n = Ec(Wt(e), Wt(t));
  return Wt(n / e);
}
function Is(e) {
  return eu(e).map(Number);
}
function si(e) {
  return e[Id(e)];
}
function Id(e) {
  return Math.max(0, e.length - 1);
}
function eu(e) {
  return Object.keys(e);
}
function p_(e, t) {
  return [e, t].reduce((n, r) => (eu(r).forEach((i) => {
    const a = n[i], o = r[i], s = $v(a) && $v(o);
    n[i] = s ? p_(a, o) : o;
  }), n), {});
}
function h_(e, t) {
  return typeof t.MouseEvent < "u" && e instanceof t.MouseEvent;
}
function pL(e, t) {
  const n = {
    start: r,
    center: i,
    end: a
  };
  function r() {
    return 0;
  }
  function i(c) {
    return a(c) / 2;
  }
  function a(c) {
    return t - c;
  }
  function o() {
    return t * Number(e);
  }
  function s(c) {
    return Vm(e) ? o() : n[e](c);
  }
  return {
    measure: s
  };
}
function hL(e, t) {
  const n = e === "y" ? "y" : "x", r = e === "y" ? "x" : "y", i = s(), a = l();
  function o(u) {
    const {
      width: d,
      height: p
    } = u;
    return n === "x" ? d : p;
  }
  function s() {
    return n === "y" ? "top" : t === "rtl" ? "right" : "left";
  }
  function l() {
    return n === "y" ? "bottom" : t === "rtl" ? "left" : "right";
  }
  return {
    scroll: n,
    cross: r,
    startEdge: i,
    endEdge: a,
    measureSize: o
  };
}
function Fi(e, t) {
  const n = Wt(e - t);
  function r(c) {
    return c < e;
  }
  function i(c) {
    return c > t;
  }
  function a(c) {
    return r(c) || i(c);
  }
  function o(c) {
    return a(c) ? r(c) ? e : t : c;
  }
  function s(c) {
    return n ? c - n * Math.ceil((c - t) / n) : c;
  }
  return {
    length: n,
    max: t,
    min: e,
    constrain: o,
    reachedAny: a,
    reachedMax: i,
    reachedMin: r,
    removeOffset: s
  };
}
function m_(e, t, n) {
  const {
    constrain: r
  } = Fi(0, e), i = e + 1;
  let a = o(t);
  function o(p) {
    return n ? Wt((i + p) % i) : r(p);
  }
  function s() {
    return a;
  }
  function l(p) {
    return a = o(p), d;
  }
  function c(p) {
    return u().set(s() + p);
  }
  function u() {
    return m_(e, s(), n);
  }
  const d = {
    get: s,
    set: l,
    add: c,
    clone: u
  };
  return d;
}
function mL(e) {
  const t = e === "rtl" ? -1 : 1;
  function n(i) {
    return i * t;
  }
  return {
    apply: n
  };
}
function Ms() {
  let e = [];
  function t(i, a, o, s = {
    passive: !0
  }) {
    return i.addEventListener(a, o, s), e.push(() => i.removeEventListener(a, o, s)), r;
  }
  function n() {
    e = e.filter((i) => i());
  }
  const r = {
    add: t,
    clear: n
  };
  return r;
}
function gL(e, t, n, r, i, a, o, s, l, c, u, d, p, f, h, m, y, g, v) {
  const {
    cross: b
  } = e, T = ["INPUT", "SELECT", "TEXTAREA"], O = {
    passive: !1
  }, S = Ms(), P = Ms(), M = Fi(50, 225).constrain(h.measure(20)), L = {
    mouse: 300,
    touch: 400
  }, k = {
    mouse: 500,
    touch: 600
  }, I = m ? 43 : 25;
  let B = !1, U = 0, z = 0, D = !1, j = !1, V = !1, W = !1;
  function de(he, Oe) {
    if (!Oe)
      return;
    function we(st) {
      (Hm(Oe) || Oe(he, st)) && Ze(st);
    }
    const Fe = n;
    S.add(Fe, "dragstart", (st) => st.preventDefault(), O).add(Fe, "touchmove", () => {
    }, O).add(Fe, "touchend", () => {
    }).add(Fe, "touchstart", we).add(Fe, "mousedown", we).add(Fe, "touchcancel", qe).add(Fe, "contextmenu", qe).add(Fe, "click", rt, !0);
  }
  function x() {
    S.clear(), P.clear();
  }
  function ie() {
    const he = W ? r : n;
    P.add(he, "touchmove", Pe, O).add(he, "touchend", qe).add(he, "mousemove", Pe, O).add(he, "mouseup", qe);
  }
  function ve(he) {
    const Oe = he.nodeName || "";
    return T.includes(Oe);
  }
  function E() {
    return (m ? k : L)[W ? "mouse" : "touch"];
  }
  function ke(he, Oe) {
    const we = p.add(Km(he) * -1), Fe = d.byDistance(he, !m).distance;
    return m || Wt(he) < M ? Fe : g && Oe ? Fe * 0.5 : d.byIndex(we.get(), 0).distance;
  }
  function Ze(he) {
    const Oe = h_(he, i);
    W = Oe, !(Oe && he.button !== 0) && (ve(he.target) || (V = m && Oe && !he.buttons && B, B = Ec(a.get(), s.get()) >= 2, D = !0, o.pointerDown(he), u.useFriction(0).useDuration(0), a.set(s), ie(), U = o.readPoint(he), z = o.readPoint(he, b), f.emit("pointerDown")));
  }
  function Pe(he) {
    const Oe = o.readPoint(he), we = o.readPoint(he, b), Fe = Ec(Oe, U), st = Ec(we, z);
    if (!j && !W && (!he.cancelable || (j = Fe > st, !j)))
      return qe(he);
    const N = o.pointerMove(he);
    Fe > y && (V = !0), u.useFriction(0.3).useDuration(1), l.start(), a.add(t.apply(N)), he.preventDefault();
  }
  function qe(he) {
    const we = d.byDistance(0, !1).index !== p.get(), Fe = o.pointerUp(he) * E(), st = ke(t.apply(Fe), we), N = fL(Fe, st), le = I - 10 * N, pe = v + N / 50;
    j = !1, D = !1, P.clear(), u.useDuration(le).useFriction(pe), c.distance(st, !m), W = !1, f.emit("pointerUp");
  }
  function rt(he) {
    V && (he.stopPropagation(), he.preventDefault());
  }
  function Ve() {
    return D;
  }
  return {
    init: de,
    pointerDown: Ve,
    destroy: x
  };
}
function yL(e, t) {
  let r, i;
  function a(d) {
    return d.timeStamp;
  }
  function o(d, p) {
    const h = `client${(p || e.scroll) === "x" ? "X" : "Y"}`;
    return (h_(d, t) ? d : d.touches[0])[h];
  }
  function s(d) {
    return r = d, i = d, o(d);
  }
  function l(d) {
    const p = o(d) - o(i), f = a(d) - a(r) > 170;
    return i = d, f && (r = d), p;
  }
  function c(d) {
    if (!r || !i)
      return 0;
    const p = o(i) - o(r), f = a(d) - a(r), h = a(d) - a(i) > 170, m = p / f;
    return f && !h && Wt(m) > 0.1 ? m : 0;
  }
  return {
    pointerDown: s,
    pointerMove: l,
    pointerUp: c,
    readPoint: o
  };
}
function vL(e) {
  function t(r) {
    return e * (r / 100);
  }
  return {
    measure: t
  };
}
function bL(e, t, n, r, i) {
  let a, o, s = [], l = !1;
  function c(f) {
    return i.measureSize(f.getBoundingClientRect());
  }
  function u(f, h) {
    if (!h)
      return;
    o = c(e), s = r.map(c);
    function m(g) {
      for (const v of g) {
        const b = v.target === e, T = r.indexOf(v.target), O = b ? o : s[T], S = c(b ? e : r[T]);
        if (O !== S) {
          n.requestAnimationFrame(() => {
            f.reInit(), t.emit("resize");
          });
          break;
        }
      }
    }
    a = new ResizeObserver((g) => {
      l || (Hm(h) || h(f, g)) && m(g);
    }), [e].concat(r).forEach((g) => a.observe(g));
  }
  function d() {
    a && a.disconnect(), l = !0;
  }
  return {
    init: u,
    destroy: d
  };
}
function wL(e, t, n, r) {
  let i = !0, a = 0, o = 0, s = n, l = r, c = e.get(), u = 0;
  function d() {
    const O = t.get() - e.get(), S = !s;
    let P = 0;
    return S ? (a = 0, e.set(t), P = O) : (a += O / s, a *= l, c += a, e.add(a), P = c - u), o = Km(P), u = c, i = Wt(O) < 1e-3, T;
  }
  function p() {
    return i;
  }
  function f() {
    return s;
  }
  function h() {
    return o;
  }
  function m() {
    return a;
  }
  function y() {
    return v(n);
  }
  function g() {
    return b(r);
  }
  function v(O) {
    return s = O, T;
  }
  function b(O) {
    return l = O, T;
  }
  const T = {
    direction: h,
    duration: f,
    velocity: m,
    seek: d,
    settled: p,
    useBaseFriction: g,
    useBaseDuration: y,
    useFriction: b,
    useDuration: v
  };
  return T;
}
function xL(e, t, n, r, i) {
  const a = i.measure(10), o = i.measure(50), s = Fi(0.1, 0.99);
  let l = !1;
  function c() {
    return !(l || !e.reachedAny(n.get()) || !e.reachedAny(t.get()));
  }
  function u(f) {
    if (!c())
      return;
    const h = e.reachedMin(t.get()) ? "min" : "max", m = Wt(e[h] - t.get()), y = n.get() - t.get(), g = s.constrain(m / o);
    n.subtract(y * g), !f && Wt(y) < a && (n.set(e.constrain(n.get())), r.useDuration(25).useBaseFriction());
  }
  function d(f) {
    l = !f;
  }
  return {
    constrain: u,
    toggleActive: d
  };
}
function _L(e, t, n, r) {
  const i = Fi(-t + e, n[0]), a = l(), o = c();
  function s() {
    const d = a[0], p = si(a), f = a.lastIndexOf(d), h = a.indexOf(p) + 1;
    return Fi(f, h);
  }
  function l() {
    return n.map(i.constrain).map((d) => parseFloat(d.toFixed(3)));
  }
  function c() {
    if (t <= e)
      return [i.max];
    if (r === "keepSnaps")
      return a;
    const {
      min: d,
      max: p
    } = s();
    return a.slice(d, p);
  }
  return {
    snapsContained: o
  };
}
function SL(e, t, n) {
  const r = t[0], i = n ? r - e : si(t);
  return {
    limit: Fi(i, r)
  };
}
function EL(e, t, n, r) {
  const a = t.min + 0.1, o = t.max + 0.1, {
    reachedMin: s,
    reachedMax: l
  } = Fi(a, o);
  function c(p) {
    return p === 1 ? l(n.get()) : p === -1 ? s(n.get()) : !1;
  }
  function u(p) {
    if (!c(p))
      return;
    const f = e * (p * -1);
    r.forEach((h) => h.add(f));
  }
  return {
    loop: u
  };
}
function kL(e) {
  const {
    max: t,
    length: n
  } = e;
  function r(a) {
    return (a - t) / -n;
  }
  return {
    get: r
  };
}
function TL(e, t, n, r, i, a, o) {
  const {
    startEdge: s,
    endEdge: l
  } = e, {
    groupSlides: c
  } = a, u = f().map(t.measure), d = h(), p = m();
  function f() {
    return c(r).map((g) => si(g)[l] - g[0][s]).map(Wt);
  }
  function h() {
    return r.map((g) => n[s] - g[s]).map((g) => -Wt(g));
  }
  function m() {
    const v = si(d) - si(i);
    return c(d).map((b) => b[0]).map((b, T, O) => {
      const S = !T, P = T === Id(O);
      return o && S ? 0 : o && P ? v : b + u[T];
    });
  }
  return {
    snaps: d,
    snapsAligned: p
  };
}
function CL(e, t, n, r, i) {
  const {
    reachedAny: a,
    removeOffset: o,
    constrain: s
  } = r;
  function l(h) {
    return h.concat().sort((m, y) => Wt(m) - Wt(y))[0];
  }
  function c(h) {
    const m = e ? o(h) : s(h), y = t.map((v) => v - m).map((v) => u(v, 0)).map((v, b) => ({
      diff: v,
      index: b
    })).sort((v, b) => Wt(v.diff) - Wt(b.diff)), {
      index: g
    } = y[0];
    return {
      index: g,
      distance: m
    };
  }
  function u(h, m) {
    const y = [h, h + n, h - n];
    if (!e)
      return y[0];
    if (!m)
      return l(y);
    const g = y.filter((v) => Km(v) === m);
    return l(g);
  }
  function d(h, m) {
    const y = t[h] - i.get(), g = u(y, m);
    return {
      index: h,
      distance: g
    };
  }
  function p(h, m) {
    const y = i.get() + h, {
      index: g,
      distance: v
    } = c(y), b = !e && a(y);
    if (!m || b)
      return {
        index: g,
        distance: h
      };
    const T = t[g] - v, O = h + u(T, 0);
    return {
      index: g,
      distance: O
    };
  }
  return {
    byDistance: p,
    byIndex: d,
    shortcut: u
  };
}
function OL(e, t, n, r, i, a, o) {
  function s(d) {
    const p = d.distance, f = d.index !== t.get();
    a.add(p), p && (i.duration() ? e.start() : (e.update(), e.render(1), e.update())), f && (n.set(t.get()), t.set(d.index), o.emit("select"));
  }
  function l(d, p) {
    const f = r.byDistance(d, p);
    s(f);
  }
  function c(d, p) {
    const f = t.clone().set(d), h = r.byIndex(f.get(), p);
    s(h);
  }
  return {
    distance: l,
    index: c
  };
}
function kc(e) {
  let t = e;
  function n() {
    return t;
  }
  function r(l) {
    t = o(l);
  }
  function i(l) {
    t += o(l);
  }
  function a(l) {
    t -= o(l);
  }
  function o(l) {
    return Vm(l) ? l : l.get();
  }
  return {
    get: n,
    set: r,
    add: i,
    subtract: a
  };
}
function g_(e, t, n) {
  const r = e.scroll === "x" ? o : s, i = n.style;
  let a = !1;
  function o(p) {
    return `translate3d(${p}px,0px,0px)`;
  }
  function s(p) {
    return `translate3d(0px,${p}px,0px)`;
  }
  function l(p) {
    a || (i.transform = r(t.apply(p)));
  }
  function c(p) {
    a = !p;
  }
  function u() {
    a || (i.transform = "", n.getAttribute("style") || n.removeAttribute("style"));
  }
  return {
    clear: u,
    to: l,
    toggleActive: c
  };
}
function AL(e, t, n, r, i, a, o, s, l) {
  const c = Is(i), u = Is(i).reverse(), d = m().concat(y());
  function p(O, S) {
    return O.reduce((P, M) => P - i[M], S);
  }
  function f(O, S) {
    return O.reduce((P, M) => p(P, S) > 0 ? P.concat([M]) : P, []);
  }
  function h(O, S) {
    const P = S === "start", M = P ? -r : r, L = o.findSlideBounds([M]);
    return O.map((k) => {
      const I = P ? 0 : -r, B = P ? r : 0, z = L.filter((D) => D.index === k)[0][P ? "end" : "start"];
      return {
        index: k,
        slideLocation: kc(-1),
        translate: g_(e, t, l[k]),
        target: () => s.get() > z ? I : B
      };
    });
  }
  function m() {
    const O = a[0] - 1, S = f(u, O);
    return h(S, "end");
  }
  function y() {
    const O = n - a[0] - 1, S = f(c, O);
    return h(S, "start");
  }
  function g() {
    return d.every(({
      index: O
    }) => {
      const S = c.filter((P) => P !== O);
      return p(S, n) <= 0.1;
    });
  }
  function v() {
    d.forEach((O) => {
      const {
        target: S,
        translate: P,
        slideLocation: M
      } = O, L = S();
      L !== M.get() && (P.to(L), M.set(L));
    });
  }
  function b() {
    d.forEach((O) => O.translate.clear());
  }
  return {
    canLoop: g,
    clear: b,
    loop: v,
    loopPoints: d
  };
}
function $L(e, t) {
  let n, r = !1;
  function i(s, l) {
    if (!l)
      return;
    function c(u) {
      for (const d of u)
        if (d.type === "childList") {
          s.reInit(), t.emit("slidesChanged");
          break;
        }
    }
    n = new MutationObserver((u) => {
      r || (Hm(l) || l(s, u)) && c(u);
    }), n.observe(e, {
      childList: !0
    });
  }
  function a() {
    n && n.disconnect(), r = !0;
  }
  return {
    init: i,
    destroy: a
  };
}
function RL(e, t, n, r, i, a, o) {
  const {
    removeOffset: s,
    constrain: l
  } = i, c = 0.5, u = a ? [0, t, -t] : [0], d = f(u, o);
  function p(y) {
    const g = y || 0;
    return n.map((v) => Fi(c, v - c).constrain(v * g));
  }
  function f(y, g) {
    const v = y || u, b = p(g);
    return v.reduce((T, O) => {
      const S = r.map((P, M) => ({
        start: P - n[M] + b[M] + O,
        end: P + e - b[M] + O,
        index: M
      }));
      return T.concat(S);
    }, []);
  }
  function h(y, g) {
    const v = a ? s(y) : l(y);
    return (g || d).reduce((T, O) => {
      const {
        index: S,
        start: P,
        end: M
      } = O, L = T.includes(S), k = P < v && M > v;
      return !L && k ? T.concat([S]) : T;
    }, []);
  }
  return {
    check: h,
    findSlideBounds: f
  };
}
function PL(e, t, n, r, i, a) {
  const {
    measureSize: o,
    startEdge: s,
    endEdge: l
  } = e, c = n[0] && i, u = h(), d = m(), p = n.map(o), f = y();
  function h() {
    if (!c)
      return 0;
    const v = n[0];
    return Wt(t[s] - v[s]);
  }
  function m() {
    if (!c)
      return 0;
    const v = a.getComputedStyle(si(r));
    return parseFloat(v.getPropertyValue(`margin-${l}`));
  }
  function y() {
    return n.map((v, b, T) => {
      const O = !b, S = b === Id(T);
      return O ? p[b] + u : S ? p[b] + d : T[b + 1][s] - v[s];
    }).map(Wt);
  }
  return {
    slideSizes: p,
    slideSizesWithGaps: f
  };
}
function IL(e, t, n) {
  const r = Vm(n);
  function i(l, c) {
    return Is(l).filter((u) => u % c === 0).map((u) => l.slice(u, u + c));
  }
  function a(l) {
    return Is(l).reduce((c, u) => {
      const p = t.slice(si(c), u + 1).reduce((f, h) => f + h, 0);
      return !u || p > e ? c.concat(u) : c;
    }, []).map((c, u, d) => l.slice(c, d[u + 1]));
  }
  function o(l) {
    return r ? i(l, n) : a(l);
  }
  return {
    groupSlides: o
  };
}
function ML(e, t, n, r, i, a, o, s) {
  const {
    align: l,
    axis: c,
    direction: u,
    startIndex: d,
    inViewThreshold: p,
    loop: f,
    duration: h,
    dragFree: m,
    dragThreshold: y,
    slidesToScroll: g,
    skipSnaps: v,
    containScroll: b
  } = a, T = t.getBoundingClientRect(), O = n.map((pe) => pe.getBoundingClientRect()), S = mL(u), P = hL(c, u), M = P.measureSize(T), L = vL(M), k = pL(l, M), I = !f && !!b, B = f || !!b, {
    slideSizes: U,
    slideSizesWithGaps: z
  } = PL(P, T, O, n, B, i), D = IL(M, z, g), {
    snaps: j,
    snapsAligned: V
  } = TL(P, k, T, O, z, D, I), W = -si(j) + si(z), {
    snapsContained: de
  } = _L(M, W, V, b), x = I ? de : V, {
    limit: ie
  } = SL(W, x, f), ve = m_(Id(x), d, f), E = ve.clone(), ke = Is(n), Ze = ({
    dragHandler: pe,
    scrollBody: ue,
    scrollBounds: Le,
    eventHandler: Me,
    animation: Ke,
    options: {
      loop: gt
    }
  }) => {
    const tt = pe.pointerDown();
    gt || Le.constrain(tt);
    const Z = ue.seek().settled();
    Z && !tt && (Ke.stop(), Me.emit("settle")), Z || Me.emit("scroll");
  }, Pe = ({
    scrollBody: pe,
    translate: ue,
    location: Le,
    offsetLocation: Me,
    scrollLooper: Ke,
    slideLooper: gt,
    options: {
      loop: tt
    }
  }, Z) => {
    const J = pe.velocity();
    Me.set(Le.get() - J + J * Z), tt && (Ke.loop(pe.direction()), gt.loop()), ue.to(Me.get());
  }, qe = {
    start: () => s.start(le),
    stop: () => s.stop(le),
    update: () => Ze(le),
    render: (pe) => Pe(le, pe)
  }, rt = 0.68, Ve = x[ve.get()], be = kc(Ve), he = kc(Ve), Oe = kc(Ve), we = wL(be, Oe, h, rt), Fe = CL(f, x, W, ie, Oe), st = OL(qe, ve, E, Fe, we, Oe, o), N = RL(M, W, U, j, ie, f, p), le = {
    ownerDocument: r,
    ownerWindow: i,
    eventHandler: o,
    containerRect: T,
    slideRects: O,
    animation: qe,
    axis: P,
    direction: S,
    dragHandler: gL(P, S, e, r, i, Oe, yL(P, i), be, qe, st, we, Fe, ve, o, L, m, y, v, rt),
    eventStore: Ms(),
    percentOfView: L,
    index: ve,
    indexPrevious: E,
    limit: ie,
    location: be,
    offsetLocation: he,
    options: a,
    resizeHandler: bL(t, o, i, n, P),
    scrollBody: we,
    scrollBounds: xL(ie, be, Oe, we, L),
    scrollLooper: EL(W, ie, he, [be, he, Oe]),
    scrollProgress: kL(ie),
    scrollSnaps: x,
    scrollTarget: Fe,
    scrollTo: st,
    slideLooper: AL(P, S, M, W, z, x, N, he, n),
    slidesHandler: $L(t, o),
    slidesInView: N,
    slideIndexes: ke,
    slidesToScroll: D,
    target: Oe,
    translate: g_(P, S, t)
  };
  return le;
}
function NL(e) {
  const t = 16.666666666666668;
  let n = [], r = null, i = 0, a = 0;
  function o(d) {
    r || (r = d);
    const p = d - r;
    for (r = d, i += p; i >= t; )
      n.forEach(({
        animation: h
      }) => h.update()), i -= t;
    const f = Wt(i / t);
    n.forEach(({
      animation: h
    }) => h.render(f)), a && e.requestAnimationFrame(o);
  }
  function s(d) {
    n.includes(d) || n.push(d), !a && (a = e.requestAnimationFrame(o));
  }
  function l(d) {
    n = n.filter((p) => p !== d), !n.length && (e.cancelAnimationFrame(a), r = null, i = 0, a = 0);
  }
  function c() {
    r = null, i = 0;
  }
  return {
    start: s,
    stop: l,
    reset: c,
    window: e
  };
}
function DL() {
  const e = {};
  let t;
  function n(l) {
    t = l;
  }
  function r(l) {
    return e[l] || [];
  }
  function i(l) {
    return r(l).forEach((c) => c(t, l)), s;
  }
  function a(l, c) {
    return e[l] = r(l).concat([c]), s;
  }
  function o(l, c) {
    return e[l] = r(l).filter((u) => u !== c), s;
  }
  const s = {
    init: n,
    emit: i,
    off: o,
    on: a
  };
  return s;
}
const LL = {
  align: "center",
  axis: "x",
  container: null,
  slides: null,
  containScroll: "trimSnaps",
  direction: "ltr",
  slidesToScroll: 1,
  breakpoints: {},
  dragFree: !1,
  dragThreshold: 10,
  inViewThreshold: 0,
  loop: !1,
  skipSnaps: !1,
  duration: 25,
  startIndex: 0,
  active: !0,
  watchDrag: !0,
  watchResize: !0,
  watchSlides: !0
};
function jL(e) {
  function t(a, o) {
    return p_(a, o || {});
  }
  function n(a) {
    const o = a.breakpoints || {}, s = eu(o).filter((l) => e.matchMedia(l).matches).map((l) => o[l]).reduce((l, c) => t(l, c), {});
    return t(a, s);
  }
  function r(a) {
    return a.map((o) => eu(o.breakpoints || {})).reduce((o, s) => o.concat(s), []).map(e.matchMedia);
  }
  return {
    mergeOptions: t,
    optionsAtMedia: n,
    optionsMediaQueries: r
  };
}
function UL(e) {
  let t = [];
  function n(a, o) {
    return t = a.filter(({
      options: s
    }) => e.optionsAtMedia(s).active !== !1), t.forEach((s) => s.init(o, e)), a.reduce((s, l) => Object.assign(s, {
      [l.name]: l
    }), {});
  }
  function r() {
    t = t.filter((a) => a.destroy());
  }
  return {
    init: n,
    destroy: r
  };
}
function yo(e, t, n) {
  const r = e.ownerDocument, i = r.defaultView, a = jL(i), o = UL(a), s = Ms(), l = Ms(), c = DL(), {
    animationRealms: u
  } = yo, {
    mergeOptions: d,
    optionsAtMedia: p,
    optionsMediaQueries: f
  } = a, {
    on: h,
    off: m,
    emit: y
  } = c, g = U;
  let v = !1, b, T = d(LL, yo.globalOptions), O = d(T), S = [], P, M, L;
  function k() {
    const {
      container: we,
      slides: Fe
    } = O;
    M = (Av(we) ? e.querySelector(we) : we) || e.children[0];
    const N = Av(Fe) ? M.querySelectorAll(Fe) : Fe;
    L = [].slice.call(N || M.children);
  }
  function I(we, Fe) {
    const st = ML(e, M, L, r, i, we, c, Fe);
    if (we.loop && !st.slideLooper.canLoop()) {
      const N = Object.assign({}, we, {
        loop: !1
      });
      return I(N, Fe);
    }
    return st;
  }
  function B(we, Fe) {
    if (v)
      return;
    const st = u.find((le) => le.window === i), N = st || NL(i);
    st || u.push(N), T = d(T, we), O = p(T), S = Fe || S, k(), b = I(O, N), f([T, ...S.map(({
      options: le
    }) => le)]).forEach((le) => s.add(le, "change", U)), O.active && (b.translate.to(b.location.get()), b.eventHandler.init(Oe), b.resizeHandler.init(Oe, O.watchResize), b.slidesHandler.init(Oe, O.watchSlides), l.add(r, "visibilitychange", () => {
      r.hidden && N.reset();
    }), b.options.loop && b.slideLooper.loop(), M.offsetParent && L.length && b.dragHandler.init(Oe, O.watchDrag), P = o.init(S, Oe));
  }
  function U(we, Fe) {
    const st = Ze();
    z(), B(d({
      startIndex: st
    }, we), Fe), c.emit("reInit");
  }
  function z() {
    b.dragHandler.destroy(), b.animation.stop(), b.eventStore.clear(), b.translate.clear(), b.slideLooper.clear(), b.resizeHandler.destroy(), b.slidesHandler.destroy(), o.destroy(), s.clear(), l.clear();
  }
  function D() {
    v || (v = !0, s.clear(), z(), c.emit("destroy"));
  }
  function j(we) {
    const Fe = b[we ? "target" : "location"].get(), st = O.loop ? "removeOffset" : "constrain";
    return b.slidesInView.check(b.limit[st](Fe));
  }
  function V(we) {
    const Fe = j(we);
    return b.slideIndexes.filter((st) => !Fe.includes(st));
  }
  function W(we, Fe, st) {
    !O.active || v || (b.scrollBody.useBaseFriction().useDuration(Fe ? 0 : O.duration), b.scrollTo.index(we, st || 0));
  }
  function de(we) {
    const Fe = b.index.add(1).get();
    W(Fe, we === !0, -1);
  }
  function x(we) {
    const Fe = b.index.add(-1).get();
    W(Fe, we === !0, 1);
  }
  function ie() {
    return b.index.add(1).get() !== Ze();
  }
  function ve() {
    return b.index.add(-1).get() !== Ze();
  }
  function E() {
    return b.scrollSnaps.map(b.scrollProgress.get);
  }
  function ke() {
    return b.scrollProgress.get(b.location.get());
  }
  function Ze() {
    return b.index.get();
  }
  function Pe() {
    return b.indexPrevious.get();
  }
  function qe() {
    return P;
  }
  function rt() {
    return b;
  }
  function Ve() {
    return e;
  }
  function be() {
    return M;
  }
  function he() {
    return L;
  }
  const Oe = {
    canScrollNext: ie,
    canScrollPrev: ve,
    containerNode: be,
    internalEngine: rt,
    destroy: D,
    off: m,
    on: h,
    emit: y,
    plugins: qe,
    previousScrollSnap: Pe,
    reInit: g,
    rootNode: Ve,
    scrollNext: de,
    scrollPrev: x,
    scrollProgress: ke,
    scrollSnapList: E,
    scrollTo: W,
    selectedScrollSnap: Ze,
    slideNodes: he,
    slidesInView: j,
    slidesNotInView: V
  };
  return B(t, n), setTimeout(() => c.emit("init"), 0), Oe;
}
yo.animationRealms = [];
yo.globalOptions = void 0;
function Gm(e = {}, t = []) {
  const n = Xe(e), r = Xe(t), [i, a] = De(), [o, s] = De(), l = nn(() => {
    i && i.reInit(n.current, r.current);
  }, [i]);
  return Be(() => {
    if (uL() && o) {
      yo.globalOptions = Gm.globalOptions;
      const c = yo(o, n.current, r.current);
      return a(c), () => c.destroy();
    } else
      a(void 0);
  }, [o, a]), Be(() => {
    Wm(n.current, e) || (n.current = e, l());
  }, [e, l]), Be(() => {
    dL(r.current, t) || (r.current = t, l());
  }, [t, l]), [s, i];
}
Gm.globalOptions = void 0;
function FL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    fillRule: "evenodd",
    d: "M7.72 12.53a.75.75 0 010-1.06l7.5-7.5a.75.75 0 111.06 1.06L9.31 12l6.97 6.97a.75.75 0 11-1.06 1.06l-7.5-7.5z",
    clipRule: "evenodd"
  }));
}
const BL = A.forwardRef(FL), zL = BL;
function ZL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    fillRule: "evenodd",
    d: "M16.28 11.47a.75.75 0 010 1.06l-7.5 7.5a.75.75 0 01-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 011.06-1.06l7.5 7.5z",
    clipRule: "evenodd"
  }));
}
const qL = A.forwardRef(ZL), WL = qL;
function VL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    fillRule: "evenodd",
    d: "M5.625 1.5c-1.036 0-1.875.84-1.875 1.875v17.25c0 1.035.84 1.875 1.875 1.875h12.75c1.035 0 1.875-.84 1.875-1.875V12.75A3.75 3.75 0 0016.5 9h-1.875a1.875 1.875 0 01-1.875-1.875V5.25A3.75 3.75 0 009 1.5H5.625zM7.5 15a.75.75 0 01.75-.75h7.5a.75.75 0 010 1.5h-7.5A.75.75 0 017.5 15zm.75 2.25a.75.75 0 000 1.5H12a.75.75 0 000-1.5H8.25z",
    clipRule: "evenodd"
  }), /* @__PURE__ */ A.createElement("path", {
    d: "M12.971 1.816A5.23 5.23 0 0114.25 5.25v1.875c0 .207.168.375.375.375H16.5a5.23 5.23 0 013.434 1.279 9.768 9.768 0 00-6.963-6.963z"
  }));
}
const HL = A.forwardRef(VL), KL = HL;
function GL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    d: "M1.5 8.67v8.58a3 3 0 003 3h15a3 3 0 003-3V8.67l-8.928 5.493a3 3 0 01-3.144 0L1.5 8.67z"
  }), /* @__PURE__ */ A.createElement("path", {
    d: "M22.5 6.908V6.75a3 3 0 00-3-3h-15a3 3 0 00-3 3v.158l9.714 5.978a1.5 1.5 0 001.572 0L22.5 6.908z"
  }));
}
const JL = A.forwardRef(GL), YL = JL;
function XL({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    d: "M21.721 12.752a9.711 9.711 0 00-.945-5.003 12.754 12.754 0 01-4.339 2.708 18.991 18.991 0 01-.214 4.772 17.165 17.165 0 005.498-2.477zM14.634 15.55a17.324 17.324 0 00.332-4.647c-.952.227-1.945.347-2.966.347-1.021 0-2.014-.12-2.966-.347a17.515 17.515 0 00.332 4.647 17.385 17.385 0 005.268 0zM9.772 17.119a18.963 18.963 0 004.456 0A17.182 17.182 0 0112 21.724a17.18 17.18 0 01-2.228-4.605zM7.777 15.23a18.87 18.87 0 01-.214-4.774 12.753 12.753 0 01-4.34-2.708 9.711 9.711 0 00-.944 5.004 17.165 17.165 0 005.498 2.477zM21.356 14.752a9.765 9.765 0 01-7.478 6.817 18.64 18.64 0 001.988-4.718 18.627 18.627 0 005.49-2.098zM2.644 14.752c1.682.971 3.53 1.688 5.49 2.099a18.64 18.64 0 001.988 4.718 9.765 9.765 0 01-7.478-6.816zM13.878 2.43a9.755 9.755 0 016.116 3.986 11.267 11.267 0 01-3.746 2.504 18.63 18.63 0 00-2.37-6.49zM12 2.276a17.152 17.152 0 012.805 7.121c-.897.23-1.837.353-2.805.353-.968 0-1.908-.122-2.805-.353A17.151 17.151 0 0112 2.276zM10.122 2.43a18.629 18.629 0 00-2.37 6.49 11.266 11.266 0 01-3.746-2.504 9.754 9.754 0 016.116-3.985z"
  }));
}
const QL = A.forwardRef(XL), ej = QL;
function tj({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    fillRule: "evenodd",
    d: "M12 1.5a5.25 5.25 0 00-5.25 5.25v3a3 3 0 00-3 3v6.75a3 3 0 003 3h10.5a3 3 0 003-3v-6.75a3 3 0 00-3-3v-3c0-2.9-2.35-5.25-5.25-5.25zm3.75 8.25v-3a3.75 3.75 0 10-7.5 0v3h7.5z",
    clipRule: "evenodd"
  }));
}
const nj = A.forwardRef(tj), rj = nj;
function ij({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    fillRule: "evenodd",
    d: "M1.5 4.5a3 3 0 013-3h1.372c.86 0 1.61.586 1.819 1.42l1.105 4.423a1.875 1.875 0 01-.694 1.955l-1.293.97c-.135.101-.164.249-.126.352a11.285 11.285 0 006.697 6.697c.103.038.25.009.352-.126l.97-1.293a1.875 1.875 0 011.955-.694l4.423 1.105c.834.209 1.42.959 1.42 1.82V19.5a3 3 0 01-3 3h-2.25C8.552 22.5 1.5 15.448 1.5 6.75V4.5z",
    clipRule: "evenodd"
  }));
}
const aj = A.forwardRef(ij), oj = aj, sj = ze(({ type: e, styles: t, blocks: n }, r) => {
  const [i, a] = Gm({ skipSnaps: !0 }), [o, s] = De(!0), [l, c] = De(!0), u = nn(() => a && a.scrollPrev(), [a]), d = nn(() => a && a.scrollNext(), [a]), p = t == null ? void 0 : t[e], f = nn((h) => {
    s(!h.canScrollPrev()), c(!h.canScrollNext());
  }, []);
  return Be(() => {
    a && (f(a), a.on("reInit", f), a.on("select", f));
  }, [a, f]), /* @__PURE__ */ F.jsxs("div", { ...p == null ? void 0 : p.container, "data-container": "carousel", ref: i, children: [
    /* @__PURE__ */ F.jsx("div", { ref: r, ...p == null ? void 0 : p.slidesContainer, children: n.map((h, m) => /* @__PURE__ */ F.jsx(yl, { styles: t, block: h }, m)) }),
    /* @__PURE__ */ F.jsx(
      zL,
      {
        ...p == null ? void 0 : p.backButton,
        "data-disabled": o ? "" : void 0,
        onClick: u
      }
    ),
    /* @__PURE__ */ F.jsx(
      WL,
      {
        ...p == null ? void 0 : p.nextButton,
        "data-disabled": l ? "" : void 0,
        onClick: d
      }
    )
  ] });
}), vo = Math.min, Yn = Math.max, tu = Math.round, eo = Math.floor, Bi = (e) => ({
  x: e,
  y: e
});
function Rv(e, t, n) {
  return Yn(e, vo(t, n));
}
function Md(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function fl(e) {
  return e.split("-")[0];
}
function Jm(e) {
  return e.split("-")[1];
}
function y_(e) {
  return e === "x" ? "y" : "x";
}
function lj(e) {
  return e === "y" ? "height" : "width";
}
function pl(e) {
  return ["top", "bottom"].includes(fl(e)) ? "y" : "x";
}
function cj(e) {
  return y_(pl(e));
}
function uj(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function dj(e) {
  return typeof e != "number" ? uj(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function nu(e) {
  return {
    ...e,
    top: e.y,
    left: e.x,
    right: e.x + e.width,
    bottom: e.y + e.height
  };
}
function zi(e) {
  return v_(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function er(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function vi(e) {
  var t;
  return (t = (v_(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function v_(e) {
  return e instanceof Node || e instanceof er(e).Node;
}
function Gt(e) {
  return e instanceof Element || e instanceof er(e).Element;
}
function An(e) {
  return e instanceof HTMLElement || e instanceof er(e).HTMLElement;
}
function mh(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof er(e).ShadowRoot;
}
function hl(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: i
  } = tr(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(i);
}
function fj(e) {
  return ["table", "td", "th"].includes(zi(e));
}
function Ym(e) {
  const t = Xm(), n = tr(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function pj(e) {
  let t = wa(e);
  for (; An(t) && !ml(t); ) {
    if (Ym(t))
      return t;
    t = wa(t);
  }
  return null;
}
function Xm() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function ml(e) {
  return ["html", "body", "#document"].includes(zi(e));
}
function tr(e) {
  return er(e).getComputedStyle(e);
}
function Nd(e) {
  return Gt(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function wa(e) {
  if (zi(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    mh(e) && e.host || // Fallback.
    vi(e)
  );
  return mh(t) ? t.host : t;
}
function b_(e) {
  const t = wa(e);
  return ml(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : An(t) && hl(t) ? t : b_(t);
}
function Li(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const i = b_(e), a = i === ((r = e.ownerDocument) == null ? void 0 : r.body), o = er(i);
  return a ? t.concat(o, o.visualViewport || [], hl(i) ? i : [], o.frameElement && n ? Li(o.frameElement) : []) : t.concat(i, Li(i, [], n));
}
function Pi(e) {
  let t = e.activeElement;
  for (; ((n = t) == null || (r = n.shadowRoot) == null ? void 0 : r.activeElement) != null; ) {
    var n, r;
    t = t.shadowRoot.activeElement;
  }
  return t;
}
function qn(e, t) {
  if (!e || !t)
    return !1;
  const n = t.getRootNode && t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && mh(n)) {
    let r = t;
    for (; r; ) {
      if (e === r)
        return !0;
      r = r.parentNode || r.host;
    }
  }
  return !1;
}
function w_() {
  const e = navigator.userAgentData;
  return e != null && e.platform ? e.platform : navigator.platform;
}
function hj() {
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? e.brands.map((t) => {
    let {
      brand: n,
      version: r
    } = t;
    return n + "/" + r;
  }).join(" ") : navigator.userAgent;
}
function x_(e) {
  if (e.mozInputSource === 0 && e.isTrusted)
    return !0;
  const t = /Android/i;
  return (t.test(w_()) || t.test(hj())) && e.pointerType ? e.type === "click" && e.buttons === 1 : e.detail === 0 && !e.pointerType;
}
function __(e) {
  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType !== "mouse" || // iOS VoiceOver returns 0.333 for width/height.
  e.width < 1 && e.height < 1 && e.pressure === 0 && e.detail === 0;
}
function S_() {
  return /apple/i.test(navigator.vendor);
}
function mj() {
  return w_().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function Pv(e, t) {
  const n = ["mouse", "pen"];
  return t || n.push("", void 0), n.includes(e);
}
function gj(e) {
  return "nativeEvent" in e;
}
function yj(e) {
  return e.matches("html,body");
}
function mr(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function lp(e, t) {
  if (t == null)
    return !1;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
function E_(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
const vj = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function k_(e) {
  return An(e) && e.matches(vj);
}
function wn(e) {
  e.preventDefault(), e.stopPropagation();
}
function Iv(e, t, n) {
  let {
    reference: r,
    floating: i
  } = e;
  const a = pl(t), o = cj(t), s = lj(o), l = fl(t), c = a === "y", u = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, p = r[s] / 2 - i[s] / 2;
  let f;
  switch (l) {
    case "top":
      f = {
        x: u,
        y: r.y - i.height
      };
      break;
    case "bottom":
      f = {
        x: u,
        y: r.y + r.height
      };
      break;
    case "right":
      f = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      f = {
        x: r.x - i.width,
        y: d
      };
      break;
    default:
      f = {
        x: r.x,
        y: r.y
      };
  }
  switch (Jm(t)) {
    case "start":
      f[o] -= p * (n && c ? -1 : 1);
      break;
    case "end":
      f[o] += p * (n && c ? -1 : 1);
      break;
  }
  return f;
}
const bj = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: a = [],
    platform: o
  } = n, s = a.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(t));
  let c = await o.getElementRects({
    reference: e,
    floating: t,
    strategy: i
  }), {
    x: u,
    y: d
  } = Iv(c, r, l), p = r, f = {}, h = 0;
  for (let m = 0; m < s.length; m++) {
    const {
      name: y,
      fn: g
    } = s[m], {
      x: v,
      y: b,
      data: T,
      reset: O
    } = await g({
      x: u,
      y: d,
      initialPlacement: r,
      placement: p,
      strategy: i,
      middlewareData: f,
      rects: c,
      platform: o,
      elements: {
        reference: e,
        floating: t
      }
    });
    if (u = v ?? u, d = b ?? d, f = {
      ...f,
      [y]: {
        ...f[y],
        ...T
      }
    }, O && h <= 50) {
      h++, typeof O == "object" && (O.placement && (p = O.placement), O.rects && (c = O.rects === !0 ? await o.getElementRects({
        reference: e,
        floating: t,
        strategy: i
      }) : O.rects), {
        x: u,
        y: d
      } = Iv(c, p, l)), m = -1;
      continue;
    }
  }
  return {
    x: u,
    y: d,
    placement: p,
    strategy: i,
    middlewareData: f
  };
};
async function T_(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: i,
    platform: a,
    rects: o,
    elements: s,
    strategy: l
  } = e, {
    boundary: c = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: p = !1,
    padding: f = 0
  } = Md(t, e), h = dj(f), y = s[p ? d === "floating" ? "reference" : "floating" : d], g = nu(await a.getClippingRect({
    element: (n = await (a.isElement == null ? void 0 : a.isElement(y))) == null || n ? y : y.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(s.floating)),
    boundary: c,
    rootBoundary: u,
    strategy: l
  })), v = d === "floating" ? {
    ...o.floating,
    x: r,
    y: i
  } : o.reference, b = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(s.floating)), T = await (a.isElement == null ? void 0 : a.isElement(b)) ? await (a.getScale == null ? void 0 : a.getScale(b)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, O = nu(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: v,
    offsetParent: b,
    strategy: l
  }) : v);
  return {
    top: (g.top - O.top + h.top) / T.y,
    bottom: (O.bottom - g.bottom + h.bottom) / T.y,
    left: (g.left - O.left + h.left) / T.x,
    right: (O.right - g.right + h.right) / T.x
  };
}
async function wj(e, t) {
  const {
    placement: n,
    platform: r,
    elements: i
  } = e, a = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = fl(n), s = Jm(n), l = pl(n) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = a && l ? -1 : 1, d = Md(t, e);
  let {
    mainAxis: p,
    crossAxis: f,
    alignmentAxis: h
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return s && typeof h == "number" && (f = s === "end" ? h * -1 : h), l ? {
    x: f * u,
    y: p * c
  } : {
    x: p * c,
    y: f * u
  };
}
const xj = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r
      } = t, i = await wj(t, e);
      return {
        x: n + i.x,
        y: r + i.y,
        data: i
      };
    }
  };
}, _j = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: i
      } = t, {
        mainAxis: a = !0,
        crossAxis: o = !1,
        limiter: s = {
          fn: (y) => {
            let {
              x: g,
              y: v
            } = y;
            return {
              x: g,
              y: v
            };
          }
        },
        ...l
      } = Md(e, t), c = {
        x: n,
        y: r
      }, u = await T_(t, l), d = pl(fl(i)), p = y_(d);
      let f = c[p], h = c[d];
      if (a) {
        const y = p === "y" ? "top" : "left", g = p === "y" ? "bottom" : "right", v = f + u[y], b = f - u[g];
        f = Rv(v, f, b);
      }
      if (o) {
        const y = d === "y" ? "top" : "left", g = d === "y" ? "bottom" : "right", v = h + u[y], b = h - u[g];
        h = Rv(v, h, b);
      }
      const m = s.fn({
        ...t,
        [p]: f,
        [d]: h
      });
      return {
        ...m,
        data: {
          x: m.x - n,
          y: m.y - r
        }
      };
    }
  };
}, Sj = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      const {
        placement: n,
        rects: r,
        platform: i,
        elements: a
      } = t, {
        apply: o = () => {
        },
        ...s
      } = Md(e, t), l = await T_(t, s), c = fl(n), u = Jm(n), d = pl(n) === "y", {
        width: p,
        height: f
      } = r.floating;
      let h, m;
      c === "top" || c === "bottom" ? (h = c, m = u === (await (i.isRTL == null ? void 0 : i.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (m = c, h = u === "end" ? "top" : "bottom");
      const y = f - l[h], g = p - l[m], v = !t.middlewareData.shift;
      let b = y, T = g;
      if (d) {
        const S = p - l.left - l.right;
        T = u || v ? vo(g, S) : S;
      } else {
        const S = f - l.top - l.bottom;
        b = u || v ? vo(y, S) : S;
      }
      if (v && !u) {
        const S = Yn(l.left, 0), P = Yn(l.right, 0), M = Yn(l.top, 0), L = Yn(l.bottom, 0);
        d ? T = p - 2 * (S !== 0 || P !== 0 ? S + P : Yn(l.left, l.right)) : b = f - 2 * (M !== 0 || L !== 0 ? M + L : Yn(l.top, l.bottom));
      }
      await o({
        ...t,
        availableWidth: T,
        availableHeight: b
      });
      const O = await i.getDimensions(a.floating);
      return p !== O.width || f !== O.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function C_(e) {
  const t = tr(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const i = An(e), a = i ? e.offsetWidth : n, o = i ? e.offsetHeight : r, s = tu(n) !== a || tu(r) !== o;
  return s && (n = a, r = o), {
    width: n,
    height: r,
    $: s
  };
}
function Qm(e) {
  return Gt(e) ? e : e.contextElement;
}
function so(e) {
  const t = Qm(e);
  if (!An(t))
    return Bi(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: i,
    $: a
  } = C_(t);
  let o = (a ? tu(n.width) : n.width) / r, s = (a ? tu(n.height) : n.height) / i;
  return (!o || !Number.isFinite(o)) && (o = 1), (!s || !Number.isFinite(s)) && (s = 1), {
    x: o,
    y: s
  };
}
const Ej = /* @__PURE__ */ Bi(0);
function O_(e) {
  const t = er(e);
  return !Xm() || !t.visualViewport ? Ej : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function kj(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== er(e) ? !1 : t;
}
function xa(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const i = e.getBoundingClientRect(), a = Qm(e);
  let o = Bi(1);
  t && (r ? Gt(r) && (o = so(r)) : o = so(e));
  const s = kj(a, n, r) ? O_(a) : Bi(0);
  let l = (i.left + s.x) / o.x, c = (i.top + s.y) / o.y, u = i.width / o.x, d = i.height / o.y;
  if (a) {
    const p = er(a), f = r && Gt(r) ? er(r) : r;
    let h = p.frameElement;
    for (; h && r && f !== p; ) {
      const m = so(h), y = h.getBoundingClientRect(), g = tr(h), v = y.left + (h.clientLeft + parseFloat(g.paddingLeft)) * m.x, b = y.top + (h.clientTop + parseFloat(g.paddingTop)) * m.y;
      l *= m.x, c *= m.y, u *= m.x, d *= m.y, l += v, c += b, h = er(h).frameElement;
    }
  }
  return nu({
    width: u,
    height: d,
    x: l,
    y: c
  });
}
function Tj(e) {
  let {
    rect: t,
    offsetParent: n,
    strategy: r
  } = e;
  const i = An(n), a = vi(n);
  if (n === a)
    return t;
  let o = {
    scrollLeft: 0,
    scrollTop: 0
  }, s = Bi(1);
  const l = Bi(0);
  if ((i || !i && r !== "fixed") && ((zi(n) !== "body" || hl(a)) && (o = Nd(n)), An(n))) {
    const c = xa(n);
    s = so(n), l.x = c.x + n.clientLeft, l.y = c.y + n.clientTop;
  }
  return {
    width: t.width * s.x,
    height: t.height * s.y,
    x: t.x * s.x - o.scrollLeft * s.x + l.x,
    y: t.y * s.y - o.scrollTop * s.y + l.y
  };
}
function Cj(e) {
  return Array.from(e.getClientRects());
}
function A_(e) {
  return xa(vi(e)).left + Nd(e).scrollLeft;
}
function Oj(e) {
  const t = vi(e), n = Nd(e), r = e.ownerDocument.body, i = Yn(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), a = Yn(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let o = -n.scrollLeft + A_(e);
  const s = -n.scrollTop;
  return tr(r).direction === "rtl" && (o += Yn(t.clientWidth, r.clientWidth) - i), {
    width: i,
    height: a,
    x: o,
    y: s
  };
}
function Aj(e, t) {
  const n = er(e), r = vi(e), i = n.visualViewport;
  let a = r.clientWidth, o = r.clientHeight, s = 0, l = 0;
  if (i) {
    a = i.width, o = i.height;
    const c = Xm();
    (!c || c && t === "fixed") && (s = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: a,
    height: o,
    x: s,
    y: l
  };
}
function $j(e, t) {
  const n = xa(e, !0, t === "fixed"), r = n.top + e.clientTop, i = n.left + e.clientLeft, a = An(e) ? so(e) : Bi(1), o = e.clientWidth * a.x, s = e.clientHeight * a.y, l = i * a.x, c = r * a.y;
  return {
    width: o,
    height: s,
    x: l,
    y: c
  };
}
function Mv(e, t, n) {
  let r;
  if (t === "viewport")
    r = Aj(e, n);
  else if (t === "document")
    r = Oj(vi(e));
  else if (Gt(t))
    r = $j(t, n);
  else {
    const i = O_(e);
    r = {
      ...t,
      x: t.x - i.x,
      y: t.y - i.y
    };
  }
  return nu(r);
}
function $_(e, t) {
  const n = wa(e);
  return n === t || !Gt(n) || ml(n) ? !1 : tr(n).position === "fixed" || $_(n, t);
}
function Rj(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Li(e, [], !1).filter((s) => Gt(s) && zi(s) !== "body"), i = null;
  const a = tr(e).position === "fixed";
  let o = a ? wa(e) : e;
  for (; Gt(o) && !ml(o); ) {
    const s = tr(o), l = Ym(o);
    !l && s.position === "fixed" && (i = null), (a ? !l && !i : !l && s.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || hl(o) && !l && $_(e, o)) ? r = r.filter((u) => u !== o) : i = s, o = wa(o);
  }
  return t.set(e, r), r;
}
function Pj(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: i
  } = e;
  const o = [...n === "clippingAncestors" ? Rj(t, this._c) : [].concat(n), r], s = o[0], l = o.reduce((c, u) => {
    const d = Mv(t, u, i);
    return c.top = Yn(d.top, c.top), c.right = vo(d.right, c.right), c.bottom = vo(d.bottom, c.bottom), c.left = Yn(d.left, c.left), c;
  }, Mv(t, s, i));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function Ij(e) {
  return C_(e);
}
function Mj(e, t, n) {
  const r = An(t), i = vi(t), a = n === "fixed", o = xa(e, !0, a, t);
  let s = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const l = Bi(0);
  if (r || !r && !a)
    if ((zi(t) !== "body" || hl(i)) && (s = Nd(t)), r) {
      const c = xa(t, !0, a, t);
      l.x = c.x + t.clientLeft, l.y = c.y + t.clientTop;
    } else
      i && (l.x = A_(i));
  return {
    x: o.left + s.scrollLeft - l.x,
    y: o.top + s.scrollTop - l.y,
    width: o.width,
    height: o.height
  };
}
function Nv(e, t) {
  return !An(e) || tr(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function R_(e, t) {
  const n = er(e);
  if (!An(e))
    return n;
  let r = Nv(e, t);
  for (; r && fj(r) && tr(r).position === "static"; )
    r = Nv(r, t);
  return r && (zi(r) === "html" || zi(r) === "body" && tr(r).position === "static" && !Ym(r)) ? n : r || pj(e) || n;
}
const Nj = async function(e) {
  let {
    reference: t,
    floating: n,
    strategy: r
  } = e;
  const i = this.getOffsetParent || R_, a = this.getDimensions;
  return {
    reference: Mj(t, await i(n), r),
    floating: {
      x: 0,
      y: 0,
      ...await a(n)
    }
  };
};
function Dj(e) {
  return tr(e).direction === "rtl";
}
const Lj = {
  convertOffsetParentRelativeRectToViewportRelativeRect: Tj,
  getDocumentElement: vi,
  getClippingRect: Pj,
  getOffsetParent: R_,
  getElementRects: Nj,
  getClientRects: Cj,
  getDimensions: Ij,
  getScale: so,
  isElement: Gt,
  isRTL: Dj
};
function jj(e, t) {
  let n = null, r;
  const i = vi(e);
  function a() {
    clearTimeout(r), n && n.disconnect(), n = null;
  }
  function o(s, l) {
    s === void 0 && (s = !1), l === void 0 && (l = 1), a();
    const {
      left: c,
      top: u,
      width: d,
      height: p
    } = e.getBoundingClientRect();
    if (s || t(), !d || !p)
      return;
    const f = eo(u), h = eo(i.clientWidth - (c + d)), m = eo(i.clientHeight - (u + p)), y = eo(c), v = {
      rootMargin: -f + "px " + -h + "px " + -m + "px " + -y + "px",
      threshold: Yn(0, vo(1, l)) || 1
    };
    let b = !0;
    function T(O) {
      const S = O[0].intersectionRatio;
      if (S !== l) {
        if (!b)
          return o();
        S ? o(!1, S) : r = setTimeout(() => {
          o(!1, 1e-7);
        }, 100);
      }
      b = !1;
    }
    try {
      n = new IntersectionObserver(T, {
        ...v,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(T, v);
    }
    n.observe(e);
  }
  return o(!0), a;
}
function Uj(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: a = !0,
    elementResize: o = typeof ResizeObserver == "function",
    layoutShift: s = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = r, c = Qm(e), u = i || a ? [...c ? Li(c) : [], ...Li(t)] : [];
  u.forEach((g) => {
    i && g.addEventListener("scroll", n, {
      passive: !0
    }), a && g.addEventListener("resize", n);
  });
  const d = c && s ? jj(c, n) : null;
  let p = -1, f = null;
  o && (f = new ResizeObserver((g) => {
    let [v] = g;
    v && v.target === c && f && (f.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      f && f.observe(t);
    })), n();
  }), c && !l && f.observe(c), f.observe(t));
  let h, m = l ? xa(e) : null;
  l && y();
  function y() {
    const g = xa(e);
    m && (g.x !== m.x || g.y !== m.y || g.width !== m.width || g.height !== m.height) && n(), m = g, h = requestAnimationFrame(y);
  }
  return n(), () => {
    u.forEach((g) => {
      i && g.removeEventListener("scroll", n), a && g.removeEventListener("resize", n);
    }), d && d(), f && f.disconnect(), f = null, l && cancelAnimationFrame(h);
  };
}
const Fj = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: Lj,
    ...n
  }, a = {
    ...i.platform,
    _c: r
  };
  return bj(e, t, {
    ...i,
    platform: a
  });
};
var Tc = typeof document < "u" ? sl : Be;
function ru(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, i;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (r = n; r-- !== 0; )
        if (!ru(e[r], t[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, i[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const a = i[r];
      if (!(a === "_owner" && e.$$typeof) && !ru(e[a], t[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function P_(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Dv(e, t) {
  const n = P_(e);
  return Math.round(t * n) / n;
}
function Lv(e) {
  const t = A.useRef(e);
  return Tc(() => {
    t.current = e;
  }), t;
}
function Bj(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: a,
      floating: o
    } = {},
    transform: s = !0,
    whileElementsMounted: l,
    open: c
  } = e, [u, d] = A.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [p, f] = A.useState(r);
  ru(p, r) || f(r);
  const [h, m] = A.useState(null), [y, g] = A.useState(null), v = A.useCallback((j) => {
    j != S.current && (S.current = j, m(j));
  }, [m]), b = A.useCallback((j) => {
    j !== P.current && (P.current = j, g(j));
  }, [g]), T = a || h, O = o || y, S = A.useRef(null), P = A.useRef(null), M = A.useRef(u), L = Lv(l), k = Lv(i), I = A.useCallback(() => {
    if (!S.current || !P.current)
      return;
    const j = {
      placement: t,
      strategy: n,
      middleware: p
    };
    k.current && (j.platform = k.current), Fj(S.current, P.current, j).then((V) => {
      const W = {
        ...V,
        isPositioned: !0
      };
      B.current && !ru(M.current, W) && (M.current = W, gA.flushSync(() => {
        d(W);
      }));
    });
  }, [p, t, n, k]);
  Tc(() => {
    c === !1 && M.current.isPositioned && (M.current.isPositioned = !1, d((j) => ({
      ...j,
      isPositioned: !1
    })));
  }, [c]);
  const B = A.useRef(!1);
  Tc(() => (B.current = !0, () => {
    B.current = !1;
  }), []), Tc(() => {
    if (T && (S.current = T), O && (P.current = O), T && O) {
      if (L.current)
        return L.current(T, O, I);
      I();
    }
  }, [T, O, I, L]);
  const U = A.useMemo(() => ({
    reference: S,
    floating: P,
    setReference: v,
    setFloating: b
  }), [v, b]), z = A.useMemo(() => ({
    reference: T,
    floating: O
  }), [T, O]), D = A.useMemo(() => {
    const j = {
      position: n,
      left: 0,
      top: 0
    };
    if (!z.floating)
      return j;
    const V = Dv(z.floating, u.x), W = Dv(z.floating, u.y);
    return s ? {
      ...j,
      transform: "translate(" + V + "px, " + W + "px)",
      ...P_(z.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: V,
      top: W
    };
  }, [n, s, z.floating, u.x, u.y]);
  return A.useMemo(() => ({
    ...u,
    update: I,
    refs: U,
    elements: z,
    floatingStyles: D
  }), [u, I, U, z, D]);
}
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var zj = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"], gh = /* @__PURE__ */ zj.join(","), I_ = typeof Element > "u", Ns = I_ ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, iu = !I_ && Element.prototype.getRootNode ? function(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
} : function(e) {
  return e == null ? void 0 : e.ownerDocument;
}, au = function e(t, n) {
  var r;
  n === void 0 && (n = !0);
  var i = t == null || (r = t.getAttribute) === null || r === void 0 ? void 0 : r.call(t, "inert"), a = i === "" || i === "true", o = a || n && t && e(t.parentNode);
  return o;
}, Zj = function(t) {
  var n, r = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "contenteditable");
  return r === "" || r === "true";
}, qj = function(t, n, r) {
  if (au(t))
    return [];
  var i = Array.prototype.slice.apply(t.querySelectorAll(gh));
  return n && Ns.call(t, gh) && i.unshift(t), i = i.filter(r), i;
}, Wj = function e(t, n, r) {
  for (var i = [], a = Array.from(t); a.length; ) {
    var o = a.shift();
    if (!au(o, !1))
      if (o.tagName === "SLOT") {
        var s = o.assignedElements(), l = s.length ? s : o.children, c = e(l, !0, r);
        r.flatten ? i.push.apply(i, c) : i.push({
          scopeParent: o,
          candidates: c
        });
      } else {
        var u = Ns.call(o, gh);
        u && r.filter(o) && (n || !t.includes(o)) && i.push(o);
        var d = o.shadowRoot || // check for an undisclosed shadow
        typeof r.getShadowRoot == "function" && r.getShadowRoot(o), p = !au(d, !1) && (!r.shadowRootFilter || r.shadowRootFilter(o));
        if (d && p) {
          var f = e(d === !0 ? o.children : d.children, !0, r);
          r.flatten ? i.push.apply(i, f) : i.push({
            scopeParent: o,
            candidates: f
          });
        } else
          a.unshift.apply(a, o.children);
      }
  }
  return i;
}, M_ = function(t) {
  return !isNaN(parseInt(t.getAttribute("tabindex"), 10));
}, N_ = function(t) {
  if (!t)
    throw new Error("No node provided");
  return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || Zj(t)) && !M_(t) ? 0 : t.tabIndex;
}, Vj = function(t, n) {
  var r = N_(t);
  return r < 0 && n && !M_(t) ? 0 : r;
}, Hj = function(t, n) {
  return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex;
}, D_ = function(t) {
  return t.tagName === "INPUT";
}, Kj = function(t) {
  return D_(t) && t.type === "hidden";
}, Gj = function(t) {
  var n = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(r) {
    return r.tagName === "SUMMARY";
  });
  return n;
}, Jj = function(t, n) {
  for (var r = 0; r < t.length; r++)
    if (t[r].checked && t[r].form === n)
      return t[r];
}, Yj = function(t) {
  if (!t.name)
    return !0;
  var n = t.form || iu(t), r = function(s) {
    return n.querySelectorAll('input[type="radio"][name="' + s + '"]');
  }, i;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    i = r(window.CSS.escape(t.name));
  else
    try {
      i = r(t.name);
    } catch (o) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", o.message), !1;
    }
  var a = Jj(i, t.form);
  return !a || a === t;
}, Xj = function(t) {
  return D_(t) && t.type === "radio";
}, Qj = function(t) {
  return Xj(t) && !Yj(t);
}, eU = function(t) {
  var n, r = t && iu(t), i = (n = r) === null || n === void 0 ? void 0 : n.host, a = !1;
  if (r && r !== t) {
    var o, s, l;
    for (a = !!((o = i) !== null && o !== void 0 && (s = o.ownerDocument) !== null && s !== void 0 && s.contains(i) || t != null && (l = t.ownerDocument) !== null && l !== void 0 && l.contains(t)); !a && i; ) {
      var c, u, d;
      r = iu(i), i = (c = r) === null || c === void 0 ? void 0 : c.host, a = !!((u = i) !== null && u !== void 0 && (d = u.ownerDocument) !== null && d !== void 0 && d.contains(i));
    }
  }
  return a;
}, jv = function(t) {
  var n = t.getBoundingClientRect(), r = n.width, i = n.height;
  return r === 0 && i === 0;
}, tU = function(t, n) {
  var r = n.displayCheck, i = n.getShadowRoot;
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  var a = Ns.call(t, "details>summary:first-of-type"), o = a ? t.parentElement : t;
  if (Ns.call(o, "details:not([open]) *"))
    return !0;
  if (!r || r === "full" || r === "legacy-full") {
    if (typeof i == "function") {
      for (var s = t; t; ) {
        var l = t.parentElement, c = iu(t);
        if (l && !l.shadowRoot && i(l) === !0)
          return jv(t);
        t.assignedSlot ? t = t.assignedSlot : !l && c !== t.ownerDocument ? t = c.host : t = l;
      }
      t = s;
    }
    if (eU(t))
      return !t.getClientRects().length;
    if (r !== "legacy-full")
      return !0;
  } else if (r === "non-zero-area")
    return jv(t);
  return !1;
}, nU = function(t) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
    for (var n = t.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var r = 0; r < n.children.length; r++) {
          var i = n.children.item(r);
          if (i.tagName === "LEGEND")
            return Ns.call(n, "fieldset[disabled] *") ? !0 : !i.contains(t);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, rU = function(t, n) {
  return !(n.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  au(n) || Kj(n) || tU(n, t) || // For a details element with a summary, the summary element gets the focus
  Gj(n) || nU(n));
}, Uv = function(t, n) {
  return !(Qj(n) || N_(n) < 0 || !rU(t, n));
}, iU = function(t) {
  var n = parseInt(t.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, aU = function e(t) {
  var n = [], r = [];
  return t.forEach(function(i, a) {
    var o = !!i.scopeParent, s = o ? i.scopeParent : i, l = Vj(s, o), c = o ? e(i.candidates) : s;
    l === 0 ? o ? n.push.apply(n, c) : n.push(s) : r.push({
      documentOrder: a,
      tabIndex: l,
      item: i,
      isScope: o,
      content: c
    });
  }), r.sort(Hj).reduce(function(i, a) {
    return a.isScope ? i.push.apply(i, a.content) : i.push(a.content), i;
  }, []).concat(n);
}, eg = function(t, n) {
  n = n || {};
  var r;
  return n.getShadowRoot ? r = Wj([t], n.includeContainer, {
    filter: Uv.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: iU
  }) : r = qj(t, n.includeContainer, Uv.bind(null, n)), aU(r);
};
const tg = "ArrowUp", Dd = "ArrowDown", bo = "ArrowLeft", gl = "ArrowRight";
function tc(e, t, n) {
  return Math.floor(e / t) !== n;
}
function ks(e, t) {
  return t < 0 || t >= e.current.length;
}
function cp(e, t) {
  return kn(e, {
    disabledIndices: t
  });
}
function Fv(e, t) {
  return kn(e, {
    decrement: !0,
    startingIndex: e.current.length,
    disabledIndices: t
  });
}
function kn(e, t) {
  let {
    startingIndex: n = -1,
    decrement: r = !1,
    disabledIndices: i,
    amount: a = 1
  } = t === void 0 ? {} : t;
  const o = e.current;
  let s = n;
  do {
    var l, c;
    s = s + (r ? -a : a);
  } while (s >= 0 && s <= o.length - 1 && (i ? i.includes(s) : o[s] == null || (l = o[s]) != null && l.hasAttribute("disabled") || ((c = o[s]) == null ? void 0 : c.getAttribute("aria-disabled")) === "true"));
  return s;
}
function oU(e, t) {
  let {
    event: n,
    orientation: r,
    loop: i,
    cols: a,
    disabledIndices: o,
    minIndex: s,
    maxIndex: l,
    prevIndex: c,
    stopEvent: u = !1
  } = t, d = c;
  if (n.key === tg) {
    if (u && wn(n), c === -1)
      d = l;
    else if (d = kn(e, {
      startingIndex: d,
      amount: a,
      decrement: !0,
      disabledIndices: o
    }), i && (c - a < s || d < 0)) {
      const p = c % a, f = l % a, h = l - (f - p);
      f === p ? d = l : d = f > p ? h : h - a;
    }
    ks(e, d) && (d = c);
  }
  if (n.key === Dd && (u && wn(n), c === -1 ? d = s : (d = kn(e, {
    startingIndex: c,
    amount: a,
    disabledIndices: o
  }), i && c + a > l && (d = kn(e, {
    startingIndex: c % a - a,
    amount: a,
    disabledIndices: o
  }))), ks(e, d) && (d = c)), r === "both") {
    const p = eo(c / a);
    n.key === gl && (u && wn(n), c % a !== a - 1 ? (d = kn(e, {
      startingIndex: c,
      disabledIndices: o
    }), i && tc(d, a, p) && (d = kn(e, {
      startingIndex: c - c % a - 1,
      disabledIndices: o
    }))) : i && (d = kn(e, {
      startingIndex: c - c % a - 1,
      disabledIndices: o
    })), tc(d, a, p) && (d = c)), n.key === bo && (u && wn(n), c % a !== 0 ? (d = kn(e, {
      startingIndex: c,
      disabledIndices: o,
      decrement: !0
    }), i && tc(d, a, p) && (d = kn(e, {
      startingIndex: c + (a - c % a),
      decrement: !0,
      disabledIndices: o
    }))) : i && (d = kn(e, {
      startingIndex: c + (a - c % a),
      decrement: !0,
      disabledIndices: o
    })), tc(d, a, p) && (d = c));
    const f = eo(l / a) === p;
    ks(e, d) && (i && f ? d = n.key === bo ? l : kn(e, {
      startingIndex: c - c % a - 1,
      disabledIndices: o
    }) : d = c);
  }
  return d;
}
let Bv = 0;
function ti(e, t) {
  t === void 0 && (t = {});
  const {
    preventScroll: n = !1,
    cancelPrevious: r = !0,
    sync: i = !1
  } = t;
  r && cancelAnimationFrame(Bv);
  const a = () => e == null ? void 0 : e.focus({
    preventScroll: n
  });
  i ? a() : Bv = requestAnimationFrame(a);
}
var un = typeof document < "u" ? sl : Be;
function ou() {
  return ou = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, ou.apply(this, arguments);
}
let up = !1, sU = 0;
const zv = () => "floating-ui-" + sU++;
function lU() {
  const [e, t] = A.useState(() => up ? zv() : void 0);
  return un(() => {
    e == null && t(zv());
  }, []), A.useEffect(() => {
    up || (up = !0);
  }, []), e;
}
const cU = A[/* @__PURE__ */ "useId".toString()], ng = cU || lU;
function uU() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, n) {
      var r;
      (r = e.get(t)) == null || r.forEach((i) => i(n));
    },
    on(t, n) {
      e.set(t, [...e.get(t) || [], n]);
    },
    off(t, n) {
      var r;
      e.set(t, ((r = e.get(t)) == null ? void 0 : r.filter((i) => i !== n)) || []);
    }
  };
}
const dU = /* @__PURE__ */ A.createContext(null), fU = /* @__PURE__ */ A.createContext(null), L_ = () => {
  var e;
  return ((e = A.useContext(dU)) == null ? void 0 : e.id) || null;
}, Ld = () => A.useContext(fU);
function Ds(e) {
  return "data-floating-ui-" + e;
}
function ji(e) {
  const t = Xe(e);
  return un(() => {
    t.current = e;
  }), t;
}
function pU(e, t) {
  var n;
  let r = [], i = (n = e.find((a) => a.id === t)) == null ? void 0 : n.parentId;
  for (; i; ) {
    const a = e.find((o) => o.id === i);
    i = a == null ? void 0 : a.parentId, a && (r = r.concat(a));
  }
  return r;
}
function lo(e, t) {
  let n = e.filter((i) => {
    var a;
    return i.parentId === t && ((a = i.context) == null ? void 0 : a.open);
  }), r = n;
  for (; r.length; )
    r = e.filter((i) => {
      var a;
      return (a = r) == null ? void 0 : a.some((o) => {
        var s;
        return i.parentId === o.id && ((s = i.context) == null ? void 0 : s.open);
      });
    }), n = n.concat(r);
  return n;
}
function hU(e, t) {
  let n, r = -1;
  function i(a, o) {
    o > r && (n = a, r = o), lo(e, a).forEach((l) => {
      i(l.id, o + 1);
    });
  }
  return i(t, 0), e.find((a) => a.id === n);
}
let za = /* @__PURE__ */ new WeakMap(), nc = /* @__PURE__ */ new WeakSet(), rc = {}, dp = 0;
const mU = () => typeof HTMLElement < "u" && "inert" in HTMLElement.prototype, j_ = (e) => e && (e.host || j_(e.parentNode)), gU = (e, t) => t.map((n) => {
  if (e.contains(n))
    return n;
  const r = j_(n);
  return e.contains(r) ? r : null;
}).filter((n) => n != null);
function yU(e, t, n, r) {
  const i = "data-floating-ui-inert", a = r ? "inert" : n ? "aria-hidden" : null, o = gU(t, e), s = /* @__PURE__ */ new Set(), l = new Set(o), c = [];
  rc[i] || (rc[i] = /* @__PURE__ */ new WeakMap());
  const u = rc[i];
  o.forEach(d), p(t), s.clear();
  function d(f) {
    !f || s.has(f) || (s.add(f), f.parentNode && d(f.parentNode));
  }
  function p(f) {
    !f || l.has(f) || Array.prototype.forEach.call(f.children, (h) => {
      if (s.has(h))
        p(h);
      else {
        const m = a ? h.getAttribute(a) : null, y = m !== null && m !== "false", g = (za.get(h) || 0) + 1, v = (u.get(h) || 0) + 1;
        za.set(h, g), u.set(h, v), c.push(h), g === 1 && y && nc.add(h), v === 1 && h.setAttribute(i, ""), !y && a && h.setAttribute(a, "true");
      }
    });
  }
  return dp++, () => {
    c.forEach((f) => {
      const h = (za.get(f) || 0) - 1, m = (u.get(f) || 0) - 1;
      za.set(f, h), u.set(f, m), h || (!nc.has(f) && a && f.removeAttribute(a), nc.delete(f)), m || f.removeAttribute(i);
    }), dp--, dp || (za = /* @__PURE__ */ new WeakMap(), za = /* @__PURE__ */ new WeakMap(), nc = /* @__PURE__ */ new WeakSet(), rc = {});
  };
}
function Zv(e, t, n) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = mr(e[0]).body;
  return yU(e.concat(Array.from(r.querySelectorAll("[aria-live]"))), r, t, n);
}
const rg = () => ({
  getShadowRoot: !0,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function U_(e, t) {
  const n = eg(e, rg());
  t === "prev" && n.reverse();
  const r = n.indexOf(Pi(mr(e)));
  return n.slice(r + 1)[0];
}
function F_() {
  return U_(document.body, "next");
}
function B_() {
  return U_(document.body, "prev");
}
function Ts(e, t) {
  const n = t || e.currentTarget, r = e.relatedTarget;
  return !r || !qn(n, r);
}
function vU(e) {
  eg(e, rg()).forEach((n) => {
    n.dataset.tabindex = n.getAttribute("tabindex") || "", n.setAttribute("tabindex", "-1");
  });
}
function bU(e) {
  e.querySelectorAll("[data-tabindex]").forEach((n) => {
    const r = n.dataset.tabindex;
    delete n.dataset.tabindex, r ? n.setAttribute("tabindex", r) : n.removeAttribute("tabindex");
  });
}
const ig = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
let wU;
function qv(e) {
  e.key === "Tab" && (e.target, clearTimeout(wU));
}
const su = /* @__PURE__ */ A.forwardRef(function(t, n) {
  const [r, i] = A.useState();
  un(() => (S_() && i("button"), document.addEventListener("keydown", qv), () => {
    document.removeEventListener("keydown", qv);
  }), []);
  const a = {
    ref: n,
    tabIndex: 0,
    // Role is only for VoiceOver
    role: r,
    "aria-hidden": r ? void 0 : !0,
    [Ds("focus-guard")]: "",
    style: ig
  };
  return /* @__PURE__ */ A.createElement("span", ou({}, t, a));
}), z_ = /* @__PURE__ */ A.createContext(null);
function xU(e) {
  let {
    id: t,
    root: n
  } = e === void 0 ? {} : e;
  const [r, i] = A.useState(null), a = ng(), o = Z_(), s = A.useMemo(() => ({
    id: t,
    root: n,
    portalContext: o,
    uniqueId: a
  }), [t, n, o, a]), l = A.useRef();
  return un(() => () => {
    r == null || r.remove();
  }, [r, s]), un(() => {
    if (l.current === s)
      return;
    l.current = s;
    const {
      id: c,
      root: u,
      portalContext: d,
      uniqueId: p
    } = s, f = c ? document.getElementById(c) : null, h = Ds("portal");
    if (f) {
      const m = document.createElement("div");
      m.id = p, m.setAttribute(h, ""), f.appendChild(m), i(m);
    } else {
      let m = u || (d == null ? void 0 : d.portalNode);
      m && !Gt(m) && (m = m.current), m = m || document.body;
      let y = null;
      c && (y = document.createElement("div"), y.id = c, m.appendChild(y));
      const g = document.createElement("div");
      g.id = p, g.setAttribute(h, ""), m = y || m, m.appendChild(g), i(g);
    }
  }, [s]), r;
}
function _U(e) {
  let {
    children: t,
    id: n,
    root: r = null,
    preserveTabOrder: i = !0
  } = e;
  const a = xU({
    id: n,
    root: r
  }), [o, s] = A.useState(null), l = A.useRef(null), c = A.useRef(null), u = A.useRef(null), d = A.useRef(null), p = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!o && // Guards are only for non-modal focus management.
    !o.modal && // Don't render if unmount is transitioning.
    o.open && i && !!(r || a)
  );
  return A.useEffect(() => {
    if (!a || !i || o != null && o.modal)
      return;
    function f(h) {
      a && Ts(h) && (h.type === "focusin" ? bU : vU)(a);
    }
    return a.addEventListener("focusin", f, !0), a.addEventListener("focusout", f, !0), () => {
      a.removeEventListener("focusin", f, !0), a.removeEventListener("focusout", f, !0);
    };
  }, [a, i, o == null ? void 0 : o.modal]), /* @__PURE__ */ A.createElement(z_.Provider, {
    value: A.useMemo(() => ({
      preserveTabOrder: i,
      beforeOutsideRef: l,
      afterOutsideRef: c,
      beforeInsideRef: u,
      afterInsideRef: d,
      portalNode: a,
      setFocusManagerState: s
    }), [i, a])
  }, p && a && /* @__PURE__ */ A.createElement(su, {
    "data-type": "outside",
    ref: l,
    onFocus: (f) => {
      if (Ts(f, a)) {
        var h;
        (h = u.current) == null || h.focus();
      } else {
        const m = B_() || (o == null ? void 0 : o.refs.domReference.current);
        m == null || m.focus();
      }
    }
  }), p && a && /* @__PURE__ */ A.createElement("span", {
    "aria-owns": a.id,
    style: ig
  }), a && /* @__PURE__ */ yA(t, a), p && a && /* @__PURE__ */ A.createElement(su, {
    "data-type": "outside",
    ref: c,
    onFocus: (f) => {
      if (Ts(f, a)) {
        var h;
        (h = d.current) == null || h.focus();
      } else {
        const m = F_() || (o == null ? void 0 : o.refs.domReference.current);
        m == null || m.focus(), o != null && o.closeOnFocusOut && (o == null || o.onOpenChange(!1, f.nativeEvent));
      }
    }
  }));
}
const Z_ = () => A.useContext(z_), SU = /* @__PURE__ */ A.forwardRef(function(t, n) {
  return /* @__PURE__ */ A.createElement("button", ou({}, t, {
    type: "button",
    ref: n,
    tabIndex: -1,
    style: ig
  }));
});
function EU(e) {
  const {
    context: t,
    children: n,
    disabled: r = !1,
    order: i = ["content"],
    guards: a = !0,
    initialFocus: o = 0,
    returnFocus: s = !0,
    modal: l = !0,
    visuallyHiddenDismiss: c = !1,
    closeOnFocusOut: u = !0
  } = e, {
    open: d,
    refs: p,
    nodeId: f,
    onOpenChange: h,
    events: m,
    dataRef: y,
    elements: {
      domReference: g,
      floating: v
    }
  } = t, b = mU() ? a : !0, T = ji(i), O = ji(o), S = ji(s), P = Ld(), M = Z_(), L = typeof o == "number" && o < 0, k = A.useRef(null), I = A.useRef(null), B = A.useRef(!1), U = A.useRef(null), z = A.useRef(!1), D = M != null, j = g && g.getAttribute("role") === "combobox" && k_(g) && L, V = A.useCallback(function(ie) {
    return ie === void 0 && (ie = v), ie ? eg(ie, rg()) : [];
  }, [v]), W = A.useCallback((ie) => {
    const ve = V(ie);
    return T.current.map((E) => g && E === "reference" ? g : v && E === "floating" ? v : ve).filter(Boolean).flat();
  }, [g, v, T, V]);
  A.useEffect(() => {
    if (r || !l)
      return;
    function ie(E) {
      if (E.key === "Tab") {
        qn(v, Pi(mr(v))) && V().length === 0 && !j && wn(E);
        const ke = W(), Ze = E_(E);
        T.current[0] === "reference" && Ze === g && (wn(E), E.shiftKey ? ti(ke[ke.length - 1]) : ti(ke[1])), T.current[1] === "floating" && Ze === v && E.shiftKey && (wn(E), ti(ke[0]));
      }
    }
    const ve = mr(v);
    return ve.addEventListener("keydown", ie), () => {
      ve.removeEventListener("keydown", ie);
    };
  }, [r, g, v, l, T, p, j, V, W]), A.useEffect(() => {
    if (r || !u)
      return;
    function ie() {
      z.current = !0, setTimeout(() => {
        z.current = !1;
      });
    }
    function ve(E) {
      const ke = E.relatedTarget;
      queueMicrotask(() => {
        const Ze = !(qn(g, ke) || qn(v, ke) || qn(ke, v) || qn(M == null ? void 0 : M.portalNode, ke) || ke != null && ke.hasAttribute(Ds("focus-guard")) || P && (lo(P.nodesRef.current, f).find((Pe) => {
          var qe, rt;
          return qn((qe = Pe.context) == null ? void 0 : qe.elements.floating, ke) || qn((rt = Pe.context) == null ? void 0 : rt.elements.domReference, ke);
        }) || pU(P.nodesRef.current, f).find((Pe) => {
          var qe, rt;
          return ((qe = Pe.context) == null ? void 0 : qe.elements.floating) === ke || ((rt = Pe.context) == null ? void 0 : rt.elements.domReference) === ke;
        })));
        ke && Ze && !z.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        ke !== U.current && (B.current = !0, h(!1, E));
      });
    }
    if (v && An(g))
      return g.addEventListener("focusout", ve), g.addEventListener("pointerdown", ie), !l && v.addEventListener("focusout", ve), () => {
        g.removeEventListener("focusout", ve), g.removeEventListener("pointerdown", ie), !l && v.removeEventListener("focusout", ve);
      };
  }, [r, g, v, l, f, P, M, h, u]), A.useEffect(() => {
    var ie;
    if (r)
      return;
    const ve = Array.from((M == null || (ie = M.portalNode) == null ? void 0 : ie.querySelectorAll("[" + Ds("portal") + "]")) || []);
    if (v) {
      const E = [v, ...ve, k.current, I.current, T.current.includes("reference") || j ? g : null].filter((Ze) => Ze != null), ke = l ? Zv(E, b, !b) : Zv(E);
      return () => {
        ke();
      };
    }
  }, [r, g, v, l, T, M, j, b]), un(() => {
    if (r || !v)
      return;
    const ie = mr(v), ve = Pi(ie);
    queueMicrotask(() => {
      const E = W(v), ke = O.current, Ze = (typeof ke == "number" ? E[ke] : ke.current) || v, Pe = qn(v, ve);
      !L && !Pe && d && ti(Ze, {
        preventScroll: Ze === v
      });
    });
  }, [r, d, v, L, W, O]), un(() => {
    if (r || !v)
      return;
    let ie = !1;
    const ve = mr(v), E = Pi(ve), ke = y.current;
    U.current = E;
    function Ze(Pe) {
      if (Pe.type === "escapeKey" && p.domReference.current && (U.current = p.domReference.current), ["referencePress", "escapeKey"].includes(Pe.type))
        return;
      const qe = Pe.data.returnFocus;
      typeof qe == "object" ? (B.current = !1, ie = qe.preventScroll) : B.current = !qe;
    }
    return m.on("dismiss", Ze), () => {
      m.off("dismiss", Ze);
      const Pe = Pi(ve);
      (qn(v, Pe) || P && lo(P.nodesRef.current, f).some((rt) => {
        var Ve;
        return qn((Ve = rt.context) == null ? void 0 : Ve.elements.floating, Pe);
      }) || ke.openEvent && ["click", "mousedown"].includes(ke.openEvent.type)) && p.domReference.current && (U.current = p.domReference.current), // eslint-disable-next-line react-hooks/exhaustive-deps
      S.current && An(U.current) && !B.current && ti(U.current, {
        // When dismissing nested floating elements, by the time the rAF has
        // executed, the menus will all have been unmounted. When they try
        // to get focused, the calls get ignored  leaving the root
        // reference focused as desired.
        cancelPrevious: !1,
        preventScroll: ie
      });
    };
  }, [r, v, S, y, p, m, P, f]), un(() => {
    if (!(r || !M))
      return M.setFocusManagerState({
        modal: l,
        closeOnFocusOut: u,
        open: d,
        onOpenChange: h,
        refs: p
      }), () => {
        M.setFocusManagerState(null);
      };
  }, [r, M, l, d, h, p, u]), un(() => {
    if (!r && v && typeof MutationObserver == "function" && !L) {
      const ie = () => {
        const E = v.getAttribute("tabindex");
        T.current.includes("floating") || Pi(mr(v)) !== p.domReference.current && V().length === 0 ? E !== "0" && v.setAttribute("tabindex", "0") : E !== "-1" && v.setAttribute("tabindex", "-1");
      };
      ie();
      const ve = new MutationObserver(ie);
      return ve.observe(v, {
        childList: !0,
        subtree: !0,
        attributes: !0
      }), () => {
        ve.disconnect();
      };
    }
  }, [r, v, p, T, V, L]);
  function de(ie) {
    return r || !c || !l ? null : /* @__PURE__ */ A.createElement(SU, {
      ref: ie === "start" ? k : I,
      onClick: (ve) => h(!1, ve.nativeEvent)
    }, typeof c == "string" ? c : "Dismiss");
  }
  const x = !r && b && !j && (D || l);
  return /* @__PURE__ */ A.createElement(A.Fragment, null, x && /* @__PURE__ */ A.createElement(su, {
    "data-type": "inside",
    ref: M == null ? void 0 : M.beforeInsideRef,
    onFocus: (ie) => {
      if (l) {
        const E = W();
        ti(i[0] === "reference" ? E[0] : E[E.length - 1]);
      } else if (M != null && M.preserveTabOrder && M.portalNode)
        if (B.current = !1, Ts(ie, M.portalNode)) {
          const E = F_() || g;
          E == null || E.focus();
        } else {
          var ve;
          (ve = M.beforeOutsideRef.current) == null || ve.focus();
        }
    }
  }), !j && de("start"), n, de("end"), x && /* @__PURE__ */ A.createElement(su, {
    "data-type": "inside",
    ref: M == null ? void 0 : M.afterInsideRef,
    onFocus: (ie) => {
      if (l)
        ti(W()[0]);
      else if (M != null && M.preserveTabOrder && M.portalNode)
        if (u && (B.current = !0), Ts(ie, M.portalNode)) {
          const E = B_() || g;
          E == null || E.focus();
        } else {
          var ve;
          (ve = M.afterOutsideRef.current) == null || ve.focus();
        }
    }
  }));
}
function Wv(e) {
  return An(e.target) && e.target.tagName === "BUTTON";
}
function Vv(e) {
  return k_(e);
}
function kU(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    dataRef: i,
    elements: {
      domReference: a
    }
  } = e, {
    enabled: o = !0,
    event: s = "click",
    toggle: l = !0,
    ignoreMouse: c = !1,
    keyboardHandlers: u = !0
  } = t, d = A.useRef(), p = A.useRef(!1);
  return A.useMemo(() => o ? {
    reference: {
      onPointerDown(f) {
        d.current = f.pointerType;
      },
      onMouseDown(f) {
        f.button === 0 && (Pv(d.current, !0) && c || s !== "click" && (n && l && (!i.current.openEvent || i.current.openEvent.type === "mousedown") ? r(!1, f.nativeEvent) : (f.preventDefault(), r(!0, f.nativeEvent))));
      },
      onClick(f) {
        if (s === "mousedown" && d.current) {
          d.current = void 0;
          return;
        }
        Pv(d.current, !0) && c || (n && l && (!i.current.openEvent || i.current.openEvent.type === "click") ? r(!1, f.nativeEvent) : r(!0, f.nativeEvent));
      },
      onKeyDown(f) {
        d.current = void 0, !(f.defaultPrevented || !u || Wv(f)) && (f.key === " " && !Vv(a) && (f.preventDefault(), p.current = !0), f.key === "Enter" && r(!(n && l), f.nativeEvent));
      },
      onKeyUp(f) {
        f.defaultPrevented || !u || Wv(f) || Vv(a) || f.key === " " && p.current && (p.current = !1, r(!(n && l), f.nativeEvent));
      }
    }
  } : {}, [o, i, s, c, u, a, l, n, r]);
}
const TU = A[/* @__PURE__ */ "useInsertionEffect".toString()], CU = TU || ((e) => e());
function Ui(e) {
  const t = A.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return CU(() => {
    t.current = e;
  }), A.useCallback(function() {
    for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
      r[i] = arguments[i];
    return t.current == null ? void 0 : t.current(...r);
  }, []);
}
const OU = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, AU = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, $U = (e) => {
  var t, n;
  return {
    escapeKeyBubbles: typeof e == "boolean" ? e : (t = e == null ? void 0 : e.escapeKey) != null ? t : !1,
    outsidePressBubbles: typeof e == "boolean" ? e : (n = e == null ? void 0 : e.outsidePress) != null ? n : !0
  };
};
function RU(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: r,
    events: i,
    nodeId: a,
    elements: {
      reference: o,
      domReference: s,
      floating: l
    },
    dataRef: c
  } = e, {
    enabled: u = !0,
    escapeKey: d = !0,
    outsidePress: p = !0,
    outsidePressEvent: f = "pointerdown",
    referencePress: h = !1,
    referencePressEvent: m = "pointerdown",
    ancestorScroll: y = !1,
    bubbles: g
  } = t, v = Ld(), b = L_() != null, T = Ui(typeof p == "function" ? p : () => !1), O = typeof p == "function" ? T : p, S = A.useRef(!1), {
    escapeKeyBubbles: P,
    outsidePressBubbles: M
  } = $U(g), L = Ui((I) => {
    if (!n || !u || !d || I.key !== "Escape")
      return;
    const B = v ? lo(v.nodesRef.current, a) : [];
    if (!P && (I.stopPropagation(), B.length > 0)) {
      let U = !0;
      if (B.forEach((z) => {
        var D;
        if ((D = z.context) != null && D.open && !z.context.dataRef.current.__escapeKeyBubbles) {
          U = !1;
          return;
        }
      }), !U)
        return;
    }
    i.emit("dismiss", {
      type: "escapeKey",
      data: {
        returnFocus: {
          preventScroll: !1
        }
      }
    }), r(!1, gj(I) ? I.nativeEvent : I);
  }), k = Ui((I) => {
    const B = S.current;
    if (S.current = !1, B || typeof O == "function" && !O(I))
      return;
    const U = E_(I), z = "[" + Ds("inert") + "]", D = mr(l).querySelectorAll(z);
    let j = Gt(U) ? U : null;
    for (; j && !ml(j); ) {
      const de = wa(j);
      if (de === mr(l).body || !Gt(de))
        break;
      j = de;
    }
    if (D.length && Gt(U) && !yj(U) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !qn(U, l) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(D).every((de) => !qn(j, de)))
      return;
    if (An(U) && l) {
      const de = U.clientWidth > 0 && U.scrollWidth > U.clientWidth, x = U.clientHeight > 0 && U.scrollHeight > U.clientHeight;
      let ie = x && I.offsetX > U.clientWidth;
      if (x && tr(U).direction === "rtl" && (ie = I.offsetX <= U.offsetWidth - U.clientWidth), ie || de && I.offsetY > U.clientHeight)
        return;
    }
    const V = v && lo(v.nodesRef.current, a).some((de) => {
      var x;
      return lp(I, (x = de.context) == null ? void 0 : x.elements.floating);
    });
    if (lp(I, l) || lp(I, s) || V)
      return;
    const W = v ? lo(v.nodesRef.current, a) : [];
    if (W.length > 0) {
      let de = !0;
      if (W.forEach((x) => {
        var ie;
        if ((ie = x.context) != null && ie.open && !x.context.dataRef.current.__outsidePressBubbles) {
          de = !1;
          return;
        }
      }), !de)
        return;
    }
    i.emit("dismiss", {
      type: "outsidePress",
      data: {
        returnFocus: b ? {
          preventScroll: !0
        } : x_(I) || __(I)
      }
    }), r(!1, I);
  });
  return A.useEffect(() => {
    if (!n || !u)
      return;
    c.current.__escapeKeyBubbles = P, c.current.__outsidePressBubbles = M;
    function I(z) {
      r(!1, z);
    }
    const B = mr(l);
    d && B.addEventListener("keydown", L), O && B.addEventListener(f, k);
    let U = [];
    return y && (Gt(s) && (U = Li(s)), Gt(l) && (U = U.concat(Li(l))), !Gt(o) && o && o.contextElement && (U = U.concat(Li(o.contextElement)))), U = U.filter((z) => {
      var D;
      return z !== ((D = B.defaultView) == null ? void 0 : D.visualViewport);
    }), U.forEach((z) => {
      z.addEventListener("scroll", I, {
        passive: !0
      });
    }), () => {
      d && B.removeEventListener("keydown", L), O && B.removeEventListener(f, k), U.forEach((z) => {
        z.removeEventListener("scroll", I);
      });
    };
  }, [c, l, s, o, d, O, f, n, r, y, u, P, M, L, k]), A.useEffect(() => {
    S.current = !1;
  }, [O, f]), A.useMemo(() => u ? {
    reference: {
      onKeyDown: L,
      [OU[m]]: (I) => {
        h && (i.emit("dismiss", {
          type: "referencePress",
          data: {
            returnFocus: !1
          }
        }), r(!1, I.nativeEvent));
      }
    },
    floating: {
      onKeyDown: L,
      [AU[f]]: () => {
        S.current = !0;
      }
    }
  } : {}, [u, i, h, f, m, r, L]);
}
let yh;
process.env.NODE_ENV !== "production" && (yh = /* @__PURE__ */ new Set());
function PU(e) {
  var t;
  e === void 0 && (e = {});
  const {
    open: n = !1,
    onOpenChange: r,
    nodeId: i
  } = e;
  if (process.env.NODE_ENV !== "production") {
    var a;
    const P = "Floating UI: Cannot pass a virtual element to the `elements.reference` option, as it must be a real DOM element. Use `refs.setPositionReference` instead.";
    if ((a = e.elements) != null && a.reference && !Gt(e.elements.reference)) {
      var o;
      if (!((o = yh) != null && o.has(P))) {
        var s;
        (s = yh) == null || s.add(P), console.error(P);
      }
    }
  }
  const [l, c] = A.useState(null), u = ((t = e.elements) == null ? void 0 : t.reference) || l, d = Bj(e), p = Ld(), f = Ui((P, M) => {
    P && (m.current.openEvent = M), r == null || r(P, M);
  }), h = A.useRef(null), m = A.useRef({}), y = A.useState(() => uU())[0], g = ng(), v = A.useCallback((P) => {
    const M = Gt(P) ? {
      getBoundingClientRect: () => P.getBoundingClientRect(),
      contextElement: P
    } : P;
    d.refs.setReference(M);
  }, [d.refs]), b = A.useCallback((P) => {
    (Gt(P) || P === null) && (h.current = P, c(P)), (Gt(d.refs.reference.current) || d.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    P !== null && !Gt(P)) && d.refs.setReference(P);
  }, [d.refs]), T = A.useMemo(() => ({
    ...d.refs,
    setReference: b,
    setPositionReference: v,
    domReference: h
  }), [d.refs, b, v]), O = A.useMemo(() => ({
    ...d.elements,
    domReference: u
  }), [d.elements, u]), S = A.useMemo(() => ({
    ...d,
    refs: T,
    elements: O,
    dataRef: m,
    nodeId: i,
    floatingId: g,
    events: y,
    open: n,
    onOpenChange: f
  }), [d, i, g, y, n, f, T, O]);
  return un(() => {
    const P = p == null ? void 0 : p.nodesRef.current.find((M) => M.id === i);
    P && (P.context = S);
  }), A.useMemo(() => ({
    ...d,
    context: S,
    refs: T,
    elements: O
  }), [d, T, O, S]);
}
function fp(e, t, n) {
  const r = /* @__PURE__ */ new Map();
  return {
    ...n === "floating" && {
      tabIndex: -1
    },
    ...e,
    ...t.map((i) => i ? i[n] : null).concat(e).reduce((i, a) => (a && Object.entries(a).forEach((o) => {
      let [s, l] = o;
      if (s.indexOf("on") === 0) {
        if (r.has(s) || r.set(s, []), typeof l == "function") {
          var c;
          (c = r.get(s)) == null || c.push(l), i[s] = function() {
            for (var u, d = arguments.length, p = new Array(d), f = 0; f < d; f++)
              p[f] = arguments[f];
            return (u = r.get(s)) == null ? void 0 : u.map((h) => h(...p)).find((h) => h !== void 0);
          };
        }
      } else
        i[s] = l;
    }), i), {})
  };
}
function IU(e) {
  e === void 0 && (e = []);
  const t = e, n = A.useCallback(
    (a) => fp(a, e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), r = A.useCallback(
    (a) => fp(a, e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), i = A.useCallback(
    (a) => fp(a, e, "item"),
    // Granularly check for `item` changes, because the `getItemProps` getter
    // should be as referentially stable as possible since it may be passed as
    // a prop to many components. All `item` key values must therefore be
    // memoized.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e.map((a) => a == null ? void 0 : a.item)
  );
  return A.useMemo(() => ({
    getReferenceProps: n,
    getFloatingProps: r,
    getItemProps: i
  }), [n, r, i]);
}
let Hv = !1;
function jd(e, t, n) {
  switch (e) {
    case "vertical":
      return t;
    case "horizontal":
      return n;
    default:
      return t || n;
  }
}
function Kv(e, t) {
  return jd(t, e === tg || e === Dd, e === bo || e === gl);
}
function pp(e, t, n) {
  return jd(t, e === Dd, n ? e === bo : e === gl) || e === "Enter" || e == " " || e === "";
}
function MU(e, t, n) {
  return jd(t, n ? e === bo : e === gl, e === Dd);
}
function Gv(e, t, n) {
  return jd(t, n ? e === gl : e === bo, e === tg);
}
function NU(e, t) {
  const {
    open: n,
    onOpenChange: r,
    refs: i,
    elements: {
      domReference: a,
      floating: o
    }
  } = e, {
    listRef: s,
    activeIndex: l,
    onNavigate: c = () => {
    },
    enabled: u = !0,
    selectedIndex: d = null,
    allowEscape: p = !1,
    loop: f = !1,
    nested: h = !1,
    rtl: m = !1,
    virtual: y = !1,
    focusItemOnOpen: g = "auto",
    focusItemOnHover: v = !0,
    openOnArrowKeyDown: b = !0,
    disabledIndices: T = void 0,
    orientation: O = "vertical",
    cols: S = 1,
    scrollItemIntoView: P = !0,
    virtualItemRef: M
  } = t;
  process.env.NODE_ENV !== "production" && (p && (f || console.warn(["Floating UI: `useListNavigation` looping must be enabled to allow", "escaping."].join(" ")), y || console.warn(["Floating UI: `useListNavigation` must be virtual to allow", "escaping."].join(" "))), O === "vertical" && S > 1 && console.warn(["Floating UI: In grid list navigation mode (`cols` > 1), the", '`orientation` should be either "horizontal" or "both".'].join(" ")));
  const L = L_(), k = Ld(), I = Ui(c), B = A.useRef(g), U = A.useRef(d ?? -1), z = A.useRef(null), D = A.useRef(!0), j = A.useRef(I), V = A.useRef(!!o), W = A.useRef(!1), de = A.useRef(!1), x = ji(T), ie = ji(n), ve = ji(P), [E, ke] = A.useState(), [Ze, Pe] = A.useState(), qe = Ui(function(be, he, Oe) {
    Oe === void 0 && (Oe = !1);
    const we = be.current[he.current];
    we && (y ? (ke(we.id), k == null || k.events.emit("virtualfocus", we), M && (M.current = we)) : ti(we, {
      preventScroll: !0,
      // Mac Safari does not move the virtual cursor unless the focus call
      // is sync. However, for the very first focus call, we need to wait
      // for the position to be ready in order to prevent unwanted
      // scrolling. This means the virtual cursor will not move to the first
      // item when first opening the floating element, but will on
      // subsequent calls. `preventScroll` is supported in modern Safari,
      // so we can use that instead.
      // iOS Safari must be async or the first item will not be focused.
      sync: mj() && S_() ? Hv || W.current : !1
    }), requestAnimationFrame(() => {
      const Fe = ve.current;
      Fe && we && (Oe || !D.current) && (we.scrollIntoView == null || we.scrollIntoView(typeof Fe == "boolean" ? {
        block: "nearest",
        inline: "nearest"
      } : Fe));
    }));
  });
  un(() => {
    document.createElement("div").focus({
      get preventScroll() {
        return Hv = !0, !1;
      }
    });
  }, []), un(() => {
    u && (n && o ? B.current && d != null && (de.current = !0, I(d)) : V.current && (U.current = -1, j.current(null)));
  }, [u, n, o, d, I]), un(() => {
    if (u && n && o)
      if (l == null) {
        if (W.current = !1, d != null)
          return;
        if (V.current && (U.current = -1, qe(s, U)), !V.current && B.current && (z.current != null || B.current === !0 && z.current == null)) {
          let be = 0;
          const he = () => {
            s.current[0] == null ? (be < 2 && (be ? requestAnimationFrame : queueMicrotask)(he), be++) : (U.current = z.current == null || pp(z.current, O, m) || h ? cp(s, x.current) : Fv(s, x.current), z.current = null, I(U.current));
          };
          he();
        }
      } else
        ks(s, l) || (U.current = l, qe(s, U, de.current), de.current = !1);
  }, [u, n, o, l, d, h, s, O, m, I, qe, x]), un(() => {
    var be, he;
    if (!u || o || !k || y || !V.current)
      return;
    const Oe = k.nodesRef.current, we = (be = Oe.find((N) => N.id === L)) == null || (he = be.context) == null ? void 0 : he.elements.floating, Fe = Pi(mr(o)), st = Oe.some((N) => N.context && qn(N.context.elements.floating, Fe));
    we && !st && D.current && we.focus({
      preventScroll: !0
    });
  }, [u, o, k, L, y]), un(() => {
    if (!u || !k || !y || L)
      return;
    function be(he) {
      Pe(he.id), M && (M.current = he);
    }
    return k.events.on("virtualfocus", be), () => {
      k.events.off("virtualfocus", be);
    };
  }, [u, k, y, L, M]), un(() => {
    j.current = I, V.current = !!o;
  }), un(() => {
    n || (z.current = null);
  }, [n]);
  const rt = l != null, Ve = A.useMemo(() => {
    function be(Oe) {
      if (!n)
        return;
      const we = s.current.indexOf(Oe);
      we !== -1 && I(we);
    }
    return {
      onFocus(Oe) {
        let {
          currentTarget: we
        } = Oe;
        be(we);
      },
      onClick: (Oe) => {
        let {
          currentTarget: we
        } = Oe;
        return we.focus({
          preventScroll: !0
        });
      },
      // Safari
      ...v && {
        onMouseMove(Oe) {
          let {
            currentTarget: we
          } = Oe;
          be(we);
        },
        onPointerLeave(Oe) {
          let {
            pointerType: we
          } = Oe;
          !D.current || we === "touch" || (U.current = -1, qe(s, U), I(null), y || ti(i.floating.current, {
            preventScroll: !0
          }));
        }
      }
    };
  }, [n, i, qe, v, s, I, y]);
  return A.useMemo(() => {
    if (!u)
      return {};
    const be = x.current;
    function he(N) {
      if (D.current = !1, W.current = !0, !ie.current && N.currentTarget === i.floating.current)
        return;
      if (h && Gv(N.key, O, m)) {
        wn(N), r(!1, N.nativeEvent), An(a) && !y && a.focus();
        return;
      }
      const le = U.current, pe = cp(s, be), ue = Fv(s, be);
      if (N.key === "Home" && (wn(N), U.current = pe, I(U.current)), N.key === "End" && (wn(N), U.current = ue, I(U.current)), !(S > 1 && (U.current = oU(s, {
        event: N,
        orientation: O,
        loop: f,
        cols: S,
        disabledIndices: be,
        minIndex: pe,
        maxIndex: ue,
        prevIndex: U.current,
        stopEvent: !0
      }), I(U.current), O === "both")) && Kv(N.key, O)) {
        if (wn(N), n && !y && Pi(N.currentTarget.ownerDocument) === N.currentTarget) {
          U.current = pp(N.key, O, m) ? pe : ue, I(U.current);
          return;
        }
        pp(N.key, O, m) ? f ? U.current = le >= ue ? p && le !== s.current.length ? -1 : pe : kn(s, {
          startingIndex: le,
          disabledIndices: be
        }) : U.current = Math.min(ue, kn(s, {
          startingIndex: le,
          disabledIndices: be
        })) : f ? U.current = le <= pe ? p && le !== -1 ? s.current.length : ue : kn(s, {
          startingIndex: le,
          decrement: !0,
          disabledIndices: be
        }) : U.current = Math.max(pe, kn(s, {
          startingIndex: le,
          decrement: !0,
          disabledIndices: be
        })), ks(s, U.current) ? I(null) : I(U.current);
      }
    }
    function Oe(N) {
      g === "auto" && x_(N.nativeEvent) && (B.current = !0);
    }
    function we(N) {
      B.current = g, g === "auto" && __(N.nativeEvent) && (B.current = !0);
    }
    const Fe = y && n && rt && {
      "aria-activedescendant": Ze || E
    }, st = s.current.find((N) => (N == null ? void 0 : N.id) === E);
    return {
      reference: {
        ...Fe,
        onKeyDown(N) {
          D.current = !1;
          const le = N.key.indexOf("Arrow") === 0, pe = MU(N.key, O, m), ue = Gv(N.key, O, m), Le = Kv(N.key, O), Me = (h ? pe : Le) || N.key === "Enter" || N.key.trim() === "";
          if (y && n) {
            const Z = k == null ? void 0 : k.nodesRef.current.find((ce) => ce.parentId == null), J = k && Z ? hU(k.nodesRef.current, Z.id) : null;
            if (le && J && M) {
              const ce = new KeyboardEvent("keydown", {
                key: N.key,
                bubbles: !0
              });
              if (pe || ue) {
                var Ke, gt;
                const Ne = ((Ke = J.context) == null ? void 0 : Ke.elements.domReference) === N.currentTarget, it = ue && !Ne ? (gt = J.context) == null ? void 0 : gt.elements.domReference : pe ? st : null;
                it && (wn(N), it.dispatchEvent(ce), Pe(void 0));
              }
              if (Le && J.context && J.context.open && J.parentId && N.currentTarget !== J.context.elements.domReference) {
                var tt;
                wn(N), (tt = J.context.elements.domReference) == null || tt.dispatchEvent(ce);
                return;
              }
            }
            return he(N);
          }
          if (!(!n && !b && le)) {
            if (Me && (z.current = h && Le ? null : N.key), h) {
              pe && (wn(N), n ? (U.current = cp(s, be), I(U.current)) : r(!0, N.nativeEvent));
              return;
            }
            Le && (d != null && (U.current = d), wn(N), !n && b ? r(!0, N.nativeEvent) : he(N), n && I(U.current));
          }
        },
        onFocus() {
          n && I(null);
        },
        onPointerDown: we,
        onMouseDown: Oe,
        onClick: Oe
      },
      floating: {
        "aria-orientation": O === "both" ? void 0 : O,
        ...Fe,
        onKeyDown: he,
        onPointerMove() {
          D.current = !0;
        }
      },
      item: Ve
    };
  }, [a, i, E, Ze, x, ie, s, u, O, m, y, n, rt, h, d, b, p, S, f, g, I, r, Ve, k, M]);
}
function DU(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    floatingId: r
  } = e, {
    enabled: i = !0,
    role: a = "dialog"
  } = t, o = ng();
  return A.useMemo(() => {
    const s = {
      id: r,
      role: a
    };
    return i ? a === "tooltip" ? {
      reference: {
        "aria-describedby": n ? r : void 0
      },
      floating: s
    } : {
      reference: {
        "aria-expanded": n ? "true" : "false",
        "aria-haspopup": a === "alertdialog" ? "dialog" : a,
        "aria-controls": n ? r : void 0,
        ...a === "listbox" && {
          role: "combobox"
        },
        ...a === "menu" && {
          id: o
        }
      },
      floating: {
        ...s,
        ...a === "menu" && {
          "aria-labelledby": o
        }
      }
    } : {};
  }, [i, a, n, r, o]);
}
function LU(e, t) {
  var n;
  const {
    open: r,
    dataRef: i
  } = e, {
    listRef: a,
    activeIndex: o,
    onMatch: s,
    onTypingChange: l,
    enabled: c = !0,
    findMatch: u = null,
    resetMs: d = 750,
    ignoreKeys: p = [],
    selectedIndex: f = null
  } = t, h = A.useRef(), m = A.useRef(""), y = A.useRef((n = f ?? o) != null ? n : -1), g = A.useRef(null), v = Ui(s), b = Ui(l), T = ji(u), O = ji(p);
  return un(() => {
    r && (clearTimeout(h.current), g.current = null, m.current = "");
  }, [r]), un(() => {
    if (r && m.current === "") {
      var S;
      y.current = (S = f ?? o) != null ? S : -1;
    }
  }, [r, f, o]), A.useMemo(() => {
    if (!c)
      return {};
    function S(L) {
      L ? i.current.typing || (i.current.typing = L, b(L)) : i.current.typing && (i.current.typing = L, b(L));
    }
    function P(L, k, I) {
      const B = T.current ? T.current(k, I) : k.find((U) => (U == null ? void 0 : U.toLocaleLowerCase().indexOf(I.toLocaleLowerCase())) === 0);
      return B ? L.indexOf(B) : -1;
    }
    function M(L) {
      const k = a.current;
      if (m.current.length > 0 && m.current[0] !== " " && (P(k, k, m.current) === -1 ? S(!1) : L.key === " " && wn(L)), k == null || O.current.includes(L.key) || // Character key.
      L.key.length !== 1 || // Modifier key.
      L.ctrlKey || L.metaKey || L.altKey)
        return;
      r && L.key !== " " && (wn(L), S(!0)), k.every((z) => {
        var D, j;
        return z ? ((D = z[0]) == null ? void 0 : D.toLocaleLowerCase()) !== ((j = z[1]) == null ? void 0 : j.toLocaleLowerCase()) : !0;
      }) && m.current === L.key && (m.current = "", y.current = g.current), m.current += L.key, clearTimeout(h.current), h.current = setTimeout(() => {
        m.current = "", y.current = g.current, S(!1);
      }, d);
      const B = y.current, U = P(k, [...k.slice((B || 0) + 1), ...k.slice(0, (B || 0) + 1)], m.current);
      U !== -1 ? (v(U), g.current = U) : L.key !== " " && (m.current = "", S(!1));
    }
    return {
      reference: {
        onKeyDown: M
      },
      floating: {
        onKeyDown: M,
        onKeyUp(L) {
          L.key === " " && S(!1);
        }
      }
    };
  }, [c, r, i, a, d, O, T, v, b]);
}
const jU = ({ styles: e, type: t, options: n, label: r, reusable: i }) => {
  var V, W, de, x, ie, ve, E, ke, Ze, Pe, qe, rt;
  const { state: a, client: o, messageContainerRef: s } = It(), [l, c] = A.useState(!1), [u, d] = A.useState(null), [p, f] = A.useState(null), h = n.reduce(
    (Ve, be) => (Ve[be.label] = be.value, Ve),
    {}
  ), m = h ? Object.keys(h) : [], y = (Ve) => {
    c(p !== null && !i ? !1 : Ve);
  }, { refs: g, floatingStyles: v, context: b } = PU({
    placement: "bottom-start",
    open: l,
    onOpenChange: y,
    whileElementsMounted: Uj,
    middleware: [
      xj(5),
      _j({
        padding: 10,
        boundary: (s == null ? void 0 : s.current) ?? void 0,
        crossAxis: !0
      }),
      Sj({
        apply({ rects: Ve, elements: be, availableHeight: he }) {
          Object.assign(be.floating.style, {
            maxHeight: `${he}px`,
            minWidth: `${Ve.reference.width}px`
          });
        },
        padding: 10
      })
    ]
  }), T = A.useRef([]), O = A.useRef(m), S = A.useRef(!1), P = kU(b, { event: "mousedown" }), M = RU(b), L = DU(b, { role: "listbox" }), k = NU(b, {
    listRef: T,
    activeIndex: u,
    selectedIndex: p,
    onNavigate: d,
    // This is a large list, allow looping.
    loop: !0
  }), I = LU(b, {
    listRef: O,
    activeIndex: u,
    selectedIndex: p,
    onMatch: l ? d : f,
    onTypingChange(Ve) {
      S.current = Ve;
    }
  }), { getReferenceProps: B, getFloatingProps: U, getItemProps: z } = IU([
    M,
    L,
    k,
    I,
    P
  ]), D = (Ve) => {
    f(Ve), o == null || o.sendMessage(h[m[Ve]]), c(!1);
  }, j = p !== null ? m[p] : void 0;
  return /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
    /* @__PURE__ */ F.jsxs(
      "div",
      {
        tabIndex: 0,
        ref: g.setReference,
        "aria-labelledby": "select-label",
        "aria-autocomplete": "none",
        "data-disabled": p !== null && !i ? "" : void 0,
        ...(W = (V = e == null ? void 0 : e[t]) == null ? void 0 : V.button) == null ? void 0 : W.container,
        ...B(),
        children: [
          /* @__PURE__ */ F.jsx("span", { ...(x = (de = e == null ? void 0 : e[t]) == null ? void 0 : de.button) == null ? void 0 : x.text, children: j || r || "Select..." }),
          /* @__PURE__ */ F.jsx(Q2, { ...(ve = (ie = e == null ? void 0 : e[t]) == null ? void 0 : ie.button) == null ? void 0 : ve.icon })
        ]
      }
    ),
    l && /* @__PURE__ */ F.jsx(_U, { children: /* @__PURE__ */ F.jsx(EU, { context: b, modal: !1, children: /* @__PURE__ */ F.jsx(
      "div",
      {
        ref: g.setFloating,
        className: (Ze = (ke = (E = e == null ? void 0 : e[t]) == null ? void 0 : E.content) == null ? void 0 : ke.container) == null ? void 0 : Ze.className,
        style: { ...v, ...(rt = (qe = (Pe = e == null ? void 0 : e[t]) == null ? void 0 : Pe.content) == null ? void 0 : qe.container) == null ? void 0 : rt.style },
        ...U(),
        children: m.map((Ve, be) => {
          var he, Oe;
          return /* @__PURE__ */ F.jsx(
            "div",
            {
              ref: (we) => {
                T.current[be] = we;
              },
              role: "option",
              tabIndex: be === u ? 0 : -1,
              "aria-selected": be === p && be === u,
              "data-active": be === u ? "" : void 0,
              ...(Oe = (he = e == null ? void 0 : e[t]) == null ? void 0 : he.content) == null ? void 0 : Oe.item,
              ...z({
                onClick() {
                  a.isReadOnly || D(be);
                },
                onKeyDown(we) {
                  a.isReadOnly || (we.key === "Enter" && (we.preventDefault(), D(be)), we.key === " " && !S.current && (we.preventDefault(), D(be)));
                }
              }),
              children: Ve
            },
            Ve
          );
        })
      }
    ) }) })
  ] });
}, UU = ze(({ type: e, title: t, styles: n, url: r, ...i }, a) => {
  var o, s, l;
  return /* @__PURE__ */ F.jsxs("a", { ...i, ...(o = n == null ? void 0 : n[e]) == null ? void 0 : o.container, href: r, download: !0, ref: a, children: [
    /* @__PURE__ */ F.jsx("p", { ...(s = n == null ? void 0 : n[e]) == null ? void 0 : s.title, children: t || r }),
    /* @__PURE__ */ F.jsx(nL, { ...(l = n == null ? void 0 : n[e]) == null ? void 0 : l.icon })
  ] });
}), q_ = {
  audio: B2,
  bubble: yD,
  button: mD,
  carousel: sj,
  column: sL,
  dropdown: jU,
  file: UU,
  image: j2,
  location: oL,
  row: lL,
  text: pD,
  video: F2
}, yl = ({ block: e, styles: t, ...n }) => {
  const r = q_[e.type], i = { ...n, styles: t, ...e };
  return /* @__PURE__ */ F.jsx(r, { ...i });
}, Jv = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (l, c) => {
    const u = typeof l == "function" ? l(t) : l;
    if (!Object.is(u, t)) {
      const d = t;
      t = c ?? typeof u != "object" ? u : Object.assign({}, t, u), n.forEach((p) => p(t, d));
    }
  }, i = () => t, s = { setState: r, getState: i, subscribe: (l) => (n.add(l), () => n.delete(l)), destroy: () => {
    n.clear();
  } };
  return t = e(r, i, s), s;
}, FU = (e) => e ? Jv(e) : Jv;
var vh = { exports: {} }, hp = {}, ic = { exports: {} }, mp = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Yv;
function BU() {
  if (Yv)
    return mp;
  Yv = 1;
  var e = Jt;
  function t(d, p) {
    return d === p && (d !== 0 || 1 / d === 1 / p) || d !== d && p !== p;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, a = e.useLayoutEffect, o = e.useDebugValue;
  function s(d, p) {
    var f = p(), h = r({ inst: { value: f, getSnapshot: p } }), m = h[0].inst, y = h[1];
    return a(function() {
      m.value = f, m.getSnapshot = p, l(m) && y({ inst: m });
    }, [d, f, p]), i(function() {
      return l(m) && y({ inst: m }), d(function() {
        l(m) && y({ inst: m });
      });
    }, [d]), o(f), f;
  }
  function l(d) {
    var p = d.getSnapshot;
    d = d.value;
    try {
      var f = p();
      return !n(d, f);
    } catch {
      return !0;
    }
  }
  function c(d, p) {
    return p();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? c : s;
  return mp.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : u, mp;
}
var gp = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xv;
function zU() {
  return Xv || (Xv = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = Jt, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(b) {
      {
        for (var T = arguments.length, O = new Array(T > 1 ? T - 1 : 0), S = 1; S < T; S++)
          O[S - 1] = arguments[S];
        r("error", b, O);
      }
    }
    function r(b, T, O) {
      {
        var S = t.ReactDebugCurrentFrame, P = S.getStackAddendum();
        P !== "" && (T += "%s", O = O.concat([P]));
        var M = O.map(function(L) {
          return String(L);
        });
        M.unshift("Warning: " + T), Function.prototype.apply.call(console[b], console, M);
      }
    }
    function i(b, T) {
      return b === T && (b !== 0 || 1 / b === 1 / T) || b !== b && T !== T;
    }
    var a = typeof Object.is == "function" ? Object.is : i, o = e.useState, s = e.useEffect, l = e.useLayoutEffect, c = e.useDebugValue, u = !1, d = !1;
    function p(b, T, O) {
      u || e.startTransition !== void 0 && (u = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var S = T();
      if (!d) {
        var P = T();
        a(S, P) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), d = !0);
      }
      var M = o({
        inst: {
          value: S,
          getSnapshot: T
        }
      }), L = M[0].inst, k = M[1];
      return l(function() {
        L.value = S, L.getSnapshot = T, f(L) && k({
          inst: L
        });
      }, [b, S, T]), s(function() {
        f(L) && k({
          inst: L
        });
        var I = function() {
          f(L) && k({
            inst: L
          });
        };
        return b(I);
      }, [b]), c(S), S;
    }
    function f(b) {
      var T = b.getSnapshot, O = b.value;
      try {
        var S = T();
        return !a(O, S);
      } catch {
        return !0;
      }
    }
    function h(b, T, O) {
      return T();
    }
    var m = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", y = !m, g = y ? h : p, v = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : g;
    gp.useSyncExternalStore = v, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), gp;
}
var Qv;
function W_() {
  return Qv || (Qv = 1, process.env.NODE_ENV === "production" ? ic.exports = BU() : ic.exports = zU()), ic.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eb;
function ZU() {
  if (eb)
    return hp;
  eb = 1;
  var e = Jt, t = W_();
  function n(c, u) {
    return c === u && (c !== 0 || 1 / c === 1 / u) || c !== c && u !== u;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, a = e.useRef, o = e.useEffect, s = e.useMemo, l = e.useDebugValue;
  return hp.useSyncExternalStoreWithSelector = function(c, u, d, p, f) {
    var h = a(null);
    if (h.current === null) {
      var m = { hasValue: !1, value: null };
      h.current = m;
    } else
      m = h.current;
    h = s(function() {
      function g(S) {
        if (!v) {
          if (v = !0, b = S, S = p(S), f !== void 0 && m.hasValue) {
            var P = m.value;
            if (f(P, S))
              return T = P;
          }
          return T = S;
        }
        if (P = T, r(b, S))
          return P;
        var M = p(S);
        return f !== void 0 && f(P, M) ? P : (b = S, T = M);
      }
      var v = !1, b, T, O = d === void 0 ? null : d;
      return [function() {
        return g(u());
      }, O === null ? void 0 : function() {
        return g(O());
      }];
    }, [u, d, p, f]);
    var y = i(c, h[0], h[1]);
    return o(function() {
      m.hasValue = !0, m.value = y;
    }, [y]), l(y), y;
  }, hp;
}
var yp = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tb;
function qU() {
  return tb || (tb = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = Jt, t = W_();
    function n(u, d) {
      return u === d && (u !== 0 || 1 / u === 1 / d) || u !== u && d !== d;
    }
    var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, a = e.useRef, o = e.useEffect, s = e.useMemo, l = e.useDebugValue;
    function c(u, d, p, f, h) {
      var m = a(null), y;
      m.current === null ? (y = {
        hasValue: !1,
        value: null
      }, m.current = y) : y = m.current;
      var g = s(function() {
        var O = !1, S, P, M = function(B) {
          if (!O) {
            O = !0, S = B;
            var U = f(B);
            if (h !== void 0 && y.hasValue) {
              var z = y.value;
              if (h(z, U))
                return P = z, z;
            }
            return P = U, U;
          }
          var D = S, j = P;
          if (r(D, B))
            return j;
          var V = f(B);
          return h !== void 0 && h(j, V) ? j : (S = B, P = V, V);
        }, L = p === void 0 ? null : p, k = function() {
          return M(d());
        }, I = L === null ? void 0 : function() {
          return M(L());
        };
        return [k, I];
      }, [d, p, f, h]), v = g[0], b = g[1], T = i(u, v, b);
      return o(function() {
        y.hasValue = !0, y.value = T;
      }, [T]), l(T), T;
    }
    yp.useSyncExternalStoreWithSelector = c, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), yp;
}
process.env.NODE_ENV === "production" ? vh.exports = ZU() : vh.exports = qU();
var WU = vh.exports;
const VU = /* @__PURE__ */ Ki(WU), { useSyncExternalStoreWithSelector: HU } = VU;
function KU(e, t = e.getState, n) {
  const r = HU(
    e.subscribe,
    e.getState,
    e.getServerState || e.getState,
    t,
    n
  );
  return mA(r), r;
}
const nb = (e) => {
  const t = typeof e == "function" ? FU(e) : e, n = (r, i) => KU(t, r, i);
  return Object.assign(n, t), n;
}, GU = (e) => e ? nb(e) : nb, bh = /* @__PURE__ */ new Map(), ac = (e) => {
  const t = bh.get(e);
  return t ? Object.fromEntries(
    Object.entries(t.stores).map(([n, r]) => [n, r.getState()])
  ) : {};
}, JU = (e, t, n) => {
  if (e === void 0)
    return {
      type: "untracked",
      connection: t.connect(n)
    };
  const r = bh.get(n.name);
  if (r)
    return { type: "tracked", store: e, ...r };
  const i = {
    connection: t.connect(n),
    stores: {}
  };
  return bh.set(n.name, i), { type: "tracked", store: e, ...i };
}, YU = (e, t = {}) => (n, r, i) => {
  const { enabled: a, anonymousActionType: o, store: s, ...l } = t;
  let c;
  try {
    c = (a ?? !1) && window.__REDUX_DEVTOOLS_EXTENSION__;
  } catch {
  }
  if (!c)
    return e(n, r, i);
  const { connection: u, ...d } = JU(s, c, l);
  let p = !0;
  i.setState = (m, y, g) => {
    const v = n(m, y);
    if (!p)
      return v;
    const b = g === void 0 ? { type: o || "anonymous" } : typeof g == "string" ? { type: g } : g;
    return s === void 0 ? (u == null || u.send(b, r()), v) : (u == null || u.send(
      {
        ...b,
        type: `${s}/${b.type}`
      },
      {
        ...ac(l.name),
        [s]: i.getState()
      }
    ), v);
  };
  const f = (...m) => {
    const y = p;
    p = !1, n(...m), p = y;
  }, h = e(i.setState, r, i);
  if (d.type === "untracked" ? u == null || u.init(h) : (d.stores[d.store] = i, u == null || u.init(
    Object.fromEntries(
      Object.entries(d.stores).map(([m, y]) => [
        m,
        m === d.store ? h : y.getState()
      ])
    )
  )), i.dispatchFromDevtools && typeof i.dispatch == "function") {
    let m = !1;
    const y = i.dispatch;
    i.dispatch = (...g) => {
      y(...g);
    };
  }
  return u.subscribe((m) => {
    var y;
    switch (m.type) {
      case "ACTION":
        if (typeof m.payload != "string") {
          console.error(
            "[zustand devtools middleware] Unsupported action format"
          );
          return;
        }
        return vp(
          m.payload,
          (g) => {
            if (g.type === "__setState") {
              if (s === void 0) {
                f(g.state);
                return;
              }
              Object.keys(g.state).length !== 1 && console.error(
                `
                    [zustand devtools middleware] Unsupported __setState action format. 
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `
              );
              const v = g.state[s];
              if (v == null)
                return;
              JSON.stringify(i.getState()) !== JSON.stringify(v) && f(v);
              return;
            }
            i.dispatchFromDevtools && typeof i.dispatch == "function" && i.dispatch(g);
          }
        );
      case "DISPATCH":
        switch (m.payload.type) {
          case "RESET":
            return f(h), s === void 0 ? u == null ? void 0 : u.init(i.getState()) : u == null ? void 0 : u.init(ac(l.name));
          case "COMMIT":
            if (s === void 0) {
              u == null || u.init(i.getState());
              return;
            }
            return u == null ? void 0 : u.init(ac(l.name));
          case "ROLLBACK":
            return vp(m.state, (g) => {
              if (s === void 0) {
                f(g), u == null || u.init(i.getState());
                return;
              }
              f(g[s]), u == null || u.init(ac(l.name));
            });
          case "JUMP_TO_STATE":
          case "JUMP_TO_ACTION":
            return vp(m.state, (g) => {
              if (s === void 0) {
                f(g);
                return;
              }
              JSON.stringify(i.getState()) !== JSON.stringify(g[s]) && f(g[s]);
            });
          case "IMPORT_STATE": {
            const { nextLiftedState: g } = m.payload, v = (y = g.computedStates.slice(-1)[0]) == null ? void 0 : y.state;
            if (!v)
              return;
            f(s === void 0 ? v : v[s]), u == null || u.send(
              null,
              // FIXME no-any
              g
            );
            return;
          }
          case "PAUSE_RECORDING":
            return p = !p;
        }
        return;
    }
  }), h;
}, XU = YU, vp = (e, t) => {
  let n;
  try {
    n = JSON.parse(e);
  } catch (r) {
    console.error(
      "[zustand devtools middleware] Could not parse the received json",
      r
    );
  }
  n !== void 0 && t(n);
};
function QU(e, t) {
  let n;
  try {
    n = e();
  } catch {
    return;
  }
  return {
    getItem: (i) => {
      var a;
      const o = (l) => l === null ? null : JSON.parse(l, t == null ? void 0 : t.reviver), s = (a = n.getItem(i)) != null ? a : null;
      return s instanceof Promise ? s.then(o) : o(s);
    },
    setItem: (i, a) => n.setItem(
      i,
      JSON.stringify(a, t == null ? void 0 : t.replacer)
    ),
    removeItem: (i) => n.removeItem(i)
  };
}
const Ls = (e) => (t) => {
  try {
    const n = e(t);
    return n instanceof Promise ? n : {
      then(r) {
        return Ls(r)(n);
      },
      catch(r) {
        return this;
      }
    };
  } catch (n) {
    return {
      then(r) {
        return this;
      },
      catch(r) {
        return Ls(r)(n);
      }
    };
  }
}, eF = (e, t) => (n, r, i) => {
  let a = {
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (y) => y,
    version: 0,
    merge: (y, g) => ({
      ...g,
      ...y
    }),
    ...t
  }, o = !1;
  const s = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let c;
  try {
    c = a.getStorage();
  } catch {
  }
  if (!c)
    return e(
      (...y) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${a.name}', the given storage is currently unavailable.`
        ), n(...y);
      },
      r,
      i
    );
  const u = Ls(a.serialize), d = () => {
    const y = a.partialize({ ...r() });
    let g;
    const v = u({ state: y, version: a.version }).then(
      (b) => c.setItem(a.name, b)
    ).catch((b) => {
      g = b;
    });
    if (g)
      throw g;
    return v;
  }, p = i.setState;
  i.setState = (y, g) => {
    p(y, g), d();
  };
  const f = e(
    (...y) => {
      n(...y), d();
    },
    r,
    i
  );
  let h;
  const m = () => {
    var y;
    if (!c)
      return;
    o = !1, s.forEach((v) => v(r()));
    const g = ((y = a.onRehydrateStorage) == null ? void 0 : y.call(a, r())) || void 0;
    return Ls(c.getItem.bind(c))(a.name).then((v) => {
      if (v)
        return a.deserialize(v);
    }).then((v) => {
      if (v)
        if (typeof v.version == "number" && v.version !== a.version) {
          if (a.migrate)
            return a.migrate(
              v.state,
              v.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return v.state;
    }).then((v) => {
      var b;
      return h = a.merge(
        v,
        (b = r()) != null ? b : f
      ), n(h, !0), d();
    }).then(() => {
      g == null || g(h, void 0), o = !0, l.forEach((v) => v(h));
    }).catch((v) => {
      g == null || g(void 0, v);
    });
  };
  return i.persist = {
    setOptions: (y) => {
      a = {
        ...a,
        ...y
      }, y.getStorage && (c = y.getStorage());
    },
    clearStorage: () => {
      c == null || c.removeItem(a.name);
    },
    getOptions: () => a,
    rehydrate: () => m(),
    hasHydrated: () => o,
    onHydrate: (y) => (s.add(y), () => {
      s.delete(y);
    }),
    onFinishHydration: (y) => (l.add(y), () => {
      l.delete(y);
    })
  }, m(), h || f;
}, tF = (e, t) => (n, r, i) => {
  let a = {
    storage: QU(() => localStorage),
    partialize: (m) => m,
    version: 0,
    merge: (m, y) => ({
      ...y,
      ...m
    }),
    ...t
  }, o = !1;
  const s = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let c = a.storage;
  if (!c)
    return e(
      (...m) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${a.name}', the given storage is currently unavailable.`
        ), n(...m);
      },
      r,
      i
    );
  const u = () => {
    const m = a.partialize({ ...r() });
    return c.setItem(a.name, {
      state: m,
      version: a.version
    });
  }, d = i.setState;
  i.setState = (m, y) => {
    d(m, y), u();
  };
  const p = e(
    (...m) => {
      n(...m), u();
    },
    r,
    i
  );
  let f;
  const h = () => {
    var m, y;
    if (!c)
      return;
    o = !1, s.forEach((v) => {
      var b;
      return v((b = r()) != null ? b : p);
    });
    const g = ((y = a.onRehydrateStorage) == null ? void 0 : y.call(a, (m = r()) != null ? m : p)) || void 0;
    return Ls(c.getItem.bind(c))(a.name).then((v) => {
      if (v)
        if (typeof v.version == "number" && v.version !== a.version) {
          if (a.migrate)
            return a.migrate(
              v.state,
              v.version
            );
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return v.state;
    }).then((v) => {
      var b;
      return f = a.merge(
        v,
        (b = r()) != null ? b : p
      ), n(f, !0), u();
    }).then(() => {
      g == null || g(f, void 0), f = r(), o = !0, l.forEach((v) => v(f));
    }).catch((v) => {
      g == null || g(void 0, v);
    });
  };
  return i.persist = {
    setOptions: (m) => {
      a = {
        ...a,
        ...m
      }, m.storage && (c = m.storage);
    },
    clearStorage: () => {
      c == null || c.removeItem(a.name);
    },
    getOptions: () => a,
    rehydrate: () => h(),
    hasHydrated: () => o,
    onHydrate: (m) => (s.add(m), () => {
      s.delete(m);
    }),
    onFinishHydration: (m) => (l.add(m), () => {
      l.delete(m);
    })
  }, a.skipHydration || h(), f || p;
}, nF = (e, t) => "getStorage" in t || "serialize" in t || "deserialize" in t ? eF(e, t) : tF(e, t), rF = nF, Oi = GU()(
  XU(
    rF(
      (e, t) => ({
        messageHistory: {},
        addMessageToHistory: ({ userId: n, message: r }) => e((i) => ({
          ...i,
          messageHistory: {
            ...i.messageHistory,
            [n]: [r, ...(i.messageHistory[n] ?? []).slice(0, 100)]
          }
        })),
        clientMode: "",
        setClientMode: (n) => {
          const { clearAll: r, clientMode: i } = t();
          i !== n && r(), e((a) => ({
            ...a,
            clientMode: n
          }));
        },
        setUser: (n) => e((r) => ({
          ...r,
          user: n
        })),
        setConversationId: (n) => e((r) => ({
          ...r,
          conversationId: n
        })),
        clearAll: () => {
          e((n) => ({
            ...n,
            messageHistory: {},
            user: void 0,
            conversationId: void 0
          }));
        }
      }),
      {
        name: "botpress-webchat"
      }
    )
  )
);
var lu = function() {
  return lu = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
    }
    return t;
  }, lu.apply(this, arguments);
};
function iF() {
  var e = Xe(!1), t = nn(function() {
    return e.current;
  }, []);
  return Be(function() {
    return e.current = !0, function() {
      e.current = !1;
    };
  }, []), t;
}
function aF(e, t, n) {
  t === void 0 && (t = []), n === void 0 && (n = { loading: !1 });
  var r = Xe(0), i = iF(), a = De(n), o = a[0], s = a[1], l = nn(function() {
    for (var c = [], u = 0; u < arguments.length; u++)
      c[u] = arguments[u];
    var d = ++r.current;
    return o.loading || s(function(p) {
      return lu(lu({}, p), { loading: !0 });
    }), e.apply(void 0, c).then(function(p) {
      return i() && d === r.current && s({ value: p, loading: !1 }), p;
    }, function(p) {
      return i() && d === r.current && s({ error: p, loading: !1 }), p;
    });
  }, t);
  return [o, l];
}
function wh(e, t) {
  t === void 0 && (t = []);
  var n = aF(e, t, {
    loading: !0
  }), r = n[0], i = n[1];
  return Be(function() {
    i();
  }, [i]), r;
}
function oF(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  e && e.addEventListener && e.addEventListener.apply(e, t);
}
function sF(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  e && e.removeEventListener && e.removeEventListener.apply(e, t);
}
var lF = function(e) {
  Be(e, []);
};
const ha = lF;
var cF = function(e) {
  ha(function() {
    e();
  });
};
const uF = cF;
var dF = function(e) {
  var t = Xe(e);
  t.current = e, ha(function() {
    return function() {
      return t.current();
    };
  });
};
const fF = dF;
var pF = function(e) {
  var t = Xe(0), n = De(e), r = n[0], i = n[1], a = nn(function(o) {
    cancelAnimationFrame(t.current), t.current = requestAnimationFrame(function() {
      i(o);
    });
  }, []);
  return fF(function() {
    cancelAnimationFrame(t.current);
  }), [r, a];
};
const hF = pF;
var mF = function(e) {
  process.env.NODE_ENV === "development" && (typeof e != "object" || typeof e.current > "u") && console.error("`useScroll` expects a single ref argument.");
  var t = hF({
    x: 0,
    y: 0
  }), n = t[0], r = t[1];
  return Be(function() {
    var i = function() {
      e.current && r({
        x: e.current.scrollLeft,
        y: e.current.scrollTop
      });
    };
    return e.current && oF(e.current, "scroll", i, {
      capture: !1,
      passive: !0
    }), function() {
      e.current && sF(e.current, "scroll", i);
    };
  }, [e]), n;
};
const gF = mF, yF = (e) => {
  const t = /* @__PURE__ */ new Date();
  return e.getTime() - t.getTime();
}, vF = (e = yF) => {
  const [t, n] = De(0), [r, i] = De(), a = () => n((o) => o + 1);
  return wh(async () => {
    if (r) {
      const o = setTimeout(a, e(r));
      return () => {
        clearTimeout(o);
      };
    }
  }, [r]), [t, i];
};
var V_ = {}, ag = {}, H_ = {};
Object.defineProperty(H_, "__esModule", { value: !0 });
var Ud = {}, bF = Je && Je.__awaiter || function(e, t, n, r) {
  function i(a) {
    return a instanceof n ? a : new n(function(o) {
      o(a);
    });
  }
  return new (n || (n = Promise))(function(a, o) {
    function s(u) {
      try {
        c(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      u.done ? a(u.value) : i(u.value).then(s, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
};
Object.defineProperty(Ud, "__esModule", { value: !0 });
Ud.Emitter = void 0;
let wF = class {
  constructor() {
    this.listeners = {};
  }
  on(t, n, r = !1) {
    const i = this.listeners[t];
    i ? r ? i.unshift(n) : i.push(n) : this.listeners[t] = [n];
  }
  emit(t, n) {
    return bF(this, void 0, void 0, function* () {
      const r = this.listeners[t];
      if (r != null && r.length) {
        for (const i of r)
          yield i(n);
        return !0;
      } else
        return !1;
    });
  }
};
Ud.Emitter = wF;
var K_ = {};
Object.defineProperty(K_, "__esModule", { value: !0 });
var G_ = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.HealthEventType = void 0, function(t) {
    t.Create = "create", t.Configure = "configure", t.Start = "start", t.StartFailure = "start-failure", t.Initialize = "initialize", t.InitializeFailure = "initialize-failure", t.Sleep = "sleep", t.Delete = "delete";
  }(e.HealthEventType || (e.HealthEventType = {}));
})(G_);
var J_ = {};
Object.defineProperty(J_, "__esModule", { value: !0 });
var Y_ = {};
Object.defineProperty(Y_, "__esModule", { value: !0 });
var X_ = {};
Object.defineProperty(X_, "__esModule", { value: !0 });
var Q_ = {};
Object.defineProperty(Q_, "__esModule", { value: !0 });
(function(e) {
  var t = Je && Je.__createBinding || (Object.create ? function(r, i, a, o) {
    o === void 0 && (o = a), Object.defineProperty(r, o, { enumerable: !0, get: function() {
      return i[a];
    } });
  } : function(r, i, a, o) {
    o === void 0 && (o = a), r[o] = i[a];
  }), n = Je && Je.__exportStar || function(r, i) {
    for (var a in r)
      a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && t(i, r, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(H_, e), n(Ud, e), n(K_, e), n(G_, e), n(J_, e), n(Y_, e), n(X_, e), n(Q_, e);
})(ag);
var Fd = {}, e1 = {}, xh = { exports: {} }, Bd = {}, og = {}, zd = {}, vl = {}, wo = {}, Ma = {}, qo = {}, xo = {}, Nr = {};
Object.defineProperty(Nr, "__esModule", { value: !0 });
Nr.ERROR_PACKET = Nr.PACKET_TYPES_REVERSE = Nr.PACKET_TYPES = void 0;
const jr = /* @__PURE__ */ Object.create(null);
Nr.PACKET_TYPES = jr;
jr.open = "0";
jr.close = "1";
jr.ping = "2";
jr.pong = "3";
jr.message = "4";
jr.upgrade = "5";
jr.noop = "6";
const t1 = /* @__PURE__ */ Object.create(null);
Nr.PACKET_TYPES_REVERSE = t1;
Object.keys(jr).forEach((e) => {
  t1[jr[e]] = e;
});
const xF = { type: "error", data: "parser error" };
Nr.ERROR_PACKET = xF;
Object.defineProperty(xo, "__esModule", { value: !0 });
xo.encodePacket = xo.encodePacketToBinary = void 0;
const _F = Nr, n1 = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", r1 = typeof ArrayBuffer == "function", i1 = (e) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e && e.buffer instanceof ArrayBuffer, a1 = ({ type: e, data: t }, n, r) => n1 && t instanceof Blob ? n ? r(t) : rb(t, r) : r1 && (t instanceof ArrayBuffer || i1(t)) ? n ? r(t) : rb(new Blob([t]), r) : r(_F.PACKET_TYPES[e] + (t || ""));
xo.encodePacket = a1;
const rb = (e, t) => {
  const n = new FileReader();
  return n.onload = function() {
    const r = n.result.split(",")[1];
    t("b" + (r || ""));
  }, n.readAsDataURL(e);
};
function ib(e) {
  return e instanceof Uint8Array ? e : e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
}
let bp;
function SF(e, t) {
  if (n1 && e.data instanceof Blob)
    return e.data.arrayBuffer().then(ib).then(t);
  if (r1 && (e.data instanceof ArrayBuffer || i1(e.data)))
    return t(ib(e.data));
  a1(e, !1, (n) => {
    bp || (bp = new TextEncoder()), t(bp.encode(n));
  });
}
xo.encodePacketToBinary = SF;
var Zd = {}, _o = {};
Object.defineProperty(_o, "__esModule", { value: !0 });
_o.decode = _o.encode = void 0;
const to = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", vs = typeof Uint8Array > "u" ? [] : new Uint8Array(256);
for (let e = 0; e < to.length; e++)
  vs[to.charCodeAt(e)] = e;
const EF = (e) => {
  let t = new Uint8Array(e), n, r = t.length, i = "";
  for (n = 0; n < r; n += 3)
    i += to[t[n] >> 2], i += to[(t[n] & 3) << 4 | t[n + 1] >> 4], i += to[(t[n + 1] & 15) << 2 | t[n + 2] >> 6], i += to[t[n + 2] & 63];
  return r % 3 === 2 ? i = i.substring(0, i.length - 1) + "=" : r % 3 === 1 && (i = i.substring(0, i.length - 2) + "=="), i;
};
_o.encode = EF;
const kF = (e) => {
  let t = e.length * 0.75, n = e.length, r, i = 0, a, o, s, l;
  e[e.length - 1] === "=" && (t--, e[e.length - 2] === "=" && t--);
  const c = new ArrayBuffer(t), u = new Uint8Array(c);
  for (r = 0; r < n; r += 4)
    a = vs[e.charCodeAt(r)], o = vs[e.charCodeAt(r + 1)], s = vs[e.charCodeAt(r + 2)], l = vs[e.charCodeAt(r + 3)], u[i++] = a << 2 | o >> 4, u[i++] = (o & 15) << 4 | s >> 2, u[i++] = (s & 3) << 6 | l & 63;
  return c;
};
_o.decode = kF;
Object.defineProperty(Zd, "__esModule", { value: !0 });
Zd.decodePacket = void 0;
const oc = Nr, TF = _o, CF = typeof ArrayBuffer == "function", OF = (e, t) => {
  if (typeof e != "string")
    return {
      type: "message",
      data: o1(e, t)
    };
  const n = e.charAt(0);
  return n === "b" ? {
    type: "message",
    data: AF(e.substring(1), t)
  } : oc.PACKET_TYPES_REVERSE[n] ? e.length > 1 ? {
    type: oc.PACKET_TYPES_REVERSE[n],
    data: e.substring(1)
  } : {
    type: oc.PACKET_TYPES_REVERSE[n]
  } : oc.ERROR_PACKET;
};
Zd.decodePacket = OF;
const AF = (e, t) => {
  if (CF) {
    const n = (0, TF.decode)(e);
    return o1(n, t);
  } else
    return { base64: !0, data: e };
}, o1 = (e, t) => {
  switch (t) {
    case "blob":
      return e instanceof Blob ? e : new Blob([e]);
    case "arraybuffer":
    default:
      return e instanceof ArrayBuffer ? e : e.buffer;
  }
};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.decodePayload = e.decodePacket = e.encodePayload = e.encodePacket = e.protocol = e.createPacketDecoderStream = e.createPacketEncoderStream = void 0;
  const t = xo;
  Object.defineProperty(e, "encodePacket", { enumerable: !0, get: function() {
    return t.encodePacket;
  } });
  const n = Zd;
  Object.defineProperty(e, "decodePacket", { enumerable: !0, get: function() {
    return n.decodePacket;
  } });
  const r = Nr, i = String.fromCharCode(30), a = (p, f) => {
    const h = p.length, m = new Array(h);
    let y = 0;
    p.forEach((g, v) => {
      (0, t.encodePacket)(g, !1, (b) => {
        m[v] = b, ++y === h && f(m.join(i));
      });
    });
  };
  e.encodePayload = a;
  const o = (p, f) => {
    const h = p.split(i), m = [];
    for (let y = 0; y < h.length; y++) {
      const g = (0, n.decodePacket)(h[y], f);
      if (m.push(g), g.type === "error")
        break;
    }
    return m;
  };
  e.decodePayload = o;
  function s() {
    return new TransformStream({
      transform(p, f) {
        (0, t.encodePacketToBinary)(p, (h) => {
          const m = h.length;
          let y;
          if (m < 126)
            y = new Uint8Array(1), new DataView(y.buffer).setUint8(0, m);
          else if (m < 65536) {
            y = new Uint8Array(3);
            const g = new DataView(y.buffer);
            g.setUint8(0, 126), g.setUint16(1, m);
          } else {
            y = new Uint8Array(9);
            const g = new DataView(y.buffer);
            g.setUint8(0, 127), g.setBigUint64(1, BigInt(m));
          }
          p.data && typeof p.data != "string" && (y[0] |= 128), f.enqueue(y), f.enqueue(h);
        });
      }
    });
  }
  e.createPacketEncoderStream = s;
  let l;
  function c(p) {
    return p.reduce((f, h) => f + h.length, 0);
  }
  function u(p, f) {
    if (p[0].length === f)
      return p.shift();
    const h = new Uint8Array(f);
    let m = 0;
    for (let y = 0; y < f; y++)
      h[y] = p[0][m++], m === p[0].length && (p.shift(), m = 0);
    return p.length && m < p[0].length && (p[0] = p[0].slice(m)), h;
  }
  function d(p, f) {
    l || (l = new TextDecoder());
    const h = [];
    let m = 0, y = -1, g = !1;
    return new TransformStream({
      transform(v, b) {
        for (h.push(v); ; ) {
          if (m === 0) {
            if (c(h) < 1)
              break;
            const T = u(h, 1);
            g = (T[0] & 128) === 128, y = T[0] & 127, y < 126 ? m = 3 : y === 126 ? m = 1 : m = 2;
          } else if (m === 1) {
            if (c(h) < 2)
              break;
            const T = u(h, 2);
            y = new DataView(T.buffer, T.byteOffset, T.length).getUint16(0), m = 3;
          } else if (m === 2) {
            if (c(h) < 8)
              break;
            const T = u(h, 8), O = new DataView(T.buffer, T.byteOffset, T.length), S = O.getUint32(0);
            if (S > Math.pow(2, 53 - 32) - 1) {
              b.enqueue(r.ERROR_PACKET);
              break;
            }
            y = S * Math.pow(2, 32) + O.getUint32(4), m = 3;
          } else {
            if (c(h) < y)
              break;
            const T = u(h, y);
            b.enqueue((0, n.decodePacket)(g ? T : l.decode(T), f)), m = 0;
          }
          if (y === 0 || y > p) {
            b.enqueue(r.ERROR_PACKET);
            break;
          }
        }
      }
    });
  }
  e.createPacketDecoderStream = d, e.protocol = 4;
})(qo);
function Ln(e) {
  if (e)
    return $F(e);
}
function $F(e) {
  for (var t in Ln.prototype)
    e[t] = Ln.prototype[t];
  return e;
}
Ln.prototype.on = Ln.prototype.addEventListener = function(e, t) {
  return this._callbacks = this._callbacks || {}, (this._callbacks["$" + e] = this._callbacks["$" + e] || []).push(t), this;
};
Ln.prototype.once = function(e, t) {
  function n() {
    this.off(e, n), t.apply(this, arguments);
  }
  return n.fn = t, this.on(e, n), this;
};
Ln.prototype.off = Ln.prototype.removeListener = Ln.prototype.removeAllListeners = Ln.prototype.removeEventListener = function(e, t) {
  if (this._callbacks = this._callbacks || {}, arguments.length == 0)
    return this._callbacks = {}, this;
  var n = this._callbacks["$" + e];
  if (!n)
    return this;
  if (arguments.length == 1)
    return delete this._callbacks["$" + e], this;
  for (var r, i = 0; i < n.length; i++)
    if (r = n[i], r === t || r.fn === t) {
      n.splice(i, 1);
      break;
    }
  return n.length === 0 && delete this._callbacks["$" + e], this;
};
Ln.prototype.emit = function(e) {
  this._callbacks = this._callbacks || {};
  for (var t = new Array(arguments.length - 1), n = this._callbacks["$" + e], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  if (n) {
    n = n.slice(0);
    for (var r = 0, i = n.length; r < i; ++r)
      n[r].apply(this, t);
  }
  return this;
};
Ln.prototype.emitReserved = Ln.prototype.emit;
Ln.prototype.listeners = function(e) {
  return this._callbacks = this._callbacks || {}, this._callbacks["$" + e] || [];
};
Ln.prototype.hasListeners = function(e) {
  return !!this.listeners(e).length;
};
const RF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Emitter: Ln
}, Symbol.toStringTag, { value: "Module" })), Wo = /* @__PURE__ */ _m(RF);
var sr = {}, Na = {};
Object.defineProperty(Na, "__esModule", { value: !0 });
Na.globalThisShim = void 0;
Na.globalThisShim = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())();
Object.defineProperty(sr, "__esModule", { value: !0 });
sr.byteLength = sr.installTimerFunctions = sr.pick = void 0;
const Ai = Na;
function PF(e, ...t) {
  return t.reduce((n, r) => (e.hasOwnProperty(r) && (n[r] = e[r]), n), {});
}
sr.pick = PF;
const IF = Ai.globalThisShim.setTimeout, MF = Ai.globalThisShim.clearTimeout;
function NF(e, t) {
  t.useNativeTimers ? (e.setTimeoutFn = IF.bind(Ai.globalThisShim), e.clearTimeoutFn = MF.bind(Ai.globalThisShim)) : (e.setTimeoutFn = Ai.globalThisShim.setTimeout.bind(Ai.globalThisShim), e.clearTimeoutFn = Ai.globalThisShim.clearTimeout.bind(Ai.globalThisShim));
}
sr.installTimerFunctions = NF;
const DF = 1.33;
function LF(e) {
  return typeof e == "string" ? jF(e) : Math.ceil((e.byteLength || e.size) * DF);
}
sr.byteLength = LF;
function jF(e) {
  let t = 0, n = 0;
  for (let r = 0, i = e.length; r < i; r++)
    t = e.charCodeAt(r), t < 128 ? n += 1 : t < 2048 ? n += 2 : t < 55296 || t >= 57344 ? n += 3 : (r++, n += 4);
  return n;
}
var _h = { exports: {} }, wp, ab;
function UF() {
  if (ab)
    return wp;
  ab = 1;
  var e = 1e3, t = e * 60, n = t * 60, r = n * 24, i = r * 7, a = r * 365.25;
  wp = function(u, d) {
    d = d || {};
    var p = typeof u;
    if (p === "string" && u.length > 0)
      return o(u);
    if (p === "number" && isFinite(u))
      return d.long ? l(u) : s(u);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(u)
    );
  };
  function o(u) {
    if (u = String(u), !(u.length > 100)) {
      var d = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        u
      );
      if (d) {
        var p = parseFloat(d[1]), f = (d[2] || "ms").toLowerCase();
        switch (f) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return p * a;
          case "weeks":
          case "week":
          case "w":
            return p * i;
          case "days":
          case "day":
          case "d":
            return p * r;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return p * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return p * t;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return p * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return p;
          default:
            return;
        }
      }
    }
  }
  function s(u) {
    var d = Math.abs(u);
    return d >= r ? Math.round(u / r) + "d" : d >= n ? Math.round(u / n) + "h" : d >= t ? Math.round(u / t) + "m" : d >= e ? Math.round(u / e) + "s" : u + "ms";
  }
  function l(u) {
    var d = Math.abs(u);
    return d >= r ? c(u, d, r, "day") : d >= n ? c(u, d, n, "hour") : d >= t ? c(u, d, t, "minute") : d >= e ? c(u, d, e, "second") : u + " ms";
  }
  function c(u, d, p, f) {
    var h = d >= p * 1.5;
    return Math.round(u / p) + " " + f + (h ? "s" : "");
  }
  return wp;
}
function FF(e) {
  n.debug = n, n.default = n, n.coerce = l, n.disable = a, n.enable = i, n.enabled = o, n.humanize = UF(), n.destroy = c, Object.keys(e).forEach((u) => {
    n[u] = e[u];
  }), n.names = [], n.skips = [], n.formatters = {};
  function t(u) {
    let d = 0;
    for (let p = 0; p < u.length; p++)
      d = (d << 5) - d + u.charCodeAt(p), d |= 0;
    return n.colors[Math.abs(d) % n.colors.length];
  }
  n.selectColor = t;
  function n(u) {
    let d, p = null, f, h;
    function m(...y) {
      if (!m.enabled)
        return;
      const g = m, v = Number(/* @__PURE__ */ new Date()), b = v - (d || v);
      g.diff = b, g.prev = d, g.curr = v, d = v, y[0] = n.coerce(y[0]), typeof y[0] != "string" && y.unshift("%O");
      let T = 0;
      y[0] = y[0].replace(/%([a-zA-Z%])/g, (S, P) => {
        if (S === "%%")
          return "%";
        T++;
        const M = n.formatters[P];
        if (typeof M == "function") {
          const L = y[T];
          S = M.call(g, L), y.splice(T, 1), T--;
        }
        return S;
      }), n.formatArgs.call(g, y), (g.log || n.log).apply(g, y);
    }
    return m.namespace = u, m.useColors = n.useColors(), m.color = n.selectColor(u), m.extend = r, m.destroy = n.destroy, Object.defineProperty(m, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: () => p !== null ? p : (f !== n.namespaces && (f = n.namespaces, h = n.enabled(u)), h),
      set: (y) => {
        p = y;
      }
    }), typeof n.init == "function" && n.init(m), m;
  }
  function r(u, d) {
    const p = n(this.namespace + (typeof d > "u" ? ":" : d) + u);
    return p.log = this.log, p;
  }
  function i(u) {
    n.save(u), n.namespaces = u, n.names = [], n.skips = [];
    let d;
    const p = (typeof u == "string" ? u : "").split(/[\s,]+/), f = p.length;
    for (d = 0; d < f; d++)
      p[d] && (u = p[d].replace(/\*/g, ".*?"), u[0] === "-" ? n.skips.push(new RegExp("^" + u.slice(1) + "$")) : n.names.push(new RegExp("^" + u + "$")));
  }
  function a() {
    const u = [
      ...n.names.map(s),
      ...n.skips.map(s).map((d) => "-" + d)
    ].join(",");
    return n.enable(""), u;
  }
  function o(u) {
    if (u[u.length - 1] === "*")
      return !0;
    let d, p;
    for (d = 0, p = n.skips.length; d < p; d++)
      if (n.skips[d].test(u))
        return !1;
    for (d = 0, p = n.names.length; d < p; d++)
      if (n.names[d].test(u))
        return !0;
    return !1;
  }
  function s(u) {
    return u.toString().substring(2, u.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(u) {
    return u instanceof Error ? u.stack || u.message : u;
  }
  function c() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return n.enable(n.load()), n;
}
var BF = FF;
(function(e, t) {
  t.formatArgs = r, t.save = i, t.load = a, t.useColors = n, t.storage = o(), t.destroy = (() => {
    let l = !1;
    return () => {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })(), t.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function n() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
    typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
    typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function r(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
      return;
    const c = "color: " + this.color;
    l.splice(1, 0, c, "color: inherit");
    let u = 0, d = 0;
    l[0].replace(/%[a-zA-Z%]/g, (p) => {
      p !== "%%" && (u++, p === "%c" && (d = u));
    }), l.splice(d, 0, c);
  }
  t.log = console.debug || console.log || (() => {
  });
  function i(l) {
    try {
      l ? t.storage.setItem("debug", l) : t.storage.removeItem("debug");
    } catch {
    }
  }
  function a() {
    let l;
    try {
      l = t.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
  }
  function o() {
    try {
      return localStorage;
    } catch {
    }
  }
  e.exports = BF(t);
  const { formatters: s } = e.exports;
  s.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (c) {
      return "[UnexpectedJSONParseError]: " + c.message;
    }
  };
})(_h, _h.exports);
var zr = _h.exports, _a = {};
Object.defineProperty(_a, "__esModule", { value: !0 });
_a.decode = _a.encode = void 0;
function zF(e) {
  let t = "";
  for (let n in e)
    e.hasOwnProperty(n) && (t.length && (t += "&"), t += encodeURIComponent(n) + "=" + encodeURIComponent(e[n]));
  return t;
}
_a.encode = zF;
function ZF(e) {
  let t = {}, n = e.split("&");
  for (let r = 0, i = n.length; r < i; r++) {
    let a = n[r].split("=");
    t[decodeURIComponent(a[0])] = decodeURIComponent(a[1]);
  }
  return t;
}
_a.decode = ZF;
var qF = Je && Je.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ma, "__esModule", { value: !0 });
Ma.Transport = void 0;
const WF = qo, VF = Wo, HF = sr, KF = qF(zr), GF = _a, JF = (0, KF.default)("engine.io-client:transport");
class YF extends Error {
  constructor(t, n, r) {
    super(t), this.description = n, this.context = r, this.type = "TransportError";
  }
}
class XF extends VF.Emitter {
  /**
   * Transport abstract constructor.
   *
   * @param {Object} opts - options
   * @protected
   */
  constructor(t) {
    super(), this.writable = !1, (0, HF.installTimerFunctions)(this, t), this.opts = t, this.query = t.query, this.socket = t.socket;
  }
  /**
   * Emits an error.
   *
   * @param {String} reason
   * @param description
   * @param context - the error context
   * @return {Transport} for chaining
   * @protected
   */
  onError(t, n, r) {
    return super.emitReserved("error", new YF(t, n, r)), this;
  }
  /**
   * Opens the transport.
   */
  open() {
    return this.readyState = "opening", this.doOpen(), this;
  }
  /**
   * Closes the transport.
   */
  close() {
    return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this;
  }
  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   */
  send(t) {
    this.readyState === "open" ? this.write(t) : JF("transport is not open, discarding packets");
  }
  /**
   * Called upon open
   *
   * @protected
   */
  onOpen() {
    this.readyState = "open", this.writable = !0, super.emitReserved("open");
  }
  /**
   * Called with data.
   *
   * @param {String} data
   * @protected
   */
  onData(t) {
    const n = (0, WF.decodePacket)(t, this.socket.binaryType);
    this.onPacket(n);
  }
  /**
   * Called with a decoded packet.
   *
   * @protected
   */
  onPacket(t) {
    super.emitReserved("packet", t);
  }
  /**
   * Called upon close.
   *
   * @protected
   */
  onClose(t) {
    this.readyState = "closed", super.emitReserved("close", t);
  }
  /**
   * Pauses the transport, in order not to lose packets during an upgrade.
   *
   * @param onPause
   */
  pause(t) {
  }
  createUri(t, n = {}) {
    return t + "://" + this._hostname() + this._port() + this.opts.path + this._query(n);
  }
  _hostname() {
    const t = this.opts.hostname;
    return t.indexOf(":") === -1 ? t : "[" + t + "]";
  }
  _port() {
    return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "";
  }
  _query(t) {
    const n = (0, GF.encode)(t);
    return n.length ? "?" + n : "";
  }
}
Ma.Transport = XF;
var li = {};
Object.defineProperty(li, "__esModule", { value: !0 });
li.yeast = li.decode = li.encode = void 0;
const s1 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), cu = 64, l1 = {};
let ob = 0, Mi = 0, sb;
function Sh(e) {
  let t = "";
  do
    t = s1[e % cu] + t, e = Math.floor(e / cu);
  while (e > 0);
  return t;
}
li.encode = Sh;
function QF(e) {
  let t = 0;
  for (Mi = 0; Mi < e.length; Mi++)
    t = t * cu + l1[e.charAt(Mi)];
  return t;
}
li.decode = QF;
function eB() {
  const e = Sh(+/* @__PURE__ */ new Date());
  return e !== sb ? (ob = 0, sb = e) : e + "." + Sh(ob++);
}
li.yeast = eB;
for (; Mi < cu; Mi++)
  l1[s1[Mi]] = Mi;
var So = {}, qd = {};
Object.defineProperty(qd, "__esModule", { value: !0 });
qd.hasCORS = void 0;
let c1 = !1;
try {
  c1 = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest();
} catch {
}
qd.hasCORS = c1;
Object.defineProperty(So, "__esModule", { value: !0 });
So.createCookieJar = So.XHR = void 0;
const tB = qd, nB = Na;
function rB(e) {
  const t = e.xdomain;
  try {
    if (typeof XMLHttpRequest < "u" && (!t || tB.hasCORS))
      return new XMLHttpRequest();
  } catch {
  }
  if (!t)
    try {
      return new nB.globalThisShim[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch {
    }
}
So.XHR = rB;
function iB() {
}
So.createCookieJar = iB;
var aB = Je && Je.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(wo, "__esModule", { value: !0 });
wo.Request = wo.Polling = void 0;
const oB = Ma, sB = aB(zr), lB = li, lb = qo, sg = So, cB = Wo, cb = sr, uB = Na, Zn = (0, sB.default)("engine.io-client:polling");
function dB() {
}
const fB = function() {
  return new sg.XHR({
    xdomain: !1
  }).responseType != null;
}();
class pB extends oB.Transport {
  /**
   * XHR Polling constructor.
   *
   * @param {Object} opts
   * @package
   */
  constructor(t) {
    if (super(t), this.polling = !1, typeof location < "u") {
      const r = location.protocol === "https:";
      let i = location.port;
      i || (i = r ? "443" : "80"), this.xd = typeof location < "u" && t.hostname !== location.hostname || i !== t.port;
    }
    const n = t && t.forceBase64;
    this.supportsBinary = fB && !n, this.opts.withCredentials && (this.cookieJar = (0, sg.createCookieJar)());
  }
  get name() {
    return "polling";
  }
  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @protected
   */
  doOpen() {
    this.poll();
  }
  /**
   * Pauses polling.
   *
   * @param {Function} onPause - callback upon buffers are flushed and transport is paused
   * @package
   */
  pause(t) {
    this.readyState = "pausing";
    const n = () => {
      Zn("paused"), this.readyState = "paused", t();
    };
    if (this.polling || !this.writable) {
      let r = 0;
      this.polling && (Zn("we are currently polling - waiting to pause"), r++, this.once("pollComplete", function() {
        Zn("pre-pause polling complete"), --r || n();
      })), this.writable || (Zn("we are currently writing - waiting to pause"), r++, this.once("drain", function() {
        Zn("pre-pause writing complete"), --r || n();
      }));
    } else
      n();
  }
  /**
   * Starts polling cycle.
   *
   * @private
   */
  poll() {
    Zn("polling"), this.polling = !0, this.doPoll(), this.emitReserved("poll");
  }
  /**
   * Overloads onData to detect payloads.
   *
   * @protected
   */
  onData(t) {
    Zn("polling got data %s", t);
    const n = (r) => {
      if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close")
        return this.onClose({ description: "transport closed by the server" }), !1;
      this.onPacket(r);
    };
    (0, lb.decodePayload)(t, this.socket.binaryType).forEach(n), this.readyState !== "closed" && (this.polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" ? this.poll() : Zn('ignoring poll - transport state "%s"', this.readyState));
  }
  /**
   * For polling, send a close packet.
   *
   * @protected
   */
  doClose() {
    const t = () => {
      Zn("writing close packet"), this.write([{ type: "close" }]);
    };
    this.readyState === "open" ? (Zn("transport open - closing"), t()) : (Zn("transport not open - deferring close"), this.once("open", t));
  }
  /**
   * Writes a packets payload.
   *
   * @param {Array} packets - data packets
   * @protected
   */
  write(t) {
    this.writable = !1, (0, lb.encodePayload)(t, (n) => {
      this.doWrite(n, () => {
        this.writable = !0, this.emitReserved("drain");
      });
    });
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "https" : "http", n = this.query || {};
    return this.opts.timestampRequests !== !1 && (n[this.opts.timestampParam] = (0, lB.yeast)()), !this.supportsBinary && !n.sid && (n.b64 = 1), this.createUri(t, n);
  }
  /**
   * Creates a request.
   *
   * @param {String} method
   * @private
   */
  request(t = {}) {
    return Object.assign(t, { xd: this.xd, cookieJar: this.cookieJar }, this.opts), new vr(this.uri(), t);
  }
  /**
   * Sends data.
   *
   * @param {String} data to send.
   * @param {Function} called upon flush.
   * @private
   */
  doWrite(t, n) {
    const r = this.request({
      method: "POST",
      data: t
    });
    r.on("success", n), r.on("error", (i, a) => {
      this.onError("xhr post error", i, a);
    });
  }
  /**
   * Starts a poll cycle.
   *
   * @private
   */
  doPoll() {
    Zn("xhr poll");
    const t = this.request();
    t.on("data", this.onData.bind(this)), t.on("error", (n, r) => {
      this.onError("xhr poll error", n, r);
    }), this.pollXhr = t;
  }
}
wo.Polling = pB;
class vr extends cB.Emitter {
  /**
   * Request constructor
   *
   * @param {Object} options
   * @package
   */
  constructor(t, n) {
    super(), (0, cb.installTimerFunctions)(this, n), this.opts = n, this.method = n.method || "GET", this.uri = t, this.data = n.data !== void 0 ? n.data : null, this.create();
  }
  /**
   * Creates the XHR object and sends the request.
   *
   * @private
   */
  create() {
    var t;
    const n = (0, cb.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
    n.xdomain = !!this.opts.xd;
    const r = this.xhr = new sg.XHR(n);
    try {
      Zn("xhr open %s: %s", this.method, this.uri), r.open(this.method, this.uri, !0);
      try {
        if (this.opts.extraHeaders) {
          r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0);
          for (let i in this.opts.extraHeaders)
            this.opts.extraHeaders.hasOwnProperty(i) && r.setRequestHeader(i, this.opts.extraHeaders[i]);
        }
      } catch {
      }
      if (this.method === "POST")
        try {
          r.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
        } catch {
        }
      try {
        r.setRequestHeader("Accept", "*/*");
      } catch {
      }
      (t = this.opts.cookieJar) === null || t === void 0 || t.addCookies(r), "withCredentials" in r && (r.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (r.timeout = this.opts.requestTimeout), r.onreadystatechange = () => {
        var i;
        r.readyState === 3 && ((i = this.opts.cookieJar) === null || i === void 0 || i.parseCookies(r)), r.readyState === 4 && (r.status === 200 || r.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {
          this.onError(typeof r.status == "number" ? r.status : 0);
        }, 0));
      }, Zn("xhr data %s", this.data), r.send(this.data);
    } catch (i) {
      this.setTimeoutFn(() => {
        this.onError(i);
      }, 0);
      return;
    }
    typeof document < "u" && (this.index = vr.requestsCount++, vr.requests[this.index] = this);
  }
  /**
   * Called upon error.
   *
   * @private
   */
  onError(t) {
    this.emitReserved("error", t, this.xhr), this.cleanup(!0);
  }
  /**
   * Cleans up house.
   *
   * @private
   */
  cleanup(t) {
    if (!(typeof this.xhr > "u" || this.xhr === null)) {
      if (this.xhr.onreadystatechange = dB, t)
        try {
          this.xhr.abort();
        } catch {
        }
      typeof document < "u" && delete vr.requests[this.index], this.xhr = null;
    }
  }
  /**
   * Called upon load.
   *
   * @private
   */
  onLoad() {
    const t = this.xhr.responseText;
    t !== null && (this.emitReserved("data", t), this.emitReserved("success"), this.cleanup());
  }
  /**
   * Aborts the request.
   *
   * @package
   */
  abort() {
    this.cleanup();
  }
}
wo.Request = vr;
vr.requestsCount = 0;
vr.requests = {};
if (typeof document < "u") {
  if (typeof attachEvent == "function")
    attachEvent("onunload", ub);
  else if (typeof addEventListener == "function") {
    const e = "onpagehide" in uB.globalThisShim ? "pagehide" : "unload";
    addEventListener(e, ub, !1);
  }
}
function ub() {
  for (let e in vr.requests)
    vr.requests.hasOwnProperty(e) && vr.requests[e].abort();
}
var Wd = {}, Xn = {};
Object.defineProperty(Xn, "__esModule", { value: !0 });
Xn.defaultBinaryType = Xn.usingBrowserWebSocket = Xn.WebSocket = Xn.nextTick = void 0;
const db = Na;
Xn.nextTick = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? (t) => Promise.resolve().then(t) : (t, n) => n(t, 0))();
Xn.WebSocket = db.globalThisShim.WebSocket || db.globalThisShim.MozWebSocket;
Xn.usingBrowserWebSocket = !0;
Xn.defaultBinaryType = "arraybuffer";
var hB = Je && Je.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Wd, "__esModule", { value: !0 });
Wd.WS = void 0;
const mB = Ma, gB = li, yB = sr, Si = Xn, vB = hB(zr), bB = qo, wB = (0, vB.default)("engine.io-client:websocket"), fb = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative";
class xB extends mB.Transport {
  /**
   * WebSocket transport constructor.
   *
   * @param {Object} opts - connection options
   * @protected
   */
  constructor(t) {
    super(t), this.supportsBinary = !t.forceBase64;
  }
  get name() {
    return "websocket";
  }
  doOpen() {
    if (!this.check())
      return;
    const t = this.uri(), n = this.opts.protocols, r = fb ? {} : (0, yB.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);
    try {
      this.ws = Si.usingBrowserWebSocket && !fb ? n ? new Si.WebSocket(t, n) : new Si.WebSocket(t) : new Si.WebSocket(t, n, r);
    } catch (i) {
      return this.emitReserved("error", i);
    }
    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();
  }
  /**
   * Adds event listeners to the socket
   *
   * @private
   */
  addEventListeners() {
    this.ws.onopen = () => {
      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();
    }, this.ws.onclose = (t) => this.onClose({
      description: "websocket connection closed",
      context: t
    }), this.ws.onmessage = (t) => this.onData(t.data), this.ws.onerror = (t) => this.onError("websocket error", t);
  }
  write(t) {
    this.writable = !1;
    for (let n = 0; n < t.length; n++) {
      const r = t[n], i = n === t.length - 1;
      (0, bB.encodePacket)(r, this.supportsBinary, (a) => {
        const o = {};
        Si.usingBrowserWebSocket || (r.options && (o.compress = r.options.compress), this.opts.perMessageDeflate && // @ts-ignore
        (typeof a == "string" ? Buffer.byteLength(a) : a.length) < this.opts.perMessageDeflate.threshold && (o.compress = !1));
        try {
          Si.usingBrowserWebSocket ? this.ws.send(a) : this.ws.send(a, o);
        } catch {
          wB("websocket closed before onclose event");
        }
        i && (0, Si.nextTick)(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    typeof this.ws < "u" && (this.ws.close(), this.ws = null);
  }
  /**
   * Generates uri for connection.
   *
   * @private
   */
  uri() {
    const t = this.opts.secure ? "wss" : "ws", n = this.query || {};
    return this.opts.timestampRequests && (n[this.opts.timestampParam] = (0, gB.yeast)()), this.supportsBinary || (n.b64 = 1), this.createUri(t, n);
  }
  /**
   * Feature detection for WebSocket.
   *
   * @return {Boolean} whether this transport is available.
   * @private
   */
  check() {
    return !!Si.WebSocket;
  }
}
Wd.WS = xB;
var Vd = {}, _B = Je && Je.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Vd, "__esModule", { value: !0 });
Vd.WT = void 0;
const SB = Ma, EB = Xn, pb = qo, kB = _B(zr), ds = (0, kB.default)("engine.io-client:webtransport");
class TB extends SB.Transport {
  get name() {
    return "webtransport";
  }
  doOpen() {
    typeof WebTransport == "function" && (this.transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]), this.transport.closed.then(() => {
      ds("transport closed gracefully"), this.onClose();
    }).catch((t) => {
      ds("transport closed due to %s", t), this.onError("webtransport error", t);
    }), this.transport.ready.then(() => {
      this.transport.createBidirectionalStream().then((t) => {
        const n = (0, pb.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType), r = t.readable.pipeThrough(n).getReader(), i = (0, pb.createPacketEncoderStream)();
        i.readable.pipeTo(t.writable), this.writer = i.writable.getWriter();
        const a = () => {
          r.read().then(({ done: s, value: l }) => {
            if (s) {
              ds("session is closed");
              return;
            }
            ds("received chunk: %o", l), this.onPacket(l), a();
          }).catch((s) => {
            ds("an error occurred while reading: %s", s);
          });
        };
        a();
        const o = { type: "open" };
        this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this.writer.write(o).then(() => this.onOpen());
      });
    }));
  }
  write(t) {
    this.writable = !1;
    for (let n = 0; n < t.length; n++) {
      const r = t[n], i = n === t.length - 1;
      this.writer.write(r).then(() => {
        i && (0, EB.nextTick)(() => {
          this.writable = !0, this.emitReserved("drain");
        }, this.setTimeoutFn);
      });
    }
  }
  doClose() {
    var t;
    (t = this.transport) === null || t === void 0 || t.close();
  }
}
Vd.WT = TB;
Object.defineProperty(vl, "__esModule", { value: !0 });
vl.transports = void 0;
const CB = wo, OB = Wd, AB = Vd;
vl.transports = {
  websocket: OB.WS,
  webtransport: AB.WT,
  polling: CB.Polling
};
var bl = {};
Object.defineProperty(bl, "__esModule", { value: !0 });
bl.parse = void 0;
const $B = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, RB = [
  "source",
  "protocol",
  "authority",
  "userInfo",
  "user",
  "password",
  "host",
  "port",
  "relative",
  "path",
  "directory",
  "file",
  "query",
  "anchor"
];
function PB(e) {
  const t = e, n = e.indexOf("["), r = e.indexOf("]");
  n != -1 && r != -1 && (e = e.substring(0, n) + e.substring(n, r).replace(/:/g, ";") + e.substring(r, e.length));
  let i = $B.exec(e || ""), a = {}, o = 14;
  for (; o--; )
    a[RB[o]] = i[o] || "";
  return n != -1 && r != -1 && (a.source = t, a.host = a.host.substring(1, a.host.length - 1).replace(/;/g, ":"), a.authority = a.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), a.ipv6uri = !0), a.pathNames = IB(a, a.path), a.queryKey = MB(a, a.query), a;
}
bl.parse = PB;
function IB(e, t) {
  const n = /\/{2,9}/g, r = t.replace(n, "/").split("/");
  return (t.slice(0, 1) == "/" || t.length === 0) && r.splice(0, 1), t.slice(-1) == "/" && r.splice(r.length - 1, 1), r;
}
function MB(e, t) {
  const n = {};
  return t.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, i, a) {
    i && (n[i] = a);
  }), n;
}
var NB = Je && Je.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(zd, "__esModule", { value: !0 });
zd.Socket = void 0;
const DB = vl, hb = sr, LB = _a, mb = bl, jB = NB(zr), UB = Wo, u1 = qo, FB = Xn, Ft = (0, jB.default)("engine.io-client:socket");
let d1 = class Ka extends UB.Emitter {
  /**
   * Socket constructor.
   *
   * @param {String|Object} uri - uri or options
   * @param {Object} opts - options
   */
  constructor(t, n = {}) {
    super(), this.binaryType = FB.defaultBinaryType, this.writeBuffer = [], t && typeof t == "object" && (n = t, t = null), t ? (t = (0, mb.parse)(t), n.hostname = t.host, n.secure = t.protocol === "https" || t.protocol === "wss", n.port = t.port, t.query && (n.query = t.query)) : n.host && (n.hostname = (0, mb.parse)(n.host).host), (0, hb.installTimerFunctions)(this, n), this.secure = n.secure != null ? n.secure : typeof location < "u" && location.protocol === "https:", n.hostname && !n.port && (n.port = this.secure ? "443" : "80"), this.hostname = n.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = n.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = n.transports || [
      "polling",
      "websocket",
      "webtransport"
    ], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({
      path: "/engine.io",
      agent: !1,
      withCredentials: !1,
      upgrade: !0,
      timestampParam: "t",
      rememberUpgrade: !1,
      addTrailingSlash: !0,
      rejectUnauthorized: !0,
      perMessageDeflate: {
        threshold: 1024
      },
      transportOptions: {},
      closeOnBeforeunload: !1
    }, n), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = (0, LB.decode)(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == "function" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {
      this.transport && (this.transport.removeAllListeners(), this.transport.close());
    }, addEventListener("beforeunload", this.beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this.offlineEventListener = () => {
      this.onClose("transport close", {
        description: "network connection lost"
      });
    }, addEventListener("offline", this.offlineEventListener, !1))), this.open();
  }
  /**
   * Creates transport of the given type.
   *
   * @param {String} name - transport name
   * @return {Transport}
   * @private
   */
  createTransport(t) {
    Ft('creating transport "%s"', t);
    const n = Object.assign({}, this.opts.query);
    n.EIO = u1.protocol, n.transport = t, this.id && (n.sid = this.id);
    const r = Object.assign({}, this.opts, {
      query: n,
      socket: this,
      hostname: this.hostname,
      secure: this.secure,
      port: this.port
    }, this.opts.transportOptions[t]);
    return Ft("options: %j", r), new DB.transports[t](r);
  }
  /**
   * Initializes transport to use and starts probe.
   *
   * @private
   */
  open() {
    let t;
    if (this.opts.rememberUpgrade && Ka.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1)
      t = "websocket";
    else if (this.transports.length === 0) {
      this.setTimeoutFn(() => {
        this.emitReserved("error", "No transports available");
      }, 0);
      return;
    } else
      t = this.transports[0];
    this.readyState = "opening";
    try {
      t = this.createTransport(t);
    } catch (n) {
      Ft("error while creating transport: %s", n), this.transports.shift(), this.open();
      return;
    }
    t.open(), this.setTransport(t);
  }
  /**
   * Sets the current transport. Disables the existing one (if any).
   *
   * @private
   */
  setTransport(t) {
    Ft("setting transport %s", t.name), this.transport && (Ft("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners()), this.transport = t, t.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", (n) => this.onClose("transport close", n));
  }
  /**
   * Probes a transport.
   *
   * @param {String} name - transport name
   * @private
   */
  probe(t) {
    Ft('probing transport "%s"', t);
    let n = this.createTransport(t), r = !1;
    Ka.priorWebsocketSuccess = !1;
    const i = () => {
      r || (Ft('probe transport "%s" opened', t), n.send([{ type: "ping", data: "probe" }]), n.once("packet", (d) => {
        if (!r)
          if (d.type === "pong" && d.data === "probe") {
            if (Ft('probe transport "%s" pong', t), this.upgrading = !0, this.emitReserved("upgrading", n), !n)
              return;
            Ka.priorWebsocketSuccess = n.name === "websocket", Ft('pausing current transport "%s"', this.transport.name), this.transport.pause(() => {
              r || this.readyState !== "closed" && (Ft("changing transport and sending upgrade packet"), u(), this.setTransport(n), n.send([{ type: "upgrade" }]), this.emitReserved("upgrade", n), n = null, this.upgrading = !1, this.flush());
            });
          } else {
            Ft('probe transport "%s" failed', t);
            const p = new Error("probe error");
            p.transport = n.name, this.emitReserved("upgradeError", p);
          }
      }));
    };
    function a() {
      r || (r = !0, u(), n.close(), n = null);
    }
    const o = (d) => {
      const p = new Error("probe error: " + d);
      p.transport = n.name, a(), Ft('probe transport "%s" failed because of error: %s', t, d), this.emitReserved("upgradeError", p);
    };
    function s() {
      o("transport closed");
    }
    function l() {
      o("socket closed");
    }
    function c(d) {
      n && d.name !== n.name && (Ft('"%s" works - aborting "%s"', d.name, n.name), a());
    }
    const u = () => {
      n.removeListener("open", i), n.removeListener("error", o), n.removeListener("close", s), this.off("close", l), this.off("upgrading", c);
    };
    n.once("open", i), n.once("error", o), n.once("close", s), this.once("close", l), this.once("upgrading", c), this.upgrades.indexOf("webtransport") !== -1 && t !== "webtransport" ? this.setTimeoutFn(() => {
      r || n.open();
    }, 200) : n.open();
  }
  /**
   * Called when connection is deemed open.
   *
   * @private
   */
  onOpen() {
    if (Ft("socket open"), this.readyState = "open", Ka.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush(), this.readyState === "open" && this.opts.upgrade) {
      Ft("starting upgrade probes");
      let t = 0;
      const n = this.upgrades.length;
      for (; t < n; t++)
        this.probe(this.upgrades[t]);
    }
  }
  /**
   * Handles a packet.
   *
   * @private
   */
  onPacket(t) {
    if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing")
      switch (Ft('socket receive: type "%s", data "%s"', t.type, t.data), this.emitReserved("packet", t), this.emitReserved("heartbeat"), this.resetPingTimeout(), t.type) {
        case "open":
          this.onHandshake(JSON.parse(t.data));
          break;
        case "ping":
          this.sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong");
          break;
        case "error":
          const n = new Error("server error");
          n.code = t.data, this.onError(n);
          break;
        case "message":
          this.emitReserved("data", t.data), this.emitReserved("message", t.data);
          break;
      }
    else
      Ft('packet received with socket readyState "%s"', this.readyState);
  }
  /**
   * Called upon handshake completion.
   *
   * @param {Object} data - handshake obj
   * @private
   */
  onHandshake(t) {
    this.emitReserved("handshake", t), this.id = t.sid, this.transport.query.sid = t.sid, this.upgrades = this.filterUpgrades(t.upgrades), this.pingInterval = t.pingInterval, this.pingTimeout = t.pingTimeout, this.maxPayload = t.maxPayload, this.onOpen(), this.readyState !== "closed" && this.resetPingTimeout();
  }
  /**
   * Sets and resets ping timeout timer based on server pings.
   *
   * @private
   */
  resetPingTimeout() {
    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {
      this.onClose("ping timeout");
    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();
  }
  /**
   * Called on `drain` event
   *
   * @private
   */
  onDrain() {
    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush();
  }
  /**
   * Flush write buffers.
   *
   * @private
   */
  flush() {
    if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
      const t = this.getWritablePackets();
      Ft("flushing %d packets in socket", t.length), this.transport.send(t), this.prevBufferLen = t.length, this.emitReserved("flush");
    }
  }
  /**
   * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
   * long-polling)
   *
   * @private
   */
  getWritablePackets() {
    if (!(this.maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1))
      return this.writeBuffer;
    let n = 1;
    for (let r = 0; r < this.writeBuffer.length; r++) {
      const i = this.writeBuffer[r].data;
      if (i && (n += (0, hb.byteLength)(i)), r > 0 && n > this.maxPayload)
        return Ft("only send %d out of %d packets", r, this.writeBuffer.length), this.writeBuffer.slice(0, r);
      n += 2;
    }
    return Ft("payload size is %d (max: %d)", n, this.maxPayload), this.writeBuffer;
  }
  /**
   * Sends a message.
   *
   * @param {String} msg - message.
   * @param {Object} options.
   * @param {Function} callback function.
   * @return {Socket} for chaining.
   */
  write(t, n, r) {
    return this.sendPacket("message", t, n, r), this;
  }
  send(t, n, r) {
    return this.sendPacket("message", t, n, r), this;
  }
  /**
   * Sends a packet.
   *
   * @param {String} type: packet type.
   * @param {String} data.
   * @param {Object} options.
   * @param {Function} fn - callback function.
   * @private
   */
  sendPacket(t, n, r, i) {
    if (typeof n == "function" && (i = n, n = void 0), typeof r == "function" && (i = r, r = null), this.readyState === "closing" || this.readyState === "closed")
      return;
    r = r || {}, r.compress = r.compress !== !1;
    const a = {
      type: t,
      data: n,
      options: r
    };
    this.emitReserved("packetCreate", a), this.writeBuffer.push(a), i && this.once("flush", i), this.flush();
  }
  /**
   * Closes the connection.
   */
  close() {
    const t = () => {
      this.onClose("forced close"), Ft("socket closing - telling transport to close"), this.transport.close();
    }, n = () => {
      this.off("upgrade", n), this.off("upgradeError", n), t();
    }, r = () => {
      this.once("upgrade", n), this.once("upgradeError", n);
    };
    return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => {
      this.upgrading ? r() : t();
    }) : this.upgrading ? r() : t()), this;
  }
  /**
   * Called upon transport error
   *
   * @private
   */
  onError(t) {
    Ft("socket error %j", t), Ka.priorWebsocketSuccess = !1, this.emitReserved("error", t), this.onClose("transport error", t);
  }
  /**
   * Called upon transport close.
   *
   * @private
   */
  onClose(t, n) {
    (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") && (Ft('socket close with reason: "%s"', t), this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == "function" && (removeEventListener("beforeunload", this.beforeunloadEventListener, !1), removeEventListener("offline", this.offlineEventListener, !1)), this.readyState = "closed", this.id = null, this.emitReserved("close", t, n), this.writeBuffer = [], this.prevBufferLen = 0);
  }
  /**
   * Filters upgrades, returning only those matching client transports.
   *
   * @param {Array} upgrades - server upgrades
   * @private
   */
  filterUpgrades(t) {
    const n = [];
    let r = 0;
    const i = t.length;
    for (; r < i; r++)
      ~this.transports.indexOf(t[r]) && n.push(t[r]);
    return n;
  }
};
zd.Socket = d1;
d1.protocol = u1.protocol;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.nextTick = e.parse = e.installTimerFunctions = e.transports = e.Transport = e.protocol = e.Socket = void 0;
  const t = zd;
  Object.defineProperty(e, "Socket", { enumerable: !0, get: function() {
    return t.Socket;
  } }), e.protocol = t.Socket.protocol;
  var n = Ma;
  Object.defineProperty(e, "Transport", { enumerable: !0, get: function() {
    return n.Transport;
  } });
  var r = vl;
  Object.defineProperty(e, "transports", { enumerable: !0, get: function() {
    return r.transports;
  } });
  var i = sr;
  Object.defineProperty(e, "installTimerFunctions", { enumerable: !0, get: function() {
    return i.installTimerFunctions;
  } });
  var a = bl;
  Object.defineProperty(e, "parse", { enumerable: !0, get: function() {
    return a.parse;
  } });
  var o = Xn;
  Object.defineProperty(e, "nextTick", { enumerable: !0, get: function() {
    return o.nextTick;
  } });
})(og);
var BB = Je && Je.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Bd, "__esModule", { value: !0 });
Bd.url = void 0;
const zB = og, ZB = BB(zr), gb = ZB.default("socket.io-client:url");
function qB(e, t = "", n) {
  let r = e;
  n = n || typeof location < "u" && location, e == null && (e = n.protocol + "//" + n.host), typeof e == "string" && (e.charAt(0) === "/" && (e.charAt(1) === "/" ? e = n.protocol + e : e = n.host + e), /^(https?|wss?):\/\//.test(e) || (gb("protocol-less url %s", e), typeof n < "u" ? e = n.protocol + "//" + e : e = "https://" + e), gb("parse %s", e), r = zB.parse(e)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/";
  const a = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host;
  return r.id = r.protocol + "://" + a + ":" + r.port + t, r.href = r.protocol + "://" + a + (n && n.port === r.port ? "" : ":" + r.port), r;
}
Bd.url = qB;
var Hd = {}, wl = {}, Kd = {}, Eo = {}, Sa = {};
Object.defineProperty(Sa, "__esModule", { value: !0 });
Sa.hasBinary = Sa.isBinary = void 0;
const WB = typeof ArrayBuffer == "function", VB = (e) => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(e) : e.buffer instanceof ArrayBuffer, f1 = Object.prototype.toString, HB = typeof Blob == "function" || typeof Blob < "u" && f1.call(Blob) === "[object BlobConstructor]", KB = typeof File == "function" || typeof File < "u" && f1.call(File) === "[object FileConstructor]";
function p1(e) {
  return WB && (e instanceof ArrayBuffer || VB(e)) || HB && e instanceof Blob || KB && e instanceof File;
}
Sa.isBinary = p1;
function Cc(e, t) {
  if (!e || typeof e != "object")
    return !1;
  if (Array.isArray(e)) {
    for (let n = 0, r = e.length; n < r; n++)
      if (Cc(e[n]))
        return !0;
    return !1;
  }
  if (p1(e))
    return !0;
  if (e.toJSON && typeof e.toJSON == "function" && arguments.length === 1)
    return Cc(e.toJSON(), !0);
  for (const n in e)
    if (Object.prototype.hasOwnProperty.call(e, n) && Cc(e[n]))
      return !0;
  return !1;
}
Sa.hasBinary = Cc;
Object.defineProperty(Eo, "__esModule", { value: !0 });
Eo.reconstructPacket = Eo.deconstructPacket = void 0;
const GB = Sa;
function JB(e) {
  const t = [], n = e.data, r = e;
  return r.data = Eh(n, t), r.attachments = t.length, { packet: r, buffers: t };
}
Eo.deconstructPacket = JB;
function Eh(e, t) {
  if (!e)
    return e;
  if ((0, GB.isBinary)(e)) {
    const n = { _placeholder: !0, num: t.length };
    return t.push(e), n;
  } else if (Array.isArray(e)) {
    const n = new Array(e.length);
    for (let r = 0; r < e.length; r++)
      n[r] = Eh(e[r], t);
    return n;
  } else if (typeof e == "object" && !(e instanceof Date)) {
    const n = {};
    for (const r in e)
      Object.prototype.hasOwnProperty.call(e, r) && (n[r] = Eh(e[r], t));
    return n;
  }
  return e;
}
function YB(e, t) {
  return e.data = kh(e.data, t), delete e.attachments, e;
}
Eo.reconstructPacket = YB;
function kh(e, t) {
  if (!e)
    return e;
  if (e && e._placeholder === !0) {
    if (typeof e.num == "number" && e.num >= 0 && e.num < t.length)
      return t[e.num];
    throw new Error("illegal attachments");
  } else if (Array.isArray(e))
    for (let n = 0; n < e.length; n++)
      e[n] = kh(e[n], t);
  else if (typeof e == "object")
    for (const n in e)
      Object.prototype.hasOwnProperty.call(e, n) && (e[n] = kh(e[n], t));
  return e;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Decoder = e.Encoder = e.PacketType = e.protocol = void 0;
  const t = Wo, n = Eo, r = Sa, a = (0, zr.default)("socket.io-parser"), o = [
    "connect",
    "connect_error",
    "disconnect",
    "disconnecting",
    "newListener",
    "removeListener"
    // used by the Node.js EventEmitter
  ];
  e.protocol = 5;
  var s;
  (function(p) {
    p[p.CONNECT = 0] = "CONNECT", p[p.DISCONNECT = 1] = "DISCONNECT", p[p.EVENT = 2] = "EVENT", p[p.ACK = 3] = "ACK", p[p.CONNECT_ERROR = 4] = "CONNECT_ERROR", p[p.BINARY_EVENT = 5] = "BINARY_EVENT", p[p.BINARY_ACK = 6] = "BINARY_ACK";
  })(s = e.PacketType || (e.PacketType = {}));
  class l {
    /**
     * Encoder constructor
     *
     * @param {function} replacer - custom replacer to pass down to JSON.parse
     */
    constructor(f) {
      this.replacer = f;
    }
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    encode(f) {
      return a("encoding packet %j", f), (f.type === s.EVENT || f.type === s.ACK) && (0, r.hasBinary)(f) ? this.encodeAsBinary({
        type: f.type === s.EVENT ? s.BINARY_EVENT : s.BINARY_ACK,
        nsp: f.nsp,
        data: f.data,
        id: f.id
      }) : [this.encodeAsString(f)];
    }
    /**
     * Encode packet as string.
     */
    encodeAsString(f) {
      let h = "" + f.type;
      return (f.type === s.BINARY_EVENT || f.type === s.BINARY_ACK) && (h += f.attachments + "-"), f.nsp && f.nsp !== "/" && (h += f.nsp + ","), f.id != null && (h += f.id), f.data != null && (h += JSON.stringify(f.data, this.replacer)), a("encoded %j as %s", f, h), h;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */
    encodeAsBinary(f) {
      const h = (0, n.deconstructPacket)(f), m = this.encodeAsString(h.packet), y = h.buffers;
      return y.unshift(m), y;
    }
  }
  e.Encoder = l;
  function c(p) {
    return Object.prototype.toString.call(p) === "[object Object]";
  }
  class u extends t.Emitter {
    /**
     * Decoder constructor
     *
     * @param {function} reviver - custom reviver to pass down to JSON.stringify
     */
    constructor(f) {
      super(), this.reviver = f;
    }
    /**
     * Decodes an encoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     */
    add(f) {
      let h;
      if (typeof f == "string") {
        if (this.reconstructor)
          throw new Error("got plaintext data when reconstructing a packet");
        h = this.decodeString(f);
        const m = h.type === s.BINARY_EVENT;
        m || h.type === s.BINARY_ACK ? (h.type = m ? s.EVENT : s.ACK, this.reconstructor = new d(h), h.attachments === 0 && super.emitReserved("decoded", h)) : super.emitReserved("decoded", h);
      } else if ((0, r.isBinary)(f) || f.base64)
        if (this.reconstructor)
          h = this.reconstructor.takeBinaryData(f), h && (this.reconstructor = null, super.emitReserved("decoded", h));
        else
          throw new Error("got binary data when not reconstructing a packet");
      else
        throw new Error("Unknown type: " + f);
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */
    decodeString(f) {
      let h = 0;
      const m = {
        type: Number(f.charAt(0))
      };
      if (s[m.type] === void 0)
        throw new Error("unknown packet type " + m.type);
      if (m.type === s.BINARY_EVENT || m.type === s.BINARY_ACK) {
        const g = h + 1;
        for (; f.charAt(++h) !== "-" && h != f.length; )
          ;
        const v = f.substring(g, h);
        if (v != Number(v) || f.charAt(h) !== "-")
          throw new Error("Illegal attachments");
        m.attachments = Number(v);
      }
      if (f.charAt(h + 1) === "/") {
        const g = h + 1;
        for (; ++h && !(f.charAt(h) === "," || h === f.length); )
          ;
        m.nsp = f.substring(g, h);
      } else
        m.nsp = "/";
      const y = f.charAt(h + 1);
      if (y !== "" && Number(y) == y) {
        const g = h + 1;
        for (; ++h; ) {
          const v = f.charAt(h);
          if (v == null || Number(v) != v) {
            --h;
            break;
          }
          if (h === f.length)
            break;
        }
        m.id = Number(f.substring(g, h + 1));
      }
      if (f.charAt(++h)) {
        const g = this.tryParse(f.substr(h));
        if (u.isPayloadValid(m.type, g))
          m.data = g;
        else
          throw new Error("invalid payload");
      }
      return a("decoded %s as %j", f, m), m;
    }
    tryParse(f) {
      try {
        return JSON.parse(f, this.reviver);
      } catch {
        return !1;
      }
    }
    static isPayloadValid(f, h) {
      switch (f) {
        case s.CONNECT:
          return c(h);
        case s.DISCONNECT:
          return h === void 0;
        case s.CONNECT_ERROR:
          return typeof h == "string" || c(h);
        case s.EVENT:
        case s.BINARY_EVENT:
          return Array.isArray(h) && (typeof h[0] == "number" || typeof h[0] == "string" && o.indexOf(h[0]) === -1);
        case s.ACK:
        case s.BINARY_ACK:
          return Array.isArray(h);
      }
    }
    /**
     * Deallocates a parser's resources
     */
    destroy() {
      this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);
    }
  }
  e.Decoder = u;
  class d {
    constructor(f) {
      this.packet = f, this.buffers = [], this.reconPack = f;
    }
    /**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     */
    takeBinaryData(f) {
      if (this.buffers.push(f), this.buffers.length === this.reconPack.attachments) {
        const h = (0, n.reconstructPacket)(this.reconPack, this.buffers);
        return this.finishedReconstruction(), h;
      }
      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */
    finishedReconstruction() {
      this.reconPack = null, this.buffers = [];
    }
  }
})(Kd);
var xl = {};
Object.defineProperty(xl, "__esModule", { value: !0 });
xl.on = void 0;
function XB(e, t, n) {
  return e.on(t, n), function() {
    e.off(t, n);
  };
}
xl.on = XB;
var QB = Je && Je.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(wl, "__esModule", { value: !0 });
wl.Socket = void 0;
const pr = Kd, sc = xl, e3 = Wo, t3 = QB(zr), on = t3.default("socket.io-client:socket"), n3 = Object.freeze({
  connect: 1,
  connect_error: 1,
  disconnect: 1,
  disconnecting: 1,
  // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
  newListener: 1,
  removeListener: 1
});
class r3 extends e3.Emitter {
  /**
   * `Socket` constructor.
   */
  constructor(t, n, r) {
    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = t, this.nsp = n, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();
  }
  /**
   * Whether the socket is currently disconnected
   *
   * @example
   * const socket = io();
   *
   * socket.on("connect", () => {
   *   console.log(socket.disconnected); // false
   * });
   *
   * socket.on("disconnect", () => {
   *   console.log(socket.disconnected); // true
   * });
   */
  get disconnected() {
    return !this.connected;
  }
  /**
   * Subscribe to open, close and packet events
   *
   * @private
   */
  subEvents() {
    if (this.subs)
      return;
    const t = this.io;
    this.subs = [
      sc.on(t, "open", this.onopen.bind(this)),
      sc.on(t, "packet", this.onpacket.bind(this)),
      sc.on(t, "error", this.onerror.bind(this)),
      sc.on(t, "close", this.onclose.bind(this))
    ];
  }
  /**
   * Whether the Socket will try to reconnect when its Manager connects or reconnects.
   *
   * @example
   * const socket = io();
   *
   * console.log(socket.active); // true
   *
   * socket.on("disconnect", (reason) => {
   *   if (reason === "io server disconnect") {
   *     // the disconnection was initiated by the server, you need to manually reconnect
   *     console.log(socket.active); // false
   *   }
   *   // else the socket will automatically try to reconnect
   *   console.log(socket.active); // true
   * });
   */
  get active() {
    return !!this.subs;
  }
  /**
   * "Opens" the socket.
   *
   * @example
   * const socket = io({
   *   autoConnect: false
   * });
   *
   * socket.connect();
   */
  connect() {
    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this);
  }
  /**
   * Alias for {@link connect()}.
   */
  open() {
    return this.connect();
  }
  /**
   * Sends a `message` event.
   *
   * This method mimics the WebSocket.send() method.
   *
   * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
   *
   * @example
   * socket.send("hello");
   *
   * // this is equivalent to
   * socket.emit("message", "hello");
   *
   * @return self
   */
  send(...t) {
    return t.unshift("message"), this.emit.apply(this, t), this;
  }
  /**
   * Override `emit`.
   * If the event is in `events`, it's emitted normally.
   *
   * @example
   * socket.emit("hello", "world");
   *
   * // all serializable datastructures are supported (no need to call JSON.stringify)
   * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
   *
   * // with an acknowledgement from the server
   * socket.emit("hello", "world", (val) => {
   *   // ...
   * });
   *
   * @return self
   */
  emit(t, ...n) {
    if (n3.hasOwnProperty(t))
      throw new Error('"' + t.toString() + '" is a reserved event name');
    if (n.unshift(t), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)
      return this._addToQueue(n), this;
    const r = {
      type: pr.PacketType.EVENT,
      data: n
    };
    if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof n[n.length - 1] == "function") {
      const o = this.ids++;
      on("emitting packet with ack id %d", o);
      const s = n.pop();
      this._registerAckCallback(o, s), r.id = o;
    }
    const i = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
    return this.flags.volatile && (!i || !this.connected) ? on("discard packet as the transport is not currently writable") : this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r), this.flags = {}, this;
  }
  /**
   * @private
   */
  _registerAckCallback(t, n) {
    var r;
    const i = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;
    if (i === void 0) {
      this.acks[t] = n;
      return;
    }
    const a = this.io.setTimeoutFn(() => {
      delete this.acks[t];
      for (let o = 0; o < this.sendBuffer.length; o++)
        this.sendBuffer[o].id === t && (on("removing packet with ack id %d from the buffer", t), this.sendBuffer.splice(o, 1));
      on("event with ack id %d has timed out after %d ms", t, i), n.call(this, new Error("operation has timed out"));
    }, i);
    this.acks[t] = (...o) => {
      this.io.clearTimeoutFn(a), n.apply(this, [null, ...o]);
    };
  }
  /**
   * Emits an event and waits for an acknowledgement
   *
   * @example
   * // without timeout
   * const response = await socket.emitWithAck("hello", "world");
   *
   * // with a specific timeout
   * try {
   *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
   * } catch (err) {
   *   // the server did not acknowledge the event in the given delay
   * }
   *
   * @return a Promise that will be fulfilled when the server acknowledges the event
   */
  emitWithAck(t, ...n) {
    const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;
    return new Promise((i, a) => {
      n.push((o, s) => r ? o ? a(o) : i(s) : i(o)), this.emit(t, ...n);
    });
  }
  /**
   * Add the packet to the queue.
   * @param args
   * @private
   */
  _addToQueue(t) {
    let n;
    typeof t[t.length - 1] == "function" && (n = t.pop());
    const r = {
      id: this._queueSeq++,
      tryCount: 0,
      pending: !1,
      args: t,
      flags: Object.assign({ fromQueue: !0 }, this.flags)
    };
    t.push((i, ...a) => r !== this._queue[0] ? void 0 : (i !== null ? r.tryCount > this._opts.retries && (on("packet [%d] is discarded after %d tries", r.id, r.tryCount), this._queue.shift(), n && n(i)) : (on("packet [%d] was successfully sent", r.id), this._queue.shift(), n && n(null, ...a)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue();
  }
  /**
   * Send the first packet of the queue, and wait for an acknowledgement from the server.
   * @param force - whether to resend a packet that has not been acknowledged yet
   *
   * @private
   */
  _drainQueue(t = !1) {
    if (on("draining queue"), !this.connected || this._queue.length === 0)
      return;
    const n = this._queue[0];
    if (n.pending && !t) {
      on("packet [%d] has already been sent and is waiting for an ack", n.id);
      return;
    }
    n.pending = !0, n.tryCount++, on("sending packet [%d] (try n%d)", n.id, n.tryCount), this.flags = n.flags, this.emit.apply(this, n.args);
  }
  /**
   * Sends a packet.
   *
   * @param packet
   * @private
   */
  packet(t) {
    t.nsp = this.nsp, this.io._packet(t);
  }
  /**
   * Called upon engine `open`.
   *
   * @private
   */
  onopen() {
    on("transport is open - connecting"), typeof this.auth == "function" ? this.auth((t) => {
      this._sendConnectPacket(t);
    }) : this._sendConnectPacket(this.auth);
  }
  /**
   * Sends a CONNECT packet to initiate the Socket.IO session.
   *
   * @param data
   * @private
   */
  _sendConnectPacket(t) {
    this.packet({
      type: pr.PacketType.CONNECT,
      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, t) : t
    });
  }
  /**
   * Called upon engine or manager `error`.
   *
   * @param err
   * @private
   */
  onerror(t) {
    this.connected || this.emitReserved("connect_error", t);
  }
  /**
   * Called upon engine `close`.
   *
   * @param reason
   * @param description
   * @private
   */
  onclose(t, n) {
    on("close (%s)", t), this.connected = !1, delete this.id, this.emitReserved("disconnect", t, n);
  }
  /**
   * Called with socket packet.
   *
   * @param packet
   * @private
   */
  onpacket(t) {
    if (t.nsp === this.nsp)
      switch (t.type) {
        case pr.PacketType.CONNECT:
          t.data && t.data.sid ? this.onconnect(t.data.sid, t.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          break;
        case pr.PacketType.EVENT:
        case pr.PacketType.BINARY_EVENT:
          this.onevent(t);
          break;
        case pr.PacketType.ACK:
        case pr.PacketType.BINARY_ACK:
          this.onack(t);
          break;
        case pr.PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case pr.PacketType.CONNECT_ERROR:
          this.destroy();
          const r = new Error(t.data.message);
          r.data = t.data.data, this.emitReserved("connect_error", r);
          break;
      }
  }
  /**
   * Called upon a server event.
   *
   * @param packet
   * @private
   */
  onevent(t) {
    const n = t.data || [];
    on("emitting event %j", n), t.id != null && (on("attaching ack callback to event"), n.push(this.ack(t.id))), this.connected ? this.emitEvent(n) : this.receiveBuffer.push(Object.freeze(n));
  }
  emitEvent(t) {
    if (this._anyListeners && this._anyListeners.length) {
      const n = this._anyListeners.slice();
      for (const r of n)
        r.apply(this, t);
    }
    super.emit.apply(this, t), this._pid && t.length && typeof t[t.length - 1] == "string" && (this._lastOffset = t[t.length - 1]);
  }
  /**
   * Produces an ack callback to emit with an event.
   *
   * @private
   */
  ack(t) {
    const n = this;
    let r = !1;
    return function(...i) {
      r || (r = !0, on("sending ack %j", i), n.packet({
        type: pr.PacketType.ACK,
        id: t,
        data: i
      }));
    };
  }
  /**
   * Called upon a server acknowlegement.
   *
   * @param packet
   * @private
   */
  onack(t) {
    const n = this.acks[t.id];
    typeof n == "function" ? (on("calling ack %s with %j", t.id, t.data), n.apply(this, t.data), delete this.acks[t.id]) : on("bad ack %s", t.id);
  }
  /**
   * Called upon server connect.
   *
   * @private
   */
  onconnect(t, n) {
    on("socket connected with id %s", t), this.id = t, this.recovered = n && this._pid === n, this._pid = n, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0);
  }
  /**
   * Emit buffered events (received and emitted).
   *
   * @private
   */
  emitBuffered() {
    this.receiveBuffer.forEach((t) => this.emitEvent(t)), this.receiveBuffer = [], this.sendBuffer.forEach((t) => {
      this.notifyOutgoingListeners(t), this.packet(t);
    }), this.sendBuffer = [];
  }
  /**
   * Called upon server disconnect.
   *
   * @private
   */
  ondisconnect() {
    on("server disconnect (%s)", this.nsp), this.destroy(), this.onclose("io server disconnect");
  }
  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don't get triggered for this.
   *
   * @private
   */
  destroy() {
    this.subs && (this.subs.forEach((t) => t()), this.subs = void 0), this.io._destroy(this);
  }
  /**
   * Disconnects the socket manually. In that case, the socket will not try to reconnect.
   *
   * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
   *
   * @example
   * const socket = io();
   *
   * socket.on("disconnect", (reason) => {
   *   // console.log(reason); prints "io client disconnect"
   * });
   *
   * socket.disconnect();
   *
   * @return self
   */
  disconnect() {
    return this.connected && (on("performing disconnect (%s)", this.nsp), this.packet({ type: pr.PacketType.DISCONNECT })), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
  }
  /**
   * Alias for {@link disconnect()}.
   *
   * @return self
   */
  close() {
    return this.disconnect();
  }
  /**
   * Sets the compress flag.
   *
   * @example
   * socket.compress(false).emit("hello");
   *
   * @param compress - if `true`, compresses the sending data
   * @return self
   */
  compress(t) {
    return this.flags.compress = t, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
   * ready to send messages.
   *
   * @example
   * socket.volatile.emit("hello"); // the server may or may not receive it
   *
   * @returns self
   */
  get volatile() {
    return this.flags.volatile = !0, this;
  }
  /**
   * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
   * given number of milliseconds have elapsed without an acknowledgement from the server:
   *
   * @example
   * socket.timeout(5000).emit("my-event", (err) => {
   *   if (err) {
   *     // the server did not acknowledge the event in the given delay
   *   }
   * });
   *
   * @returns self
   */
  timeout(t) {
    return this.flags.timeout = t, this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * @example
   * socket.onAny((event, ...args) => {
   *   console.log(`got ${event}`);
   * });
   *
   * @param listener
   */
  onAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * @example
   * socket.prependAny((event, ...args) => {
   *   console.log(`got event ${event}`);
   * });
   *
   * @param listener
   */
  prependAny(t) {
    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`got event ${event}`);
   * }
   *
   * socket.onAny(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAny(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAny();
   *
   * @param listener
   */
  offAny(t) {
    if (!this._anyListeners)
      return this;
    if (t) {
      const n = this._anyListeners;
      for (let r = 0; r < n.length; r++)
        if (t === n[r])
          return n.splice(r, 1), this;
    } else
      this._anyListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAny() {
    return this._anyListeners || [];
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.onAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  onAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(t), this;
  }
  /**
   * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
   * callback. The listener is added to the beginning of the listeners array.
   *
   * Note: acknowledgements sent to the server are not included.
   *
   * @example
   * socket.prependAnyOutgoing((event, ...args) => {
   *   console.log(`sent event ${event}`);
   * });
   *
   * @param listener
   */
  prependAnyOutgoing(t) {
    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(t), this;
  }
  /**
   * Removes the listener that will be fired when any event is emitted.
   *
   * @example
   * const catchAllListener = (event, ...args) => {
   *   console.log(`sent event ${event}`);
   * }
   *
   * socket.onAnyOutgoing(catchAllListener);
   *
   * // remove a specific listener
   * socket.offAnyOutgoing(catchAllListener);
   *
   * // or remove all listeners
   * socket.offAnyOutgoing();
   *
   * @param [listener] - the catch-all listener (optional)
   */
  offAnyOutgoing(t) {
    if (!this._anyOutgoingListeners)
      return this;
    if (t) {
      const n = this._anyOutgoingListeners;
      for (let r = 0; r < n.length; r++)
        if (t === n[r])
          return n.splice(r, 1), this;
    } else
      this._anyOutgoingListeners = [];
    return this;
  }
  /**
   * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
   * e.g. to remove listeners.
   */
  listenersAnyOutgoing() {
    return this._anyOutgoingListeners || [];
  }
  /**
   * Notify the listeners for each packet sent
   *
   * @param packet
   *
   * @private
   */
  notifyOutgoingListeners(t) {
    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
      const n = this._anyOutgoingListeners.slice();
      for (const r of n)
        r.apply(this, t.data);
    }
  }
}
wl.Socket = r3;
var Gd = {};
Object.defineProperty(Gd, "__esModule", { value: !0 });
Gd.Backoff = void 0;
function Vo(e) {
  e = e || {}, this.ms = e.min || 100, this.max = e.max || 1e4, this.factor = e.factor || 2, this.jitter = e.jitter > 0 && e.jitter <= 1 ? e.jitter : 0, this.attempts = 0;
}
Gd.Backoff = Vo;
Vo.prototype.duration = function() {
  var e = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var t = Math.random(), n = Math.floor(t * this.jitter * e);
    e = Math.floor(t * 10) & 1 ? e + n : e - n;
  }
  return Math.min(e, this.max) | 0;
};
Vo.prototype.reset = function() {
  this.attempts = 0;
};
Vo.prototype.setMin = function(e) {
  this.ms = e;
};
Vo.prototype.setMax = function(e) {
  this.max = e;
};
Vo.prototype.setJitter = function(e) {
  this.jitter = e;
};
var i3 = Je && Je.__createBinding || (Object.create ? function(e, t, n, r) {
  r === void 0 && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function() {
    return t[n];
  } });
} : function(e, t, n, r) {
  r === void 0 && (r = n), e[r] = t[n];
}), a3 = Je && Je.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), o3 = Je && Je.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.prototype.hasOwnProperty.call(e, n) && i3(t, e, n);
  return a3(t, e), t;
}, s3 = Je && Je.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Hd, "__esModule", { value: !0 });
Hd.Manager = void 0;
const xp = og, l3 = wl, c3 = o3(Kd), ra = xl, u3 = Gd, d3 = Wo, f3 = s3(zr), yn = f3.default("socket.io-client:manager");
class p3 extends d3.Emitter {
  constructor(t, n) {
    var r;
    super(), this.nsps = {}, this.subs = [], t && typeof t == "object" && (n = t, t = void 0), n = n || {}, n.path = n.path || "/socket.io", this.opts = n, xp.installTimerFunctions(this, n), this.reconnection(n.reconnection !== !1), this.reconnectionAttempts(n.reconnectionAttempts || 1 / 0), this.reconnectionDelay(n.reconnectionDelay || 1e3), this.reconnectionDelayMax(n.reconnectionDelayMax || 5e3), this.randomizationFactor((r = n.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new u3.Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    }), this.timeout(n.timeout == null ? 2e4 : n.timeout), this._readyState = "closed", this.uri = t;
    const i = n.parser || c3;
    this.encoder = new i.Encoder(), this.decoder = new i.Decoder(), this._autoConnect = n.autoConnect !== !1, this._autoConnect && this.open();
  }
  reconnection(t) {
    return arguments.length ? (this._reconnection = !!t, this) : this._reconnection;
  }
  reconnectionAttempts(t) {
    return t === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = t, this);
  }
  reconnectionDelay(t) {
    var n;
    return t === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = t, (n = this.backoff) === null || n === void 0 || n.setMin(t), this);
  }
  randomizationFactor(t) {
    var n;
    return t === void 0 ? this._randomizationFactor : (this._randomizationFactor = t, (n = this.backoff) === null || n === void 0 || n.setJitter(t), this);
  }
  reconnectionDelayMax(t) {
    var n;
    return t === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = t, (n = this.backoff) === null || n === void 0 || n.setMax(t), this);
  }
  timeout(t) {
    return arguments.length ? (this._timeout = t, this) : this._timeout;
  }
  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @private
   */
  maybeReconnectOnOpen() {
    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();
  }
  /**
   * Sets the current transport `socket`.
   *
   * @param {Function} fn - optional, callback
   * @return self
   * @public
   */
  open(t) {
    if (yn("readyState %s", this._readyState), ~this._readyState.indexOf("open"))
      return this;
    yn("opening %s", this.uri), this.engine = new xp.Socket(this.uri, this.opts);
    const n = this.engine, r = this;
    this._readyState = "opening", this.skipReconnect = !1;
    const i = ra.on(n, "open", function() {
      r.onopen(), t && t();
    }), a = (s) => {
      yn("error"), this.cleanup(), this._readyState = "closed", this.emitReserved("error", s), t ? t(s) : this.maybeReconnectOnOpen();
    }, o = ra.on(n, "error", a);
    if (this._timeout !== !1) {
      const s = this._timeout;
      yn("connect attempt will timeout after %d", s);
      const l = this.setTimeoutFn(() => {
        yn("connect attempt timed out after %d", s), i(), a(new Error("timeout")), n.close();
      }, s);
      this.opts.autoUnref && l.unref(), this.subs.push(() => {
        this.clearTimeoutFn(l);
      });
    }
    return this.subs.push(i), this.subs.push(o), this;
  }
  /**
   * Alias for open()
   *
   * @return self
   * @public
   */
  connect(t) {
    return this.open(t);
  }
  /**
   * Called upon transport open.
   *
   * @private
   */
  onopen() {
    yn("open"), this.cleanup(), this._readyState = "open", this.emitReserved("open");
    const t = this.engine;
    this.subs.push(ra.on(t, "ping", this.onping.bind(this)), ra.on(t, "data", this.ondata.bind(this)), ra.on(t, "error", this.onerror.bind(this)), ra.on(t, "close", this.onclose.bind(this)), ra.on(this.decoder, "decoded", this.ondecoded.bind(this)));
  }
  /**
   * Called upon a ping.
   *
   * @private
   */
  onping() {
    this.emitReserved("ping");
  }
  /**
   * Called with data.
   *
   * @private
   */
  ondata(t) {
    try {
      this.decoder.add(t);
    } catch (n) {
      this.onclose("parse error", n);
    }
  }
  /**
   * Called when parser fully decodes a packet.
   *
   * @private
   */
  ondecoded(t) {
    xp.nextTick(() => {
      this.emitReserved("packet", t);
    }, this.setTimeoutFn);
  }
  /**
   * Called upon socket error.
   *
   * @private
   */
  onerror(t) {
    yn("error", t), this.emitReserved("error", t);
  }
  /**
   * Creates a new socket for the given `nsp`.
   *
   * @return {Socket}
   * @public
   */
  socket(t, n) {
    let r = this.nsps[t];
    return r ? this._autoConnect && !r.active && r.connect() : (r = new l3.Socket(this, t, n), this.nsps[t] = r), r;
  }
  /**
   * Called upon a socket close.
   *
   * @param socket
   * @private
   */
  _destroy(t) {
    const n = Object.keys(this.nsps);
    for (const r of n)
      if (this.nsps[r].active) {
        yn("socket %s is still active, skipping close", r);
        return;
      }
    this._close();
  }
  /**
   * Writes a packet.
   *
   * @param packet
   * @private
   */
  _packet(t) {
    yn("writing packet %j", t);
    const n = this.encoder.encode(t);
    for (let r = 0; r < n.length; r++)
      this.engine.write(n[r], t.options);
  }
  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @private
   */
  cleanup() {
    yn("cleanup"), this.subs.forEach((t) => t()), this.subs.length = 0, this.decoder.destroy();
  }
  /**
   * Close the current socket.
   *
   * @private
   */
  _close() {
    yn("disconnect"), this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close"), this.engine && this.engine.close();
  }
  /**
   * Alias for close()
   *
   * @private
   */
  disconnect() {
    return this._close();
  }
  /**
   * Called upon engine close.
   *
   * @private
   */
  onclose(t, n) {
    yn("closed due to %s", t), this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", t, n), this._reconnection && !this.skipReconnect && this.reconnect();
  }
  /**
   * Attempt a reconnection.
   *
   * @private
   */
  reconnect() {
    if (this._reconnecting || this.skipReconnect)
      return this;
    const t = this;
    if (this.backoff.attempts >= this._reconnectionAttempts)
      yn("reconnect failed"), this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1;
    else {
      const n = this.backoff.duration();
      yn("will wait %dms before reconnect attempt", n), this._reconnecting = !0;
      const r = this.setTimeoutFn(() => {
        t.skipReconnect || (yn("attempting reconnect"), this.emitReserved("reconnect_attempt", t.backoff.attempts), !t.skipReconnect && t.open((i) => {
          i ? (yn("reconnect attempt error"), t._reconnecting = !1, t.reconnect(), this.emitReserved("reconnect_error", i)) : (yn("reconnect success"), t.onreconnect());
        }));
      }, n);
      this.opts.autoUnref && r.unref(), this.subs.push(() => {
        this.clearTimeoutFn(r);
      });
    }
  }
  /**
   * Called upon successful reconnect.
   *
   * @private
   */
  onreconnect() {
    const t = this.backoff.attempts;
    this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", t);
  }
}
Hd.Manager = p3;
(function(e, t) {
  var n = Je && Je.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.default = t.connect = t.io = t.Socket = t.Manager = t.protocol = void 0;
  const r = Bd, i = Hd;
  Object.defineProperty(t, "Manager", { enumerable: !0, get: function() {
    return i.Manager;
  } });
  const a = wl;
  Object.defineProperty(t, "Socket", { enumerable: !0, get: function() {
    return a.Socket;
  } });
  const s = n(zr).default("socket.io-client"), l = {};
  function c(d, p) {
    typeof d == "object" && (p = d, d = void 0), p = p || {};
    const f = r.url(d, p.path || "/socket.io"), h = f.source, m = f.id, y = f.path, g = l[m] && y in l[m].nsps, v = p.forceNew || p["force new connection"] || p.multiplex === !1 || g;
    let b;
    return v ? (s("ignoring socket cache for %s", h), b = new i.Manager(h, p)) : (l[m] || (s("new io instance for %s", h), l[m] = new i.Manager(h, p)), b = l[m]), f.query && !p.query && (p.query = f.queryKey), b.socket(f.path, p);
  }
  t.io = c, t.connect = c, t.default = c, Object.assign(c, {
    Manager: i.Manager,
    Socket: a.Socket,
    io: c,
    connect: c
  });
  var u = Kd;
  Object.defineProperty(t, "protocol", { enumerable: !0, get: function() {
    return u.protocol;
  } }), e.exports = c;
})(xh, xh.exports);
var h3 = xh.exports;
(function(e) {
  var t = Je && Je.__awaiter || function(l, c, u, d) {
    function p(f) {
      return f instanceof u ? f : new u(function(h) {
        h(f);
      });
    }
    return new (u || (u = Promise))(function(f, h) {
      function m(v) {
        try {
          g(d.next(v));
        } catch (b) {
          h(b);
        }
      }
      function y(v) {
        try {
          g(d.throw(v));
        } catch (b) {
          h(b);
        }
      }
      function g(v) {
        v.done ? f(v.value) : p(v.value).then(m, y);
      }
      g((d = d.apply(l, c || [])).next());
    });
  }, n = Je && Je.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.SocketComEmitter = e.SocketComEvents = e.SocketCom = void 0;
  const r = ag, i = n(h3);
  class a {
    constructor(c) {
      this.url = c, this.pending = {}, this.emitter = new s(), this.events = this.emitter;
    }
    connect(c, u) {
      return t(this, void 0, void 0, function* () {
        return new Promise((d, p) => {
          this.disconnect(), this.socket = (0, i.default)(this.url, {
            transports: ["websocket"],
            auth: c,
            autoConnect: !1,
            query: u
          });
          const f = setTimeout(() => {
            p("connection timed out");
          }, 5e3);
          this.socket.on("login", (h) => t(this, void 0, void 0, function* () {
            clearTimeout(f), d(h);
          })), this.socket.on("connect_error", (h) => {
            var m;
            (m = this.socket) === null || m === void 0 || m.close(), clearTimeout(f), p(h.message);
          }), this.socket.on("message", (h) => t(this, void 0, void 0, function* () {
            var m;
            this.pending[h.request] && (!((m = h.data) === null || m === void 0) && m.error ? this.pending[h.request].reject(new Error(h.data.message)) : this.pending[h.request].resolve(h.data), delete this.pending[h.request]), yield this.emitter.emit(o.Message, h);
          })), this.socket.connect();
        });
      });
    }
    disconnect() {
      var c;
      this.socket && !(!((c = this.socket) === null || c === void 0) && c.disconnected) && this.socket.disconnect();
    }
    request(c, u) {
      var d;
      return t(this, void 0, void 0, function* () {
        if (!(!((d = this.socket) === null || d === void 0) && d.connected))
          throw new Error("Client is disconnected");
        const p = this.random(32), f = new Promise((h, m) => {
          this.pending[p] = { resolve: h, reject: m };
        });
        return this.socket.send({ request: p, type: c, data: u }), f;
      });
    }
    random(c) {
      const u = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      let d = "";
      for (let p = 0; p < c; p++)
        d += u.charAt(Math.floor(Math.random() * u.length));
      return d;
    }
  }
  e.SocketCom = a;
  var o;
  (function(l) {
    l.Message = "message";
  })(o = e.SocketComEvents || (e.SocketComEvents = {}));
  class s extends r.Emitter {
  }
  e.SocketComEmitter = s;
})(e1);
var Jd = {}, m3 = Je && Je.__awaiter || function(e, t, n, r) {
  function i(a) {
    return a instanceof n ? a : new n(function(o) {
      o(a);
    });
  }
  return new (n || (n = Promise))(function(a, o) {
    function s(u) {
      try {
        c(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      u.done ? a(u.value) : i(u.value).then(s, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
};
Object.defineProperty(Jd, "__esModule", { value: !0 });
Jd.SocketEmitter = void 0;
class g3 {
  constructor() {
    this.listeners = {};
  }
  on(t, n) {
    const r = this.listeners[t];
    r ? r.push(n) : this.listeners[t] = [n];
  }
  removeListeners(t) {
    this.listeners[t] = [];
  }
  emit(t, n) {
    return m3(this, void 0, void 0, function* () {
      const r = this.listeners[t];
      if (r != null && r.length) {
        for (const i of r)
          yield i(n);
        return !0;
      } else
        return !1;
    });
  }
}
Jd.SocketEmitter = g3;
var Bn = Je && Je.__awaiter || function(e, t, n, r) {
  function i(a) {
    return a instanceof n ? a : new n(function(o) {
      o(a);
    });
  }
  return new (n || (n = Promise))(function(a, o) {
    function s(u) {
      try {
        c(r.next(u));
      } catch (d) {
        o(d);
      }
    }
    function l(u) {
      try {
        c(r.throw(u));
      } catch (d) {
        o(d);
      }
    }
    function c(u) {
      u.done ? a(u.value) : i(u.value).then(s, l);
    }
    c((r = r.apply(e, t || [])).next());
  });
};
Object.defineProperty(Fd, "__esModule", { value: !0 });
Fd.MessagingSocket = void 0;
const yb = e1, y3 = Jd;
class v3 extends y3.SocketEmitter {
  constructor(t) {
    super(), this.clientId = t.clientId, this.com = new yb.SocketCom(t.url), this.com.events.on(yb.SocketComEvents.Message, (n) => Bn(this, void 0, void 0, function* () {
      n.type === "message.new" && (yield this.emit("message", n.data.message));
    }));
  }
  get creds() {
    return this._creds;
  }
  get userId() {
    var t;
    return (t = this._creds) === null || t === void 0 ? void 0 : t.userId;
  }
  get conversationId() {
    return this._conversationId;
  }
  connect(t, n) {
    return Bn(this, void 0, void 0, function* () {
      const r = n ? { userData: JSON.stringify(n) } : void 0, i = yield this.com.connect({ clientId: this.clientId, creds: t }, r);
      return i.userId === (t == null ? void 0 : t.userId) && !i.userToken && (i.userToken = t.userToken), this._creds = i, yield this.emit("connect", this._creds), yield this.emit("user", this._creds.userId), i;
    });
  }
  disconnect() {
    return Bn(this, void 0, void 0, function* () {
      this.com.disconnect(), yield this.emit("disconnect", void 0);
    });
  }
  getUser() {
    return Bn(this, void 0, void 0, function* () {
      return this.request("users.get", {});
    });
  }
  switchConversation(t) {
    return Bn(this, void 0, void 0, function* () {
      this._conversationId = t, yield this.emit("conversation", this._conversationId);
    });
  }
  createConversation(t) {
    return Bn(this, void 0, void 0, function* () {
      const n = yield this.request("conversations.create", {});
      return (t == null ? void 0 : t.switch) !== !1 && (yield this.switchConversation(n.id)), n;
    });
  }
  startConversation(t) {
    return Bn(this, void 0, void 0, function* () {
      yield this.request("conversations.start", { id: t || this._conversationId });
    });
  }
  getConversation(t) {
    return Bn(this, void 0, void 0, function* () {
      return this.request("conversations.get", {
        id: t || this._conversationId
      });
    });
  }
  deleteConversation(t) {
    return Bn(this, void 0, void 0, function* () {
      const n = yield this.request("conversations.delete", {
        id: t || this._conversationId
      });
      return n && (yield this.switchConversation(void 0)), n;
    });
  }
  listConversations(t) {
    return Bn(this, void 0, void 0, function* () {
      return this.request("conversations.list", {
        limit: t || 20
      });
    });
  }
  sendText(t) {
    return Bn(this, void 0, void 0, function* () {
      return this.request("messages.create", {
        conversationId: this._conversationId,
        payload: { type: "text", text: t }
      });
    });
  }
  sendPayload(t) {
    return Bn(this, void 0, void 0, function* () {
      return this.request("messages.create", {
        conversationId: this._conversationId,
        payload: t
      });
    });
  }
  listMessages(t) {
    return Bn(this, void 0, void 0, function* () {
      return this.request("messages.list", {
        conversationId: this._conversationId,
        limit: t || 20
      });
    });
  }
  sendFeedback(t, n) {
    return Bn(this, void 0, void 0, function* () {
      yield this.request("messages.feedback", {
        messageId: t,
        feedback: n
      });
    });
  }
  request(t, n) {
    return this.com.request(t, n);
  }
}
Fd.MessagingSocket = v3;
(function(e) {
  var t = Je && Je.__createBinding || (Object.create ? function(r, i, a, o) {
    o === void 0 && (o = a), Object.defineProperty(r, o, { enumerable: !0, get: function() {
      return i[a];
    } });
  } : function(r, i, a, o) {
    o === void 0 && (o = a), r[o] = i[a];
  }), n = Je && Je.__exportStar || function(r, i) {
    for (var a in r)
      a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && t(i, r, a);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), n(ag, e), n(Fd, e);
})(V_);
var h1 = { exports: {} };
function b3() {
  this.__data__ = [], this.size = 0;
}
var w3 = b3;
function x3(e, t) {
  return e === t || e !== e && t !== t;
}
var _l = x3, _3 = _l;
function S3(e, t) {
  for (var n = e.length; n--; )
    if (_3(e[n][0], t))
      return n;
  return -1;
}
var Yd = S3, E3 = Yd, k3 = Array.prototype, T3 = k3.splice;
function C3(e) {
  var t = this.__data__, n = E3(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : T3.call(t, n, 1), --this.size, !0;
}
var O3 = C3, A3 = Yd;
function $3(e) {
  var t = this.__data__, n = A3(t, e);
  return n < 0 ? void 0 : t[n][1];
}
var R3 = $3, P3 = Yd;
function I3(e) {
  return P3(this.__data__, e) > -1;
}
var M3 = I3, N3 = Yd;
function D3(e, t) {
  var n = this.__data__, r = N3(n, e);
  return r < 0 ? (++this.size, n.push([e, t])) : n[r][1] = t, this;
}
var L3 = D3, j3 = w3, U3 = O3, F3 = R3, B3 = M3, z3 = L3;
function Ho(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Ho.prototype.clear = j3;
Ho.prototype.delete = U3;
Ho.prototype.get = F3;
Ho.prototype.has = B3;
Ho.prototype.set = z3;
var Xd = Ho, Z3 = Xd;
function q3() {
  this.__data__ = new Z3(), this.size = 0;
}
var W3 = q3;
function V3(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
var H3 = V3;
function K3(e) {
  return this.__data__.get(e);
}
var G3 = K3;
function J3(e) {
  return this.__data__.has(e);
}
var Y3 = J3, X3 = typeof Je == "object" && Je && Je.Object === Object && Je, m1 = X3, Q3 = m1, e5 = typeof self == "object" && self && self.Object === Object && self, t5 = Q3 || e5 || Function("return this")(), Zr = t5, n5 = Zr, r5 = n5.Symbol, Ko = r5, vb = Ko, g1 = Object.prototype, i5 = g1.hasOwnProperty, a5 = g1.toString, fs = vb ? vb.toStringTag : void 0;
function o5(e) {
  var t = i5.call(e, fs), n = e[fs];
  try {
    e[fs] = void 0;
    var r = !0;
  } catch {
  }
  var i = a5.call(e);
  return r && (t ? e[fs] = n : delete e[fs]), i;
}
var s5 = o5, l5 = Object.prototype, c5 = l5.toString;
function u5(e) {
  return c5.call(e);
}
var d5 = u5, bb = Ko, f5 = s5, p5 = d5, h5 = "[object Null]", m5 = "[object Undefined]", wb = bb ? bb.toStringTag : void 0;
function g5(e) {
  return e == null ? e === void 0 ? m5 : h5 : wb && wb in Object(e) ? f5(e) : p5(e);
}
var Da = g5;
function y5(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var qr = y5, v5 = Da, b5 = qr, w5 = "[object AsyncFunction]", x5 = "[object Function]", _5 = "[object GeneratorFunction]", S5 = "[object Proxy]";
function E5(e) {
  if (!b5(e))
    return !1;
  var t = v5(e);
  return t == x5 || t == _5 || t == w5 || t == S5;
}
var lg = E5, k5 = Zr, T5 = k5["__core-js_shared__"], C5 = T5, _p = C5, xb = function() {
  var e = /[^.]+$/.exec(_p && _p.keys && _p.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function O5(e) {
  return !!xb && xb in e;
}
var A5 = O5, $5 = Function.prototype, R5 = $5.toString;
function P5(e) {
  if (e != null) {
    try {
      return R5.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var y1 = P5, I5 = lg, M5 = A5, N5 = qr, D5 = y1, L5 = /[\\^$.*+?()[\]{}|]/g, j5 = /^\[object .+?Constructor\]$/, U5 = Function.prototype, F5 = Object.prototype, B5 = U5.toString, z5 = F5.hasOwnProperty, Z5 = RegExp(
  "^" + B5.call(z5).replace(L5, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function q5(e) {
  if (!N5(e) || M5(e))
    return !1;
  var t = I5(e) ? Z5 : j5;
  return t.test(D5(e));
}
var W5 = q5;
function V5(e, t) {
  return e == null ? void 0 : e[t];
}
var H5 = V5, K5 = W5, G5 = H5;
function J5(e, t) {
  var n = G5(e, t);
  return K5(n) ? n : void 0;
}
var La = J5, Y5 = La, X5 = Zr, Q5 = Y5(X5, "Map"), cg = Q5, ez = La, tz = ez(Object, "create"), Qd = tz, _b = Qd;
function nz() {
  this.__data__ = _b ? _b(null) : {}, this.size = 0;
}
var rz = nz;
function iz(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var az = iz, oz = Qd, sz = "__lodash_hash_undefined__", lz = Object.prototype, cz = lz.hasOwnProperty;
function uz(e) {
  var t = this.__data__;
  if (oz) {
    var n = t[e];
    return n === sz ? void 0 : n;
  }
  return cz.call(t, e) ? t[e] : void 0;
}
var dz = uz, fz = Qd, pz = Object.prototype, hz = pz.hasOwnProperty;
function mz(e) {
  var t = this.__data__;
  return fz ? t[e] !== void 0 : hz.call(t, e);
}
var gz = mz, yz = Qd, vz = "__lodash_hash_undefined__";
function bz(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = yz && t === void 0 ? vz : t, this;
}
var wz = bz, xz = rz, _z = az, Sz = dz, Ez = gz, kz = wz;
function Go(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Go.prototype.clear = xz;
Go.prototype.delete = _z;
Go.prototype.get = Sz;
Go.prototype.has = Ez;
Go.prototype.set = kz;
var Tz = Go, Sb = Tz, Cz = Xd, Oz = cg;
function Az() {
  this.size = 0, this.__data__ = {
    hash: new Sb(),
    map: new (Oz || Cz)(),
    string: new Sb()
  };
}
var $z = Az;
function Rz(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
var Pz = Rz, Iz = Pz;
function Mz(e, t) {
  var n = e.__data__;
  return Iz(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
var ef = Mz, Nz = ef;
function Dz(e) {
  var t = Nz(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
var Lz = Dz, jz = ef;
function Uz(e) {
  return jz(this, e).get(e);
}
var Fz = Uz, Bz = ef;
function zz(e) {
  return Bz(this, e).has(e);
}
var Zz = zz, qz = ef;
function Wz(e, t) {
  var n = qz(this, e), r = n.size;
  return n.set(e, t), this.size += n.size == r ? 0 : 1, this;
}
var Vz = Wz, Hz = $z, Kz = Lz, Gz = Fz, Jz = Zz, Yz = Vz;
function Jo(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
Jo.prototype.clear = Hz;
Jo.prototype.delete = Kz;
Jo.prototype.get = Gz;
Jo.prototype.has = Jz;
Jo.prototype.set = Yz;
var ug = Jo, Xz = Xd, Qz = cg, e4 = ug, t4 = 200;
function n4(e, t) {
  var n = this.__data__;
  if (n instanceof Xz) {
    var r = n.__data__;
    if (!Qz || r.length < t4 - 1)
      return r.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new e4(r);
  }
  return n.set(e, t), this.size = n.size, this;
}
var r4 = n4, i4 = Xd, a4 = W3, o4 = H3, s4 = G3, l4 = Y3, c4 = r4;
function Yo(e) {
  var t = this.__data__ = new i4(e);
  this.size = t.size;
}
Yo.prototype.clear = a4;
Yo.prototype.delete = o4;
Yo.prototype.get = s4;
Yo.prototype.has = l4;
Yo.prototype.set = c4;
var tf = Yo;
function u4(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r && t(e[n], n, e) !== !1; )
    ;
  return e;
}
var d4 = u4, f4 = La, p4 = function() {
  try {
    var e = f4(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), v1 = p4, Eb = v1;
function h4(e, t, n) {
  t == "__proto__" && Eb ? Eb(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
var dg = h4, m4 = dg, g4 = _l, y4 = Object.prototype, v4 = y4.hasOwnProperty;
function b4(e, t, n) {
  var r = e[t];
  (!(v4.call(e, t) && g4(r, n)) || n === void 0 && !(t in e)) && m4(e, t, n);
}
var b1 = b4, w4 = b1, x4 = dg;
function _4(e, t, n, r) {
  var i = !n;
  n || (n = {});
  for (var a = -1, o = t.length; ++a < o; ) {
    var s = t[a], l = r ? r(n[s], e[s], s, n, e) : void 0;
    l === void 0 && (l = e[s]), i ? x4(n, s, l) : w4(n, s, l);
  }
  return n;
}
var Xo = _4;
function S4(e, t) {
  for (var n = -1, r = Array(e); ++n < e; )
    r[n] = t(n);
  return r;
}
var E4 = S4;
function k4(e) {
  return e != null && typeof e == "object";
}
var Wr = k4, T4 = Da, C4 = Wr, O4 = "[object Arguments]";
function A4(e) {
  return C4(e) && T4(e) == O4;
}
var $4 = A4, kb = $4, R4 = Wr, w1 = Object.prototype, P4 = w1.hasOwnProperty, I4 = w1.propertyIsEnumerable, M4 = kb(function() {
  return arguments;
}()) ? kb : function(e) {
  return R4(e) && P4.call(e, "callee") && !I4.call(e, "callee");
}, Sl = M4, N4 = Array.isArray, Hn = N4, uu = { exports: {} };
function D4() {
  return !1;
}
var L4 = D4;
uu.exports;
(function(e, t) {
  var n = Zr, r = L4, i = t && !t.nodeType && t, a = i && !0 && e && !e.nodeType && e, o = a && a.exports === i, s = o ? n.Buffer : void 0, l = s ? s.isBuffer : void 0, c = l || r;
  e.exports = c;
})(uu, uu.exports);
var El = uu.exports, j4 = 9007199254740991, U4 = /^(?:0|[1-9]\d*)$/;
function F4(e, t) {
  var n = typeof e;
  return t = t ?? j4, !!t && (n == "number" || n != "symbol" && U4.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
var fg = F4, B4 = 9007199254740991;
function z4(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= B4;
}
var pg = z4, Z4 = Da, q4 = pg, W4 = Wr, V4 = "[object Arguments]", H4 = "[object Array]", K4 = "[object Boolean]", G4 = "[object Date]", J4 = "[object Error]", Y4 = "[object Function]", X4 = "[object Map]", Q4 = "[object Number]", e6 = "[object Object]", t6 = "[object RegExp]", n6 = "[object Set]", r6 = "[object String]", i6 = "[object WeakMap]", a6 = "[object ArrayBuffer]", o6 = "[object DataView]", s6 = "[object Float32Array]", l6 = "[object Float64Array]", c6 = "[object Int8Array]", u6 = "[object Int16Array]", d6 = "[object Int32Array]", f6 = "[object Uint8Array]", p6 = "[object Uint8ClampedArray]", h6 = "[object Uint16Array]", m6 = "[object Uint32Array]", jt = {};
jt[s6] = jt[l6] = jt[c6] = jt[u6] = jt[d6] = jt[f6] = jt[p6] = jt[h6] = jt[m6] = !0;
jt[V4] = jt[H4] = jt[a6] = jt[K4] = jt[o6] = jt[G4] = jt[J4] = jt[Y4] = jt[X4] = jt[Q4] = jt[e6] = jt[t6] = jt[n6] = jt[r6] = jt[i6] = !1;
function g6(e) {
  return W4(e) && q4(e.length) && !!jt[Z4(e)];
}
var y6 = g6;
function v6(e) {
  return function(t) {
    return e(t);
  };
}
var hg = v6, du = { exports: {} };
du.exports;
(function(e, t) {
  var n = m1, r = t && !t.nodeType && t, i = r && !0 && e && !e.nodeType && e, a = i && i.exports === r, o = a && n.process, s = function() {
    try {
      var l = i && i.require && i.require("util").types;
      return l || o && o.binding && o.binding("util");
    } catch {
    }
  }();
  e.exports = s;
})(du, du.exports);
var mg = du.exports, b6 = y6, w6 = hg, Tb = mg, Cb = Tb && Tb.isTypedArray, x6 = Cb ? w6(Cb) : b6, nf = x6, _6 = E4, S6 = Sl, E6 = Hn, k6 = El, T6 = fg, C6 = nf, O6 = Object.prototype, A6 = O6.hasOwnProperty;
function $6(e, t) {
  var n = E6(e), r = !n && S6(e), i = !n && !r && k6(e), a = !n && !r && !i && C6(e), o = n || r || i || a, s = o ? _6(e.length, String) : [], l = s.length;
  for (var c in e)
    (t || A6.call(e, c)) && !(o && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    i && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    T6(c, l))) && s.push(c);
  return s;
}
var x1 = $6, R6 = Object.prototype;
function P6(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || R6;
  return e === n;
}
var rf = P6;
function I6(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var _1 = I6, M6 = _1, N6 = M6(Object.keys, Object), D6 = N6, L6 = rf, j6 = D6, U6 = Object.prototype, F6 = U6.hasOwnProperty;
function B6(e) {
  if (!L6(e))
    return j6(e);
  var t = [];
  for (var n in Object(e))
    F6.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
var S1 = B6, z6 = lg, Z6 = pg;
function q6(e) {
  return e != null && Z6(e.length) && !z6(e);
}
var Yi = q6, W6 = x1, V6 = S1, H6 = Yi;
function K6(e) {
  return H6(e) ? W6(e) : V6(e);
}
var Qo = K6, G6 = Xo, J6 = Qo;
function Y6(e, t) {
  return e && G6(t, J6(t), e);
}
var X6 = Y6;
function Q6(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var e7 = Q6, t7 = qr, n7 = rf, r7 = e7, i7 = Object.prototype, a7 = i7.hasOwnProperty;
function o7(e) {
  if (!t7(e))
    return r7(e);
  var t = n7(e), n = [];
  for (var r in e)
    r == "constructor" && (t || !a7.call(e, r)) || n.push(r);
  return n;
}
var s7 = o7, l7 = x1, c7 = s7, u7 = Yi;
function d7(e) {
  return u7(e) ? l7(e, !0) : c7(e);
}
var kl = d7, f7 = Xo, p7 = kl;
function h7(e, t) {
  return e && f7(t, p7(t), e);
}
var m7 = h7, fu = { exports: {} };
fu.exports;
(function(e, t) {
  var n = Zr, r = t && !t.nodeType && t, i = r && !0 && e && !e.nodeType && e, a = i && i.exports === r, o = a ? n.Buffer : void 0, s = o ? o.allocUnsafe : void 0;
  function l(c, u) {
    if (u)
      return c.slice();
    var d = c.length, p = s ? s(d) : new c.constructor(d);
    return c.copy(p), p;
  }
  e.exports = l;
})(fu, fu.exports);
var E1 = fu.exports;
function g7(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
var k1 = g7;
function y7(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = 0, a = []; ++n < r; ) {
    var o = e[n];
    t(o, n, e) && (a[i++] = o);
  }
  return a;
}
var v7 = y7;
function b7() {
  return [];
}
var T1 = b7, w7 = v7, x7 = T1, _7 = Object.prototype, S7 = _7.propertyIsEnumerable, Ob = Object.getOwnPropertySymbols, E7 = Ob ? function(e) {
  return e == null ? [] : (e = Object(e), w7(Ob(e), function(t) {
    return S7.call(e, t);
  }));
} : x7, gg = E7, k7 = Xo, T7 = gg;
function C7(e, t) {
  return k7(e, T7(e), t);
}
var O7 = C7;
function A7(e, t) {
  for (var n = -1, r = t.length, i = e.length; ++n < r; )
    e[i + n] = t[n];
  return e;
}
var yg = A7, $7 = _1, R7 = $7(Object.getPrototypeOf, Object), vg = R7, P7 = yg, I7 = vg, M7 = gg, N7 = T1, D7 = Object.getOwnPropertySymbols, L7 = D7 ? function(e) {
  for (var t = []; e; )
    P7(t, M7(e)), e = I7(e);
  return t;
} : N7, C1 = L7, j7 = Xo, U7 = C1;
function F7(e, t) {
  return j7(e, U7(e), t);
}
var B7 = F7, z7 = yg, Z7 = Hn;
function q7(e, t, n) {
  var r = t(e);
  return Z7(e) ? r : z7(r, n(e));
}
var O1 = q7, W7 = O1, V7 = gg, H7 = Qo;
function K7(e) {
  return W7(e, H7, V7);
}
var A1 = K7, G7 = O1, J7 = C1, Y7 = kl;
function X7(e) {
  return G7(e, Y7, J7);
}
var $1 = X7, Q7 = La, eZ = Zr, tZ = Q7(eZ, "DataView"), nZ = tZ, rZ = La, iZ = Zr, aZ = rZ(iZ, "Promise"), oZ = aZ, sZ = La, lZ = Zr, cZ = sZ(lZ, "Set"), R1 = cZ, uZ = La, dZ = Zr, fZ = uZ(dZ, "WeakMap"), pZ = fZ, Th = nZ, Ch = cg, Oh = oZ, Ah = R1, $h = pZ, P1 = Da, es = y1, Ab = "[object Map]", hZ = "[object Object]", $b = "[object Promise]", Rb = "[object Set]", Pb = "[object WeakMap]", Ib = "[object DataView]", mZ = es(Th), gZ = es(Ch), yZ = es(Oh), vZ = es(Ah), bZ = es($h), aa = P1;
(Th && aa(new Th(new ArrayBuffer(1))) != Ib || Ch && aa(new Ch()) != Ab || Oh && aa(Oh.resolve()) != $b || Ah && aa(new Ah()) != Rb || $h && aa(new $h()) != Pb) && (aa = function(e) {
  var t = P1(e), n = t == hZ ? e.constructor : void 0, r = n ? es(n) : "";
  if (r)
    switch (r) {
      case mZ:
        return Ib;
      case gZ:
        return Ab;
      case yZ:
        return $b;
      case vZ:
        return Rb;
      case bZ:
        return Pb;
    }
  return t;
});
var Tl = aa, wZ = Object.prototype, xZ = wZ.hasOwnProperty;
function _Z(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && xZ.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
var SZ = _Z, EZ = Zr, kZ = EZ.Uint8Array, I1 = kZ, Mb = I1;
function TZ(e) {
  var t = new e.constructor(e.byteLength);
  return new Mb(t).set(new Mb(e)), t;
}
var bg = TZ, CZ = bg;
function OZ(e, t) {
  var n = t ? CZ(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var AZ = OZ, $Z = /\w*$/;
function RZ(e) {
  var t = new e.constructor(e.source, $Z.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var PZ = RZ, Nb = Ko, Db = Nb ? Nb.prototype : void 0, Lb = Db ? Db.valueOf : void 0;
function IZ(e) {
  return Lb ? Object(Lb.call(e)) : {};
}
var MZ = IZ, NZ = bg;
function DZ(e, t) {
  var n = t ? NZ(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var M1 = DZ, LZ = bg, jZ = AZ, UZ = PZ, FZ = MZ, BZ = M1, zZ = "[object Boolean]", ZZ = "[object Date]", qZ = "[object Map]", WZ = "[object Number]", VZ = "[object RegExp]", HZ = "[object Set]", KZ = "[object String]", GZ = "[object Symbol]", JZ = "[object ArrayBuffer]", YZ = "[object DataView]", XZ = "[object Float32Array]", QZ = "[object Float64Array]", e9 = "[object Int8Array]", t9 = "[object Int16Array]", n9 = "[object Int32Array]", r9 = "[object Uint8Array]", i9 = "[object Uint8ClampedArray]", a9 = "[object Uint16Array]", o9 = "[object Uint32Array]";
function s9(e, t, n) {
  var r = e.constructor;
  switch (t) {
    case JZ:
      return LZ(e);
    case zZ:
    case ZZ:
      return new r(+e);
    case YZ:
      return jZ(e, n);
    case XZ:
    case QZ:
    case e9:
    case t9:
    case n9:
    case r9:
    case i9:
    case a9:
    case o9:
      return BZ(e, n);
    case qZ:
      return new r();
    case WZ:
    case KZ:
      return new r(e);
    case VZ:
      return UZ(e);
    case HZ:
      return new r();
    case GZ:
      return FZ(e);
  }
}
var l9 = s9, c9 = qr, jb = Object.create, u9 = function() {
  function e() {
  }
  return function(t) {
    if (!c9(t))
      return {};
    if (jb)
      return jb(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}(), d9 = u9, f9 = d9, p9 = vg, h9 = rf;
function m9(e) {
  return typeof e.constructor == "function" && !h9(e) ? f9(p9(e)) : {};
}
var N1 = m9, g9 = Tl, y9 = Wr, v9 = "[object Map]";
function b9(e) {
  return y9(e) && g9(e) == v9;
}
var w9 = b9, x9 = w9, _9 = hg, Ub = mg, Fb = Ub && Ub.isMap, S9 = Fb ? _9(Fb) : x9, E9 = S9, k9 = Tl, T9 = Wr, C9 = "[object Set]";
function O9(e) {
  return T9(e) && k9(e) == C9;
}
var A9 = O9, $9 = A9, R9 = hg, Bb = mg, zb = Bb && Bb.isSet, P9 = zb ? R9(zb) : $9, I9 = P9, M9 = tf, N9 = d4, D9 = b1, L9 = X6, j9 = m7, U9 = E1, F9 = k1, B9 = O7, z9 = B7, Z9 = A1, q9 = $1, W9 = Tl, V9 = SZ, H9 = l9, K9 = N1, G9 = Hn, J9 = El, Y9 = E9, X9 = qr, Q9 = I9, eq = Qo, tq = kl, nq = 1, rq = 2, iq = 4, D1 = "[object Arguments]", aq = "[object Array]", oq = "[object Boolean]", sq = "[object Date]", lq = "[object Error]", L1 = "[object Function]", cq = "[object GeneratorFunction]", uq = "[object Map]", dq = "[object Number]", j1 = "[object Object]", fq = "[object RegExp]", pq = "[object Set]", hq = "[object String]", mq = "[object Symbol]", gq = "[object WeakMap]", yq = "[object ArrayBuffer]", vq = "[object DataView]", bq = "[object Float32Array]", wq = "[object Float64Array]", xq = "[object Int8Array]", _q = "[object Int16Array]", Sq = "[object Int32Array]", Eq = "[object Uint8Array]", kq = "[object Uint8ClampedArray]", Tq = "[object Uint16Array]", Cq = "[object Uint32Array]", Pt = {};
Pt[D1] = Pt[aq] = Pt[yq] = Pt[vq] = Pt[oq] = Pt[sq] = Pt[bq] = Pt[wq] = Pt[xq] = Pt[_q] = Pt[Sq] = Pt[uq] = Pt[dq] = Pt[j1] = Pt[fq] = Pt[pq] = Pt[hq] = Pt[mq] = Pt[Eq] = Pt[kq] = Pt[Tq] = Pt[Cq] = !0;
Pt[lq] = Pt[L1] = Pt[gq] = !1;
function Oc(e, t, n, r, i, a) {
  var o, s = t & nq, l = t & rq, c = t & iq;
  if (n && (o = i ? n(e, r, i, a) : n(e)), o !== void 0)
    return o;
  if (!X9(e))
    return e;
  var u = G9(e);
  if (u) {
    if (o = V9(e), !s)
      return F9(e, o);
  } else {
    var d = W9(e), p = d == L1 || d == cq;
    if (J9(e))
      return U9(e, s);
    if (d == j1 || d == D1 || p && !i) {
      if (o = l || p ? {} : K9(e), !s)
        return l ? z9(e, j9(o, e)) : B9(e, L9(o, e));
    } else {
      if (!Pt[d])
        return i ? e : {};
      o = H9(e, d, s);
    }
  }
  a || (a = new M9());
  var f = a.get(e);
  if (f)
    return f;
  a.set(e, o), Q9(e) ? e.forEach(function(y) {
    o.add(Oc(y, t, n, y, e, a));
  }) : Y9(e) && e.forEach(function(y, g) {
    o.set(g, Oc(y, t, n, g, e, a));
  });
  var h = c ? l ? q9 : Z9 : l ? tq : eq, m = u ? void 0 : h(e);
  return N9(m || e, function(y, g) {
    m && (g = y, y = e[g]), D9(o, g, Oc(y, t, n, g, e, a));
  }), o;
}
var U1 = Oc, Oq = U1, Aq = 1, $q = 4;
function Rq(e) {
  return Oq(e, Aq | $q);
}
var Pq = Rq;
function Iq(e, t, n) {
  return e === e && (n !== void 0 && (e = e <= n ? e : n), t !== void 0 && (e = e >= t ? e : t)), e;
}
var Mq = Iq;
function Nq(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length, i = Array(r); ++n < r; )
    i[n] = t(e[n], n, e);
  return i;
}
var af = Nq, Dq = Da, Lq = Wr, jq = "[object Symbol]";
function Uq(e) {
  return typeof e == "symbol" || Lq(e) && Dq(e) == jq;
}
var of = Uq, Zb = Ko, Fq = af, Bq = Hn, zq = of, Zq = 1 / 0, qb = Zb ? Zb.prototype : void 0, Wb = qb ? qb.toString : void 0;
function F1(e) {
  if (typeof e == "string")
    return e;
  if (Bq(e))
    return Fq(e, F1) + "";
  if (zq(e))
    return Wb ? Wb.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -Zq ? "-0" : t;
}
var wg = F1, qq = /\s/;
function Wq(e) {
  for (var t = e.length; t-- && qq.test(e.charAt(t)); )
    ;
  return t;
}
var Vq = Wq, Hq = Vq, Kq = /^\s+/;
function Gq(e) {
  return e && e.slice(0, Hq(e) + 1).replace(Kq, "");
}
var B1 = Gq, Jq = B1, Vb = qr, Yq = of, Hb = 0 / 0, Xq = /^[-+]0x[0-9a-f]+$/i, Qq = /^0b[01]+$/i, e8 = /^0o[0-7]+$/i, t8 = parseInt;
function n8(e) {
  if (typeof e == "number")
    return e;
  if (Yq(e))
    return Hb;
  if (Vb(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Vb(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = Jq(e);
  var n = Qq.test(e);
  return n || e8.test(e) ? t8(e.slice(2), n ? 2 : 8) : Xq.test(e) ? Hb : +e;
}
var r8 = n8, i8 = r8, Kb = 1 / 0, a8 = 17976931348623157e292;
function o8(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = i8(e), e === Kb || e === -Kb) {
    var t = e < 0 ? -1 : 1;
    return t * a8;
  }
  return e === e ? e : 0;
}
var s8 = o8, l8 = s8;
function c8(e) {
  var t = l8(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
var z1 = c8, u8 = wg;
function d8(e) {
  return e == null ? "" : u8(e);
}
var Cl = d8, f8 = Mq, p8 = wg, h8 = z1, m8 = Cl;
function g8(e, t, n) {
  e = m8(e), t = p8(t);
  var r = e.length;
  n = n === void 0 ? r : f8(h8(n), 0, r);
  var i = n;
  return n -= t.length, n >= 0 && e.slice(n, i) == t;
}
var y8 = g8, v8 = "__lodash_hash_undefined__";
function b8(e) {
  return this.__data__.set(e, v8), this;
}
var w8 = b8;
function x8(e) {
  return this.__data__.has(e);
}
var _8 = x8, S8 = ug, E8 = w8, k8 = _8;
function pu(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new S8(); ++t < n; )
    this.add(e[t]);
}
pu.prototype.add = pu.prototype.push = E8;
pu.prototype.has = k8;
var Z1 = pu;
function T8(e, t) {
  for (var n = -1, r = e == null ? 0 : e.length; ++n < r; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
var C8 = T8;
function O8(e, t) {
  return e.has(t);
}
var q1 = O8, A8 = Z1, $8 = C8, R8 = q1, P8 = 1, I8 = 2;
function M8(e, t, n, r, i, a) {
  var o = n & P8, s = e.length, l = t.length;
  if (s != l && !(o && l > s))
    return !1;
  var c = a.get(e), u = a.get(t);
  if (c && u)
    return c == t && u == e;
  var d = -1, p = !0, f = n & I8 ? new A8() : void 0;
  for (a.set(e, t), a.set(t, e); ++d < s; ) {
    var h = e[d], m = t[d];
    if (r)
      var y = o ? r(m, h, d, t, e, a) : r(h, m, d, e, t, a);
    if (y !== void 0) {
      if (y)
        continue;
      p = !1;
      break;
    }
    if (f) {
      if (!$8(t, function(g, v) {
        if (!R8(f, v) && (h === g || i(h, g, n, r, a)))
          return f.push(v);
      })) {
        p = !1;
        break;
      }
    } else if (!(h === m || i(h, m, n, r, a))) {
      p = !1;
      break;
    }
  }
  return a.delete(e), a.delete(t), p;
}
var W1 = M8;
function N8(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r, i) {
    n[++t] = [i, r];
  }), n;
}
var D8 = N8;
function L8(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(r) {
    n[++t] = r;
  }), n;
}
var xg = L8, Gb = Ko, Jb = I1, j8 = _l, U8 = W1, F8 = D8, B8 = xg, z8 = 1, Z8 = 2, q8 = "[object Boolean]", W8 = "[object Date]", V8 = "[object Error]", H8 = "[object Map]", K8 = "[object Number]", G8 = "[object RegExp]", J8 = "[object Set]", Y8 = "[object String]", X8 = "[object Symbol]", Q8 = "[object ArrayBuffer]", eW = "[object DataView]", Yb = Gb ? Gb.prototype : void 0, Sp = Yb ? Yb.valueOf : void 0;
function tW(e, t, n, r, i, a, o) {
  switch (n) {
    case eW:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case Q8:
      return !(e.byteLength != t.byteLength || !a(new Jb(e), new Jb(t)));
    case q8:
    case W8:
    case K8:
      return j8(+e, +t);
    case V8:
      return e.name == t.name && e.message == t.message;
    case G8:
    case Y8:
      return e == t + "";
    case H8:
      var s = F8;
    case J8:
      var l = r & z8;
      if (s || (s = B8), e.size != t.size && !l)
        return !1;
      var c = o.get(e);
      if (c)
        return c == t;
      r |= Z8, o.set(e, t);
      var u = U8(s(e), s(t), r, i, a, o);
      return o.delete(e), u;
    case X8:
      if (Sp)
        return Sp.call(e) == Sp.call(t);
  }
  return !1;
}
var nW = tW, Xb = A1, rW = 1, iW = Object.prototype, aW = iW.hasOwnProperty;
function oW(e, t, n, r, i, a) {
  var o = n & rW, s = Xb(e), l = s.length, c = Xb(t), u = c.length;
  if (l != u && !o)
    return !1;
  for (var d = l; d--; ) {
    var p = s[d];
    if (!(o ? p in t : aW.call(t, p)))
      return !1;
  }
  var f = a.get(e), h = a.get(t);
  if (f && h)
    return f == t && h == e;
  var m = !0;
  a.set(e, t), a.set(t, e);
  for (var y = o; ++d < l; ) {
    p = s[d];
    var g = e[p], v = t[p];
    if (r)
      var b = o ? r(v, g, p, t, e, a) : r(g, v, p, e, t, a);
    if (!(b === void 0 ? g === v || i(g, v, n, r, a) : b)) {
      m = !1;
      break;
    }
    y || (y = p == "constructor");
  }
  if (m && !y) {
    var T = e.constructor, O = t.constructor;
    T != O && "constructor" in e && "constructor" in t && !(typeof T == "function" && T instanceof T && typeof O == "function" && O instanceof O) && (m = !1);
  }
  return a.delete(e), a.delete(t), m;
}
var sW = oW, Ep = tf, lW = W1, cW = nW, uW = sW, Qb = Tl, ew = Hn, tw = El, dW = nf, fW = 1, nw = "[object Arguments]", rw = "[object Array]", lc = "[object Object]", pW = Object.prototype, iw = pW.hasOwnProperty;
function hW(e, t, n, r, i, a) {
  var o = ew(e), s = ew(t), l = o ? rw : Qb(e), c = s ? rw : Qb(t);
  l = l == nw ? lc : l, c = c == nw ? lc : c;
  var u = l == lc, d = c == lc, p = l == c;
  if (p && tw(e)) {
    if (!tw(t))
      return !1;
    o = !0, u = !1;
  }
  if (p && !u)
    return a || (a = new Ep()), o || dW(e) ? lW(e, t, n, r, i, a) : cW(e, t, l, n, r, i, a);
  if (!(n & fW)) {
    var f = u && iw.call(e, "__wrapped__"), h = d && iw.call(t, "__wrapped__");
    if (f || h) {
      var m = f ? e.value() : e, y = h ? t.value() : t;
      return a || (a = new Ep()), i(m, y, n, r, a);
    }
  }
  return p ? (a || (a = new Ep()), uW(e, t, n, r, i, a)) : !1;
}
var mW = hW, gW = mW, aw = Wr;
function V1(e, t, n, r, i) {
  return e === t ? !0 : e == null || t == null || !aw(e) && !aw(t) ? e !== e && t !== t : gW(e, t, n, r, V1, i);
}
var _g = V1, yW = _g;
function vW(e, t) {
  return yW(e, t);
}
var H1 = vW, bW = dg, wW = _l;
function xW(e, t, n) {
  (n !== void 0 && !wW(e[t], n) || n === void 0 && !(t in e)) && bW(e, t, n);
}
var K1 = xW;
function _W(e) {
  return function(t, n, r) {
    for (var i = -1, a = Object(t), o = r(t), s = o.length; s--; ) {
      var l = o[e ? s : ++i];
      if (n(a[l], l, a) === !1)
        break;
    }
    return t;
  };
}
var SW = _W, EW = SW, kW = EW(), G1 = kW, TW = Yi, CW = Wr;
function OW(e) {
  return CW(e) && TW(e);
}
var AW = OW, $W = Da, RW = vg, PW = Wr, IW = "[object Object]", MW = Function.prototype, NW = Object.prototype, J1 = MW.toString, DW = NW.hasOwnProperty, LW = J1.call(Object);
function jW(e) {
  if (!PW(e) || $W(e) != IW)
    return !1;
  var t = RW(e);
  if (t === null)
    return !0;
  var n = DW.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && J1.call(n) == LW;
}
var ja = jW;
function UW(e, t) {
  if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
    return e[t];
}
var Y1 = UW, FW = Xo, BW = kl;
function zW(e) {
  return FW(e, BW(e));
}
var ZW = zW, ow = K1, qW = E1, WW = M1, VW = k1, HW = N1, sw = Sl, lw = Hn, KW = AW, GW = El, JW = lg, YW = qr, XW = ja, QW = nf, cw = Y1, eV = ZW;
function tV(e, t, n, r, i, a, o) {
  var s = cw(e, n), l = cw(t, n), c = o.get(l);
  if (c) {
    ow(e, n, c);
    return;
  }
  var u = a ? a(s, l, n + "", e, t, o) : void 0, d = u === void 0;
  if (d) {
    var p = lw(l), f = !p && GW(l), h = !p && !f && QW(l);
    u = l, p || f || h ? lw(s) ? u = s : KW(s) ? u = VW(s) : f ? (d = !1, u = qW(l, !0)) : h ? (d = !1, u = WW(l, !0)) : u = [] : XW(l) || sw(l) ? (u = s, sw(s) ? u = eV(s) : (!YW(s) || JW(s)) && (u = HW(l))) : d = !1;
  }
  d && (o.set(l, u), i(u, l, r, a, o), o.delete(l)), ow(e, n, u);
}
var nV = tV, rV = tf, iV = K1, aV = G1, oV = nV, sV = qr, lV = kl, cV = Y1;
function X1(e, t, n, r, i) {
  e !== t && aV(t, function(a, o) {
    if (i || (i = new rV()), sV(a))
      oV(e, t, o, n, X1, r, i);
    else {
      var s = r ? r(cV(e, o), a, o + "", e, t, i) : void 0;
      s === void 0 && (s = a), iV(e, o, s);
    }
  }, lV);
}
var uV = X1;
function dV(e) {
  return e;
}
var Sg = dV;
function fV(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
var pV = fV, hV = pV, uw = Math.max;
function mV(e, t, n) {
  return t = uw(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var r = arguments, i = -1, a = uw(r.length - t, 0), o = Array(a); ++i < a; )
      o[i] = r[t + i];
    i = -1;
    for (var s = Array(t + 1); ++i < t; )
      s[i] = r[i];
    return s[t] = n(o), hV(e, this, s);
  };
}
var Q1 = mV;
function gV(e) {
  return function() {
    return e;
  };
}
var yV = gV, vV = yV, dw = v1, bV = Sg, wV = dw ? function(e, t) {
  return dw(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: vV(t),
    writable: !0
  });
} : bV, xV = wV, _V = 800, SV = 16, EV = Date.now;
function kV(e) {
  var t = 0, n = 0;
  return function() {
    var r = EV(), i = SV - (r - n);
    if (n = r, i > 0) {
      if (++t >= _V)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
var TV = kV, CV = xV, OV = TV, AV = OV(CV), eS = AV, $V = Sg, RV = Q1, PV = eS;
function IV(e, t) {
  return PV(RV(e, t, $V), e + "");
}
var MV = IV, NV = _l, DV = Yi, LV = fg, jV = qr;
function UV(e, t, n) {
  if (!jV(n))
    return !1;
  var r = typeof t;
  return (r == "number" ? DV(n) && LV(t, n.length) : r == "string" && t in n) ? NV(n[t], e) : !1;
}
var FV = UV, BV = MV, zV = FV;
function ZV(e) {
  return BV(function(t, n) {
    var r = -1, i = n.length, a = i > 1 ? n[i - 1] : void 0, o = i > 2 ? n[2] : void 0;
    for (a = e.length > 3 && typeof a == "function" ? (i--, a) : void 0, o && zV(n[0], n[1], o) && (a = i < 3 ? void 0 : a, i = 1), t = Object(t); ++r < i; ) {
      var s = n[r];
      s && e(t, s, r, a);
    }
    return t;
  });
}
var qV = ZV, WV = uV, VV = qV, HV = VV(function(e, t, n) {
  WV(e, t, n);
}), KV = HV, tS = ug, GV = "Expected a function";
function Eg(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(GV);
  var n = function() {
    var r = arguments, i = t ? t.apply(this, r) : r[0], a = n.cache;
    if (a.has(i))
      return a.get(i);
    var o = e.apply(this, r);
    return n.cache = a.set(i, o) || a, o;
  };
  return n.cache = new (Eg.Cache || tS)(), n;
}
Eg.Cache = tS;
var sf = Eg, JV = Hn, YV = of, XV = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, QV = /^\w*$/;
function eH(e, t) {
  if (JV(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || YV(e) ? !0 : QV.test(e) || !XV.test(e) || t != null && e in Object(t);
}
var kg = eH, tH = sf, nH = 500;
function rH(e) {
  var t = tH(e, function(r) {
    return n.size === nH && n.clear(), r;
  }), n = t.cache;
  return t;
}
var iH = rH, aH = iH, oH = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, sH = /\\(\\)?/g, lH = aH(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(oH, function(n, r, i, a) {
    t.push(i ? a.replace(sH, "$1") : r || n);
  }), t;
}), cH = lH, uH = Hn, dH = kg, fH = cH, pH = Cl;
function hH(e, t) {
  return uH(e) ? e : dH(e, t) ? [e] : fH(pH(e));
}
var lf = hH;
function mH(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
var gH = mH, yH = of, vH = 1 / 0;
function bH(e) {
  if (typeof e == "string" || yH(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -vH ? "-0" : t;
}
var Ol = bH, wH = lf, xH = Ol;
function _H(e, t) {
  t = wH(t, e);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[xH(t[n++])];
  return n && n == r ? e : void 0;
}
var Tg = _H;
function SH(e, t, n) {
  var r = -1, i = e.length;
  t < 0 && (t = -t > i ? 0 : i + t), n = n > i ? i : n, n < 0 && (n += i), i = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var a = Array(i); ++r < i; )
    a[r] = e[r + t];
  return a;
}
var nS = SH, EH = Tg, kH = nS;
function TH(e, t) {
  return t.length < 2 ? e : EH(e, kH(t, 0, -1));
}
var CH = TH, OH = lf, AH = gH, $H = CH, RH = Ol;
function PH(e, t) {
  return t = OH(t, e), e = $H(e, t), e == null || delete e[RH(AH(t))];
}
var IH = PH, MH = ja;
function NH(e) {
  return MH(e) ? void 0 : e;
}
var DH = NH, fw = Ko, LH = Sl, jH = Hn, pw = fw ? fw.isConcatSpreadable : void 0;
function UH(e) {
  return jH(e) || LH(e) || !!(pw && e && e[pw]);
}
var FH = UH, BH = yg, zH = FH;
function rS(e, t, n, r, i) {
  var a = -1, o = e.length;
  for (n || (n = zH), i || (i = []); ++a < o; ) {
    var s = e[a];
    t > 0 && n(s) ? t > 1 ? rS(s, t - 1, n, r, i) : BH(i, s) : r || (i[i.length] = s);
  }
  return i;
}
var ZH = rS, qH = ZH;
function WH(e) {
  var t = e == null ? 0 : e.length;
  return t ? qH(e, 1) : [];
}
var VH = WH, HH = VH, KH = Q1, GH = eS;
function JH(e) {
  return GH(KH(e, void 0, HH), e + "");
}
var YH = JH, XH = af, QH = U1, eK = IH, tK = lf, nK = Xo, rK = DH, iK = YH, aK = $1, oK = 1, sK = 2, lK = 4, cK = iK(function(e, t) {
  var n = {};
  if (e == null)
    return n;
  var r = !1;
  t = XH(t, function(a) {
    return a = tK(a, e), r || (r = a.length > 1), a;
  }), nK(e, aK(e), n), r && (n = QH(n, oK | sK | lK, rK));
  for (var i = t.length; i--; )
    eK(n, t[i]);
  return n;
}), iS = cK;
function uK(e) {
  return function(t) {
    return e == null ? void 0 : e[t];
  };
}
var dK = uK, fK = dK, pK = {
  // Latin-1 Supplement block.
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "a",
  : "C",
  : "c",
  : "D",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "N",
  : "n",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "o",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "Y",
  : "y",
  : "y",
  : "Ae",
  : "ae",
  : "Th",
  : "th",
  : "ss",
  // Latin Extended-A block.
  : "A",
  : "A",
  : "A",
  : "a",
  : "a",
  : "a",
  : "C",
  : "C",
  : "C",
  : "C",
  : "c",
  : "c",
  : "c",
  : "c",
  : "D",
  : "D",
  : "d",
  : "d",
  : "E",
  : "E",
  : "E",
  : "E",
  : "E",
  : "e",
  : "e",
  : "e",
  : "e",
  : "e",
  : "G",
  : "G",
  : "G",
  : "G",
  : "g",
  : "g",
  : "g",
  : "g",
  : "H",
  : "H",
  : "h",
  : "h",
  : "I",
  : "I",
  : "I",
  : "I",
  : "I",
  : "i",
  : "i",
  : "i",
  : "i",
  : "i",
  : "J",
  : "j",
  : "K",
  : "k",
  : "k",
  : "L",
  : "L",
  : "L",
  : "L",
  : "L",
  : "l",
  : "l",
  : "l",
  : "l",
  : "l",
  : "N",
  : "N",
  : "N",
  : "N",
  : "n",
  : "n",
  : "n",
  : "n",
  : "O",
  : "O",
  : "O",
  : "o",
  : "o",
  : "o",
  : "R",
  : "R",
  : "R",
  : "r",
  : "r",
  : "r",
  : "S",
  : "S",
  : "S",
  : "S",
  : "s",
  : "s",
  : "s",
  : "s",
  : "T",
  : "T",
  : "T",
  : "t",
  : "t",
  : "t",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "U",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "u",
  : "W",
  : "w",
  : "Y",
  : "y",
  : "Y",
  : "Z",
  : "Z",
  : "Z",
  : "z",
  : "z",
  : "z",
  : "IJ",
  : "ij",
  : "Oe",
  : "oe",
  : "'n",
  : "s"
}, hK = fK(pK), mK = hK, gK = mK, yK = Cl, vK = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, bK = "\\u0300-\\u036f", wK = "\\ufe20-\\ufe2f", xK = "\\u20d0-\\u20ff", _K = bK + wK + xK, SK = "[" + _K + "]", EK = RegExp(SK, "g");
function kK(e) {
  return e = yK(e), e && e.replace(vK, gK).replace(EK, "");
}
var TK = kK, CK = nS;
function OK(e, t, n) {
  var r = e.length;
  return n = n === void 0 ? r : n, !t && n >= r ? e : CK(e, t, n);
}
var aS = OK;
function AK(e, t, n, r) {
  for (var i = e.length, a = n + (r ? 1 : -1); r ? a-- : ++a < i; )
    if (t(e[a], a, e))
      return a;
  return -1;
}
var $K = AK;
function RK(e) {
  return e !== e;
}
var PK = RK;
function IK(e, t, n) {
  for (var r = n - 1, i = e.length; ++r < i; )
    if (e[r] === t)
      return r;
  return -1;
}
var MK = IK, NK = $K, DK = PK, LK = MK;
function jK(e, t, n) {
  return t === t ? LK(e, t, n) : NK(e, DK, n);
}
var cf = jK, UK = cf;
function FK(e, t) {
  for (var n = e.length; n-- && UK(t, e[n], 0) > -1; )
    ;
  return n;
}
var BK = FK, zK = cf;
function ZK(e, t) {
  for (var n = -1, r = e.length; ++n < r && zK(t, e[n], 0) > -1; )
    ;
  return n;
}
var qK = ZK;
function WK(e) {
  return e.split("");
}
var VK = WK, HK = "\\ud800-\\udfff", KK = "\\u0300-\\u036f", GK = "\\ufe20-\\ufe2f", JK = "\\u20d0-\\u20ff", YK = KK + GK + JK, XK = "\\ufe0e\\ufe0f", QK = "\\u200d", eG = RegExp("[" + QK + HK + YK + XK + "]");
function tG(e) {
  return eG.test(e);
}
var oS = tG, sS = "\\ud800-\\udfff", nG = "\\u0300-\\u036f", rG = "\\ufe20-\\ufe2f", iG = "\\u20d0-\\u20ff", aG = nG + rG + iG, oG = "\\ufe0e\\ufe0f", sG = "[" + sS + "]", Rh = "[" + aG + "]", Ph = "\\ud83c[\\udffb-\\udfff]", lG = "(?:" + Rh + "|" + Ph + ")", lS = "[^" + sS + "]", cS = "(?:\\ud83c[\\udde6-\\uddff]){2}", uS = "[\\ud800-\\udbff][\\udc00-\\udfff]", cG = "\\u200d", dS = lG + "?", fS = "[" + oG + "]?", uG = "(?:" + cG + "(?:" + [lS, cS, uS].join("|") + ")" + fS + dS + ")*", dG = fS + dS + uG, fG = "(?:" + [lS + Rh + "?", Rh, cS, uS, sG].join("|") + ")", pG = RegExp(Ph + "(?=" + Ph + ")|" + fG + dG, "g");
function hG(e) {
  return e.match(pG) || [];
}
var mG = hG, gG = VK, yG = oS, vG = mG;
function bG(e) {
  return yG(e) ? vG(e) : gG(e);
}
var pS = bG, wG = wg, xG = B1, _G = aS, SG = BK, EG = qK, hw = pS, kG = Cl;
function TG(e, t, n) {
  if (e = kG(e), e && (n || t === void 0))
    return xG(e);
  if (!e || !(t = wG(t)))
    return e;
  var r = hw(e), i = hw(t), a = EG(r, i), o = SG(r, i) + 1;
  return _G(r, a, o).join("");
}
var CG = TG, OG = aS, AG = oS, $G = pS, RG = Cl;
function PG(e) {
  return function(t) {
    t = RG(t);
    var n = AG(t) ? $G(t) : void 0, r = n ? n[0] : t.charAt(0), i = n ? OG(n, 1).join("") : t.slice(1);
    return r[e]() + i;
  };
}
var IG = PG, MG = IG, NG = MG("toUpperCase"), DG = NG, LG = S1, jG = Tl, UG = Sl, FG = Hn, BG = Yi, zG = El, ZG = rf, qG = nf, WG = "[object Map]", VG = "[object Set]", HG = Object.prototype, KG = HG.hasOwnProperty;
function GG(e) {
  if (e == null)
    return !0;
  if (BG(e) && (FG(e) || typeof e == "string" || typeof e.splice == "function" || zG(e) || qG(e) || UG(e)))
    return !e.length;
  var t = jG(e);
  if (t == WG || t == VG)
    return !e.size;
  if (ZG(e))
    return !LG(e).length;
  for (var n in e)
    if (KG.call(e, n))
      return !1;
  return !0;
}
var JG = GG, YG = tf, XG = _g, QG = 1, eJ = 2;
function tJ(e, t, n, r) {
  var i = n.length, a = i, o = !r;
  if (e == null)
    return !a;
  for (e = Object(e); i--; ) {
    var s = n[i];
    if (o && s[2] ? s[1] !== e[s[0]] : !(s[0] in e))
      return !1;
  }
  for (; ++i < a; ) {
    s = n[i];
    var l = s[0], c = e[l], u = s[1];
    if (o && s[2]) {
      if (c === void 0 && !(l in e))
        return !1;
    } else {
      var d = new YG();
      if (r)
        var p = r(c, u, l, e, t, d);
      if (!(p === void 0 ? XG(u, c, QG | eJ, r, d) : p))
        return !1;
    }
  }
  return !0;
}
var nJ = tJ, rJ = qr;
function iJ(e) {
  return e === e && !rJ(e);
}
var hS = iJ, aJ = hS, oJ = Qo;
function sJ(e) {
  for (var t = oJ(e), n = t.length; n--; ) {
    var r = t[n], i = e[r];
    t[n] = [r, i, aJ(i)];
  }
  return t;
}
var lJ = sJ;
function cJ(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
var mS = cJ, uJ = nJ, dJ = lJ, fJ = mS;
function pJ(e) {
  var t = dJ(e);
  return t.length == 1 && t[0][2] ? fJ(t[0][0], t[0][1]) : function(n) {
    return n === e || uJ(n, e, t);
  };
}
var hJ = pJ, mJ = Tg;
function gJ(e, t, n) {
  var r = e == null ? void 0 : mJ(e, t);
  return r === void 0 ? n : r;
}
var yJ = gJ;
function vJ(e, t) {
  return e != null && t in Object(e);
}
var bJ = vJ, wJ = lf, xJ = Sl, _J = Hn, SJ = fg, EJ = pg, kJ = Ol;
function TJ(e, t, n) {
  t = wJ(t, e);
  for (var r = -1, i = t.length, a = !1; ++r < i; ) {
    var o = kJ(t[r]);
    if (!(a = e != null && n(e, o)))
      break;
    e = e[o];
  }
  return a || ++r != i ? a : (i = e == null ? 0 : e.length, !!i && EJ(i) && SJ(o, i) && (_J(e) || xJ(e)));
}
var CJ = TJ, OJ = bJ, AJ = CJ;
function $J(e, t) {
  return e != null && AJ(e, t, OJ);
}
var RJ = $J, PJ = _g, IJ = yJ, MJ = RJ, NJ = kg, DJ = hS, LJ = mS, jJ = Ol, UJ = 1, FJ = 2;
function BJ(e, t) {
  return NJ(e) && DJ(t) ? LJ(jJ(e), t) : function(n) {
    var r = IJ(n, e);
    return r === void 0 && r === t ? MJ(n, e) : PJ(t, r, UJ | FJ);
  };
}
var zJ = BJ;
function ZJ(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
var qJ = ZJ, WJ = Tg;
function VJ(e) {
  return function(t) {
    return WJ(t, e);
  };
}
var HJ = VJ, KJ = qJ, GJ = HJ, JJ = kg, YJ = Ol;
function XJ(e) {
  return JJ(e) ? KJ(YJ(e)) : GJ(e);
}
var QJ = XJ, eY = hJ, tY = zJ, nY = Sg, rY = Hn, iY = QJ;
function aY(e) {
  return typeof e == "function" ? e : e == null ? nY : typeof e == "object" ? rY(e) ? tY(e[0], e[1]) : eY(e) : iY(e);
}
var Cg = aY, oY = cf;
function sY(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && oY(e, t, 0) > -1;
}
var lY = sY;
function cY(e, t, n) {
  for (var r = -1, i = e == null ? 0 : e.length; ++r < i; )
    if (n(t, e[r]))
      return !0;
  return !1;
}
var uY = cY;
function dY() {
}
var fY = dY, kp = R1, pY = fY, hY = xg, mY = 1 / 0, gY = kp && 1 / hY(new kp([, -0]))[1] == mY ? function(e) {
  return new kp(e);
} : pY, yY = gY, vY = Z1, bY = lY, wY = uY, xY = q1, _Y = yY, SY = xg, EY = 200;
function kY(e, t, n) {
  var r = -1, i = bY, a = e.length, o = !0, s = [], l = s;
  if (n)
    o = !1, i = wY;
  else if (a >= EY) {
    var c = t ? null : _Y(e);
    if (c)
      return SY(c);
    o = !1, i = xY, l = new vY();
  } else
    l = t ? [] : s;
  e:
    for (; ++r < a; ) {
      var u = e[r], d = t ? t(u) : u;
      if (u = n || u !== 0 ? u : 0, o && d === d) {
        for (var p = l.length; p--; )
          if (l[p] === d)
            continue e;
        t && l.push(d), s.push(u);
      } else
        i(l, d, n) || (l !== s && l.push(d), s.push(u));
    }
  return s;
}
var TY = kY, CY = Cg, OY = TY;
function AY(e, t) {
  return e && e.length ? OY(e, CY(t)) : [];
}
var $Y = AY;
function RY(e, t, n) {
  var r;
  return n(e, function(i, a, o) {
    if (t(i, a, o))
      return r = a, !1;
  }), r;
}
var PY = RY, IY = G1, MY = Qo;
function NY(e, t) {
  return e && IY(e, t, MY);
}
var gS = NY, DY = PY, LY = gS, jY = Cg;
function UY(e, t) {
  return DY(e, jY(t), LY);
}
var FY = UY, BY = Da, zY = Hn, ZY = Wr, qY = "[object String]";
function WY(e) {
  return typeof e == "string" || !zY(e) && ZY(e) && BY(e) == qY;
}
var VY = WY, HY = af;
function KY(e, t) {
  return HY(t, function(n) {
    return e[n];
  });
}
var GY = KY, JY = GY, YY = Qo;
function XY(e) {
  return e == null ? [] : JY(e, YY(e));
}
var QY = XY, eX = cf, tX = Yi, nX = VY, rX = z1, iX = QY, aX = Math.max;
function oX(e, t, n, r) {
  e = tX(e) ? e : iX(e), n = n && !r ? rX(n) : 0;
  var i = e.length;
  return n < 0 && (n = aX(i + n, 0)), nX(e) ? n <= i && e.indexOf(t, n) > -1 : !!i && eX(e, t, n) > -1;
}
var sX = oX, lX = Yi;
function cX(e, t) {
  return function(n, r) {
    if (n == null)
      return n;
    if (!lX(n))
      return e(n, r);
    for (var i = n.length, a = t ? i : -1, o = Object(n); (t ? a-- : ++a < i) && r(o[a], a, o) !== !1; )
      ;
    return n;
  };
}
var uX = cX, dX = gS, fX = uX, pX = fX(dX), hX = pX, mX = hX, gX = Yi;
function yX(e, t) {
  var n = -1, r = gX(e) ? Array(e.length) : [];
  return mX(e, function(i, a, o) {
    r[++n] = t(i, a, o);
  }), r;
}
var vX = yX, bX = af, wX = Cg, xX = vX, _X = Hn;
function SX(e, t) {
  var n = _X(e) ? bX : xX;
  return n(e, wX(t));
}
var EX = SX, kX = Object.create, ts = Object.defineProperty, TX = Object.defineProperties, CX = Object.getOwnPropertyDescriptor, OX = Object.getOwnPropertyDescriptors, AX = Object.getOwnPropertyNames, hu = Object.getOwnPropertySymbols, $X = Object.getPrototypeOf, Og = Object.prototype.hasOwnProperty, yS = Object.prototype.propertyIsEnumerable, mw = (e, t, n) => t in e ? ts(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, R = (e, t) => {
  for (var n in t || (t = {}))
    Og.call(t, n) && mw(e, n, t[n]);
  if (hu)
    for (var n of hu(t))
      yS.call(t, n) && mw(e, n, t[n]);
  return e;
}, K = (e, t) => TX(e, OX(t)), w = (e, t) => ts(e, "name", { value: t, configurable: !0 }), vS = (e, t) => {
  var n = {};
  for (var r in e)
    Og.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && hu)
    for (var r of hu(e))
      t.indexOf(r) < 0 && yS.call(e, r) && (n[r] = e[r]);
  return n;
}, bS = (e, t) => {
  for (var n in t)
    ts(e, n, { get: t[n], enumerable: !0 });
}, wS = (e, t, n, r) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of AX(t))
      !Og.call(e, i) && i !== n && ts(e, i, { get: () => t[i], enumerable: !(r = CX(t, i)) || r.enumerable });
  return e;
}, Mt = (e, t, n) => (n = e != null ? kX($X(e)) : {}, wS(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  t || !e || !e.__esModule ? ts(n, "default", { value: e, enumerable: !0 }) : n,
  e
)), RX = (e) => wS(ts({}, "__esModule", { value: !0 }), e), xS = {};
bS(xS, {
  BRAND: () => ME,
  DIRTY: () => pa,
  EMPTY_PATH: () => YS,
  INVALID: () => Ye,
  NEVER: () => Ik,
  OK: () => $n,
  ParseInputLazyPath: () => cr,
  ParseStatus: () => jn,
  Schema: () => nt,
  ZodAny: () => Ao,
  ZodArray: () => $o,
  ZodBigInt: () => Rl,
  ZodBoolean: () => Pl,
  ZodBranded: () => Il,
  ZodCatch: () => pf,
  ZodDate: () => hf,
  ZodDefault: () => mf,
  ZodDiscriminatedUnion: () => Ug,
  ZodEffects: () => mi,
  ZodEnum: () => Ea,
  ZodError: () => Dr,
  ZodFirstPartyTypeKind: () => Dg,
  ZodFunction: () => Fg,
  ZodIntersection: () => vf,
  ZodIssueCode: () => ge,
  ZodLazy: () => gf,
  ZodLiteral: () => Nl,
  ZodMap: () => Bg,
  ZodNaN: () => zg,
  ZodNativeEnum: () => Dl,
  ZodNever: () => Zi,
  ZodNull: () => Ll,
  ZodNullable: () => hi,
  ZodNumber: () => Fl,
  ZodObject: () => Ta,
  ZodOptional: () => br,
  ZodParsedType: () => Te,
  ZodPipeline: () => bf,
  ZodPromise: () => Ul,
  ZodReadonly: () => yf,
  ZodRecord: () => Zg,
  ZodSchema: () => nt,
  ZodSet: () => qg,
  ZodString: () => rs,
  ZodSymbol: () => Wg,
  ZodTemplateLiteral: () => Tf,
  ZodTemplateLiteralUnsupportedCheckError: () => vu,
  ZodTemplateLiteralUnsupportedTypeError: () => Pg,
  ZodTransformer: () => mi,
  ZodTuple: () => ka,
  ZodType: () => nt,
  ZodUndefined: () => jl,
  ZodUnion: () => Bl,
  ZodUnknown: () => po,
  ZodVoid: () => Vg,
  ZuiForm: () => QQ,
  addIssueToContext: () => Ce,
  any: () => nk,
  array: () => ok,
  bigint: () => YE,
  boolean: () => Gg,
  coerce: () => Pk,
  createZodEnum: () => Ml,
  cuid2Regex: () => xf,
  cuidRegex: () => wf,
  custom: () => Lg,
  date: () => XE,
  datetimeRegex: () => kf,
  defaultErrorMap: () => ko,
  discriminatedUnion: () => uk,
  effect: () => ed,
  emailRegex: () => Ef,
  enum: () => bk,
  errorUtil: () => We,
  fromJsonSchema: () => $k,
  fromObject: () => Rk,
  function: () => gk,
  getErrorMap: () => Co,
  getParsedType: () => ii,
  instanceof: () => GE,
  intersection: () => dk,
  ipv4Regex: () => zs,
  ipv6Regex: () => Zs,
  isAborted: () => bu,
  isAsync: () => Us,
  isDirty: () => wu,
  isEmojiRegex: () => WE,
  isValid: () => Oo,
  jsonSchemaToZui: () => zl,
  late: () => KE,
  lazy: () => yk,
  literal: () => vk,
  makeIssue: () => js,
  map: () => hk,
  nan: () => JE,
  nativeEnum: () => wk,
  never: () => ik,
  null: () => tk,
  nullable: () => Sk,
  number: () => Kg,
  object: () => sk,
  objectToZui: () => To,
  objectUtil: () => gu,
  oboolean: () => Ak,
  onumber: () => Ok,
  optional: () => _k,
  ostring: () => Ck,
  pipeline: () => kk,
  preprocess: () => Ek,
  processCreateParams: () => ot,
  promise: () => xk,
  quotelessJson: () => VS,
  record: () => pk,
  set: () => mk,
  setErrorMap: () => Ig,
  strictObject: () => lk,
  string: () => Hg,
  symbol: () => QE,
  templateLiteral: () => Tk,
  transformer: () => ed,
  transforms: () => tee,
  tuple: () => fk,
  ulidRegex: () => _f,
  undefined: () => ek,
  union: () => ck,
  unknown: () => rk,
  util: () => bt,
  uuidRegex: () => Sf,
  void: () => ak,
  z: () => cn,
  zuiToJsonSchema: () => uf
});
var cc = RX(xS), cn = {};
bS(cn, {
  BRAND: () => ME,
  DIRTY: () => pa,
  EMPTY_PATH: () => YS,
  INVALID: () => Ye,
  NEVER: () => Ik,
  OK: () => $n,
  ParseInputLazyPath: () => cr,
  ParseStatus: () => jn,
  Schema: () => nt,
  ZodAny: () => Ao,
  ZodArray: () => $o,
  ZodBigInt: () => Rl,
  ZodBoolean: () => Pl,
  ZodBranded: () => Il,
  ZodCatch: () => pf,
  ZodDate: () => hf,
  ZodDefault: () => mf,
  ZodDiscriminatedUnion: () => Ug,
  ZodEffects: () => mi,
  ZodEnum: () => Ea,
  ZodError: () => Dr,
  ZodFirstPartyTypeKind: () => Dg,
  ZodFunction: () => Fg,
  ZodIntersection: () => vf,
  ZodIssueCode: () => ge,
  ZodLazy: () => gf,
  ZodLiteral: () => Nl,
  ZodMap: () => Bg,
  ZodNaN: () => zg,
  ZodNativeEnum: () => Dl,
  ZodNever: () => Zi,
  ZodNull: () => Ll,
  ZodNullable: () => hi,
  ZodNumber: () => Fl,
  ZodObject: () => Ta,
  ZodOptional: () => br,
  ZodParsedType: () => Te,
  ZodPipeline: () => bf,
  ZodPromise: () => Ul,
  ZodReadonly: () => yf,
  ZodRecord: () => Zg,
  ZodSchema: () => nt,
  ZodSet: () => qg,
  ZodString: () => rs,
  ZodSymbol: () => Wg,
  ZodTemplateLiteral: () => Tf,
  ZodTemplateLiteralUnsupportedCheckError: () => vu,
  ZodTemplateLiteralUnsupportedTypeError: () => Pg,
  ZodTransformer: () => mi,
  ZodTuple: () => ka,
  ZodType: () => nt,
  ZodUndefined: () => jl,
  ZodUnion: () => Bl,
  ZodUnknown: () => po,
  ZodVoid: () => Vg,
  addIssueToContext: () => Ce,
  any: () => nk,
  array: () => ok,
  bigint: () => YE,
  boolean: () => Gg,
  coerce: () => Pk,
  createZodEnum: () => Ml,
  cuid2Regex: () => xf,
  cuidRegex: () => wf,
  custom: () => Lg,
  date: () => XE,
  datetimeRegex: () => kf,
  defaultErrorMap: () => ko,
  discriminatedUnion: () => uk,
  effect: () => ed,
  emailRegex: () => Ef,
  enum: () => bk,
  errorUtil: () => We,
  fromJsonSchema: () => $k,
  fromObject: () => Rk,
  function: () => gk,
  getErrorMap: () => Co,
  getParsedType: () => ii,
  instanceof: () => GE,
  intersection: () => dk,
  ipv4Regex: () => zs,
  ipv6Regex: () => Zs,
  isAborted: () => bu,
  isAsync: () => Us,
  isDirty: () => wu,
  isEmojiRegex: () => WE,
  isValid: () => Oo,
  jsonSchemaToZui: () => zl,
  late: () => KE,
  lazy: () => yk,
  literal: () => vk,
  makeIssue: () => js,
  map: () => hk,
  nan: () => JE,
  nativeEnum: () => wk,
  never: () => ik,
  null: () => tk,
  nullable: () => Sk,
  number: () => Kg,
  object: () => sk,
  objectToZui: () => To,
  objectUtil: () => gu,
  oboolean: () => Ak,
  onumber: () => Ok,
  optional: () => _k,
  ostring: () => Ck,
  pipeline: () => kk,
  preprocess: () => Ek,
  processCreateParams: () => ot,
  promise: () => xk,
  quotelessJson: () => VS,
  record: () => pk,
  set: () => mk,
  setErrorMap: () => Ig,
  strictObject: () => lk,
  string: () => Hg,
  symbol: () => QE,
  templateLiteral: () => Tk,
  transformer: () => ed,
  tuple: () => fk,
  ulidRegex: () => _f,
  undefined: () => ek,
  union: () => ck,
  unknown: () => rk,
  util: () => bt,
  uuidRegex: () => Sf,
  void: () => ak,
  zuiToJsonSchema: () => uf
});
var PX = /* @__PURE__ */ w((e, t) => {
  let n;
  switch (e.code) {
    case ge.invalid_type:
      e.received === Te.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case ge.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, bt.jsonStringifyReplacer)}`;
      break;
    case ge.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${bt.joinValues(e.keys, ", ")}`;
      break;
    case ge.invalid_union:
      n = "Invalid input";
      break;
    case ge.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${bt.joinValues(e.options)}`;
      break;
    case ge.invalid_enum_value:
      n = `Invalid enum value. Expected ${bt.joinValues(e.options)}, received '${e.received}'`;
      break;
    case ge.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case ge.invalid_return_type:
      n = "Invalid function return type";
      break;
    case ge.invalid_date:
      n = "Invalid date";
      break;
    case ge.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : bt.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case ge.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case ge.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case ge.custom:
      n = "Invalid input";
      break;
    case ge.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case ge.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case ge.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, bt.assertNever(e);
  }
  return { message: n };
}, "errorMap"), ko = PX, IX = /^\d{4}-\d{2}-\d{2}(T|\s)?((\d{2}:\d{2}:\d{2}(\.\d{1,3})?)|(\d{2}:\d{2}))?(\s?([+-]\d{2}:\d{2}|Z))?$/, To = /* @__PURE__ */ w((e, t, n = !0) => {
  if (typeof e != "object")
    throw new Error("Input must be an object");
  const r = /* @__PURE__ */ w((o) => {
    let s = o;
    return t != null && t.nullable && (s = s.nullable()), t != null && t.optional && (s = s.optional()), t != null && t.passtrough && typeof s.passthrough == "function" && (s = s.passthrough()), s;
  }, "applyOptions"), i = Object.entries(e).reduce((o, [s, l]) => {
    if (l === null)
      o[s] = r(cn.null());
    else
      switch (typeof l) {
        case "string":
          o[s] = IX.test(l) ? r(cn.string().datetime()) : r(cn.string());
          break;
        case "number":
          o[s] = r(cn.number());
          break;
        case "boolean":
          o[s] = r(cn.boolean());
          break;
        case "object":
          Array.isArray(l) ? l.length === 0 ? o[s] = r(cn.array(cn.unknown())) : typeof l[0] == "object" ? o[s] = r(cn.array(To(l[0], t, !1))) : ["string", "number", "boolean"].includes(typeof l[0]) && (o[s] = r(cn.array(cn[typeof l[0]]()))) : o[s] = r(To(l, t, !1));
          break;
        default:
          throw new Error(`Unsupported type for key ${s}`);
      }
    return o;
  }, {}), a = Object.keys(i).length > 0;
  return t != null && t.passtrough || !n && !a ? cn.object(i).passthrough() : cn.object(i);
}, "objectToZui");
function _S() {
  return {};
}
w(_S, "parseAnyDef");
function Ag(e, t, n, r) {
  r != null && r.errorMessages && n && (e.errorMessage = K(R({}, e.errorMessage), {
    [t]: n
  }));
}
w(Ag, "addErrorMessage");
function Ot(e, t, n, r, i) {
  e[t] = n, Ag(e, t, r, i);
}
w(Ot, "setResponseValueAndErrors");
function SS(e, t) {
  var n, r;
  const i = {
    type: "array"
  };
  return ((r = (n = e.type) == null ? void 0 : n._def) == null ? void 0 : r.typeName) !== "ZodAny" && (i.items = kt(e.type._def, K(R({}, t), {
    currentPath: [...t.currentPath, "items"]
  }))), e.minLength && Ot(i, "minItems", e.minLength.value, e.minLength.message, t), e.maxLength && Ot(i, "maxItems", e.maxLength.value, e.maxLength.message, t), e.exactLength && (Ot(i, "minItems", e.exactLength.value, e.exactLength.message, t), Ot(i, "maxItems", e.exactLength.value, e.exactLength.message, t)), i;
}
w(SS, "parseArrayDef");
function ES(e, t) {
  const n = {
    type: "integer",
    format: "int64"
  };
  if (!e.checks)
    return n;
  for (const r of e.checks)
    switch (r.kind) {
      case "min":
        t.target === "jsonSchema7" ? r.inclusive ? Ot(n, "minimum", r.value, r.message, t) : Ot(n, "exclusiveMinimum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMinimum = !0), Ot(n, "minimum", r.value, r.message, t));
        break;
      case "max":
        t.target === "jsonSchema7" ? r.inclusive ? Ot(n, "maximum", r.value, r.message, t) : Ot(n, "exclusiveMaximum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMaximum = !0), Ot(n, "maximum", r.value, r.message, t));
        break;
      case "multipleOf":
        Ot(n, "multipleOf", r.value, r.message, t);
        break;
    }
  return n;
}
w(ES, "parseBigintDef");
function kS() {
  return {
    type: "boolean"
  };
}
w(kS, "parseBooleanDef");
function TS(e, t) {
  return kt(e.type._def, t);
}
w(TS, "parseBrandedDef");
var MX = /* @__PURE__ */ w((e, t) => kt(e.innerType._def, t), "parseCatchDef");
function CS(e, t) {
  return t.dateStrategy == "integer" ? NX(e, t) : {
    type: "string",
    format: "date-time"
  };
}
w(CS, "parseDateDef");
var NX = /* @__PURE__ */ w((e, t) => {
  const n = {
    type: "integer",
    format: "unix-time"
  };
  for (const r of e.checks)
    switch (r.kind) {
      case "min":
        t.target === "jsonSchema7" && Ot(
          n,
          "minimum",
          r.value,
          // This is in milliseconds
          r.message,
          t
        );
        break;
      case "max":
        t.target === "jsonSchema7" && Ot(
          n,
          "maximum",
          r.value,
          // This is in milliseconds
          r.message,
          t
        );
        break;
    }
  return n;
}, "integerDateParser");
function OS(e, t) {
  return K(R({}, kt(e.innerType._def, t)), {
    default: e.defaultValue()
  });
}
w(OS, "parseDefaultDef");
function AS(e, t) {
  return t.effectStrategy === "input" ? kt(e.schema._def, t) : {};
}
w(AS, "parseEffectsDef");
function $S(e) {
  return {
    type: "string",
    enum: e.values
  };
}
w($S, "parseEnumDef");
var DX = /* @__PURE__ */ w((e) => "type" in e && e.type === "string" ? !1 : "allOf" in e, "isJsonSchema7AllOfType");
function RS(e, t) {
  const n = [
    kt(e.left._def, K(R({}, t), {
      currentPath: [...t.currentPath, "allOf", "0"]
    })),
    kt(e.right._def, K(R({}, t), {
      currentPath: [...t.currentPath, "allOf", "1"]
    }))
  ].filter((a) => !!a);
  let r = t.target === "jsonSchema2019-09" ? { unevaluatedProperties: !1 } : void 0;
  const i = [];
  return n.forEach((a) => {
    if (DX(a))
      i.push(...a.allOf), a.unevaluatedProperties === void 0 && (r = void 0);
    else {
      let o = a;
      "additionalProperties" in a && a.additionalProperties === !1 ? o = vS(a, ["additionalProperties"]) : r = void 0, i.push(o);
    }
  }), i.length ? R({
    allOf: i
  }, r) : void 0;
}
w(RS, "parseIntersectionDef");
function PS(e, t) {
  const n = typeof e.value;
  return n !== "bigint" && n !== "number" && n !== "boolean" && n !== "string" ? {
    type: Array.isArray(e.value) ? "array" : "object"
  } : t.target === "openApi3" ? {
    type: n === "bigint" ? "integer" : n,
    enum: [e.value]
  } : {
    type: n === "bigint" ? "integer" : n,
    const: e.value
  };
}
w(PS, "parseLiteralDef");
var ps = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: "^[cC][^\\s-]{8,}$",
  cuid2: "^[a-z][a-z0-9]*$",
  ulid: "^[0-9A-HJKMNP-TV-Z]{26}$",
  /**
   * `a-z` was added to replicate /i flag
   */
  email: "^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_+-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$",
  emoji: "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
  /**
   * Unused
   */
  uuid: "^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$",
  /**
   * Unused
   */
  ipv4: "^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$",
  /**
   * Unused
   */
  ipv6: "^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$"
};
function $g(e, t) {
  const n = {
    type: "string"
  };
  function r(i) {
    return t.patternStrategy === "escape" ? LX(i) : i;
  }
  if (w(r, "processPattern"), e.checks)
    for (const i of e.checks)
      switch (i.kind) {
        case "min":
          Ot(
            n,
            "minLength",
            typeof n.minLength == "number" ? Math.max(n.minLength, i.value) : i.value,
            i.message,
            t
          );
          break;
        case "max":
          Ot(
            n,
            "maxLength",
            typeof n.maxLength == "number" ? Math.min(n.maxLength, i.value) : i.value,
            i.message,
            t
          );
          break;
        case "email":
          switch (t.emailStrategy) {
            case "format:email":
              ia(n, "email", i.message, t);
              break;
            case "format:idn-email":
              ia(n, "idn-email", i.message, t);
              break;
            case "pattern:zod":
              Xr(n, ps.email, i.message, t);
              break;
          }
          break;
        case "url":
          ia(n, "uri", i.message, t);
          break;
        case "uuid":
          ia(n, "uuid", i.message, t);
          break;
        case "regex":
          Xr(n, i.regex.source, i.message, t);
          break;
        case "cuid":
          Xr(n, ps.cuid, i.message, t);
          break;
        case "cuid2":
          Xr(n, ps.cuid2, i.message, t);
          break;
        case "startsWith":
          Xr(n, "^" + r(i.value), i.message, t);
          break;
        case "endsWith":
          Xr(n, r(i.value) + "$", i.message, t);
          break;
        case "datetime":
          ia(n, "date-time", i.message, t);
          break;
        case "length":
          Ot(
            n,
            "minLength",
            typeof n.minLength == "number" ? Math.max(n.minLength, i.value) : i.value,
            i.message,
            t
          ), Ot(
            n,
            "maxLength",
            typeof n.maxLength == "number" ? Math.min(n.maxLength, i.value) : i.value,
            i.message,
            t
          );
          break;
        case "includes": {
          Xr(n, r(i.value), i.message, t);
          break;
        }
        case "ip": {
          i.version !== "v6" && ia(n, "ipv4", i.message, t), i.version !== "v4" && ia(n, "ipv6", i.message, t);
          break;
        }
        case "emoji":
          Xr(n, ps.emoji, i.message, t);
          break;
        case "ulid": {
          Xr(n, ps.ulid, i.message, t);
          break;
        }
      }
  return n;
}
w($g, "parseStringDef");
var LX = /* @__PURE__ */ w((e) => Array.from(e).map((t) => /[a-zA-Z0-9]/.test(t) ? t : `\\${t}`).join(""), "escapeNonAlphaNumeric"), ia = /* @__PURE__ */ w((e, t, n, r) => {
  var i;
  e.format || (i = e.anyOf) != null && i.some((a) => a.format) ? (e.anyOf || (e.anyOf = []), e.format && (e.anyOf.push(R({
    format: e.format
  }, e.errorMessage && r.errorMessages && {
    errorMessage: { format: e.errorMessage.format }
  })), delete e.format, e.errorMessage && (delete e.errorMessage.format, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.anyOf.push(R({
    format: t
  }, n && r.errorMessages && { errorMessage: { format: n } }))) : Ot(e, "format", t, n, r);
}, "addFormat"), Xr = /* @__PURE__ */ w((e, t, n, r) => {
  var i;
  e.pattern || (i = e.allOf) != null && i.some((a) => a.pattern) ? (e.allOf || (e.allOf = []), e.pattern && (e.allOf.push(R({
    pattern: e.pattern
  }, e.errorMessage && r.errorMessages && {
    errorMessage: { pattern: e.errorMessage.pattern }
  })), delete e.pattern, e.errorMessage && (delete e.errorMessage.pattern, Object.keys(e.errorMessage).length === 0 && delete e.errorMessage)), e.allOf.push(R({
    pattern: t
  }, n && r.errorMessages && { errorMessage: { pattern: n } }))) : Ot(e, "pattern", t, n, r);
}, "addPattern");
function Rg(e, t) {
  var n, r, i, a, o;
  if (t.target === "openApi3" && ((n = e.keyType) == null ? void 0 : n._def.typeName) === "ZodEnum")
    return {
      type: "object",
      required: e.keyType._def.values,
      properties: e.keyType._def.values.reduce(
        (l, c) => {
          var u;
          return K(R({}, l), {
            [c]: (u = kt(e.valueType._def, K(R({}, t), {
              currentPath: [...t.currentPath, "properties", c]
            }))) != null ? u : {}
          });
        },
        {}
      ),
      additionalProperties: !1
    };
  const s = {
    type: "object",
    additionalProperties: (r = kt(e.valueType._def, K(R({}, t), {
      currentPath: [...t.currentPath, "additionalProperties"]
    }))) != null ? r : {}
  };
  if (t.target === "openApi3")
    return s;
  if (((i = e.keyType) == null ? void 0 : i._def.typeName) === "ZodString" && ((a = e.keyType._def.checks) != null && a.length)) {
    const l = Object.entries($g(e.keyType._def, t)).reduce(
      (c, [u, d]) => u === "type" ? c : K(R({}, c), { [u]: d }),
      {}
    );
    return K(R({}, s), {
      propertyNames: l
    });
  } else if (((o = e.keyType) == null ? void 0 : o._def.typeName) === "ZodEnum")
    return K(R({}, s), {
      propertyNames: {
        enum: e.keyType._def.values
      }
    });
  return s;
}
w(Rg, "parseRecordDef");
function IS(e, t) {
  if (t.mapStrategy === "record")
    return Rg(e, t);
  const n = kt(e.keyType._def, K(R({}, t), {
    currentPath: [...t.currentPath, "items", "items", "0"]
  })) || {}, r = kt(e.valueType._def, K(R({}, t), {
    currentPath: [...t.currentPath, "items", "items", "1"]
  })) || {};
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [n, r],
      minItems: 2,
      maxItems: 2
    }
  };
}
w(IS, "parseMapDef");
function MS(e) {
  const t = e.values, r = Object.keys(e.values).filter((a) => typeof t[t[a]] != "number").map((a) => t[a]), i = Array.from(new Set(r.map((a) => typeof a)));
  return {
    type: i.length === 1 ? i[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: r.filter(
      (a) => typeof a == "string" || typeof a == "number"
    )
  };
}
w(MS, "parseNativeEnumDef");
function NS() {
  return {
    not: {}
  };
}
w(NS, "parseNeverDef");
function DS(e) {
  return e.target === "openApi3" ? {
    enum: ["null"],
    nullable: !0
  } : {
    type: "null"
  };
}
w(DS, "parseNullDef");
var mu = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function LS(e, t) {
  if (t.target === "openApi3")
    return gw(e, t);
  const n = e.options instanceof Map ? Array.from(e.options.values()) : e.options;
  if (n.every((r) => r._def.typeName in mu && (!r._def.checks || !r._def.checks.length))) {
    const r = n.reduce((i, a) => {
      const o = mu[a._def.typeName];
      return o && !i.includes(o) ? [...i, o] : i;
    }, []);
    return {
      type: r.length > 1 ? r : r[0]
    };
  } else if (n.every((r) => r._def.typeName === "ZodLiteral" && !r.description)) {
    const r = n.reduce((i, a) => {
      const o = typeof a._def.value;
      switch (o) {
        case "string":
        case "number":
        case "boolean":
          return [...i, o];
        case "bigint":
          return [...i, "integer"];
        case "object":
          if (a._def.value === null)
            return [...i, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return i;
      }
    }, []);
    if (r.length === n.length) {
      const i = r.filter((a, o, s) => s.indexOf(a) === o);
      return {
        type: i.length > 1 ? i : i[0],
        enum: n.reduce(
          (a, o) => a.includes(o._def.value) ? a : [...a, o._def.value],
          []
        )
      };
    }
  } else if (n.every((r) => r._def.typeName === "ZodEnum"))
    return {
      type: "string",
      enum: n.reduce(
        (r, i) => [...r, ...i._def.values.filter((a) => !r.includes(a))],
        []
      )
    };
  return gw(e, t);
}
w(LS, "parseUnionDef");
var gw = /* @__PURE__ */ w((e, t) => {
  const n = (e.options instanceof Map ? Array.from(e.options.values()) : e.options).map(
    (i, a) => kt(i._def, K(R({}, t), {
      currentPath: [...t.currentPath, t.unionStrategy, `${a}`]
    }))
  ).filter(
    (i) => !!i && (!t.strictUnions || typeof i == "object" && Object.keys(i).length > 0)
  ), r = t.discriminator && e.typeName === "ZodDiscriminatedUnion" && typeof e.discriminator == "string" ? { discriminator: { propertyName: e.discriminator } } : {};
  if (n.length)
    return t.unionStrategy === "anyOf" ? R({ anyOf: n }, r) : R({ oneOf: n }, r);
}, "asUnionOf");
function jS(e, t) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(e.innerType._def.typeName) && (!e.innerType._def.checks || !e.innerType._def.checks.length))
    return t.target === "openApi3" ? {
      type: mu[e.innerType._def.typeName],
      nullable: !0
    } : {
      type: [mu[e.innerType._def.typeName], "null"]
    };
  if (t.target === "openApi3") {
    const r = kt(e.innerType._def, K(R({}, t), {
      currentPath: [...t.currentPath]
    }));
    return r && K(R({}, r), { nullable: !0 });
  }
  const n = kt(e.innerType._def, K(R({}, t), {
    currentPath: [...t.currentPath, "anyOf", "0"]
  }));
  return n && { anyOf: [n, { type: "null" }] };
}
w(jS, "parseNullableDef");
function US(e, t) {
  const n = {
    type: "number"
  };
  if (!e.checks)
    return n;
  for (const r of e.checks)
    switch (r.kind) {
      case "int":
        n.type = "integer", Ag(n, "type", r.message, t);
        break;
      case "min":
        t.target === "jsonSchema7" ? r.inclusive ? Ot(n, "minimum", r.value, r.message, t) : Ot(n, "exclusiveMinimum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMinimum = !0), Ot(n, "minimum", r.value, r.message, t));
        break;
      case "max":
        t.target === "jsonSchema7" ? r.inclusive ? Ot(n, "maximum", r.value, r.message, t) : Ot(n, "exclusiveMaximum", r.value, r.message, t) : (r.inclusive || (n.exclusiveMaximum = !0), Ot(n, "maximum", r.value, r.message, t));
        break;
      case "multipleOf":
        Ot(n, "multipleOf", r.value, r.message, t);
        break;
    }
  return n;
}
w(US, "parseNumberDef");
function FS(e, t) {
  var n;
  const r = K(R({
    type: "object"
  }, Object.entries(e.shape()).reduce(
    (i, [a, o]) => {
      if (o === void 0 || o._def === void 0)
        return i;
      const s = kt(o._def, K(R({}, t), {
        currentPath: [...t.currentPath, "properties", a],
        propertyPath: [...t.currentPath, "properties", a]
      }));
      return s === void 0 ? i : {
        properties: K(R({}, i.properties), { [a]: s }),
        required: o.isOptional() ? i.required : [...i.required, a]
      };
    },
    { properties: {}, required: [] }
  )), {
    additionalProperties: e.catchall._def.typeName === "ZodNever" ? e.unknownKeys === "passthrough" : (n = kt(e.catchall._def, K(R({}, t), {
      currentPath: [...t.currentPath, "additionalProperties"]
    }))) != null ? n : !0
  });
  return r.required.length || delete r.required, r;
}
w(FS, "parseObjectDef");
var jX = /* @__PURE__ */ w((e, t) => {
  var n;
  if (t.currentPath.toString() === ((n = t.propertyPath) == null ? void 0 : n.toString()))
    return kt(e.innerType._def, t);
  const r = kt(e.innerType._def, K(R({}, t), {
    currentPath: [...t.currentPath, "anyOf", "1"]
  }));
  return r ? {
    anyOf: [
      {
        not: {}
      },
      r
    ]
  } : {};
}, "parseOptionalDef"), UX = /* @__PURE__ */ w((e, t) => {
  if (t.pipeStrategy === "input")
    return kt(e.in._def, t);
  if (t.pipeStrategy === "output")
    return kt(e.out._def, t);
  const n = kt(e.in._def, K(R({}, t), {
    currentPath: [...t.currentPath, "allOf", "0"]
  })), r = kt(e.out._def, K(R({}, t), {
    currentPath: [...t.currentPath, "allOf", n ? "1" : "0"]
  }));
  return {
    allOf: [n, r].filter((i) => i !== void 0)
  };
}, "parsePipelineDef");
function BS(e, t) {
  return kt(e.type._def, t);
}
w(BS, "parsePromiseDef");
function zS(e, t) {
  const r = {
    type: "array",
    uniqueItems: !0,
    items: kt(e.valueType._def, K(R({}, t), {
      currentPath: [...t.currentPath, "items"]
    }))
  };
  return e.minSize && Ot(r, "minItems", e.minSize.value, e.minSize.message, t), e.maxSize && Ot(r, "maxItems", e.maxSize.value, e.maxSize.message, t), r;
}
w(zS, "parseSetDef");
function ZS(e, t) {
  return e.rest ? {
    type: "array",
    minItems: e.items.length,
    items: e.items.map(
      (n, r) => kt(n._def, K(R({}, t), {
        currentPath: [...t.currentPath, "items", `${r}`]
      }))
    ).reduce((n, r) => r === void 0 ? n : [...n, r], []),
    additionalItems: kt(e.rest._def, K(R({}, t), {
      currentPath: [...t.currentPath, "additionalItems"]
    }))
  } : {
    type: "array",
    minItems: e.items.length,
    maxItems: e.items.length,
    items: e.items.map(
      (n, r) => kt(n._def, K(R({}, t), {
        currentPath: [...t.currentPath, "items", `${r}`]
      }))
    ).reduce((n, r) => r === void 0 ? n : [...n, r], [])
  };
}
w(ZS, "parseTupleDef");
function qS() {
  return {
    not: {}
  };
}
w(qS, "parseUndefinedDef");
function WS() {
  return {};
}
w(WS, "parseUnknownDef");
var FX = /* @__PURE__ */ w((e, t) => kt(e.innerType._def, t), "parseReadonlyDef"), Kt = "x-zui";
function kt(e, t, n = !1) {
  const r = t.seen.get(e);
  if (r && !n) {
    const o = BX(r, t);
    if (o !== void 0)
      return o;
  }
  const i = { def: e, path: t.currentPath, jsonSchema: void 0 };
  t.seen.set(e, i);
  const a = ZX(e, e.typeName, t);
  return a && qX(e, t, a), i.jsonSchema = a, a;
}
w(kt, "parseDef");
var BX = /* @__PURE__ */ w((e, t) => {
  switch (t.$refStrategy) {
    case "root":
      return { $ref: e.path.join("/") };
    case "relative":
      return { $ref: zX(t.currentPath, e.path) };
    case "none":
    case "seen":
      return e.path.length < t.currentPath.length && e.path.every((n, r) => t.currentPath[r] === n) ? (console.warn(`Recursive reference detected at ${t.currentPath.join("/")}! Defaulting to any`), {}) : t.$refStrategy === "seen" ? {} : void 0;
  }
}, "get$ref"), zX = /* @__PURE__ */ w((e, t) => {
  let n = 0;
  for (; n < e.length && n < t.length && e[n] === t[n]; n++)
    ;
  return [(e.length - n).toString(), ...t.slice(n)].join("/");
}, "getRelativePath"), ZX = /* @__PURE__ */ w((e, t, n) => {
  switch (t) {
    case "ZodString":
      return $g(e, n);
    case "ZodNumber":
      return US(e, n);
    case "ZodObject":
      return FS(e, n);
    case "ZodBigInt":
      return ES(e, n);
    case "ZodBoolean":
      return kS();
    case "ZodDate":
      return CS(e, n);
    case "ZodUndefined":
      return qS();
    case "ZodNull":
      return DS(n);
    case "ZodArray":
      return SS(e, n);
    case "ZodUnion":
    case "ZodDiscriminatedUnion":
      return LS(e, n);
    case "ZodIntersection":
      return RS(e, n);
    case "ZodTuple":
      return ZS(e, n);
    case "ZodRecord":
      return Rg(e, n);
    case "ZodLiteral":
      return PS(e, n);
    case "ZodEnum":
      return $S(e);
    case "ZodNativeEnum":
      return MS(e);
    case "ZodNullable":
      return jS(e, n);
    case "ZodOptional":
      return jX(e, n);
    case "ZodMap":
      return IS(e, n);
    case "ZodSet":
      return zS(e, n);
    case "ZodLazy":
      return kt(e.getter()._def, n);
    case "ZodPromise":
      return BS(e, n);
    case "ZodNaN":
    case "ZodNever":
      return NS();
    case "ZodEffects":
      return AS(e, n);
    case "ZodAny":
      return _S();
    case "ZodUnknown":
      return WS();
    case "ZodDefault":
      return OS(e, n);
    case "ZodBranded":
      return TS(e, n);
    case "ZodReadonly":
      return FX(e, n);
    case "ZodCatch":
      return MX(e, n);
    case "ZodPipeline":
      return UX(e, n);
    case "ZodTemplateLiteral":
      throw new Error("Template literals are not supported yet");
    case "ZodFunction":
    case "ZodVoid":
    case "ZodSymbol":
      return;
    default:
      return /* @__PURE__ */ ((r) => {
      })();
  }
}, "selectParser"), qX = /* @__PURE__ */ w((e, t, n) => (e.description && (n.description = e.description, t.markdownDescription && (n.markdownDescription = e.description)), e[Kt] && (n[Kt] = e[Kt]), n), "addMeta"), yw = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "string",
  mapStrategy: "entries",
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: !1,
  definitions: {},
  errorMessages: !1,
  markdownDescription: !1,
  patternStrategy: "escape",
  emailStrategy: "format:email",
  discriminator: !1,
  unionStrategy: "anyOf"
}, WX = /* @__PURE__ */ w((e) => typeof e == "string" ? K(R({}, yw), {
  name: e
}) : R(R({}, yw), e), "getDefaultOptions"), VX = /* @__PURE__ */ w((e) => {
  const t = WX(e), n = t.name !== void 0 ? [...t.basePath, t.definitionPath, t.name] : t.basePath;
  return K(R({}, t), {
    currentPath: n,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(t.definitions).map(([r, i]) => [
        i._def,
        {
          def: i._def,
          path: [...t.basePath, t.definitionPath, r],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  });
}, "getRefs"), HX = /* @__PURE__ */ w((e, t) => {
  var n;
  const r = VX(t), i = typeof t == "object" && t.definitions ? Object.entries(t.definitions).reduce(
    (l, [c, u]) => {
      var d;
      return K(R({}, l), {
        [c]: (d = kt(
          u._def,
          K(R({}, r), {
            currentPath: [...r.basePath, r.definitionPath, c]
          }),
          !0
        )) != null ? d : {}
      });
    },
    {}
  ) : void 0, a = typeof t == "string" ? t : t == null ? void 0 : t.name, o = (n = kt(
    e._def,
    a === void 0 ? r : K(R({}, r), {
      currentPath: [...r.basePath, r.definitionPath, a]
    }),
    !1
  )) != null ? n : {}, s = a === void 0 ? i ? K(R({}, o), {
    [r.definitionPath]: i
  }) : o : {
    $ref: [...r.$refStrategy === "relative" ? [] : r.basePath, r.definitionPath, a].join("/"),
    [r.definitionPath]: K(R({}, i), {
      [a]: o
    })
  };
  return r.target === "jsonSchema7" ? s.$schema = "http://json-schema.org/draft-07/schema#" : r.target === "jsonSchema2019-09" && (s.$schema = "https://json-schema.org/draft/2019-09/schema#"), s;
}, "zodToJsonSchema"), uf = /* @__PURE__ */ w((e, t = { target: "openApi3" }) => {
  const n = HX(e, t);
  return t.$schemaUrl === !1 ? delete n.$schema : typeof t.$schemaUrl == "string" && (n.$schema = t.$schemaUrl), Ga(n, e, t);
}, "zuiToJsonSchema"), KX = /* @__PURE__ */ w((e) => {
  var t, n, r, i;
  if (e != null && e._def)
    return e._def.getter && typeof e._def.getter == "function" ? (n = (t = e._def.getter()._def) == null ? void 0 : t.shape) == null ? void 0 : n.call(t) : (i = (r = e._def).shape) == null ? void 0 : i.call(r);
}, "getShape"), Ga = /* @__PURE__ */ w((e, t, n) => {
  const r = /* @__PURE__ */ w((i, a) => {
    n.stripZuiProps || Object.assign(i, { [Kt]: a });
  }, "assignZuiProps");
  if (e.type === "object" && e.properties)
    for (const [i, a] of Object.entries(e.properties)) {
      const o = KX(t);
      if (o != null && o[i]) {
        const s = o[i].ui;
        r(a, s), Ga(a, o[i], n);
      }
    }
  if (e.type == "array") {
    const i = t._def;
    Array.isArray(e.items) ? (i.typeName === cn.ZodFirstPartyTypeKind.ZodTuple && e.items.forEach((a, o) => {
      const s = i.items[o];
      s && Ga(a, s, n);
    }), i.typeName === cn.ZodFirstPartyTypeKind.ZodMap && e.items.map((a) => Ga(a, i.valueType, n))) : e.items && (i.typeName === cn.ZodFirstPartyTypeKind.ZodMap ? Ga(e.items, i.valueType, n) : Ga(e.items, t._def.type, n));
  }
  return t && "ui" in t && (t != null && t.ui) && r(e, t.ui), e;
}, "mergeZuiIntoJsonSchema"), bt;
((e) => {
  e.assertEqual = /* @__PURE__ */ w((i) => i, "assertEqual");
  function t(i) {
  }
  e.assertIs = t, w(t, "assertIs");
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, w(n, "assertNever"), e.arrayToEnum = /* @__PURE__ */ w((i) => {
    const a = {};
    for (const o of i)
      a[o] = o;
    return a;
  }, "arrayToEnum"), e.getValidEnumValues = /* @__PURE__ */ w((i) => {
    const a = (0, e.objectKeys)(i).filter((s) => typeof i[i[s]] != "number"), o = {};
    for (const s of a)
      o[s] = i[s];
    return (0, e.objectValues)(o);
  }, "getValidEnumValues"), e.objectValues = /* @__PURE__ */ w((i) => (0, e.objectKeys)(i).map(function(a) {
    return i[a];
  }), "objectValues"), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const a = [];
    for (const o in i)
      Object.prototype.hasOwnProperty.call(i, o) && a.push(o);
    return a;
  }, e.find = /* @__PURE__ */ w((i, a) => {
    for (const o of i)
      if (a(o))
        return o;
  }, "find"), e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function r(i, a = " | ") {
    return i.map((o) => typeof o == "string" ? `'${o}'` : o).join(a);
  }
  e.joinValues = r, w(r, "joinValues"), e.jsonStringifyReplacer = /* @__PURE__ */ w((i, a) => typeof a == "bigint" ? a.toString() : a, "jsonStringifyReplacer");
})(bt || (bt = {}));
var gu;
((e) => {
  e.mergeShapes = /* @__PURE__ */ w((t, n) => R(R({}, t), n), "mergeShapes");
})(gu || (gu = {}));
var Te = bt.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), ii = /* @__PURE__ */ w((e) => {
  switch (typeof e) {
    case "undefined":
      return Te.undefined;
    case "string":
      return Te.string;
    case "number":
      return isNaN(e) ? Te.nan : Te.number;
    case "boolean":
      return Te.boolean;
    case "function":
      return Te.function;
    case "bigint":
      return Te.bigint;
    case "symbol":
      return Te.symbol;
    case "object":
      return Array.isArray(e) ? Te.array : e === null ? Te.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Te.promise : typeof Map < "u" && e instanceof Map ? Te.map : typeof Set < "u" && e instanceof Set ? Te.set : typeof Date < "u" && e instanceof Date ? Te.date : Te.object;
    default:
      return Te.unknown;
  }
}, "getParsedType");
function ot(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: i } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: /* @__PURE__ */ w((o, s) => o.code !== "invalid_type" ? { message: s.defaultError } : typeof s.data > "u" ? { message: r ?? s.defaultError } : { message: n ?? s.defaultError }, "customMap"), description: i };
}
w(ot, "processCreateParams");
var ge = bt.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), VS = /* @__PURE__ */ w((e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:"), "quotelessJson"), yu = class HS extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = /* @__PURE__ */ w((r) => {
      this.issues = [...this.issues, r];
    }, "addIssue"), this.addIssues = /* @__PURE__ */ w((r = []) => {
      this.issues = [...this.issues, ...r];
    }, "addIssues");
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(a) {
      return a.message;
    }, r = { _errors: [] }, i = /* @__PURE__ */ w((a) => {
      for (const o of a.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(i);
        else if (o.code === "invalid_return_type")
          i(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          i(o.argumentsError);
        else if (o.path.length === 0)
          r._errors.push(n(o));
        else {
          let s = r, l = 0;
          for (; l < o.path.length; ) {
            const c = o.path[l];
            l === o.path.length - 1 ? (s[c] = s[c] || { _errors: [] }, s[c]._errors.push(n(o))) : s[c] = s[c] || { _errors: [] }, s = s[c], l++;
          }
        }
    }, "processError");
    return i(this), r;
  }
  static assert(t) {
    if (!(t instanceof HS))
      throw new Error(`Not a ZodError: ${t}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, bt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const i of this.issues)
      i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
};
w(yu, "ZodError");
yu.create = /* @__PURE__ */ w((e) => new yu(e), "create");
var Dr = yu, KS = class extends Error {
  constructor() {
    super("Unsupported zod type!");
    const t = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodTemplateLiteralUnsupportedTypeError";
  }
};
w(KS, "ZodTemplateLiteralUnsupportedTypeError");
var Pg = KS, GS = class extends Error {
  constructor(t, n) {
    super(`${t}'s "${n}" check is not supported in template literals!`);
    const r = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r, this.name = "ZodTemplateLiteralUnsupportedCheckError";
  }
};
w(GS, "ZodTemplateLiteralUnsupportedCheckError");
var vu = GS, JS = ko;
function Ig(e) {
  JS = e;
}
w(Ig, "setErrorMap");
function Co() {
  return JS;
}
w(Co, "getErrorMap");
var js = /* @__PURE__ */ w((e) => {
  var t;
  const { data: n, path: r, errorMaps: i, issueData: a } = e, o = [...r, ...a.path || []], s = K(R({}, a), {
    path: o
  });
  let l = "";
  const c = i.filter((u) => !!u).slice().reverse();
  for (const u of c)
    l = u(s, { data: n, defaultError: l }).message;
  return K(R({}, a), {
    path: o,
    message: (t = a.message) != null ? t : l
  });
}, "makeIssue"), YS = [];
function Ce(e, t) {
  const n = js({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      // contextual error map is first priority
      e.schemaErrorMap,
      // then schema-bound map if available
      Co(),
      // then global override map
      ko
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(n);
}
w(Ce, "addIssueToContext");
var XS = class QS {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const i of n) {
      if (i.status === "aborted")
        return Ye;
      i.status === "dirty" && t.dirty(), r.push(i.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const i of n)
      r.push({
        key: await i.key,
        value: await i.value
      });
    return QS.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const i of n) {
      const { key: a, value: o } = i;
      if (a.status === "aborted" || o.status === "aborted")
        return Ye;
      a.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), a.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (r[a.value] = o.value);
    }
    return { status: t.value, value: r };
  }
};
w(XS, "ParseStatus");
var jn = XS, Ye = Object.freeze({
  status: "aborted"
}), pa = /* @__PURE__ */ w((e) => ({ status: "dirty", value: e }), "DIRTY"), $n = /* @__PURE__ */ w((e) => ({ status: "valid", value: e }), "OK"), bu = /* @__PURE__ */ w((e) => e.status === "aborted", "isAborted"), wu = /* @__PURE__ */ w((e) => e.status === "dirty", "isDirty"), Oo = /* @__PURE__ */ w((e) => e.status === "valid", "isValid"), Us = /* @__PURE__ */ w((e) => typeof Promise < "u" && e instanceof Promise, "isAsync"), We;
((e) => {
  e.errToObj = /* @__PURE__ */ w((t) => typeof t == "string" ? { message: t } : t || {}, "errToObj"), e.toString = /* @__PURE__ */ w((t) => typeof t == "string" ? t : t == null ? void 0 : t.message, "toString");
})(We || (We = {}));
var GX = Mt(Pq, 1), JX = Mt(y8, 1), YX = Mt(H1, 1), XX = Mt(KV, 1), QX = Mt(sf, 1), eQ = Mt(iS, 1);
function Al(e) {
  return "comment" in e && e.comment != null && e.comment !== "" || // Compare to true because ast.deprecated might be undefined
  "deprecated" in e && e.deprecated === !0;
}
w(Al, "hasComment");
function co(e) {
  return "standaloneName" in e && e.standaloneName != null && e.standaloneName !== "";
}
w(co, "hasStandaloneName");
var uo = {
  type: "ANY"
}, tQ = {
  keyName: "[k: string]",
  type: "ANY"
}, fo = {
  type: "UNKNOWN"
}, nQ = {
  keyName: "[k: string]",
  type: "UNKNOWN"
}, rQ = Mt(TK, 1), eE = Mt(ja, 1), iQ = Mt(CG, 1), aQ = Mt(DG, 1), oQ = Mt(sf, 1), sQ = Mt(ja, 1), Fs = Symbol("Parent"), tE = (0, oQ.default)((e) => {
  const t = e[Fs];
  return t ? tE(t) : e;
});
function nE(e) {
  return e === !0 || e === !1;
}
w(nE, "isBoolean");
function rE(e) {
  return !(0, sQ.default)(e);
}
w(rE, "isPrimitive");
function Ac(e) {
  return Array.isArray(e.type) || "anyOf" in e || "oneOf" in e;
}
w(Ac, "isCompound");
var iE = /* @__PURE__ */ w((e, t) => {
  const n = e.split("/").pop() || "";
  return t ? n.replaceAll(t, "") : n;
}, "basename"), lQ = /* @__PURE__ */ w((e) => {
  const t = iE(e), n = t.lastIndexOf(".");
  return n === -1 ? "" : t.slice(n);
}, "extname"), cQ = /* @__PURE__ */ new Set([
  "id",
  "$defs",
  "$id",
  "$schema",
  "title",
  "description",
  "default",
  "multipleOf",
  "maximum",
  "exclusiveMaximum",
  "minimum",
  "exclusiveMinimum",
  "maxLength",
  "minLength",
  "pattern",
  "additionalItems",
  "items",
  "maxItems",
  "minItems",
  "uniqueItems",
  "maxProperties",
  "minProperties",
  "required",
  "additionalProperties",
  "definitions",
  "properties",
  "patternProperties",
  "dependencies",
  "enum",
  "type",
  "allOf",
  "anyOf",
  "oneOf",
  "not"
]);
function oa(e, t, n) {
  Object.keys(e).forEach((r) => {
    e[r] && typeof e[r] == "object" && !Array.isArray(e[r]) && oi(e[r], t, n, r);
  });
}
w(oa, "traverseObjectKeys");
function Ja(e, t, n) {
  e.forEach((r, i) => oi(r, t, n, i.toString()));
}
w(Ja, "traverseArray");
function oi(e, t, n = /* @__PURE__ */ new Set(), r) {
  if (!n.has(e)) {
    if (n.add(e), t(e, r ?? null), e.anyOf && Ja(e.anyOf, t, n), e.allOf && Ja(e.allOf, t, n), e.oneOf && Ja(e.oneOf, t, n), e.properties && oa(e.properties, t, n), e.patternProperties && oa(e.patternProperties, t, n), e.additionalProperties && typeof e.additionalProperties == "object" && oi(e.additionalProperties, t, n), e.items) {
      const { items: i } = e;
      Array.isArray(i) ? Ja(i, t, n) : oi(i, t, n);
    }
    e.additionalItems && typeof e.additionalItems == "object" && oi(e.additionalItems, t, n), e.dependencies && (Array.isArray(e.dependencies) ? Ja(e.dependencies, t, n) : oa(e.dependencies, t, n)), e.definitions && oa(e.definitions, t, n), e.$defs && oa(e.$defs, t, n), e.not && oi(e.not, t, n), Object.keys(e).filter((i) => !cQ.has(i)).forEach((i) => {
      const a = e[i];
      a && typeof a == "object" && oa(a, t, n);
    });
  }
}
w(oi, "traverse");
function Ih(e = "") {
  return aE(iE(e));
}
w(Ih, "justName");
function aE(e) {
  return e.replace(lQ(e), "");
}
w(aE, "stripExtension");
function pi(e) {
  return (0, aQ.default)(
    // remove accents, umlauts, ... by their basic latin letters
    (0, rQ.default)(e).replace(/(^\s*[^a-zA-Z_$])|([^a-zA-Z_$\d])/g, " ").replace(/^_[a-z]/g, (t) => t.toUpperCase()).replace(/_[a-z]/g, (t) => t.substr(1, t.length).toUpperCase()).replace(/([\d$]+[a-zA-Z])/g, (t) => t.toUpperCase()).replace(/\s+([a-zA-Z])/g, (t) => (0, iQ.default)(t.toUpperCase())).replace(/\s/g, "")
  );
}
w(pi, "toSafeString");
function oE(e, t) {
  let n = pi(e);
  if (n || (n = "NoName"), t.has(n)) {
    let r = 1, i = `${n}${r}`;
    for (; t.has(i); )
      i = `${n}${r}`, r++;
    n = i;
  }
  return t.add(n), n;
}
w(oE, "generateName");
function sE(...e) {
  if (!process.env.VERBOSE)
    return console.error(e);
  console.error(...e);
}
w(sE, "error");
function xn(e, t, ...n) {
  if (!process.env.VERBOSE)
    return;
  let r = null;
  n.length > 1 && typeof n[n.length - 1] != "string" && (r = n.splice(n.length - 1, 1)), console.info(t, ...n), r && console.dir(r, { depth: 6, maxArrayLength: 6 });
}
w(xn, "log");
function lE(e) {
  const t = "* /";
  if (!(e === null || typeof e != "object"))
    for (const n of Object.keys(e))
      n === "description" && typeof e[n] == "string" && (e[n] = e[n].replace(/\*\//g, t));
}
w(lE, "escapeBlockComment");
function cE(e) {
  if (!("default" in e))
    return e;
  switch (e.type) {
    case "array":
      if (Array.isArray(e.default))
        return e;
      break;
    case "boolean":
      if (typeof e.default == "boolean")
        return e;
      break;
    case "integer":
    case "number":
      if (typeof e.default == "number")
        return e;
      break;
    case "string":
      if (typeof e.default == "string")
        return e;
      break;
    case "null":
      if (e.default === null)
        return e;
      break;
    case "object":
      if ((0, eE.default)(e.default))
        return e;
      break;
  }
  return delete e.default, e;
}
w(cE, "maybeStripDefault");
function uE(e) {
  return "$id" in e && delete e.$id, "description" in e && delete e.description, "name" in e && delete e.name, e;
}
w(uE, "maybeStripNameHints");
function dE(e, ...t) {
  return e ? `${e}

${t.join(`
`)}` : t.join(`
`);
}
w(dE, "appendToDescription");
function Mg(e) {
  if (!(0, eE.default)(e))
    return !1;
  const t = e[Fs];
  return t === null ? !0 : ![
    "$defs",
    "allOf",
    "anyOf",
    "definitions",
    "dependencies",
    "enum",
    "not",
    "oneOf",
    "patternProperties",
    "properties",
    "required"
  ].some((r) => t[r] === e);
}
w(Mg, "isSchemaLike");
function fE(e, t = OE) {
  return [
    t.bannerComment,
    ro(e, t, e.standaloneName),
    no(e, t, e.standaloneName),
    la(e, t)
  ].filter(Boolean).join(`

`) + `
`;
}
w(fE, "generate");
function la(e, t, n = /* @__PURE__ */ new Set()) {
  if (n.has(e))
    return "";
  n.add(e);
  let r = "";
  switch (e.type) {
    case "ENUM":
      return mE(e, t) + `
`;
    case "ARRAY":
      return la(e.params, t, n);
    case "UNION":
    case "INTERSECTION":
      return e.params.reduce((i, a) => i + la(a, t, n), "");
    case "TUPLE":
      return r = e.params.reduce((i, a) => i + la(a, t, n), ""), e.spreadParam && (r += la(e.spreadParam, t, n)), r;
    case "INTERFACE":
      return df(e).reduce((i, a) => i + la(a, t, n), "");
    default:
      return "";
  }
}
w(la, "declareEnums");
function no(e, t, n, r = /* @__PURE__ */ new Set()) {
  if (r.has(e))
    return "";
  r.add(e);
  let i = "";
  switch (e.type) {
    case "ARRAY":
      i = no(e.params, t, n, r);
      break;
    case "INTERFACE":
      i = [
        co(e) && (e.standaloneName === n || t.declareExternallyReferenced) && gE(e, t),
        df(e).map((a) => no(a, t, n, r)).filter(Boolean).join(`
`)
      ].filter(Boolean).join(`
`);
      break;
    case "INTERSECTION":
    case "TUPLE":
    case "UNION":
      i = e.params.map((a) => no(a, t, n, r)).filter(Boolean).join(`
`), e.type === "TUPLE" && e.spreadParam && (i += no(e.spreadParam, t, n, r));
      break;
    default:
      i = "";
  }
  return i;
}
w(no, "declareNamedInterfaces");
function ro(e, t, n, r = /* @__PURE__ */ new Set()) {
  if (r.has(e))
    return "";
  switch (r.add(e), e.type) {
    case "ARRAY":
      return [
        ro(e.params, t, n, r),
        co(e) ? $c(e, t) : void 0
      ].filter(Boolean).join(`
`);
    case "ENUM":
      return "";
    case "INTERFACE":
      return df(e).map(
        (i) => (i.standaloneName === n || t.declareExternallyReferenced) && ro(i, t, n, r)
      ).filter(Boolean).join(`
`);
    case "INTERSECTION":
    case "TUPLE":
    case "UNION":
      return [
        co(e) ? $c(e, t) : void 0,
        e.params.map((i) => ro(i, t, n, r)).filter(Boolean).join(`
`),
        "spreadParam" in e && e.spreadParam ? ro(e.spreadParam, t, n, r) : void 0
      ].filter(Boolean).join(`
`);
    default:
      return co(e) ? $c(e, t) : "";
  }
}
w(ro, "declareNamedTypes");
function pE(e, t) {
  const n = hE(e, t);
  return t.strictIndexSignatures && e.keyName === "[k: string]" ? `${n} | undefined` : n;
}
w(pE, "generateTypeUnmemoized");
var Lr = (0, QX.default)(pE);
function hE(e, t) {
  if (xn("magenta", "generator", e), co(e))
    return pi(e.standaloneName);
  switch (e.type) {
    case "ANY":
      return "any";
    case "ARRAY":
      return (() => {
        const n = Lr(e.params, t);
        return n.endsWith('"') ? "(" + n + ")[]" : n + "[]";
      })();
    case "BOOLEAN":
      return "boolean";
    case "INTERFACE":
      return Ng(e, t);
    case "INTERSECTION":
      return Mh(e, t);
    case "LITERAL":
      return JSON.stringify(e.params);
    case "NEVER":
      return "never";
    case "NUMBER":
      return "number";
    case "NULL":
      return "null";
    case "OBJECT":
      return "object";
    case "REFERENCE":
      return e.params;
    case "STRING":
      return "string";
    case "TUPLE":
      return (() => {
        const n = e.minItems, r = e.maxItems || -1;
        let i = e.spreadParam;
        const a = [...e.params];
        if (n > 0 && n > a.length && e.spreadParam === void 0 && r < 0 && (i = t.unknownAny ? fo : uo), r > a.length && e.spreadParam === void 0)
          for (let c = a.length; c < r; c += 1)
            a.push(t.unknownAny ? fo : uo);
        function o(c) {
          if (i) {
            const u = "...(" + Lr(i, t) + ")[]";
            c.push(u);
          }
          return c;
        }
        w(o, "addSpreadParam");
        function s(c) {
          return "[" + c.join(", ") + "]";
        }
        w(s, "paramsToString");
        const l = a.map((c) => Lr(c, t));
        if (l.length > n) {
          const c = l.slice(0, n), u = [];
          c.length > 0 ? u.push(s(c)) : u.push(s([]));
          for (let d = n; d < l.length; d += 1)
            c.push(l[d]), d === l.length - 1 && o(c), u.push(s(c));
          return u.join("|");
        }
        return s(o(l));
      })();
    case "UNION":
      return Mh(e, t);
    case "UNKNOWN":
      return "unknown";
    case "CUSTOM_TYPE":
      return e.params;
  }
}
w(hE, "generateRawType");
function Mh(e, t) {
  const n = e.params.map((i) => Lr(i, t)), r = e.type === "UNION" ? "|" : "&";
  return n.length === 1 ? n[0] : "(" + n.join(" " + r + " ") + ")";
}
w(Mh, "generateSetOperation");
function Ng(e, t) {
  return `{
` + e.params.filter((n) => !n.isPatternProperty && !n.isUnreachableDefinition).map(
    ({ isRequired: n, keyName: r, ast: i }) => [n, r, i, Lr(i, t)]
  ).map(
    ([n, r, i, a]) => (Al(i) && !i.standaloneName ? $l(i.comment, i.deprecated) + `
` : "") + yE(r) + (n ? "" : "?") + ": " + a
  ).join(`
`) + `
}`;
}
w(Ng, "generateInterface");
function $l(e, t) {
  const n = ["/**"];
  return t && n.push(" * @deprecated"), typeof e < "u" && n.push(...e.split(`
`).map((r) => " * " + r)), n.push(" */"), n.join(`
`);
}
w($l, "generateComment");
function mE(e, t) {
  return (Al(e) ? $l(e.comment, e.deprecated) + `
` : "") + "export " + (t.enableConstEnums ? "const " : "") + `enum ${pi(e.standaloneName)} {
` + e.params.map(({ ast: n, keyName: r }) => r + " = " + Lr(n, t)).join(`,
`) + `
}`;
}
w(mE, "generateStandaloneEnum");
function gE(e, t) {
  return (Al(e) ? $l(e.comment, e.deprecated) + `
` : "") + `export interface ${pi(e.standaloneName)} ` + (e.superTypes.length > 0 ? `extends ${e.superTypes.map((n) => pi(n.standaloneName)).join(", ")} ` : "") + Ng(e, t);
}
w(gE, "generateStandaloneInterface");
function $c(e, t) {
  return (Al(e) ? $l(e.comment) + `
` : "") + `export type ${pi(e.standaloneName)} = ${Lr(
    (0, eQ.default)(e, "standaloneName"),
    t
  )}`;
}
w($c, "generateStandaloneType");
function yE(e) {
  return e.length && /[A-Za-z_$]/.test(e.charAt(0)) && /^[\w$]+$/.test(e) || e === "[k: string]" ? e : JSON.stringify(e);
}
w(yE, "escapeKeyName");
function df(e) {
  return e.params.map((t) => t.ast).concat(e.superTypes);
}
w(df, "getSuperTypesAndParams");
var uQ = Mt(ja, 1);
function xu(e, t = null) {
  if (!Array.isArray(e) && !(0, uQ.default)(e) || e.hasOwnProperty(Fs))
    return e;
  Object.defineProperty(e, Fs, {
    enumerable: !1,
    value: t,
    writable: !1
  }), Array.isArray(e) && e.forEach((n) => xu(n, e));
  for (const n in e)
    xu(e[n], e);
  return e;
}
w(xu, "link");
var dQ = Mt(H1, 1), fQ = Mt(JG, 1), gn = /* @__PURE__ */ new Map();
function Bs(e, t) {
  return e.type === t || Array.isArray(e.type) && e.type.includes(t);
}
w(Bs, "hasType");
function ff(e) {
  return e.properties !== void 0 || Bs(e, "object") || Bs(e, "any");
}
w(ff, "isObjectType");
function ns(e) {
  return e.items !== void 0 || Bs(e, "array") || Bs(e, "any");
}
w(ns, "isArrayType");
gn.set('Remove `type=["null"]` if `enum=[null]`', (e) => {
  Array.isArray(e.enum) && e.enum.some((t) => t === null) && Array.isArray(e.type) && e.type.includes("null") && (e.type = e.type.filter((t) => t !== "null"));
});
gn.set("Destructure unary types", (e) => {
  e.type && Array.isArray(e.type) && e.type.length === 1 && (e.type = e.type[0]);
});
gn.set("Add empty `required` property if none is defined", (e) => {
  ff(e) && !("required" in e) && (e.required = []);
});
gn.set("Transform `required`=false to `required`=[]", (e) => {
  e.required === !1 && (e.required = []);
});
gn.set("Default additionalProperties", (e, t, n) => {
  ff(e) && !("additionalProperties" in e) && e.patternProperties === void 0 && (e.additionalProperties = n.additionalProperties);
});
gn.set("Transform id to $id", (e, t) => {
  if (Mg(e)) {
    if (e.id && e.$id && e.id !== e.$id)
      throw ReferenceError(
        `Schema must define either id or $id, not both. Given id=${e.id}, $id=${e.$id} in ${t}`
      );
    e.id && (e.$id = e.id, delete e.id);
  }
});
gn.set("Add an $id to anything that needs it", (e, t, n, r, i) => {
  if (!Mg(e))
    return;
  if (!e.$id && !e[Fs]) {
    let o = Ih(t);
    o = (0, fQ.default)(o) ? "Root" : o, e.$id = pi(o);
    return;
  }
  if (!ns(e) && !ff(e))
    return;
  const a = i.get(e);
  !e.$id && !e.title && a && (e.$id = pi(Ih(a))), a && i.delete(e);
});
gn.set("Escape closing JSDoc comment", (e) => {
  lE(e);
});
gn.set("Add JSDoc comments for minItems and maxItems", (e) => {
  if (!ns(e))
    return;
  const t = [
    "minItems" in e ? `@minItems ${e.minItems}` : "",
    "maxItems" in e ? `@maxItems ${e.maxItems}` : ""
  ].filter(Boolean);
  t.length && (e.description = dE(e.description, ...t));
});
gn.set("Optionally remove maxItems and minItems", (e, t, n) => {
  ns(e) && ("minItems" in e && n.ignoreMinAndMaxItems && delete e.minItems, "maxItems" in e && (n.ignoreMinAndMaxItems || n.maxItems === -1) && delete e.maxItems);
});
gn.set("Normalize schema.minItems", (e, t, n) => {
  if (n.ignoreMinAndMaxItems || !ns(e))
    return;
  const { minItems: r } = e;
  e.minItems = typeof r == "number" ? r : 0;
});
gn.set("Remove maxItems if it is big enough to likely cause OOMs", (e, t, n) => {
  if (n.ignoreMinAndMaxItems || n.maxItems === -1 || !ns(e))
    return;
  const { maxItems: r, minItems: i } = e;
  r !== void 0 && r - i > n.maxItems && delete e.maxItems;
});
gn.set("Normalize schema.items", (e, t, n) => {
  if (n.ignoreMinAndMaxItems)
    return;
  const { maxItems: r, minItems: i } = e, a = typeof r == "number" && r >= 0, o = typeof i == "number" && i > 0;
  if (e.items && !Array.isArray(e.items) && (a || o)) {
    const s = e.items, l = Array(r || i || 0).fill(s);
    a || (e.additionalItems = s), e.items = l;
  }
  return Array.isArray(e.items) && a && r < e.items.length && (e.items = e.items.slice(0, r)), e;
});
gn.set("Remove extends, if it is empty", (e) => {
  e.hasOwnProperty("extends") && (e.extends == null || Array.isArray(e.extends) && e.extends.length === 0) && delete e.extends;
});
gn.set("Make extends always an array, if it is defined", (e) => {
  e.extends != null && (Array.isArray(e.extends) || (e.extends = [e.extends]));
});
gn.set("Transform definitions to $defs", (e, t) => {
  if (e.definitions && e.$defs && !(0, dQ.default)(e.definitions, e.$defs))
    throw ReferenceError(
      `Schema must define either definitions or $defs, not both. Given id=${e.id} in ${t}`
    );
  e.definitions && (e.$defs = e.definitions, delete e.definitions);
});
gn.set("Transform const to singleton enum", (e) => {
  e.const !== void 0 && (e.enum = [e.const], delete e.const);
});
function vE(e, t, n, r) {
  return gn.forEach(
    (i) => oi(e, (a, o) => i(a, n, r, o, t))
  ), e;
}
w(vE, "normalize");
var pQ = Mt($Y, 1);
function Cs(e, t, n = /* @__PURE__ */ new Set()) {
  if (n.has(e))
    return e;
  switch (n.add(e), e.type) {
    case "INTERFACE":
      return Object.assign(e, {
        params: e.params.map((a) => Object.assign(a, { ast: Cs(a.ast, t, n) }))
      });
    case "INTERSECTION":
    case "UNION":
      const r = Object.assign(e, {
        params: e.params.map((a) => Cs(a, t, n))
      });
      if (r.params.some((a) => a.type === "ANY"))
        return xn("cyan", "optimizer", "[A, B, C, Any] -> Any", r), uo;
      if (r.params.some((a) => a.type === "UNKNOWN"))
        return xn("cyan", "optimizer", "[A, B, C, Unknown] -> Unknown", r), fo;
      r.params.every((a) => {
        const o = Lr(Nh(a), t), s = Lr(Nh(r.params[0]), t);
        return o === s;
      }) && r.params.some((a) => a.standaloneName !== void 0) && (xn("cyan", "optimizer", "[A (named), A] -> [A (named)]", r), r.params = r.params.filter((a) => a.standaloneName !== void 0));
      const i = (0, pQ.default)(r.params, (a) => Lr(a, t));
      return i.length !== r.params.length && (xn("cyan", "optimizer", "[A, B, B] -> [A, B]", r), r.params = i), Object.assign(r, {
        params: r.params.map((a) => Cs(a, t, n))
      });
    default:
      return e;
  }
}
w(Cs, "optimize");
function Nh(e) {
  switch (e.type) {
    case "ENUM":
      return e;
    default:
      return K(R({}, e), { standaloneName: void 0 });
  }
}
w(Nh, "omitStandaloneName");
function bE({ maxItems: e }) {
  if (e !== void 0 && e < -1)
    throw RangeError(`Expected options.maxItems to be >= -1, but was given ${e}.`);
}
w(bE, "validateOptions");
var hQ = Mt(FY, 1), Tp = Mt(sX, 1), mQ = Mt(ja, 1), Cp = Mt(EX, 1), gQ = Mt(sf, 1), yQ = Mt(iS, 1), vQ = Mt(ja, 1);
function wE(e) {
  if (e.tsType)
    return ["CUSTOM_TYPE"];
  const t = [];
  for (const [n, r] of Object.entries(bQ))
    r(e) && t.push(n);
  return t.length ? t : ["UNNAMED_SCHEMA"];
}
w(wE, "typesOfSchema");
var bQ = {
  ALL_OF(e) {
    return "allOf" in e;
  },
  ANY(e) {
    return Object.keys(e).length === 0 ? !0 : e.type === "any";
  },
  ANY_OF(e) {
    return "anyOf" in e;
  },
  BOOLEAN(e) {
    return "enum" in e ? !1 : e.type === "boolean" || !Ac(e) && typeof e.default == "boolean";
  },
  CUSTOM_TYPE() {
    return !1;
  },
  NAMED_ENUM(e) {
    return "enum" in e && "tsEnumNames" in e;
  },
  NAMED_SCHEMA(e) {
    return "$id" in e && ("patternProperties" in e || "properties" in e);
  },
  NEVER(e) {
    return e === !1;
  },
  NULL(e) {
    return e.type === "null";
  },
  NUMBER(e) {
    return "enum" in e ? !1 : e.type === "integer" || e.type === "number" || !Ac(e) && typeof e.default == "number";
  },
  OBJECT(e) {
    return e.type === "object" && !(0, vQ.default)(e.additionalProperties) && !e.allOf && !e.anyOf && !e.oneOf && !e.patternProperties && !e.properties && !e.required;
  },
  ONE_OF(e) {
    return "oneOf" in e;
  },
  REFERENCE(e) {
    return "$ref" in e;
  },
  STRING(e) {
    return "enum" in e ? !1 : e.type === "string" || !Ac(e) && typeof e.default == "string";
  },
  TYPED_ARRAY(e) {
    return e.type && e.type !== "array" ? !1 : "items" in e;
  },
  UNION(e) {
    return Array.isArray(e.type);
  },
  UNNAMED_ENUM(e) {
    return "tsEnumNames" in e || e.type && e.type !== "boolean" && e.type !== "integer" && e.type !== "number" && e.type !== "string" ? !1 : "enum" in e;
  },
  UNNAMED_SCHEMA() {
    return !1;
  },
  UNTYPED_ARRAY(e) {
    return e.type === "array" && !("items" in e);
  }
};
function Wn(e, t, n, r = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set()) {
  if (rE(e))
    return nE(e) ? xE(e, n, t) : _u(e, n);
  const a = wE(e);
  if (a.length === 1) {
    const s = Rc(e, a[0], t, n, r, i);
    return xn("blue", "parser", "Types:", a, "Input:", e, "Output:", s), s;
  }
  const o = Rc(
    {
      $id: e.$id,
      allOf: [],
      description: e.description,
      title: e.title
    },
    "ALL_OF",
    t,
    n,
    r,
    i
  );
  return o.params = a.map(
    (s) => (
      // We hoist description (for comment) and id/title (for standaloneName)
      // to the parent intersection type, so we remove it from the children.
      Rc(uE(e), s, t, n, r, i)
    )
  ), xn("blue", "parser", "Types:", a, "Input:", e, "Output:", o), o;
}
w(Wn, "parse");
function Rc(e, t, n, r, i = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set()) {
  let o = i.get(e);
  o || (o = /* @__PURE__ */ new Map(), i.set(e, o));
  const s = o.get(t);
  if (s)
    return s;
  const l = {};
  return o.set(t, l), Object.assign(l, _E(e, t, n, r, i, a));
}
w(Rc, "parseAsTypeWithCache");
function xE(e, t, n) {
  return e ? {
    keyName: t,
    type: n.unknownAny ? "UNKNOWN" : "ANY"
  } : {
    keyName: t,
    type: "NEVER"
  };
}
w(xE, "parseBooleanSchema");
function _u(e, t) {
  return {
    keyName: t,
    params: e,
    type: "LITERAL"
  };
}
w(_u, "parseLiteral");
function _E(e, t, n, r, i, a) {
  const o = wQ(tE(e)), s = (0, hQ.default)(o, (l) => l === e);
  switch (t) {
    case "ALL_OF":
      return {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        standaloneName: Qt(e, s, a),
        params: e.allOf.map((d) => Wn(d, n, void 0, i, a)),
        type: "INTERSECTION"
      };
    case "ANY":
      return K(R({}, n.unknownAny ? fo : uo), {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        standaloneName: Qt(e, s, a)
      });
    case "ANY_OF":
      return {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        standaloneName: Qt(e, s, a),
        params: e.anyOf.map((d) => Wn(d, n, void 0, i, a)),
        type: "UNION"
      };
    case "BOOLEAN":
      return {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        standaloneName: Qt(e, s, a),
        type: "BOOLEAN"
      };
    case "CUSTOM_TYPE":
      return {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        params: e.tsType,
        standaloneName: Qt(e, s, a),
        type: "CUSTOM_TYPE"
      };
    case "NAMED_ENUM":
      return {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        standaloneName: Qt(e, s ?? r, a),
        params: e.enum.map((d, p) => ({
          ast: _u(d, void 0),
          keyName: e.tsEnumNames[p]
        })),
        type: "ENUM"
      };
    case "NAMED_SCHEMA":
      return Dh(e, n, i, a, r);
    case "NEVER":
      return {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        standaloneName: Qt(e, s, a),
        type: "NEVER"
      };
    case "NULL":
      return {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        standaloneName: Qt(e, s, a),
        type: "NULL"
      };
    case "NUMBER":
      return {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        standaloneName: Qt(e, s, a),
        type: "NUMBER"
      };
    case "OBJECT":
      return {
        comment: e.description,
        keyName: r,
        standaloneName: Qt(e, s, a),
        type: "OBJECT",
        deprecated: e.deprecated
      };
    case "ONE_OF":
      return {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        standaloneName: Qt(e, s, a),
        params: e.oneOf.map((d) => Wn(d, n, void 0, i, a)),
        type: "UNION"
      };
    case "REFERENCE":
      throw Error("Refs should have been resolved by the resolver!" + e);
    case "STRING":
      return {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        standaloneName: Qt(e, s, a),
        type: "STRING"
      };
    case "TYPED_ARRAY":
      if (Array.isArray(e.items)) {
        const d = e.minItems, p = e.maxItems, f = {
          comment: e.description,
          deprecated: e.deprecated,
          keyName: r,
          maxItems: p,
          minItems: d,
          standaloneName: Qt(e, s, a),
          params: e.items.map((h) => Wn(h, n, void 0, i, a)),
          type: "TUPLE"
        };
        return e.additionalItems === !0 ? f.spreadParam = n.unknownAny ? fo : uo : e.additionalItems && (f.spreadParam = Wn(e.additionalItems, n, void 0, i, a)), f;
      } else
        return {
          comment: e.description,
          deprecated: e.deprecated,
          keyName: r,
          standaloneName: Qt(e, s, a),
          params: Wn(e.items, n, "{keyNameFromDefinition}Items", i, a),
          type: "ARRAY"
        };
    case "UNION":
      return {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        standaloneName: Qt(e, s, a),
        params: e.type.map((d) => {
          const p = K(R({}, (0, yQ.default)(e, "$id", "description", "title")), { type: d });
          return Wn(cE(p), n, void 0, i, a);
        }),
        type: "UNION"
      };
    case "UNNAMED_ENUM":
      return {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        standaloneName: Qt(e, s, a),
        params: e.enum.map((d) => _u(d, void 0)),
        type: "UNION"
      };
    case "UNNAMED_SCHEMA":
      return Dh(e, n, i, a, r, s);
    case "UNTYPED_ARRAY":
      const l = e.minItems, c = typeof e.maxItems == "number" ? e.maxItems : -1, u = n.unknownAny ? fo : uo;
      return l > 0 || c >= 0 ? {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        maxItems: e.maxItems,
        minItems: l,
        // create a tuple of length N
        params: Array(Math.max(c, l) || 0).fill(u),
        // if there is no maximum, then add a spread item to collect the rest
        spreadParam: c >= 0 ? void 0 : u,
        standaloneName: Qt(e, s, a),
        type: "TUPLE"
      } : {
        comment: e.description,
        deprecated: e.deprecated,
        keyName: r,
        params: u,
        standaloneName: Qt(e, s, a),
        type: "ARRAY"
      };
  }
}
w(_E, "parseNonLiteral");
function Qt(e, t, n) {
  const r = e.title || e.$id || t;
  if (r)
    return oE(r, n);
}
w(Qt, "standaloneName");
function Dh(e, t, n, r, i, a) {
  const o = Qt(e, a, r);
  return {
    comment: e.description,
    deprecated: e.deprecated,
    keyName: i,
    params: EE(e, t, n, r, o),
    standaloneName: o,
    superTypes: SE(e, t, n, r),
    type: "INTERFACE"
  };
}
w(Dh, "newInterface");
function SE(e, t, n, r) {
  const i = e.extends;
  return i ? i.map((a) => Wn(a, t, void 0, n, r)) : [];
}
w(SE, "parseSuperTypes");
function EE(e, t, n, r, i) {
  let a = (0, Cp.default)(e.properties, (s, l) => ({
    ast: Wn(s, t, l, n, r),
    isPatternProperty: !1,
    isRequired: (0, Tp.default)(e.required || [], l),
    isUnreachableDefinition: !1,
    keyName: l
  })), o = !1;
  switch (e.patternProperties && (o = !e.additionalProperties && Object.keys(e.patternProperties).length === 1, a = a.concat(
    (0, Cp.default)(e.patternProperties, (s, l) => {
      const c = Wn(s, t, l, n, r), u = `This interface was referenced by \`${i}\`'s JSON-Schema definition
via the \`patternProperty\` "${l.replace("*/", "*\\/")}".`;
      return c.comment = c.comment ? `${c.comment}

${u}` : u, {
        ast: c,
        isPatternProperty: !o,
        isRequired: o || (0, Tp.default)(e.required || [], l),
        isUnreachableDefinition: !1,
        keyName: o ? "[k: string]" : l
      };
    })
  )), t.unreachableDefinitions && (a = a.concat(
    (0, Cp.default)(e.$defs, (s, l) => {
      const c = Wn(s, t, l, n, r), u = `This interface was referenced by \`${i}\`'s JSON-Schema
via the \`definition\` "${l}".`;
      return c.comment = c.comment ? `${c.comment}

${u}` : u, {
        ast: c,
        isPatternProperty: !1,
        isRequired: (0, Tp.default)(e.required || [], l),
        isUnreachableDefinition: !0,
        keyName: l
      };
    })
  )), e.additionalProperties) {
    case void 0:
    case !0:
      return o ? a : a.concat({
        ast: t.unknownAny ? nQ : tQ,
        isPatternProperty: !1,
        isRequired: !0,
        isUnreachableDefinition: !1,
        keyName: "[k: string]"
      });
    case !1:
      return a;
    default:
      return a.concat({
        ast: Wn(e.additionalProperties, t, "[k: string]", n, r),
        isPatternProperty: !1,
        isRequired: !0,
        isUnreachableDefinition: !1,
        keyName: "[k: string]"
      });
  }
}
w(EE, "parseSchema");
function Su(e, t = !0, n = /* @__PURE__ */ new Set()) {
  return n.has(e) ? {} : (n.add(e), Array.isArray(e) ? e.reduce(
    (r, i) => R(R({}, r), Su(i, !1, n)),
    {}
  ) : (0, mQ.default)(e) ? R(R({}, t && kE(e) ? e.$defs : {}), Object.keys(e).reduce(
    (r, i) => R(R({}, r), Su(e[i], !1, n)),
    {}
  )) : {});
}
w(Su, "getDefinitions");
var wQ = (0, gQ.default)(Su);
function kE(e) {
  return "$defs" in e;
}
w(kE, "hasDefinitions");
async function TE(e, { cwd: t, $refOptions: n }) {
  if (xn("green", "dereferencer", "Dereferencing input schema:", t, e), typeof process > "u")
    throw new Error("process is not defined");
  const r = await import("./index-c46225a0.js").then((s) => s.i), i = new r.$RefParser(), a = /* @__PURE__ */ new WeakMap(), o = await i.dereference(t, e, K(R({}, n), {
    dereference: K(R({}, n.dereference), {
      onDereference(s, l) {
        a.set(l, s);
      }
    })
  }));
  return { dereferencedPaths: a, dereferencedSchema: o };
}
w(TE, "dereference");
var Ua = /* @__PURE__ */ new Map();
Ua.set("Enum members and tsEnumNames must be of the same length", (e) => {
  if (e.enum && e.tsEnumNames && e.enum.length !== e.tsEnumNames.length)
    return !1;
});
Ua.set("tsEnumNames must be an array of strings", (e) => {
  if (e.tsEnumNames && e.tsEnumNames.some((t) => typeof t != "string"))
    return !1;
});
Ua.set("When both maxItems and minItems are present, maxItems >= minItems", (e) => {
  const { maxItems: t, minItems: n } = e;
  if (typeof t == "number" && typeof n == "number")
    return t >= n;
});
Ua.set("When maxItems exists, maxItems >= 0", (e) => {
  const { maxItems: t } = e;
  if (typeof t == "number")
    return t >= 0;
});
Ua.set("When minItems exists, minItems >= 0", (e) => {
  const { minItems: t } = e;
  if (typeof t == "number")
    return t >= 0;
});
Ua.set("deprecated must be a boolean", (e) => {
  const t = typeof e.deprecated;
  return t === "boolean" || t === "undefined";
});
function CE(e, t) {
  const n = [];
  return Ua.forEach((r, i) => {
    oi(e, (a, o) => (r(a) === !1 && n.push(`Error at key "${o}" in file "${t}": ${i}`), a));
  }), n;
}
w(CE, "validate");
var OE = {
  $refOptions: {},
  additionalProperties: !0,
  // TODO: default to empty schema (as per spec) instead
  bannerComment: "",
  cwd: "",
  declareExternallyReferenced: !0,
  enableConstEnums: !0,
  format: !0,
  ignoreMinAndMaxItems: !1,
  maxItems: 20,
  strictIndexSignatures: !1,
  unreachableDefinitions: !1,
  unknownAny: !0
};
async function AE(e, t = "Root", n = {}) {
  bE(n);
  const r = (0, XX.default)({}, OE, n), i = Date.now();
  function a() {
    return `(${Date.now() - i}ms)`;
  }
  w(a, "time"), (0, JX.default)(r.cwd, "/") || (r.cwd += "/");
  const o = (0, GX.default)(e), { dereferencedPaths: s, dereferencedSchema: l } = await TE(o, r);
  process.env.VERBOSE && ((0, YX.default)(o, l) ? xn("green", "dereferencer", a(), " No change") : xn("green", "dereferencer", a(), " Result:", l));
  const c = xu(l);
  process.env.VERBOSE && xn("green", "linker", a(), " No change");
  const u = CE(c, t);
  if (u.length)
    throw u.forEach((m) => sE(m)), new xQ();
  process.env.VERBOSE && xn("green", "validator", a(), " No change");
  const d = vE(c, s, t, r);
  xn("yellow", "normalizer", a(), " Result:", d);
  const p = Wn(d, r);
  xn("blue", "parser", a(), " Result:", p);
  const f = Cs(p, r);
  xn("cyan", "optimizer", a(), " Result:", f);
  const h = fE(f, r);
  return xn("magenta", "generator", a(), " Result:", h), h;
}
w(AE, "compile");
var $E = class extends Error {
};
w($E, "ValidationError");
var xQ = $E, RE = /* @__PURE__ */ w(async (e, t) => {
  var n;
  const r = await AE(e, (n = t == null ? void 0 : t.schemaName) != null ? n : "Schema", R({
    bannerComment: ""
  }, t));
  return t != null && t.schemaName ? r : r.replace("export interface Schema ", "").replace("export type Schema = ", "");
}, "toTypescriptTypings"), PE = class {
  constructor(t, n, r, i) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
};
w(PE, "ParseInputLazyPath");
var cr = PE, vw = /* @__PURE__ */ w((e, t) => {
  if (Oo(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new Dr(e.common.issues);
      return this._error = n, this._error;
    }
  };
}, "handleResult"), IE = class {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return ii(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: ii(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new jn(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: ii(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (Us(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const i = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) != null ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ii(t)
    }, a = this._parseSync({ data: t, path: i.path, parent: i });
    return vw(i, a);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: ii(t)
    }, i = this._parse({ data: t, path: r.path, parent: r }), a = await (Us(i) ? i : Promise.resolve(i));
    return vw(r, a);
  }
  refine(t, n) {
    const r = /* @__PURE__ */ w((i) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(i) : n, "getIssueProperties");
    return this._refinement((i, a) => {
      const o = t(i), s = /* @__PURE__ */ w(() => a.addIssue(R({
        code: ge.custom
      }, r(i))), "setError");
      return typeof Promise < "u" && o instanceof Promise ? o.then((l) => l ? !0 : (s(), !1)) : o ? !0 : (s(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, i) => t(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1));
  }
  _refinement(t) {
    return new mi({
      schema: this,
      typeName: "ZodEffects",
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return br.create(this, this._def);
  }
  nullable() {
    return hi.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return $o.create(this, this._def);
  }
  promise() {
    return Ul.create(this, this._def);
  }
  or(t) {
    return Bl.create([this, t], this._def);
  }
  and(t) {
    return vf.create(this, t, this._def);
  }
  transform(t) {
    return new mi(K(R({}, ot(this._def)), {
      schema: this,
      typeName: "ZodEffects",
      effect: { type: "transform", transform: t }
    }));
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new mf(K(R({}, ot(this._def)), {
      innerType: this,
      defaultValue: n,
      typeName: "ZodDefault"
      /* ZodDefault */
    }));
  }
  brand() {
    return new Il(R({
      typeName: "ZodBranded",
      type: this
    }, ot(this._def)));
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new pf(K(R({}, ot(this._def)), {
      innerType: this,
      catchValue: n,
      typeName: "ZodCatch"
      /* ZodCatch */
    }));
  }
  describe(t) {
    const n = this.constructor;
    return new n(K(R({}, this._def), {
      description: t
    }));
  }
  pipe(t) {
    return bf.create(this, t);
  }
  readonly() {
    return yf.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
  // BOTPRESS EXTENSIONS
  _setZuiMeta(t, n) {
    const r = this._def, i = typeof n == "function" ? n.toString() : n;
    switch (r.typeName) {
      case "ZodNullable":
      case "ZodDefault":
      case "ZodOptional":
      case "ZodReadonly":
        r.innerType._def[Kt] = K(R({}, r.innerType._def[Kt]), {
          [t]: i
        });
        break;
      case "ZodEffects":
        r.schema._def[Kt] = K(R({}, r.schema._def[Kt]), {
          [t]: i
        });
        break;
      default:
        r[Kt] = K(R({}, r[Kt]), {
          [t]: i
        });
    }
  }
  get ui() {
    const t = this._def;
    switch (t.typeName) {
      case "ZodNullable":
      case "ZodDefault":
      case "ZodOptional":
      case "ZodReadonly":
        return t.innerType.ui;
      case "ZodEffects":
        return t.schema.ui;
      default:
        return t[Kt] || {};
    }
  }
  /**
   * The type of component to use to display the field and its options
   */
  displayAs(t) {
    var n, r, i;
    return (i = (n = this._def)[r = Kt]) != null || (n[r] = {}), this._def[Kt].displayAs = [t.id, t.params], this;
  }
  /**
   * The title of the field. Defaults to the field name.
   */
  title(t) {
    return this._setZuiMeta("title", t), this;
  }
  /**
   * Whether the field is hidden in the UI. Useful for internal fields.
   * @default false
   */
  hidden(t) {
    return this._setZuiMeta("hidden", typeof t > "u" ? !0 : t), this;
  }
  /**
   * Whether the field is disabled
   * @default false
   */
  disabled(t) {
    return this._setZuiMeta("disabled", typeof t > "u" ? !0 : t), this;
  }
  /**
   * Placeholder text for the field
   */
  placeholder(t) {
    return this._setZuiMeta("placeholder", t), this;
  }
  toJsonSchema(t) {
    return uf(this, t);
  }
  async toTypescriptTypings(t) {
    return RE(this.toJsonSchema(), t);
  }
  static fromObject(t, n) {
    return To(t, n);
  }
  static fromJsonSchema(t) {
    return zl(t);
  }
};
w(IE, "ZodType");
var nt = IE, Dg = /* @__PURE__ */ ((e) => (e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodTemplateLiteral = "ZodTemplateLiteral", e.ZodReadonly = "ZodReadonly", e))(Dg || {}), Eu = class extends nt {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return $n(t.data);
  }
};
w(Eu, "ZodAny");
Eu.create = /* @__PURE__ */ w((e) => new Eu(R({
  typeName: "ZodAny"
  /* ZodAny */
}, ot(e))), "create");
var Ao = Eu, ku = class Pc extends nt {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), i = this._def;
    if (n.parsedType !== Te.array)
      return Ce(n, {
        code: ge.invalid_type,
        expected: Te.array,
        received: n.parsedType
      }), Ye;
    if (i.exactLength !== null) {
      const o = n.data.length > i.exactLength.value, s = n.data.length < i.exactLength.value;
      (o || s) && (Ce(n, {
        code: o ? ge.too_big : ge.too_small,
        minimum: s ? i.exactLength.value : void 0,
        maximum: o ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), r.dirty());
    }
    if (i.minLength !== null && n.data.length < i.minLength.value && (Ce(n, {
      code: ge.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), r.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (Ce(n, {
      code: ge.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all(
        [...n.data].map((o, s) => i.type._parseAsync(new cr(n, o, n.path, s)))
      ).then((o) => jn.mergeArray(r, o));
    const a = [...n.data].map((o, s) => i.type._parseSync(new cr(n, o, n.path, s)));
    return jn.mergeArray(r, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new Pc(K(R({}, this._def), {
      minLength: { value: t, message: We.toString(n) }
    }));
  }
  max(t, n) {
    return new Pc(K(R({}, this._def), {
      maxLength: { value: t, message: We.toString(n) }
    }));
  }
  length(t, n) {
    return new Pc(K(R({}, this._def), {
      exactLength: { value: t, message: We.toString(n) }
    }));
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
w(ku, "ZodArray");
ku.create = /* @__PURE__ */ w((e, t) => new ku(R({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: "ZodArray"
  /* ZodArray */
}, ot(t))), "create");
var $o = ku, Tu = class Lh extends nt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== Te.bigint) {
      const a = this._getOrReturnCtx(t);
      return Ce(a, {
        code: ge.invalid_type,
        expected: Te.bigint,
        received: a.parsedType
      }), Ye;
    }
    let r;
    const i = new jn();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), Ce(r, {
        code: ge.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), Ce(r, {
        code: ge.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), Ce(r, {
        code: ge.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : bt.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, We.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, We.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, We.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, We.toString(n));
  }
  setLimit(t, n, r, i) {
    return new Lh(K(R({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: We.toString(i)
        }
      ]
    }));
  }
  _addCheck(t) {
    return new Lh(K(R({}, this._def), {
      checks: [...this._def.checks, t]
    }));
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: We.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: We.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: We.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: We.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: We.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
w(Tu, "ZodBigInt");
Tu.create = /* @__PURE__ */ w((e) => {
  var t;
  return new Tu(R({
    checks: [],
    typeName: "ZodBigInt",
    coerce: (t = e == null ? void 0 : e.coerce) != null ? t : !1
  }, ot(e)));
}, "create");
var Rl = Tu, Cu = class extends nt {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Te.boolean) {
      const r = this._getOrReturnCtx(t);
      return Ce(r, {
        code: ge.invalid_type,
        expected: Te.boolean,
        received: r.parsedType
      }), Ye;
    }
    return $n(t.data);
  }
};
w(Cu, "ZodBoolean");
Cu.create = /* @__PURE__ */ w((e) => new Cu(R({
  typeName: "ZodBoolean",
  coerce: (e == null ? void 0 : e.coerce) || !1
}, ot(e))), "create");
var Pl = Cu, ME = Symbol("zod_brand"), NE = class extends nt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
};
w(NE, "ZodBranded");
var Il = NE, Ou = class extends nt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = K(R({}, n), {
      common: K(R({}, n.common), {
        issues: []
      })
    }), i = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: R({}, r)
    });
    return Us(i) ? i.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new Dr(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new Dr(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
w(Ou, "ZodCatch");
Ou.create = /* @__PURE__ */ w((e, t) => new Ou(R({
  innerType: e,
  typeName: "ZodCatch",
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch
}, ot(t))), "create");
var pf = Ou, Lg = /* @__PURE__ */ w((e, t = {}, n) => e ? Ao.create().superRefine((r, i) => {
  var a, o;
  if (!e(r)) {
    const s = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, l = (o = (a = s.fatal) != null ? a : n) != null ? o : !0, c = typeof s == "string" ? { message: s } : s;
    i.addIssue(K(R({ code: "custom" }, c), { fatal: l }));
  }
}) : Ao.create(), "custom"), Au = class DE extends nt {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Te.date) {
      const a = this._getOrReturnCtx(t);
      return Ce(a, {
        code: ge.invalid_type,
        expected: Te.date,
        received: a.parsedType
      }), Ye;
    }
    if (isNaN(t.data.getTime())) {
      const a = this._getOrReturnCtx(t);
      return Ce(a, {
        code: ge.invalid_date
      }), Ye;
    }
    const r = new jn();
    let i;
    for (const a of this._def.checks)
      a.kind === "min" ? t.data.getTime() < a.value && (i = this._getOrReturnCtx(t, i), Ce(i, {
        code: ge.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), r.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (i = this._getOrReturnCtx(t, i), Ce(i, {
        code: ge.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), r.dirty()) : bt.assertNever(a);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new DE(K(R({}, this._def), {
      checks: [...this._def.checks, t]
    }));
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: We.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: We.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
};
w(Au, "ZodDate");
Au.create = /* @__PURE__ */ w((e) => new Au(R({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: "ZodDate"
  /* ZodDate */
}, ot(e))), "create");
var hf = Au, $u = class extends nt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === Te.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
w($u, "ZodDefault");
$u.create = /* @__PURE__ */ w((e, t) => new $u(R({
  innerType: e,
  typeName: "ZodDefault",
  defaultValue: typeof t.default == "function" ? t.default : () => t.default
}, ot(t))), "create");
var mf = $u;
function Ml(e, t) {
  return new Ea(R({
    values: e,
    typeName: "ZodEnum"
    /* ZodEnum */
  }, ot(t)));
}
w(Ml, "createZodEnum");
var jg = class jh extends nt {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return Ce(n, {
        expected: bt.joinValues(r),
        received: n.parsedType,
        code: ge.invalid_type
      }), Ye;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return Ce(n, {
        received: n.data,
        code: ge.invalid_enum_value,
        options: r
      }), Ye;
    }
    return $n(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t, n = this._def) {
    return jh.create(t, R(R({}, this._def), n));
  }
  exclude(t, n = this._def) {
    return jh.create(this.options.filter((r) => !t.includes(r)), R(R({}, this._def), n));
  }
};
w(jg, "ZodEnum");
jg.create = Ml;
var Ea = jg, Ru = class extends nt {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
};
w(Ru, "ZodLazy");
Ru.create = /* @__PURE__ */ w((e, t) => new Ru(R({
  getter: e,
  typeName: "ZodLazy"
  /* ZodLazy */
}, ot(t))), "create");
var gf = Ru, Pu = class extends nt {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return Ce(n, {
        received: n.data,
        code: ge.invalid_literal,
        expected: this._def.value
      }), Ye;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
};
w(Pu, "ZodLiteral");
Pu.create = /* @__PURE__ */ w((e, t) => new Pu(R({
  value: e,
  typeName: "ZodLiteral"
  /* ZodLiteral */
}, ot(t))), "create");
var Nl = Pu, Iu = class extends nt {
  _parse(t) {
    const n = bt.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== Te.string && r.parsedType !== Te.number) {
      const i = bt.objectValues(n);
      return Ce(r, {
        expected: bt.joinValues(i),
        received: r.parsedType,
        code: ge.invalid_type
      }), Ye;
    }
    if (n.indexOf(t.data) === -1) {
      const i = bt.objectValues(n);
      return Ce(r, {
        received: r.data,
        code: ge.invalid_enum_value,
        options: i
      }), Ye;
    }
    return $n(t.data);
  }
  get enum() {
    return this._def.values;
  }
};
w(Iu, "ZodNativeEnum");
Iu.create = /* @__PURE__ */ w((e, t) => new Iu(R({
  values: e,
  typeName: "ZodNativeEnum"
  /* ZodNativeEnum */
}, ot(t))), "create");
var Dl = Iu, Mu = class extends nt {
  _parse(t) {
    if (this._getType(t) !== Te.null) {
      const r = this._getOrReturnCtx(t);
      return Ce(r, {
        code: ge.invalid_type,
        expected: Te.null,
        received: r.parsedType
      }), Ye;
    }
    return $n(t.data);
  }
};
w(Mu, "ZodNull");
Mu.create = /* @__PURE__ */ w((e) => new Mu(R({
  typeName: "ZodNull"
  /* ZodNull */
}, ot(e))), "create");
var Ll = Mu, Nu = class extends nt {
  _parse(t) {
    return this._getType(t) === Te.null ? $n(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
w(Nu, "ZodNullable");
Nu.create = /* @__PURE__ */ w((e, t) => new Nu(R({
  innerType: e,
  typeName: "ZodNullable"
  /* ZodNullable */
}, ot(t))), "create");
var hi = Nu, Du = class extends nt {
  _parse(t) {
    return this._getType(t) === Te.undefined ? $n(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
};
w(Du, "ZodOptional");
Du.create = /* @__PURE__ */ w((e, t) => new Du(R({
  innerType: e,
  typeName: "ZodOptional"
  /* ZodOptional */
}, ot(t))), "create");
var br = Du, Lu = class extends nt {
  _parse(t) {
    const n = this._def.innerType._parse(t);
    return Oo(n) && (n.value = Object.freeze(n.value)), n;
  }
  unwrap() {
    return this._def.innerType;
  }
};
w(Lu, "ZodReadonly");
Lu.create = /* @__PURE__ */ w((e, t) => new Lu(R({
  innerType: e,
  typeName: "ZodReadonly"
  /* ZodReadonly */
}, ot(t))), "create");
var yf = Lu, Ro = class extends nt {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === "ZodEffects" ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = this._def.effect || null, a = {
      addIssue: (o) => {
        Ce(r, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), i.type === "preprocess") {
      const o = i.transform(r.data, a);
      if (r.common.async)
        return Promise.resolve(o).then(async (s) => {
          if (n.value === "aborted")
            return Ye;
          const l = await this._def.schema._parseAsync({
            data: s,
            path: r.path,
            parent: r
          });
          return l.status === "aborted" ? Ye : l.status === "dirty" || n.value === "dirty" ? pa(l.value) : l;
        });
      {
        if (n.value === "aborted")
          return Ye;
        const s = this._def.schema._parseSync({
          data: o,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? Ye : s.status === "dirty" || n.value === "dirty" ? pa(s.value) : s;
      }
    }
    if (i.type === "refinement") {
      const o = /* @__PURE__ */ w((s) => {
        const l = i.refinement(s, a);
        if (r.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      }, "executeRefinement");
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? Ye : (s.status === "dirty" && n.dirty(), o(s.value), { status: n.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => s.status === "aborted" ? Ye : (s.status === "dirty" && n.dirty(), o(s.value).then(() => ({ status: n.value, value: s.value }))));
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Oo(o))
          return o;
        const s = i.transform(o.value, a);
        if (s instanceof Promise)
          throw new Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return { status: n.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => Oo(o) ? Promise.resolve(i.transform(o.value, a)).then((s) => ({
          status: n.value,
          value: s
        })) : o);
    bt.assertNever(i);
  }
};
w(Ro, "ZodEffects");
Ro.create = /* @__PURE__ */ w((e, t, n) => new Ro(R({
  schema: e,
  typeName: "ZodEffects",
  effect: t
}, ot(n))), "create");
Ro.createWithPreprocess = /* @__PURE__ */ w((e, t, n) => new Ro(R({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: "ZodEffects"
  /* ZodEffects */
}, ot(n))), "createWithPreprocess");
var mi = Ro, ju = class extends nt {
  _parse(t) {
    if (this._getType(t) !== Te.undefined) {
      const r = this._getOrReturnCtx(t);
      return Ce(r, {
        code: ge.invalid_type,
        expected: Te.undefined,
        received: r.parsedType
      }), Ye;
    }
    return $n(t.data);
  }
};
w(ju, "ZodUndefined");
ju.create = /* @__PURE__ */ w((e) => new ju(R({
  typeName: "ZodUndefined"
  /* ZodUndefined */
}, ot(e))), "create");
var jl = ju, ei = /* @__PURE__ */ w((e) => e instanceof gf ? ei(e.schema) : e instanceof mi ? ei(e.innerType()) : e instanceof Nl ? [e.value] : e instanceof Ea ? e.options : e instanceof Dl ? bt.objectValues(e.enum) : e instanceof mf ? ei(e._def.innerType) : e instanceof jl ? [void 0] : e instanceof Ll ? [null] : e instanceof br ? [void 0, ...ei(e.unwrap())] : e instanceof hi ? [null, ...ei(e.unwrap())] : e instanceof Il || e instanceof yf ? ei(e.unwrap()) : e instanceof pf ? ei(e._def.innerType) : [], "getDiscriminator"), LE = class jE extends nt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Te.object)
      return Ce(n, {
        code: ge.invalid_type,
        expected: Te.object,
        received: n.parsedType
      }), Ye;
    const r = this.discriminator, i = n.data[r], a = this.optionsMap.get(i);
    return a ? n.common.async ? a._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : a._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (Ce(n, {
      code: ge.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), Ye);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const i = /* @__PURE__ */ new Map();
    for (const a of n) {
      const o = ei(a.shape[t]);
      if (!o.length)
        throw new Error(
          `A discriminator value for key \`${t}\` could not be extracted from all schema options`
        );
      for (const s of o) {
        if (i.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        i.set(s, a);
      }
    }
    return new jE(R({
      typeName: "ZodDiscriminatedUnion",
      discriminator: t,
      options: n,
      optionsMap: i
    }, ot(r)));
  }
};
w(LE, "ZodDiscriminatedUnion");
var Ug = LE, Uu = class extends nt {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Te.promise && n.common.async === !1)
      return Ce(n, {
        code: ge.invalid_type,
        expected: Te.promise,
        received: n.parsedType
      }), Ye;
    const r = n.parsedType === Te.promise ? n.data : Promise.resolve(n.data);
    return $n(
      r.then((i) => this._def.type.parseAsync(i, {
        path: n.path,
        errorMap: n.common.contextualErrorMap
      }))
    );
  }
};
w(Uu, "ZodPromise");
Uu.create = /* @__PURE__ */ w((e, t) => new Uu(R({
  type: e,
  typeName: "ZodPromise"
  /* ZodPromise */
}, ot(t))), "create");
var Ul = Uu, Fu = class UE extends nt {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Te.array)
      return Ce(r, {
        code: ge.invalid_type,
        expected: Te.array,
        received: r.parsedType
      }), Ye;
    if (r.data.length < this._def.items.length)
      return Ce(r, {
        code: ge.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), Ye;
    !this._def.rest && r.data.length > this._def.items.length && (Ce(r, {
      code: ge.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const a = [...r.data].map((o, s) => {
      const l = this._def.items[s] || this._def.rest;
      return l ? l._parse(new cr(r, o, r.path, s)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(a).then((o) => jn.mergeArray(n, o)) : jn.mergeArray(n, a);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new UE(K(R({}, this._def), {
      rest: t
    }));
  }
};
w(Fu, "ZodTuple");
Fu.create = /* @__PURE__ */ w((e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Fu(R({
    items: e,
    typeName: "ZodTuple",
    rest: null
  }, ot(t)));
}, "create");
var ka = Fu, Bu = class extends nt {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return $n(t.data);
  }
};
w(Bu, "ZodUnknown");
Bu.create = /* @__PURE__ */ w((e) => new Bu(R({
  typeName: "ZodUnknown"
  /* ZodUnknown */
}, ot(e))), "create");
var po = Bu, FE = class Ic extends nt {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Te.function)
      return Ce(n, {
        code: ge.invalid_type,
        expected: Te.function,
        received: n.parsedType
      }), Ye;
    function r(s, l) {
      return js({
        data: s,
        path: n.path,
        errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, Co(), ko].filter(
          (c) => !!c
        ),
        issueData: {
          code: ge.invalid_arguments,
          argumentsError: l
        }
      });
    }
    w(r, "makeArgsIssue");
    function i(s, l) {
      return js({
        data: s,
        path: n.path,
        errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, Co(), ko].filter(
          (c) => !!c
        ),
        issueData: {
          code: ge.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    w(i, "makeReturnsIssue");
    const a = { errorMap: n.common.contextualErrorMap }, o = n.data;
    if (this._def.returns instanceof Ul) {
      const s = this;
      return $n(async function(...l) {
        const c = new Dr([]), u = await s._def.args.parseAsync(l, a).catch((f) => {
          throw c.addIssue(r(l, f)), c;
        }), d = await Reflect.apply(o, this, u);
        return await s._def.returns._def.type.parseAsync(d, a).catch((f) => {
          throw c.addIssue(i(d, f)), c;
        });
      });
    } else {
      const s = this;
      return $n(function(...l) {
        const c = s._def.args.safeParse(l, a);
        if (!c.success)
          throw new Dr([r(l, c.error)]);
        const u = Reflect.apply(o, this, c.data), d = s._def.returns.safeParse(u, a);
        if (!d.success)
          throw new Dr([i(u, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new Ic(K(R({}, this._def), {
      args: ka.create(t).rest(po.create())
    }));
  }
  returns(t) {
    return new Ic(K(R({}, this._def), {
      returns: t
    }));
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new Ic(R({
      args: t || ka.create([]).rest(po.create()),
      returns: n || po.create(),
      typeName: "ZodFunction"
      /* ZodFunction */
    }, ot(r)));
  }
};
w(FE, "ZodFunction");
var Fg = FE;
function zu(e, t) {
  const n = ii(e), r = ii(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === Te.object && r === Te.object) {
    const i = bt.objectKeys(t), a = bt.objectKeys(e).filter((s) => i.indexOf(s) !== -1), o = R(R({}, e), t);
    for (const s of a) {
      const l = zu(e[s], t[s]);
      if (!l.valid)
        return { valid: !1 };
      o[s] = l.data;
    }
    return { valid: !0, data: o };
  } else if (n === Te.array && r === Te.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let a = 0; a < e.length; a++) {
      const o = e[a], s = t[a], l = zu(o, s);
      if (!l.valid)
        return { valid: !1 };
      i.push(l.data);
    }
    return { valid: !0, data: i };
  } else
    return n === Te.date && r === Te.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
w(zu, "mergeValues");
var Zu = class extends nt {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = /* @__PURE__ */ w((a, o) => {
      if (bu(a) || bu(o))
        return Ye;
      const s = zu(a.value, o.value);
      return s.valid ? ((wu(a) || wu(o)) && n.dirty(), { status: n.value, value: s.data }) : (Ce(r, {
        code: ge.invalid_intersection_types
      }), Ye);
    }, "handleParsed");
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([a, o]) => i(a, o)) : i(
      this._def.left._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      })
    );
  }
};
w(Zu, "ZodIntersection");
Zu.create = /* @__PURE__ */ w((e, t, n) => new Zu(R({
  left: e,
  right: t,
  typeName: "ZodIntersection"
  /* ZodIntersection */
}, ot(n))), "create");
var vf = Zu, qu = class extends nt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Te.map)
      return Ce(r, {
        code: ge.invalid_type,
        expected: Te.map,
        received: r.parsedType
      }), Ye;
    const i = this._def.keyType, a = this._def.valueType, o = [...r.data.entries()].map(([s, l], c) => ({
      key: i._parse(new cr(r, s, r.path, [c, "key"])),
      value: a._parse(new cr(r, l, r.path, [c, "value"]))
    }));
    if (r.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of o) {
          const c = await l.key, u = await l.value;
          if (c.status === "aborted" || u.status === "aborted")
            return Ye;
          (c.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(c.value, u.value);
        }
        return { status: n.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const l of o) {
        const c = l.key, u = l.value;
        if (c.status === "aborted" || u.status === "aborted")
          return Ye;
        (c.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(c.value, u.value);
      }
      return { status: n.value, value: s };
    }
  }
};
w(qu, "ZodMap");
qu.create = /* @__PURE__ */ w((e, t, n) => new qu(R({
  valueType: t,
  keyType: e,
  typeName: "ZodMap"
  /* ZodMap */
}, ot(n))), "create");
var Bg = qu, Wu = class extends nt {
  _parse(t) {
    if (this._getType(t) !== Te.nan) {
      const r = this._getOrReturnCtx(t);
      return Ce(r, {
        code: ge.invalid_type,
        expected: Te.nan,
        received: r.parsedType
      }), Ye;
    }
    return { status: "valid", value: t.data };
  }
};
w(Wu, "ZodNaN");
Wu.create = /* @__PURE__ */ w((e) => new Wu(R({
  typeName: "ZodNaN"
  /* ZodNaN */
}, ot(e))), "create");
var zg = Wu, Vu = class extends nt {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return Ce(n, {
      code: ge.invalid_type,
      expected: Te.never,
      received: n.parsedType
    }), Ye;
  }
};
w(Vu, "ZodNever");
Vu.create = /* @__PURE__ */ w((e) => new Vu(R({
  typeName: "ZodNever"
  /* ZodNever */
}, ot(e))), "create");
var Zi = Vu;
function BE(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, i = n > r ? n : r, a = parseInt(e.toFixed(i).replace(".", "")), o = parseInt(t.toFixed(i).replace(".", ""));
  return a % o / Math.pow(10, i);
}
w(BE, "floatSafeRemainder");
var Hu = class Uh extends nt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Te.number) {
      const a = this._getOrReturnCtx(t);
      return Ce(a, {
        code: ge.invalid_type,
        expected: Te.number,
        received: a.parsedType
      }), Ye;
    }
    let r;
    const i = new jn();
    for (const a of this._def.checks)
      a.kind === "int" ? bt.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), Ce(r, {
        code: ge.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), i.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), Ce(r, {
        code: ge.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), Ce(r, {
        code: ge.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? BE(t.data, a.value) !== 0 && (r = this._getOrReturnCtx(t, r), Ce(r, {
        code: ge.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), Ce(r, {
        code: ge.not_finite,
        message: a.message
      }), i.dirty()) : bt.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, We.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, We.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, We.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, We.toString(n));
  }
  setLimit(t, n, r, i) {
    return new Uh(K(R({}, this._def), {
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: We.toString(i)
        }
      ]
    }));
  }
  _addCheck(t) {
    return new Uh(K(R({}, this._def), {
      checks: [...this._def.checks, t]
    }));
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: We.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: We.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: We.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: We.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: We.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: We.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: We.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: We.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: We.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && bt.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
};
w(Hu, "ZodNumber");
Hu.create = /* @__PURE__ */ w((e) => new Hu(R({
  checks: [],
  typeName: "ZodNumber",
  coerce: (e == null ? void 0 : e.coerce) || !1
}, ot(e))), "create");
var Fl = Hu;
function ca(e) {
  if (e instanceof Ta) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = br.create(ca(r));
    }
    return new Ta(K(R({}, e._def), {
      shape: () => t
    }));
  } else
    return e instanceof $o ? new $o(K(R({}, e._def), {
      type: ca(e.element)
    })) : e instanceof br ? br.create(ca(e.unwrap())) : e instanceof hi ? hi.create(ca(e.unwrap())) : e instanceof ka ? ka.create(e.items.map((t) => ca(t))) : e;
}
w(ca, "deepPartialify");
var qi = class hr extends nt {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = bt.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== Te.object) {
      const c = this._getOrReturnCtx(t);
      return Ce(c, {
        code: ge.invalid_type,
        expected: Te.object,
        received: c.parsedType
      }), Ye;
    }
    const { status: r, ctx: i } = this._processInputParams(t), { shape: a, keys: o } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof Zi && this._def.unknownKeys === "strip"))
      for (const c in i.data)
        o.includes(c) || s.push(c);
    const l = [];
    for (const c of o) {
      const u = a[c], d = i.data[c];
      l.push({
        key: { status: "valid", value: c },
        value: u._parse(new cr(i, d, i.path, c)),
        alwaysSet: c in i.data
      });
    }
    if (this._def.catchall instanceof Zi) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of s)
          l.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: i.data[u] }
          });
      else if (c === "strict")
        s.length > 0 && (Ce(i, {
          code: ge.unrecognized_keys,
          keys: s
        }), r.dirty());
      else if (c !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of s) {
        const d = i.data[u];
        l.push({
          key: { status: "valid", value: u },
          value: c._parse(
            new cr(i, d, i.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const u of l) {
        const d = await u.key;
        c.push({
          key: d,
          value: await u.value,
          alwaysSet: u.alwaysSet
        });
      }
      return c;
    }).then((c) => jn.mergeObjectSync(r, c)) : jn.mergeObjectSync(r, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return We.errToObj, new hr(R(K(R({}, this._def), {
      unknownKeys: "strict"
    }), t !== void 0 ? {
      errorMap: (n, r) => {
        var i, a, o, s;
        const l = (o = (a = (i = this._def).errorMap) == null ? void 0 : a.call(i, n, r).message) != null ? o : r.defaultError;
        return n.code === "unrecognized_keys" ? {
          message: (s = We.errToObj(t).message) != null ? s : l
        } : {
          message: l
        };
      }
    } : {}));
  }
  strip() {
    return new hr(K(R({}, this._def), {
      unknownKeys: "strip"
    }));
  }
  passthrough() {
    return new hr(K(R({}, this._def), {
      unknownKeys: "passthrough"
    }));
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new hr(K(R({}, this._def), {
      shape: () => R(R({}, this._def.shape()), t)
    }));
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new hr({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => R(R({}, this._def.shape()), t._def.shape()),
      typeName: "ZodObject"
      /* ZodObject */
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new hr(K(R({}, this._def), {
      catchall: t
    }));
  }
  pick(t) {
    const n = {};
    return bt.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new hr(K(R({}, this._def), {
      shape: () => n
    }));
  }
  omit(t) {
    const n = {};
    return bt.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new hr(K(R({}, this._def), {
      shape: () => n
    }));
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return ca(this);
  }
  partial(t) {
    const n = {};
    return bt.objectKeys(this.shape).forEach((r) => {
      const i = this.shape[r];
      t && !t[r] ? n[r] = i : n[r] = i == null ? void 0 : i.optional();
    }), new hr(K(R({}, this._def), {
      shape: () => n
    }));
  }
  required(t) {
    const n = {};
    return bt.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let a = this.shape[r];
        for (; a instanceof br; )
          a = a._def.innerType;
        n[r] = a;
      }
    }), new hr(K(R({}, this._def), {
      shape: () => n
    }));
  }
  keyof() {
    return Ml(bt.objectKeys(this.shape));
  }
};
w(qi, "ZodObject");
qi.create = /* @__PURE__ */ w((e, t) => new qi(R({
  shape: () => e,
  unknownKeys: "strip",
  catchall: Zi.create(),
  typeName: "ZodObject"
  /* ZodObject */
}, ot(t))), "create");
qi.strictCreate = /* @__PURE__ */ w((e, t) => new qi(R({
  shape: () => e,
  unknownKeys: "strict",
  catchall: Zi.create(),
  typeName: "ZodObject"
  /* ZodObject */
}, ot(t))), "strictCreate");
qi.lazycreate = /* @__PURE__ */ w((e, t) => new qi(R({
  shape: e,
  unknownKeys: "strip",
  catchall: Zi.create(),
  typeName: "ZodObject"
  /* ZodObject */
}, ot(t))), "lazycreate");
var Ta = qi, zE = class ZE extends nt {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (/* @__PURE__ */ w(async () => {
        const a = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? Ye : a.status === "dirty" ? (n.dirty(), pa(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: r.path,
          parent: r
        });
      }, "handleAsync"))();
    {
      const i = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return i.status === "aborted" ? Ye : i.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new ZE({
      in: t,
      out: n,
      typeName: "ZodPipeline"
      /* ZodPipeline */
    });
  }
};
w(zE, "ZodPipeline");
var bf = zE, wf = /^c[^\s-]{8,}$/i, xf = /^[a-z][a-z0-9]*$/, _f = /^[0-9A-HJKMNP-TV-Z]{26}$/, Sf = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Ef = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, qE = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", WE = /* @__PURE__ */ w((e) => e === qE, "isEmojiRegex"), Op, zs = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Zs = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, kf = /* @__PURE__ */ w((e) => e.precision ? e.offset ? new RegExp(
  `^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`
) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$"), "datetimeRegex");
function VE(e, t) {
  return !!((t === "v4" || !t) && zs.test(e) || (t === "v6" || !t) && Zs.test(e));
}
w(VE, "isValidIP");
var Ku = class bs extends nt {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Te.string) {
      const a = this._getOrReturnCtx(t);
      return Ce(
        a,
        {
          code: ge.invalid_type,
          expected: Te.string,
          received: a.parsedType
        }
        //
      ), Ye;
    }
    const r = new jn();
    let i;
    for (const a of this._def.checks)
      if (a.kind === "min")
        t.data.length < a.value && (i = this._getOrReturnCtx(t, i), Ce(i, {
          code: ge.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "max")
        t.data.length > a.value && (i = this._getOrReturnCtx(t, i), Ce(i, {
          code: ge.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "length") {
        const o = t.data.length > a.value, s = t.data.length < a.value;
        (o || s) && (i = this._getOrReturnCtx(t, i), o ? Ce(i, {
          code: ge.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : s && Ce(i, {
          code: ge.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), r.dirty());
      } else if (a.kind === "email")
        Ef.test(t.data) || (i = this._getOrReturnCtx(t, i), Ce(i, {
          validation: "email",
          code: ge.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "emoji")
        Op || (Op = new RegExp(qE, "u")), Op.test(t.data) || (i = this._getOrReturnCtx(t, i), Ce(i, {
          validation: "emoji",
          code: ge.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "uuid")
        Sf.test(t.data) || (i = this._getOrReturnCtx(t, i), Ce(i, {
          validation: "uuid",
          code: ge.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid")
        wf.test(t.data) || (i = this._getOrReturnCtx(t, i), Ce(i, {
          validation: "cuid",
          code: ge.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid2")
        xf.test(t.data) || (i = this._getOrReturnCtx(t, i), Ce(i, {
          validation: "cuid2",
          code: ge.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "ulid")
        _f.test(t.data) || (i = this._getOrReturnCtx(t, i), Ce(i, {
          validation: "ulid",
          code: ge.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), Ce(i, {
            validation: "url",
            code: ge.invalid_string,
            message: a.message
          }), r.dirty();
        }
      else
        a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), Ce(i, {
          validation: "regex",
          code: ge.invalid_string,
          message: a.message
        }), r.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (i = this._getOrReturnCtx(t, i), Ce(i, {
          code: ge.invalid_string,
          validation: { includes: a.value, position: a.position },
          message: a.message
        }), r.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (i = this._getOrReturnCtx(t, i), Ce(i, {
          code: ge.invalid_string,
          validation: { startsWith: a.value },
          message: a.message
        }), r.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (i = this._getOrReturnCtx(t, i), Ce(i, {
          code: ge.invalid_string,
          validation: { endsWith: a.value },
          message: a.message
        }), r.dirty()) : a.kind === "datetime" ? kf(a).test(t.data) || (i = this._getOrReturnCtx(t, i), Ce(i, {
          code: ge.invalid_string,
          validation: "datetime",
          message: a.message
        }), r.dirty()) : a.kind === "ip" ? VE(t.data, a.version) || (i = this._getOrReturnCtx(t, i), Ce(i, {
          validation: "ip",
          code: ge.invalid_string,
          message: a.message
        }), r.dirty()) : bt.assertNever(a);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((i) => t.test(i), R({
      validation: n,
      code: ge.invalid_string
    }, We.errToObj(r)));
  }
  _addCheck(t) {
    return new bs(K(R({}, this._def), {
      checks: [...this._def.checks, t]
    }));
  }
  email(t) {
    return this._addCheck(R({ kind: "email" }, We.errToObj(t)));
  }
  url(t) {
    return this._addCheck(R({ kind: "url" }, We.errToObj(t)));
  }
  emoji(t) {
    return this._addCheck(R({ kind: "emoji" }, We.errToObj(t)));
  }
  uuid(t) {
    return this._addCheck(R({ kind: "uuid" }, We.errToObj(t)));
  }
  cuid(t) {
    return this._addCheck(R({ kind: "cuid" }, We.errToObj(t)));
  }
  cuid2(t) {
    return this._addCheck(R({ kind: "cuid2" }, We.errToObj(t)));
  }
  ulid(t) {
    return this._addCheck(R({ kind: "ulid" }, We.errToObj(t)));
  }
  ip(t) {
    return this._addCheck(R({ kind: "ip" }, We.errToObj(t)));
  }
  datetime(t) {
    var n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck(R({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) != null ? n : !1
    }, We.errToObj(t == null ? void 0 : t.message)));
  }
  regex(t, n) {
    return this._addCheck(R({
      kind: "regex",
      regex: t
    }, We.errToObj(n)));
  }
  includes(t, n) {
    return this._addCheck(R({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position
    }, We.errToObj(n == null ? void 0 : n.message)));
  }
  startsWith(t, n) {
    return this._addCheck(R({
      kind: "startsWith",
      value: t
    }, We.errToObj(n)));
  }
  endsWith(t, n) {
    return this._addCheck(R({
      kind: "endsWith",
      value: t
    }, We.errToObj(n)));
  }
  min(t, n) {
    return this._addCheck(R({
      kind: "min",
      value: t
    }, We.errToObj(n)));
  }
  max(t, n) {
    return this._addCheck(R({
      kind: "max",
      value: t
    }, We.errToObj(n)));
  }
  length(t, n) {
    return this._addCheck(R({
      kind: "length",
      value: t
    }, We.errToObj(n)));
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, We.errToObj(t));
  }
  trim() {
    return new bs(K(R({}, this._def), {
      checks: [...this._def.checks, { kind: "trim" }]
    }));
  }
  toLowerCase() {
    return new bs(K(R({}, this._def), {
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    }));
  }
  toUpperCase() {
    return new bs(K(R({}, this._def), {
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    }));
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
};
w(Ku, "ZodString");
Ku.create = /* @__PURE__ */ w((e) => {
  var t;
  return new Ku(R({
    checks: [],
    typeName: "ZodString",
    coerce: (t = e == null ? void 0 : e.coerce) != null ? t : !1
  }, ot(e)));
}, "create");
var rs = Ku, HE = class Fh extends nt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Te.object)
      return Ce(r, {
        code: ge.invalid_type,
        expected: Te.object,
        received: r.parsedType
      }), Ye;
    const i = [], a = this._def.keyType, o = this._def.valueType;
    for (const s in r.data)
      i.push({
        key: a._parse(new cr(r, s, r.path, s)),
        value: o._parse(new cr(r, r.data[s], r.path, s))
      });
    return r.common.async ? jn.mergeObjectAsync(n, i) : jn.mergeObjectSync(n, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof nt ? new Fh(R({
      keyType: t,
      valueType: n,
      typeName: "ZodRecord"
      /* ZodRecord */
    }, ot(r))) : new Fh(R({
      keyType: rs.create(),
      valueType: t,
      typeName: "ZodRecord"
      /* ZodRecord */
    }, ot(n)));
  }
};
w(HE, "ZodRecord");
var Zg = HE, Gu = class Bh extends nt {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Te.set)
      return Ce(r, {
        code: ge.invalid_type,
        expected: Te.set,
        received: r.parsedType
      }), Ye;
    const i = this._def;
    i.minSize !== null && r.data.size < i.minSize.value && (Ce(r, {
      code: ge.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), n.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (Ce(r, {
      code: ge.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), n.dirty());
    const a = this._def.valueType;
    function o(l) {
      const c = /* @__PURE__ */ new Set();
      for (const u of l) {
        if (u.status === "aborted")
          return Ye;
        u.status === "dirty" && n.dirty(), c.add(u.value);
      }
      return { status: n.value, value: c };
    }
    w(o, "finalizeSet");
    const s = [...r.data.values()].map(
      (l, c) => a._parse(new cr(r, l, r.path, c))
    );
    return r.common.async ? Promise.all(s).then((l) => o(l)) : o(s);
  }
  min(t, n) {
    return new Bh(K(R({}, this._def), {
      minSize: { value: t, message: We.toString(n) }
    }));
  }
  max(t, n) {
    return new Bh(K(R({}, this._def), {
      maxSize: { value: t, message: We.toString(n) }
    }));
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
};
w(Gu, "ZodSet");
Gu.create = /* @__PURE__ */ w((e, t) => new Gu(R({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: "ZodSet"
  /* ZodSet */
}, ot(t))), "create");
var qg = Gu, Ju = class extends nt {
  _parse(t) {
    if (this._getType(t) !== Te.symbol) {
      const r = this._getOrReturnCtx(t);
      return Ce(r, {
        code: ge.invalid_type,
        expected: Te.symbol,
        received: r.parsedType
      }), Ye;
    }
    return $n(t.data);
  }
};
w(Ju, "ZodSymbol");
Ju.create = /* @__PURE__ */ w((e) => new Ju(R({
  typeName: "ZodSymbol"
  /* ZodSymbol */
}, ot(e))), "create");
var Wg = Ju, Yu = class extends nt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function i(a) {
      for (const s of a)
        if (s.result.status === "valid")
          return s.result;
      for (const s of a)
        if (s.result.status === "dirty")
          return n.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((s) => new Dr(s.ctx.common.issues));
      return Ce(n, {
        code: ge.invalid_union,
        unionErrors: o
      }), Ye;
    }
    if (w(i, "handleResults"), n.common.async)
      return Promise.all(
        r.map(async (a) => {
          const o = K(R({}, n), {
            common: K(R({}, n.common), {
              issues: []
            }),
            parent: null
          });
          return {
            result: await a._parseAsync({
              data: n.data,
              path: n.path,
              parent: o
            }),
            ctx: o
          };
        })
      ).then(i);
    {
      let a;
      const o = [];
      for (const l of r) {
        const c = K(R({}, n), {
          common: K(R({}, n.common), {
            issues: []
          }),
          parent: null
        }), u = l._parseSync({
          data: n.data,
          path: n.path,
          parent: c
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !a && (a = { result: u, ctx: c }), c.common.issues.length && o.push(c.common.issues);
      }
      if (a)
        return n.common.issues.push(...a.ctx.common.issues), a.result;
      const s = o.map((l) => new Dr(l));
      return Ce(n, {
        code: ge.invalid_union,
        unionErrors: s
      }), Ye;
    }
  }
  get options() {
    return this._def.options;
  }
};
w(Yu, "ZodUnion");
Yu.create = /* @__PURE__ */ w((e, t) => new Yu(R({
  options: e,
  typeName: "ZodUnion"
  /* ZodUnion */
}, ot(t))), "create");
var Bl = Yu, Xu = class zh extends nt {
  interpolated(t) {
    return this._addPart(t);
  }
  literal(t) {
    return this._addPart(t);
  }
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Te.string) {
      const r = this._getOrReturnCtx(t);
      return Ce(r, {
        code: ge.invalid_type,
        expected: Te.string,
        received: r.parsedType
      }), Ye;
    }
    if (!new RegExp(this._def.regexString).test(t.data)) {
      const r = this._getOrReturnCtx(t);
      return Ce(r, {
        code: ge.invalid_string,
        message: `does not match template literal with pattern /${this._def.regexString}/`,
        path: r.path,
        validation: "regex"
      }), Ye;
    }
    return { status: "valid", value: t.data };
  }
  _addPart(t) {
    const n = [...this._def.parts, t];
    return new zh(K(R({}, this._def), {
      parts: n,
      regexString: this._appendToRegexString(this._def.regexString, t)
    }));
  }
  _appendToRegexString(t, n) {
    return `^${this._unwrapRegExp(t)}${this._transformPartToRegexString(n)}$`;
  }
  _transformPartToRegexString(t) {
    if (!(t instanceof nt))
      return this._escapeRegExp(t);
    if (t instanceof Nl)
      return this._escapeRegExp(t._def.value);
    if (t instanceof rs)
      return this._transformZodStringPartToRegexString(t);
    if (t instanceof Ea || t instanceof Dl)
      return `(${(t instanceof Ea ? t._def.values : bt.getValidEnumValues(t._def.values)).map(this._escapeRegExp).join("|")})`;
    if (t instanceof Bl)
      return `(${t._def.options.map((n) => this._transformPartToRegexString(n)).join("|")})`;
    if (t instanceof Fl)
      return this._transformZodNumberPartToRegexString(t);
    if (t instanceof br)
      return `(${this._transformPartToRegexString(t.unwrap())})?`;
    if (t instanceof zh)
      return this._unwrapRegExp(t._def.regexString);
    if (t instanceof Rl)
      return "\\-?\\d+";
    if (t instanceof Pl)
      return "(true|false)";
    if (t instanceof hi) {
      do
        t = t.unwrap();
      while (t instanceof hi);
      return `(${this._transformPartToRegexString(t)}|null)${t instanceof br ? "?" : ""}`;
    }
    if (t instanceof Il)
      return this._transformPartToRegexString(t.unwrap());
    if (t instanceof Ao)
      return ".*";
    if (t instanceof Ll)
      return "null";
    if (t instanceof jl)
      return "undefined";
    throw new Pg();
  }
  // FIXME: we don't support transformations, so `.trim()` is not supported.
  _transformZodStringPartToRegexString(t) {
    let n = 1 / 0, r = 0, i = "", a = "";
    for (const l of t._def.checks) {
      const c = this._resolveRegexForStringCheck(l);
      if (c)
        return this._unwrapRegExp(c);
      if (l.kind === "endsWith")
        i = l.value;
      else if (l.kind === "length")
        r = n = l.value;
      else if (l.kind === "max")
        n = Math.max(0, Math.min(n, l.value));
      else if (l.kind === "min")
        r = Math.max(r, l.value);
      else if (l.kind === "startsWith")
        a = l.value;
      else
        throw new vu("ZodString", l.kind);
    }
    const o = Math.max(0, r - a.length - i.length), s = Number.isFinite(n) ? Math.max(0, n - a.length - i.length) : 1 / 0;
    return s === 0 || o > s ? `${a}${i}` : `${a}.${this._resolveRegexWildcardLength(o, s)}${i}`;
  }
  _resolveRegexForStringCheck(t) {
    var n;
    return (n = {
      [t.kind]: null,
      cuid: wf,
      cuid2: xf,
      datetime: t.kind === "datetime" ? kf(t) : null,
      email: Ef,
      ip: t.kind === "ip" ? {
        any: new RegExp(
          `^(${this._unwrapRegExp(zs.source)})|(${this._unwrapRegExp(Zs.source)})$`
        ),
        v4: zs,
        v6: Zs
      }[t.version || "any"] : null,
      regex: t.kind === "regex" ? t.regex : null,
      ulid: _f,
      uuid: Sf
    }[t.kind]) != null ? n : null;
  }
  _resolveRegexWildcardLength(t, n) {
    return t === n ? t === 1 ? "" : `{${t}}` : n !== 1 / 0 ? `{${t},${n}}` : t === 0 ? "*" : t === 1 ? "+" : `{${t},}`;
  }
  // FIXME: we do not support exponent notation (e.g. 2e5) since it conflicts with `.int()`.
  _transformZodNumberPartToRegexString(t) {
    let n = !0, r = !0, i = -1 / 0, a = 1 / 0, o = !0, s = !1, l = !1, c = "";
    for (const u of t._def.checks)
      if (u.kind === "finite")
        s = !0;
      else if (u.kind === "int")
        l = !0;
      else if (u.kind === "max")
        a = Math.min(a, u.value), u.value <= 0 && (r = !1, u.value === 0 && !u.inclusive && (o = !1));
      else if (u.kind === "min")
        i = Math.max(i, u.value), u.value >= 0 && (n = !1, u.value === 0 && !u.inclusive && (o = !1));
      else
        throw new vu("ZodNumber", u.kind);
    if (Number.isFinite(i) && Number.isFinite(a) && (s = !0), n)
      c = `${c}\\-`, r && (c = `${c}?`);
    else if (!r)
      return "0+";
    return s || (c = `${c}(Infinity|(`), o ? l ? c = `${c}\\d+` : c = `${c}\\d+(\\.\\d+)?` : l ? c = `${c}\\d*[1-9]\\d*` : c = `${c}((\\d*[1-9]\\d*(\\.\\d+)?)|(\\d+\\.\\d*[1-9]\\d*))`, s || (c = `${c}))`), c;
  }
  _unwrapRegExp(t) {
    const n = typeof t == "string" ? "" : t.flags, r = typeof t == "string" ? t : t.source;
    return n.includes("i") ? this._unwrapRegExp(this._makeRegexStringCaseInsensitive(r)) : r.replace(/(^\^)|(\$$)/g, "");
  }
  _makeRegexStringCaseInsensitive(t) {
    const n = /* @__PURE__ */ w((a) => a.match(/[a-z]/i) != null, "isAlphabetic");
    let r = "", i = !1;
    for (let a = 0; a < t.length; a++) {
      const o = t.charAt(a), s = t.charAt(a + 1);
      if (o === "\\") {
        r += `${o}${s}`, a++;
        continue;
      }
      if (o === "[" ? i = !0 : i && o === "]" && (i = !1), !n(o)) {
        r += o;
        continue;
      }
      if (!i) {
        r += `[${o.toLowerCase()}${o.toUpperCase()}]`;
        continue;
      }
      const l = t.charAt(a + 2);
      if (s !== "-" || !n(l)) {
        r += `${o.toLowerCase()}${o.toUpperCase()}`;
        continue;
      }
      r += `${o.toLowerCase()}-${l.toLowerCase()}${o.toUpperCase()}-${l.toUpperCase()}`, a += 2;
    }
    return r;
  }
  _escapeRegExp(t) {
    return typeof t != "string" && (t = `${t}`), t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
};
w(Xu, "ZodTemplateLiteral");
Xu.create = /* @__PURE__ */ w((e) => {
  var t;
  return new Xu(K(R({}, ot(e)), {
    coerce: (t = e == null ? void 0 : e.coerce) != null ? t : !1,
    parts: [],
    regexString: "^$",
    typeName: "ZodTemplateLiteral"
    /* ZodTemplateLiteral */
  }));
}, "create");
var Tf = Xu, Qu = class extends nt {
  _parse(t) {
    if (this._getType(t) !== Te.undefined) {
      const r = this._getOrReturnCtx(t);
      return Ce(r, {
        code: ge.invalid_type,
        expected: Te.void,
        received: r.parsedType
      }), Ye;
    }
    return $n(t.data);
  }
};
w(Qu, "ZodVoid");
Qu.create = /* @__PURE__ */ w((e) => new Qu(R({
  typeName: "ZodVoid"
  /* ZodVoid */
}, ot(e))), "create");
var Vg = Qu, KE = {
  object: Ta.lazycreate
}, GE = /* @__PURE__ */ w((e, t = {
  message: `Input not instance of ${e.name}`
}) => Lg((n) => n instanceof e, t), "instanceOfType"), Hg = rs.create, Kg = Fl.create, JE = zg.create, YE = Rl.create, Gg = Pl.create, XE = hf.create, QE = Wg.create, ek = jl.create, tk = Ll.create, nk = Ao.create, rk = po.create, ik = Zi.create, ak = Vg.create, ok = $o.create, sk = Ta.create, lk = Ta.strictCreate, ck = Bl.create, uk = Ug.create, dk = vf.create, fk = ka.create, pk = Zg.create, hk = Bg.create, mk = qg.create, gk = Fg.create, yk = gf.create, vk = Nl.create, bk = Ea.create, wk = Dl.create, xk = Ul.create, ed = mi.create, _k = br.create, Sk = hi.create, Ek = mi.createWithPreprocess, kk = bf.create, Tk = Tf.create, Ck = /* @__PURE__ */ w(() => Hg().optional(), "ostring"), Ok = /* @__PURE__ */ w(() => Kg().optional(), "onumber"), Ak = /* @__PURE__ */ w(() => Gg().optional(), "oboolean"), $k = nt.fromJsonSchema, Rk = nt.fromObject, Pk = {
  string: (e) => rs.create(K(R({}, e), { coerce: !0 })),
  number: (e) => Fl.create(K(R({}, e), { coerce: !0 })),
  boolean: (e) => Pl.create(K(R({}, e), {
    coerce: !0
  })),
  bigint: (e) => Rl.create(K(R({}, e), { coerce: !0 })),
  date: (e) => hf.create(K(R({}, e), { coerce: !0 })),
  templateLiteral: (e) => Tf.create(K(R({}, e), {
    coerce: !0
  }))
}, Ik = Ye, Mk = /* @__PURE__ */ w((e, t) => e.anyOf.length ? e.anyOf.length === 1 ? mn(e.anyOf[0], K(R({}, t), {
  path: [...t.path, "anyOf", 0]
})) : `z.union([${e.anyOf.map((n, r) => mn(n, K(R({}, t), { path: [...t.path, "anyOf", r] }))).join(", ")}])` : "z.any()", "parseAnyOf"), _Q = /* @__PURE__ */ w((e) => "z.boolean()", "parseBoolean"), SQ = /* @__PURE__ */ w((e) => "z.any()", "parseDefault"), EQ = /* @__PURE__ */ w((e, t) => `z.union([${e.type.map((n) => mn(K(R({}, e), { type: n }), t)).join(", ")}])`, "parseMultipleType"), kQ = /* @__PURE__ */ w((e, t) => `z.any().refine((value) => !${mn(e.not, K(R({}, t), {
  path: [...t.path, "not"]
}))}.safeParse(value).success, "Invalid input: Should NOT be valid against schema")`, "parseNot"), TQ = /* @__PURE__ */ w((e) => "z.null()", "parseNull"), CQ = /* @__PURE__ */ w((e) => [e.slice(0, e.length / 2), e.slice(e.length / 2)], "half"), OQ = /* @__PURE__ */ w((e, ...t) => Object.keys(e).reduce((n, r) => (t.includes(r) || (n[r] = e[r]), n), {}), "omit");
function Tn(e, t, n) {
  var r;
  const i = e[t];
  let a = "";
  if (i !== void 0) {
    const o = n({ value: i, json: JSON.stringify(i) });
    if (o) {
      const s = o[0], l = o.length === 3 ? o[1] : "", c = o.length === 3 ? o[2] : o[1];
      a += s, ((r = e.errorMessage) == null ? void 0 : r[t]) !== void 0 && (a += l + JSON.stringify(e.errorMessage[t])), a += c;
    }
  }
  return a;
}
w(Tn, "withMessage");
var ws = Symbol("Original index"), AQ = /* @__PURE__ */ w((e) => {
  let t = [];
  for (let n = 0; n < e.length; n++) {
    const r = e[n];
    if (typeof r == "boolean")
      t.push(r ? { [ws]: n } : { [ws]: n, not: {} });
    else {
      if (ws in r)
        return e;
      t.push(K(R({}, r), { [ws]: n }));
    }
  }
  return t;
}, "ensureOriginalIndex");
function qs(e, t) {
  if (e.allOf.length === 0)
    return "z.never()";
  if (e.allOf.length === 1) {
    const n = e.allOf[0];
    return mn(n, K(R({}, t), {
      path: [...t.path, "allOf", n[ws]]
    }));
  } else {
    const [n, r] = CQ(AQ(e.allOf));
    return `z.intersection(${qs({ allOf: n }, t)}, ${qs(
      {
        allOf: r
      },
      t
    )})`;
  }
}
w(qs, "parseAllOf");
var $Q = /* @__PURE__ */ w((e, t) => {
  if (Array.isArray(e.items))
    return `z.tuple([${e.items.map((r, i) => mn(r, K(R({}, t), { path: [...t.path, "items", i] })))}])`;
  let n = e.items ? `z.array(${mn(e.items, K(R({}, t), {
    path: [...t.path, "items"]
  }))})` : "z.array(z.any())";
  return n += Tn(e, "minItems", ({ json: r }) => [`.min(${r}`, ", ", ")"]), n += Tn(e, "maxItems", ({ json: r }) => [`.max(${r}`, ", ", ")"]), n;
}, "parseArray"), RQ = /* @__PURE__ */ w((e) => `z.literal(${JSON.stringify(e.const)})`, "parseConst"), PQ = /* @__PURE__ */ w((e) => e.enum.length === 0 ? "z.never()" : e.enum.length === 1 ? `z.literal(${JSON.stringify(e.enum[0])})` : e.enum.every((t) => typeof t == "string") ? `z.enum([${e.enum.map((t) => JSON.stringify(t))}])` : `z.union([${e.enum.map((t) => `z.literal(${JSON.stringify(t)})`).join(", ")}])`, "parseEnum"), IQ = /* @__PURE__ */ w((e, t) => {
  const n = mn(e.if, K(R({}, t), { path: [...t.path, "if"] })), r = mn(e.then, K(R({}, t), {
    path: [...t.path, "then"]
  })), i = mn(e.else, K(R({}, t), {
    path: [...t.path, "else"]
  }));
  return `z.union([${r}, ${i}]).superRefine((value,ctx) => {
  const result = ${n}.safeParse(value).success
    ? ${r}.safeParse(value)
    : ${i}.safeParse(value);
  if (!result.success) {
    result.error.errors.forEach((error) => ctx.addIssue(error))
  }
})`;
}, "parseIfThenElse"), MQ = /* @__PURE__ */ w((e) => {
  let t = "z.number()";
  return e.type === "integer" ? t += Tn(e, "type", () => [".int(", ")"]) : t += Tn(e, "format", ({ value: n }) => {
    if (n === "int64")
      return [".int(", ")"];
  }), t += Tn(e, "multipleOf", ({ value: n, json: r }) => n === 1 ? t.startsWith("z.number().int(") ? void 0 : [".int(", ")"] : [`.multipleOf(${r}`, ", ", ")"]), typeof e.minimum == "number" ? e.exclusiveMinimum === !0 ? t += Tn(e, "minimum", ({ json: n }) => [`.gt(${n}`, ", ", ")"]) : t += Tn(e, "minimum", ({ json: n }) => [`.gte(${n}`, ", ", ")"]) : typeof e.exclusiveMinimum == "number" && (t += Tn(e, "exclusiveMinimum", ({ json: n }) => [`.gt(${n}`, ", ", ")"])), typeof e.maximum == "number" ? e.exclusiveMaximum === !0 ? t += Tn(e, "maximum", ({ json: n }) => [`.lt(${n}`, ", ", ")"]) : t += Tn(e, "maximum", ({ json: n }) => [`.lte(${n}`, ", ", ")"]) : typeof e.exclusiveMaximum == "number" && (t += Tn(e, "exclusiveMaximum", ({ json: n }) => [`.lt(${n}`, ", ", ")"])), t;
}, "parseNumber"), Jg = /* @__PURE__ */ w((e, t) => e.oneOf.length ? e.oneOf.length === 1 ? mn(e.oneOf[0], K(R({}, t), {
  path: [...t.path, "oneOf", 0]
})) : `z.any().superRefine((x, ctx) => {
    const schemas = [${e.oneOf.map(
  (n, r) => mn(n, K(R({}, t), {
    path: [...t.path, "oneOf", r]
  }))
).join(", ")}];
    const errors = schemas.reduce(
      (errors: z.ZodError[], schema) =>
        ((result) => ("error" in result ? [...errors, result.error] : errors))(
          schema.safeParse(x)
        ),
      []
    );
    if (schemas.length - errors.length !== 1) {
      ctx.addIssue({
        path: ctx.path,
        code: "invalid_union",
        unionErrors: errors,
        message: "Invalid input: Should pass single schema",
      });
    }
  })` : "z.any()", "parseOneOf");
function Nk(e, t) {
  let n;
  e.properties && (Object.keys(e.properties).length ? (n = "z.object({ ", n += Object.keys(e.properties).map((o) => {
    const s = e.properties[o], l = `${JSON.stringify(o)}: ${mn(s, K(R({}, t), {
      path: [...t.path, "properties", o]
    }))}`, c = typeof s == "object" && s.default !== void 0 || typeof e.default == "object" && e.default !== null && o in e.default, u = Array.isArray(e.required) ? e.required.includes(o) : typeof s == "object" && s.required === !0;
    return !c && !u ? `${l}.optional()` : l;
  }).join(", "), n += " })") : n = "z.object({})");
  const r = e.additionalProperties !== void 0 ? mn(e.additionalProperties, K(R({}, t), {
    path: [...t.path, "additionalProperties"]
  })) : void 0;
  let i;
  if (e.patternProperties) {
    const o = Object.fromEntries(
      Object.entries(e.patternProperties).map(([s, l]) => [
        s,
        mn(l, K(R({}, t), {
          path: [...t.path, "patternProperties", s]
        }))
      ], {})
    );
    i = "", n ? r ? i += `.catchall(z.union([${[
      ...Object.values(o),
      r
    ].join(", ")}]))` : Object.keys(o).length > 1 ? i += `.catchall(z.union([${Object.values(o).join(", ")}]))` : i += `.catchall(${Object.values(o)})` : r ? i += `z.record(z.union([${[
      ...Object.values(o),
      r
    ].join(", ")}]))` : Object.keys(o).length > 1 ? i += `z.record(z.union([${Object.values(o).join(", ")}]))` : i += `z.record(${Object.values(o)})`, i += `.superRefine((value, ctx) => {
`, i += `for (const key in value) {
`, r && (e.properties ? i += `let evaluated = [${Object.keys(e.properties).map((s) => JSON.stringify(s)).join(", ")}].includes(key)
` : i += `let evaluated = false
`);
    for (const s in e.patternProperties)
      i += "if (key.match(new RegExp(" + JSON.stringify(s) + `))) {
`, r && (i += `evaluated = true
`), i += "const result = " + o[s] + `.safeParse(value[key])
`, i += `if (!result.success) {
`, i += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: Key matching regex /\${key}/ must match schema\`,
          params: {
            issues: result.error.issues
          }
        })
`, i += `}
`, i += `}
`;
    r && (i += `if (!evaluated) {
`, i += "const result = " + r + `.safeParse(value[key])
`, i += `if (!result.success) {
`, i += `ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: \`Invalid input: must match catchall schema\`,
          params: {
            issues: result.error.issues
          }
        })
`, i += `}
`, i += `}
`), i += `}
`, i += "})";
  }
  let a = n ? i ? n + i : r ? r === "z.never()" ? n + ".strict()" : n + `.catchall(${r})` : n : i || (r ? `z.record(${r})` : "z.record(z.any())");
  return en.an.anyOf(e) && (a += `.and(${Mk(
    K(R({}, e), {
      anyOf: e.anyOf.map(
        (o) => typeof o == "object" && !o.type && (o.properties || o.additionalProperties || o.patternProperties) ? K(R({}, o), { type: "object" }) : o
      )
    }),
    t
  )})`), en.a.oneOf(e) && (a += `.and(${Jg(
    K(R({}, e), {
      oneOf: e.oneOf.map(
        (o) => typeof o == "object" && !o.type && (o.properties || o.additionalProperties || o.patternProperties) ? K(R({}, o), { type: "object" }) : o
      )
    }),
    t
  )})`), en.an.allOf(e) && (a += `.and(${qs(
    K(R({}, e), {
      allOf: e.allOf.map(
        (o) => typeof o == "object" && !o.type && (o.properties || o.additionalProperties || o.patternProperties) ? K(R({}, o), { type: "object" }) : o
      )
    }),
    t
  )})`), a;
}
w(Nk, "parseObject");
var NQ = /* @__PURE__ */ w((e) => {
  let t = "z.string()";
  return t += Tn(e, "format", ({ value: n }) => {
    switch (n) {
      case "email":
        return [".email(", ")"];
      case "ip":
        return [".ip(", ")"];
      case "ipv4":
        return ['.ip({ version: "v4"', ", message: ", " })"];
      case "ipv6":
        return ['.ip({ version: "v6"', ", message: ", " })"];
      case "uri":
        return [".url(", ")"];
      case "uuid":
        return [".uuid(", ")"];
      case "date-time":
        return [".datetime(", ")"];
    }
  }), t += Tn(e, "pattern", ({ json: n }) => [`.regex(new RegExp(${n})`, ", ", ")"]), t += Tn(e, "minLength", ({ json: n }) => [`.min(${n}`, ", ", ")"]), t += Tn(e, "maxLength", ({ json: n }) => [`.max(${n}`, ", ", ")"]), t;
}, "parseString"), DQ = /* @__PURE__ */ w((e, t) => `${mn(OQ(e, "nullable"), t, !0)}.nullable()`, "parseNullable"), LQ = /* @__PURE__ */ w((e, t) => {
  var n, r;
  if (e.oneOf.length <= 1 || !((n = e.discriminator) != null && n.propertyName))
    return Jg(e, t);
  const i = e.oneOf.map(
    (a, o) => mn(a, K(R({}, t), {
      path: [...t.path, "oneOf", o]
    }))
  );
  return `z.discriminatedUnion("${(r = e.discriminator) == null ? void 0 : r.propertyName}", [${i.join(", ")}])`;
}, "parseDiscriminator"), mn = /* @__PURE__ */ w((e, t = { seen: /* @__PURE__ */ new Map(), path: [] }, n) => {
  if (typeof e != "object")
    return e ? "z.any()" : "z.never()";
  if (t.parserOverride) {
    const a = t.parserOverride(e, t);
    if (typeof a == "string")
      return a;
  }
  let r = t.seen.get(e);
  if (r) {
    if (r.r !== void 0)
      return r.r;
    if (t.depth === void 0 || r.n >= t.depth)
      return "z.any()";
    r.n += 1;
  } else
    r = { r: void 0, n: 0 }, t.seen.set(e, r);
  let i = FQ(e, t);
  return n || (i = jQ(e, i), t.withoutDefaults || (i = UQ(e, i))), r.r = i, i;
}, "parseSchema"), jQ = /* @__PURE__ */ w((e, t) => (e.description && (t += `.describe(${JSON.stringify(e.description)})`), t), "addMeta"), UQ = /* @__PURE__ */ w((e, t) => (e.default !== void 0 && (t += `.default(${JSON.stringify(e.default)})`), t), "addDefaults"), FQ = /* @__PURE__ */ w((e, t) => en.a.nullable(e) ? DQ(e, t) : en.an.object(e) ? Nk(e, t) : en.an.array(e) ? $Q(e, t) : en.an.anyOf(e) ? Mk(e, t) : en.an.allOf(e) ? qs(e, t) : en.a.discriminator(e) ? LQ(e, t) : en.a.oneOf(e) ? Jg(e, t) : en.a.not(e) ? kQ(e, t) : en.an.enum(e) ? PQ(e) : en.a.const(e) ? RQ(e) : en.a.multipleType(e) ? EQ(e, t) : en.a.primitive(e, "string") ? NQ(e) : en.a.primitive(e, "number") || en.a.primitive(e, "integer") ? MQ(e) : en.a.primitive(e, "boolean") ? _Q(e) : en.a.primitive(e, "null") ? TQ(e) : en.a.conditional(e) ? IQ(e, t) : SQ(e), "selectParser"), en = {
  an: {
    object: (e) => e.type === "object",
    array: (e) => e.type === "array",
    anyOf: (e) => e.anyOf !== void 0,
    allOf: (e) => e.allOf !== void 0,
    enum: (e) => e.enum !== void 0
  },
  a: {
    nullable: (e) => e.nullable === !0,
    multipleType: (e) => Array.isArray(e.type),
    not: (e) => e.not !== void 0,
    const: (e) => e.const !== void 0,
    primitive: (e, t) => e.type === t,
    conditional: (e) => !!("if" in e && e.if && "then" in e && "else" in e && e.then && e.else),
    discriminator: (e) => {
      var t;
      return e.oneOf !== void 0 && ((t = e.discriminator) == null ? void 0 : t.propertyName) !== void 0;
    },
    oneOf: (e) => e.oneOf !== void 0
  }
}, BQ = /* @__PURE__ */ w((e) => mn(e, {
  seen: /* @__PURE__ */ new Map(),
  path: []
}), "jsonSchemaToZodStr"), zQ = /* @__PURE__ */ w((e) => {
  let t = BQ(e);
  return t = t.replaceAll("errors: z.ZodError[]", "errors"), new Function("z", `return ${t}`)(cn);
}, "jsonSchemaToZod"), xs = /* @__PURE__ */ w((e, t) => {
  var n, r;
  if (t[Kt] && e._def && (e._def[Kt] = t[Kt]), ((n = e._def) == null ? void 0 : n.typeName) === "ZodObject" && t.type === "object" && t.properties && Object.entries(t.properties).forEach(([i, a]) => {
    const o = typeof e._def.shape == "function" ? e._def.shape() : e._def.shape;
    o[i] && xs(o[i], a);
  }), ((r = e._def) == null ? void 0 : r.typeName) === "ZodRecord" && t.type === "object" && t.additionalProperties && xs(e._def.valueType, t.additionalProperties), t.type === "array" && t.items) {
    const i = t.items;
    if (typeof i == "object" && !Array.isArray(i)) {
      const a = e._def.type;
      a && xs(a, i);
    } else
      Array.isArray(i) && i.forEach((a, o) => {
        const s = e._def;
        s.typeName === cn.ZodFirstPartyTypeKind.ZodTuple && xs(s.items[o], a);
      });
  }
}, "applyZuiPropsRecursively"), zl = /* @__PURE__ */ w((e) => {
  const t = zQ(e);
  return xs(t, e), t;
}, "jsonSchemaToZui"), bn = Mt(Jt, 1), Jn = Jt, ZQ = Mt(Jt, 1), Dk = (0, Jn.createContext)({
  formData: void 0,
  formSchema: void 0,
  setFormData: () => {
    throw new Error("Must be within a FormDataProvider");
  },
  setHiddenState: () => {
    throw new Error("Must be within a FormDataProvider");
  },
  setDisabledState: () => {
    throw new Error("Must be within a FormDataProvider");
  },
  hiddenState: {},
  disabledState: {},
  disableValidation: !1
}), bw = /* @__PURE__ */ w((e, t, n) => {
  var r;
  const i = (r = t[Kt]) == null ? void 0 : r[e];
  if (typeof i > "u")
    return !1;
  if (typeof i == "boolean")
    return i;
  if (typeof i == "string") {
    if (typeof window > "u")
      return console.warn("Function evaluation is not supported in server side rendering"), !1;
    const o = new Function("return " + i)()(n);
    switch (typeof o) {
      case "object":
      case "boolean":
        return o;
      default:
        return !1;
    }
  }
  return !1;
}, "parseMaskableField"), Lk = /* @__PURE__ */ w((e, t) => {
  const n = (0, Jn.useContext)(Dk);
  if (n === void 0)
    throw new Error("useFormData must be used within a FormDataProvider");
  const r = (0, Jn.useMemo)(() => ua(n.formData, t), [n.formData, t]), i = (0, Jn.useMemo)(() => {
    if (n.disableValidation)
      return { formValid: null, formErrors: null };
    if (!n.formSchema)
      return { formValid: null, formErrors: null };
    const p = zl(n.formSchema).safeParse(n.formData);
    return p.success ? {
      formValid: !0,
      formErrors: []
    } : {
      formValid: !1,
      formErrors: p.error.issues
    };
  }, [n.formData]), a = (0, Jn.useMemo)(() => bw("hidden", e, r), [e, r]), o = (0, Jn.useMemo)(() => bw("disabled", e, r), [e, r]);
  (0, Jn.useEffect)(() => {
    n.setHiddenState(Ya(n.hiddenState, t, a || {})), n.setDisabledState(Ya(n.disabledState, t, o || {}));
  }, [a, o]);
  const { disabled: s, hidden: l } = (0, Jn.useMemo)(() => {
    const p = a === !0 || ua(n.hiddenState, t), f = o === !0 || ua(n.disabledState, t);
    return { hidden: p === !0, disabled: f === !0 };
  }, [n.hiddenState, n.disabledState, t]), c = (0, Jn.useCallback)(
    (p, f) => {
      n.setFormData(Ya(n.formData, p, f));
    },
    [n.formData]
  ), u = (0, Jn.useCallback)(
    (p, f) => {
      const h = ua(n.formData, p) || [];
      n.setFormData(Ya(n.formData, p, [...h, f]));
    },
    [n.formData]
  ), d = (0, Jn.useCallback)(
    (p, f) => {
      const h = ua(n.formData, p);
      h.splice(f, 1), n.setFormData(Ya(n.formData, p, h));
    },
    [n.formData]
  );
  return R(K(R({}, n), { data: r, disabled: s, hidden: l, handlePropertyChange: c, addArrayItem: u, removeArrayItem: d }), i);
}, "useFormData");
function Ya(e, t, n) {
  if (t.length === 0)
    return n;
  const r = t.length;
  return t.reduce((i, a, o) => (o === r - 1 ? i[a] = n : i[a] || (i[a] = isNaN(Number(a)) ? {} : []), i[a]), e ?? {}), R({}, e);
}
w(Ya, "setObjectPath");
var jk = /* @__PURE__ */ w((e) => Array.isArray(e) ? e.map((t) => jk(t)) : e.type === "object" ? {} : e.type === "array" ? [] : e.type === "string" ? "" : e.type === "number" ? 0 : e.type === "boolean" ? !1 : null, "getDefaultItemData"), qQ = /* @__PURE__ */ w(({
  children: e,
  setFormData: t,
  formData: n,
  formSchema: r,
  disableValidation: i
}) => {
  const [a, o] = (0, Jn.useState)({}), [s, l] = (0, Jn.useState)({});
  return /* @__PURE__ */ ZQ.default.createElement(
    Dk.Provider,
    {
      value: {
        formData: n,
        setFormData: t,
        formSchema: r,
        disableValidation: i,
        hiddenState: a,
        setHiddenState: o,
        disabledState: s,
        setDisabledState: l
      }
    },
    e
  );
}, "FormDataProvider");
function ua(e, t) {
  return t.reduce((n, r) => n ? n[r] : null, e);
}
w(ua, "getPathData");
function Zh(e, t) {
  return t || (t = new RegExp("/s|-|_| ", "g")), Bk(e).split(t).map(Uk).map(zk).reduce(Fk);
}
w(Zh, "formatTitle");
function Uk(e) {
  return e.charAt(0).toUpperCase() + e.substring(1);
}
w(Uk, "capitalize");
function Fk(e, t) {
  return `${e} ${t}`;
}
w(Fk, "combine");
function Bk(e) {
  return e.replace(/([a-z\d])([A-Z])/g, "$1_$2").replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1_$2").toLowerCase();
}
w(Bk, "decamelize");
function zk(e, t, n) {
  const r = e.toLowerCase(), i = e.toUpperCase();
  for (const a of GQ)
    if (a.toLowerCase() === r)
      return a;
  return WQ.includes(i) ? i : t === 0 || t === n.length - 1 || e.length >= 4 ? e : KQ.includes(r) || HQ.includes(r) || VQ.includes(r) ? r : e;
}
w(zk, "handleSpecialWords");
var WQ = [
  "2D",
  "3D",
  "4WD",
  "A2O",
  "API",
  "BIOS",
  "CCTV",
  "CC",
  "CCV",
  "CD",
  "CD-ROM",
  "COBOL",
  "CIA",
  "CMS",
  "CSS",
  "CSV",
  "CV",
  "DIY",
  "DVD",
  "DB",
  "DNA",
  "E3",
  "EIN",
  "ESPN",
  "FAQ",
  "FAQs",
  "FTP",
  "FPS",
  "FORTRAN",
  "FBI",
  "HTML",
  "HTTP",
  "ID",
  "IP",
  "ISO",
  "JS",
  "JSON",
  "LASER",
  "M2A",
  "M2M",
  "M2MM",
  "M2O",
  "MMORPG",
  "NAFTA",
  "NASA",
  "NDA",
  "O2M",
  "PDF",
  "PHP",
  "POP",
  "RAM",
  "RNGR",
  "ROM",
  "RPG",
  "RTFM",
  "RTS",
  "SCUBA",
  "SITCOM",
  "SKU",
  "SMTP",
  "SQL",
  "SSN",
  "SWAT",
  "TBS",
  "TTL",
  "TV",
  "TNA",
  "UI",
  "URL",
  "USB",
  "UWP",
  "VIP",
  "W3C",
  "WYSIWYG",
  "WWW",
  "WWE",
  "WWF"
], VQ = ["a", "an", "the"], HQ = [
  "and",
  "that",
  "but",
  "or",
  "as",
  "if",
  "when",
  "than",
  "because",
  "while",
  "where",
  "after",
  "so",
  "though",
  "since",
  "until",
  "whether",
  "before",
  "although",
  "nor",
  "like",
  "once",
  "unless",
  "now",
  "except"
], KQ = [
  "about",
  "above",
  "across",
  "after",
  "against",
  "along",
  "among",
  "around",
  "at",
  "because of",
  "before",
  "behind",
  "below",
  "beneath",
  "beside",
  "besides",
  "between",
  "beyond",
  "but",
  "by",
  "concerning",
  "despite",
  "down",
  "during",
  "except",
  "excepting",
  "for",
  "from",
  "in",
  "in front of",
  "inside",
  "in spite of",
  "instead of",
  "into",
  "like",
  "near",
  "of",
  "off",
  "on",
  "onto",
  "out",
  "outside",
  "over",
  "past",
  "regarding",
  "since",
  "through",
  "throughout",
  "to",
  "toward",
  "under",
  "underneath",
  "until",
  "up",
  "upon",
  "up to",
  "with",
  "within",
  "without",
  "with regard to",
  "with respect to"
], GQ = [
  "2FA",
  "3D",
  "4K",
  "5K",
  "8K",
  "AGI",
  "BI",
  "ChatGPT",
  "CTA",
  "DateTime",
  "GitHub",
  "GPT",
  "HD",
  "IBMid",
  "ID",
  "IDs",
  "iMac",
  "IMAX",
  "iOS",
  "IP",
  "iPad",
  "iPhone",
  "iPod",
  "LDAP",
  "LinkedIn",
  "LLM",
  "M2M",
  "M2O",
  "macOS",
  "McDonalds",
  "ML",
  "MySQL",
  "NLG",
  "NLP",
  "NLU",
  "O2M",
  "OpenAI",
  "PDFs",
  "PEFT",
  "pH",
  "PostgreSQL",
  "SEO",
  "TTS",
  "UHD",
  "UUID",
  "XSS",
  "YouTube"
], ww = Mt(Jt, 1), Zk = class extends ww.Component {
  constructor() {
    super(...arguments), this.state = {
      hasError: !1,
      error: null
    };
  }
  static getDerivedStateFromError(t) {
    return { hasError: !0, error: t };
  }
  componentDidCatch(t, n) {
    console.error("Uncaught error:", t, n);
  }
  render() {
    return this.state.hasError && this.props.fallback ? /* @__PURE__ */ ww.default.createElement(this.props.fallback, { error: this.state.error, schema: this.props.fieldSchema }) : this.props.children;
  }
};
w(Zk, "ErrorBoundary");
var Mc = Zk, JQ = /* @__PURE__ */ w((e) => {
  var t;
  return (t = e.anyOf) != null && t.length ? qk(e.anyOf) ? "discriminatedUnion" : "object" : e.type === "integer" ? "number" : e.type;
}, "getSchemaType"), YQ = /* @__PURE__ */ w((e, t) => {
  var n, r, i;
  const a = JQ(t), o = ((n = t[Kt]) == null ? void 0 : n.displayAs) || null;
  if (!o || !Array.isArray(o) || o.length < 2) {
    const u = (r = e == null ? void 0 : e[a]) == null ? void 0 : r.default;
    return u ? {
      Component: u,
      type: a,
      id: "default",
      params: {}
    } : null;
  }
  const s = o[0], l = ((i = e == null ? void 0 : e[a]) == null ? void 0 : i[s]) || null;
  if (!l)
    return console.warn(`Component ${a}.${s} not found`), null;
  const c = o[1] || {};
  return {
    Component: l,
    type: a,
    id: s,
    params: c
  };
}, "resolveComponent"), qk = /* @__PURE__ */ w((e) => {
  const t = e == null ? void 0 : e.map((n) => n.type !== "object" || !n.properties ? null : Object.entries(n.properties).map(([r, i]) => {
    var a;
    return i.type === "string" && ((a = i.enum) != null && a.length) ? { key: r, value: i.enum[0] } : null;
  }).filter((r) => !!r)).flat().reduce(
    (n, r) => {
      if (!r)
        return n;
      const { key: i, value: a } = r;
      return n.key === null && (n.key = i), n.key === i && n.values.push(a), n;
    },
    { key: null, values: [] }
  );
  return (t == null ? void 0 : t.key) === null || !(t != null && t.values.length) ? null : t;
}, "resolveDiscriminator"), XQ = /* @__PURE__ */ w((e, t, n) => {
  var r, i;
  if (!(n != null && n.length) || !e || !t)
    return null;
  for (const a of n) {
    if (a.type !== "object")
      continue;
    const o = (r = a.properties) == null ? void 0 : r[e];
    if ((o == null ? void 0 : o.type) === "string" && ((i = o.enum) != null && i.length) && o.enum[0] === t)
      return K(R({}, a), {
        properties: K(R({}, a.properties), {
          [e]: K(R({}, o), { [Kt]: { hidden: !0 } })
        })
      });
  }
  return null;
}, "resolveDiscriminatedSchema"), QQ = /* @__PURE__ */ w(({
  schema: e,
  components: t,
  onChange: n,
  value: r,
  disableValidation: i,
  fallback: a
}) => /* @__PURE__ */ bn.default.createElement(
  qQ,
  {
    formData: r,
    setFormData: n,
    formSchema: e,
    disableValidation: i || !1
  },
  /* @__PURE__ */ bn.default.createElement(Mc, { fallback: a, fieldSchema: e, path: [] }, /* @__PURE__ */ bn.default.createElement(
    Nc,
    {
      components: t,
      fieldSchema: e,
      path: [],
      fallback: a,
      required: !0,
      isArrayChild: !1
    }
  ))
), "ZuiForm"), eee = /* @__PURE__ */ w((e, t, n) => {
  const { handlePropertyChange: r } = Lk(e, t), { discriminator: i, value: a, discriminatedSchema: o } = (0, bn.useMemo)(() => {
    const s = qk(e.anyOf), l = s != null && s.key ? n == null ? void 0 : n[s.key] : null, c = XQ((s == null ? void 0 : s.key) || null, l, e.anyOf);
    return {
      discriminator: s,
      value: l,
      discriminatedSchema: c
    };
  }, [e.anyOf, n]);
  return (0, bn.useEffect)(() => {
    i != null && i.key && (i != null && i.values.length) && r(t, { [i.key]: i.values[0] });
  }, []), { discriminator: i, discriminatorValue: a, discriminatedSchema: o };
}, "useDiscriminator"), Nc = /* @__PURE__ */ w((e) => {
  var t = e, {
    components: n,
    fieldSchema: r,
    path: i,
    required: a,
    fallback: o
  } = t, s = vS(t, [
    "components",
    "fieldSchema",
    "path",
    "required",
    "fallback"
  ]), l, c;
  const { formData: u, disabled: d, hidden: p, handlePropertyChange: f, addArrayItem: h, removeArrayItem: m, formErrors: y, formValid: g } = Lk(r, i), v = (0, bn.useMemo)(() => ua(u, i), [u, i]), b = (0, bn.useMemo)(() => YQ(n, r), [r, n]), { discriminator: T, discriminatedSchema: O, discriminatorValue: S } = eee(r, i, v);
  if (!b || p === !0)
    return null;
  const { Component: P, type: M } = b, L = {
    type: M,
    componentID: b.id,
    scope: i.join("."),
    context: {
      path: i,
      readonly: !1,
      formData: u,
      formErrors: y,
      formValid: g,
      updateForm: f
    },
    onChange: (B) => f(i, B),
    disabled: d,
    errors: (y == null ? void 0 : y.filter((B) => B.path === i)) || [],
    label: ((l = r[Kt]) == null ? void 0 : l.title) || Zh(((c = i[i.length - 1]) == null ? void 0 : c.toString()) || ""),
    params: b.params,
    schema: r,
    zuiProps: r[Kt]
  };
  if (r.type === "array" && M === "array") {
    const B = P, U = L.schema, z = Array.isArray(v) || typeof v == "object" ? v : [], D = R(K(R({}, L), {
      type: M,
      schema: U,
      data: z,
      addItem: (j = void 0) => h(i, typeof j > "u" ? jk(U.items) : j),
      removeItem: (j) => m(i, j)
    }), s);
    return Array.isArray(r.items) ? null : /* @__PURE__ */ bn.default.createElement(B, K(R({ key: L.scope }, D), { isArrayChild: D.isArrayChild }), Array.isArray(D.data) ? D.data.map((j, V) => {
      const W = [...i, V.toString()];
      return /* @__PURE__ */ bn.default.createElement(
        Mc,
        {
          key: W.join("."),
          fallback: o,
          fieldSchema: r.items,
          path: W
        },
        /* @__PURE__ */ bn.default.createElement(
          Nc,
          {
            key: W.join("."),
            components: n,
            fieldSchema: r.items,
            path: W,
            required: a,
            isArrayChild: !0,
            index: V,
            removeSelf: () => m(i, V),
            fallback: o
          }
        )
      );
    }) : []);
  }
  if (r.type === "object" && M === "object" && r.properties) {
    const B = P, U = R(K(R({}, L), {
      type: M,
      schema: L.schema,
      data: v || {}
    }), s);
    return /* @__PURE__ */ bn.default.createElement(B, K(R({ key: L.scope }, U), { isArrayChild: U.isArrayChild }), Object.entries(r.properties).map(([z, D]) => {
      var j;
      const V = [...i, z];
      return /* @__PURE__ */ bn.default.createElement(Mc, { key: V.join("."), fallback: o, fieldSchema: D, path: V }, /* @__PURE__ */ bn.default.createElement(
        Nc,
        {
          key: V.join("."),
          components: n,
          fieldSchema: D,
          path: V,
          required: ((j = r.required) == null ? void 0 : j.includes(z)) || !1,
          isArrayChild: !1,
          fallback: o
        }
      ));
    }));
  }
  if (M === "discriminatedUnion") {
    const B = P, U = R(K(R({}, L), {
      type: M,
      schema: L.schema,
      data: v || {},
      discriminatorKey: (T == null ? void 0 : T.key) || null,
      discriminatorLabel: Zh((T == null ? void 0 : T.key) || "Unknown"),
      discriminatorOptions: (T == null ? void 0 : T.values) || null,
      discriminatorValue: S,
      setDiscriminator: (z) => {
        if (!(T != null && T.key)) {
          console.warn("No discriminator key found, cannot set discriminator");
          return;
        }
        f(i, { [T.key]: z });
      }
    }), s);
    return /* @__PURE__ */ bn.default.createElement(B, K(R({ key: L.scope }, U), { isArrayChild: U.isArrayChild }), O && /* @__PURE__ */ bn.default.createElement(Mc, { key: i.join("."), fallback: o, fieldSchema: O, path: i }, /* @__PURE__ */ bn.default.createElement(
      Nc,
      {
        components: n,
        fieldSchema: O,
        path: i,
        required: a,
        isArrayChild: !1,
        fallback: o
      }
    )));
  }
  const k = P, I = R(K(R({}, L), {
    type: M,
    schema: L.schema,
    config: {},
    required: a,
    data: v,
    description: r.description
  }), s);
  return /* @__PURE__ */ bn.default.createElement(k, R({}, I));
}, "FormElementRenderer"), tee = {
  jsonSchemaToZui: zl,
  zuiToJsonSchema: uf,
  objectToZui: To,
  zuiToTypescriptTypings: RE
};
const Yg = {}, nee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Yg
}, Symbol.toStringTag, { value: "Module" })), qh = /* @__PURE__ */ _m(nee);
function Wk(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: ree } = Object.prototype, { getPrototypeOf: Xg } = Object, Cf = ((e) => (t) => {
  const n = ree.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Vr = (e) => (e = e.toLowerCase(), (t) => Cf(t) === e), Of = (e) => (t) => typeof t === e, { isArray: is } = Array, Ws = Of("undefined");
function iee(e) {
  return e !== null && !Ws(e) && e.constructor !== null && !Ws(e.constructor) && lr(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const Vk = Vr("ArrayBuffer");
function aee(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && Vk(e.buffer), t;
}
const oee = Of("string"), lr = Of("function"), Hk = Of("number"), Af = (e) => e !== null && typeof e == "object", see = (e) => e === !0 || e === !1, Dc = (e) => {
  if (Cf(e) !== "object")
    return !1;
  const t = Xg(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, lee = Vr("Date"), cee = Vr("File"), uee = Vr("Blob"), dee = Vr("FileList"), fee = (e) => Af(e) && lr(e.pipe), pee = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || lr(e.append) && ((t = Cf(e)) === "formdata" || // detect form-data instance
  t === "object" && lr(e.toString) && e.toString() === "[object FormData]"));
}, hee = Vr("URLSearchParams"), mee = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Zl(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), is(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e), o = a.length;
    let s;
    for (r = 0; r < o; r++)
      s = a[r], t.call(null, e[s], s, e);
  }
}
function Kk(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const Gk = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), Jk = (e) => !Ws(e) && e !== Gk;
function Wh() {
  const { caseless: e } = Jk(this) && this || {}, t = {}, n = (r, i) => {
    const a = e && Kk(t, i) || i;
    Dc(t[a]) && Dc(r) ? t[a] = Wh(t[a], r) : Dc(r) ? t[a] = Wh({}, r) : is(r) ? t[a] = r.slice() : t[a] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && Zl(arguments[r], n);
  return t;
}
const gee = (e, t, n, { allOwnKeys: r } = {}) => (Zl(t, (i, a) => {
  n && lr(i) ? e[a] = Wk(i, n) : e[a] = i;
}, { allOwnKeys: r }), e), yee = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), vee = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, bee = (e, t, n, r) => {
  let i, a, o;
  const s = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (i = Object.getOwnPropertyNames(e), a = i.length; a-- > 0; )
      o = i[a], (!r || r(o, e, t)) && !s[o] && (t[o] = e[o], s[o] = !0);
    e = n !== !1 && Xg(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, wee = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, xee = (e) => {
  if (!e)
    return null;
  if (is(e))
    return e;
  let t = e.length;
  if (!Hk(t))
    return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, _ee = ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && Xg(Uint8Array)), See = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const a = i.value;
    t.call(e, a[0], a[1]);
  }
}, Eee = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, kee = Vr("HTMLFormElement"), Tee = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), xw = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), Cee = Vr("RegExp"), Yk = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  Zl(n, (i, a) => {
    let o;
    (o = t(i, a, e)) !== !1 && (r[a] = o || i);
  }), Object.defineProperties(e, r);
}, Oee = (e) => {
  Yk(e, (t, n) => {
    if (lr(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (lr(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, Aee = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((a) => {
      n[a] = !0;
    });
  };
  return is(e) ? r(e) : r(String(e).split(t)), n;
}, $ee = () => {
}, Ree = (e, t) => (e = +e, Number.isFinite(e) ? e : t), Ap = "abcdefghijklmnopqrstuvwxyz", _w = "0123456789", Xk = {
  DIGIT: _w,
  ALPHA: Ap,
  ALPHA_DIGIT: Ap + Ap.toUpperCase() + _w
}, Pee = (e = 16, t = Xk.ALPHA_DIGIT) => {
  let n = "";
  const { length: r } = t;
  for (; e--; )
    n += t[Math.random() * r | 0];
  return n;
};
function Iee(e) {
  return !!(e && lr(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]);
}
const Mee = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (Af(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const a = is(r) ? [] : {};
        return Zl(r, (o, s) => {
          const l = n(o, i + 1);
          !Ws(l) && (a[s] = l);
        }), t[i] = void 0, a;
      }
    }
    return r;
  };
  return n(e, 0);
}, Nee = Vr("AsyncFunction"), Dee = (e) => e && (Af(e) || lr(e)) && lr(e.then) && lr(e.catch), oe = {
  isArray: is,
  isArrayBuffer: Vk,
  isBuffer: iee,
  isFormData: pee,
  isArrayBufferView: aee,
  isString: oee,
  isNumber: Hk,
  isBoolean: see,
  isObject: Af,
  isPlainObject: Dc,
  isUndefined: Ws,
  isDate: lee,
  isFile: cee,
  isBlob: uee,
  isRegExp: Cee,
  isFunction: lr,
  isStream: fee,
  isURLSearchParams: hee,
  isTypedArray: _ee,
  isFileList: dee,
  forEach: Zl,
  merge: Wh,
  extend: gee,
  trim: mee,
  stripBOM: yee,
  inherits: vee,
  toFlatObject: bee,
  kindOf: Cf,
  kindOfTest: Vr,
  endsWith: wee,
  toArray: xee,
  forEachEntry: See,
  matchAll: Eee,
  isHTMLForm: kee,
  hasOwnProperty: xw,
  hasOwnProp: xw,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: Yk,
  freezeMethods: Oee,
  toObjectSet: Aee,
  toCamelCase: Tee,
  noop: $ee,
  toFiniteNumber: Ree,
  findKey: Kk,
  global: Gk,
  isContextDefined: Jk,
  ALPHABET: Xk,
  generateString: Pee,
  isSpecCompliantForm: Iee,
  toJSONObject: Mee,
  isAsyncFn: Nee,
  isThenable: Dee
};
function xt(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i);
}
oe.inherits(xt, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: oe.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const Qk = xt.prototype, eT = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  eT[e] = { value: e };
});
Object.defineProperties(xt, eT);
Object.defineProperty(Qk, "isAxiosError", { value: !0 });
xt.from = (e, t, n, r, i, a) => {
  const o = Object.create(Qk);
  return oe.toFlatObject(e, o, function(l) {
    return l !== Error.prototype;
  }, (s) => s !== "isAxiosError"), xt.call(o, e.message, t, n, r, i), o.cause = e, o.name = e.name, a && Object.assign(o, a), o;
};
const Lee = null;
function Vh(e) {
  return oe.isPlainObject(e) || oe.isArray(e);
}
function tT(e) {
  return oe.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Sw(e, t, n) {
  return e ? e.concat(t).map(function(i, a) {
    return i = tT(i), !n && a ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function jee(e) {
  return oe.isArray(e) && !e.some(Vh);
}
const Uee = oe.toFlatObject(oe, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function $f(e, t, n) {
  if (!oe.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = oe.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(m, y) {
    return !oe.isUndefined(y[m]);
  });
  const r = n.metaTokens, i = n.visitor || u, a = n.dots, o = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && oe.isSpecCompliantForm(t);
  if (!oe.isFunction(i))
    throw new TypeError("visitor must be a function");
  function c(h) {
    if (h === null)
      return "";
    if (oe.isDate(h))
      return h.toISOString();
    if (!l && oe.isBlob(h))
      throw new xt("Blob is not supported. Use a Buffer instead.");
    return oe.isArrayBuffer(h) || oe.isTypedArray(h) ? l && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  function u(h, m, y) {
    let g = h;
    if (h && !y && typeof h == "object") {
      if (oe.endsWith(m, "{}"))
        m = r ? m : m.slice(0, -2), h = JSON.stringify(h);
      else if (oe.isArray(h) && jee(h) || (oe.isFileList(h) || oe.endsWith(m, "[]")) && (g = oe.toArray(h)))
        return m = tT(m), g.forEach(function(b, T) {
          !(oe.isUndefined(b) || b === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? Sw([m], T, a) : o === null ? m : m + "[]",
            c(b)
          );
        }), !1;
    }
    return Vh(h) ? !0 : (t.append(Sw(y, m, a), c(h)), !1);
  }
  const d = [], p = Object.assign(Uee, {
    defaultVisitor: u,
    convertValue: c,
    isVisitable: Vh
  });
  function f(h, m) {
    if (!oe.isUndefined(h)) {
      if (d.indexOf(h) !== -1)
        throw Error("Circular reference detected in " + m.join("."));
      d.push(h), oe.forEach(h, function(g, v) {
        (!(oe.isUndefined(g) || g === null) && i.call(
          t,
          g,
          oe.isString(v) ? v.trim() : v,
          m,
          p
        )) === !0 && f(g, m ? m.concat(v) : [v]);
      }), d.pop();
    }
  }
  if (!oe.isObject(e))
    throw new TypeError("data must be an object");
  return f(e), t;
}
function Ew(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function Qg(e, t) {
  this._pairs = [], e && $f(e, this, t);
}
const nT = Qg.prototype;
nT.append = function(t, n) {
  this._pairs.push([t, n]);
};
nT.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, Ew);
  } : Ew;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function Fee(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function rT(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || Fee, i = n && n.serialize;
  let a;
  if (i ? a = i(t, n) : a = oe.isURLSearchParams(t) ? t.toString() : new Qg(t, n).toString(r), a) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return e;
}
let Bee = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    oe.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
};
const kw = Bee, iT = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, zee = typeof URLSearchParams < "u" ? URLSearchParams : Qg, Zee = typeof FormData < "u" ? FormData : null, qee = typeof Blob < "u" ? Blob : null, Wee = {
  isBrowser: !0,
  classes: {
    URLSearchParams: zee,
    FormData: Zee,
    Blob: qee
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, aT = typeof window < "u" && typeof document < "u", Vee = ((e) => aT && ["ReactNative", "NativeScript", "NS"].indexOf(e) < 0)(typeof navigator < "u" && navigator.product), Hee = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), Kee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: aT,
  hasStandardBrowserEnv: Vee,
  hasStandardBrowserWebWorkerEnv: Hee
}, Symbol.toStringTag, { value: "Module" })), Ir = {
  ...Kee,
  ...Wee
};
function Gee(e, t) {
  return $f(e, new Ir.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, a) {
      return Ir.isNode && oe.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function Jee(e) {
  return oe.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function Yee(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let a;
  for (r = 0; r < i; r++)
    a = n[r], t[a] = e[a];
  return t;
}
function oT(e) {
  function t(n, r, i, a) {
    let o = n[a++];
    if (o === "__proto__")
      return !0;
    const s = Number.isFinite(+o), l = a >= n.length;
    return o = !o && oe.isArray(i) ? i.length : o, l ? (oe.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !s) : ((!i[o] || !oe.isObject(i[o])) && (i[o] = []), t(n, r, i[o], a) && oe.isArray(i[o]) && (i[o] = Yee(i[o])), !s);
  }
  if (oe.isFormData(e) && oe.isFunction(e.entries)) {
    const n = {};
    return oe.forEachEntry(e, (r, i) => {
      t(Jee(r), i, n, 0);
    }), n;
  }
  return null;
}
function Xee(e, t, n) {
  if (oe.isString(e))
    try {
      return (t || JSON.parse)(e), oe.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const ey = {
  transitional: iT,
  adapter: ["xhr", "http"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, a = oe.isObject(t);
    if (a && oe.isHTMLForm(t) && (t = new FormData(t)), oe.isFormData(t))
      return i ? JSON.stringify(oT(t)) : t;
    if (oe.isArrayBuffer(t) || oe.isBuffer(t) || oe.isStream(t) || oe.isFile(t) || oe.isBlob(t))
      return t;
    if (oe.isArrayBufferView(t))
      return t.buffer;
    if (oe.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let s;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return Gee(t, this.formSerializer).toString();
      if ((s = oe.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return $f(
          s ? { "files[]": t } : t,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return a || i ? (n.setContentType("application/json", !1), Xee(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || ey.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (t && oe.isString(t) && (r && !this.responseType || i)) {
      const o = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (s) {
        if (o)
          throw s.name === "SyntaxError" ? xt.from(s, xt.ERR_BAD_RESPONSE, this, null, this.response) : s;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Ir.classes.FormData,
    Blob: Ir.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
oe.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  ey.headers[e] = {};
});
const ty = ey, Qee = oe.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), ete = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || t[n] && Qee[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, Tw = Symbol("internals");
function hs(e) {
  return e && String(e).trim().toLowerCase();
}
function Lc(e) {
  return e === !1 || e == null ? e : oe.isArray(e) ? e.map(Lc) : String(e);
}
function tte(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
const nte = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function $p(e, t, n, r, i) {
  if (oe.isFunction(r))
    return r.call(this, t, n);
  if (i && (t = n), !!oe.isString(t)) {
    if (oe.isString(r))
      return t.indexOf(r) !== -1;
    if (oe.isRegExp(r))
      return r.test(t);
  }
}
function rte(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function ite(e, t) {
  const n = oe.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, a, o) {
        return this[r].call(this, t, i, a, o);
      },
      configurable: !0
    });
  });
}
let Rf = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function a(s, l, c) {
      const u = hs(l);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const d = oe.findKey(i, u);
      (!d || i[d] === void 0 || c === !0 || c === void 0 && i[d] !== !1) && (i[d || l] = Lc(s));
    }
    const o = (s, l) => oe.forEach(s, (c, u) => a(c, u, l));
    return oe.isPlainObject(t) || t instanceof this.constructor ? o(t, n) : oe.isString(t) && (t = t.trim()) && !nte(t) ? o(ete(t), n) : t != null && a(n, t, r), this;
  }
  get(t, n) {
    if (t = hs(t), t) {
      const r = oe.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return tte(i);
        if (oe.isFunction(n))
          return n.call(this, i, r);
        if (oe.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = hs(t), t) {
      const r = oe.findKey(this, t);
      return !!(r && this[r] !== void 0 && (!n || $p(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function a(o) {
      if (o = hs(o), o) {
        const s = oe.findKey(r, o);
        s && (!n || $p(r, r[s], s, n)) && (delete r[s], i = !0);
      }
    }
    return oe.isArray(t) ? t.forEach(a) : a(t), i;
  }
  clear(t) {
    const n = Object.keys(this);
    let r = n.length, i = !1;
    for (; r--; ) {
      const a = n[r];
      (!t || $p(this, this[a], a, t, !0)) && (delete this[a], i = !0);
    }
    return i;
  }
  normalize(t) {
    const n = this, r = {};
    return oe.forEach(this, (i, a) => {
      const o = oe.findKey(r, a);
      if (o) {
        n[o] = Lc(i), delete n[a];
        return;
      }
      const s = t ? rte(a) : String(a).trim();
      s !== a && delete n[a], n[s] = Lc(i), r[s] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return oe.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && oe.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[Tw] = this[Tw] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function a(o) {
      const s = hs(o);
      r[s] || (ite(i, o), r[s] = !0);
    }
    return oe.isArray(t) ? t.forEach(a) : a(t), this;
  }
};
Rf.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
oe.reduceDescriptors(Rf.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(r) {
      this[n] = r;
    }
  };
});
oe.freezeMethods(Rf);
const ci = Rf;
function Rp(e, t) {
  const n = this || ty, r = t || n, i = ci.from(r.headers);
  let a = r.data;
  return oe.forEach(e, function(s) {
    a = s.call(n, a, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), a;
}
function sT(e) {
  return !!(e && e.__CANCEL__);
}
function ql(e, t, n) {
  xt.call(this, e ?? "canceled", xt.ERR_CANCELED, t, n), this.name = "CanceledError";
}
oe.inherits(ql, xt, {
  __CANCEL__: !0
});
function ate(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new xt(
    "Request failed with status code " + n.status,
    [xt.ERR_BAD_REQUEST, xt.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
const ote = Ir.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, r, i, a) {
      const o = [e + "=" + encodeURIComponent(t)];
      oe.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), oe.isString(r) && o.push("path=" + r), oe.isString(i) && o.push("domain=" + i), a === !0 && o.push("secure"), document.cookie = o.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function ste(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function lte(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function lT(e, t) {
  return e && !ste(t) ? lte(e, t) : t;
}
const cte = Ir.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
    let r;
    function i(a) {
      let o = a;
      return t && (n.setAttribute("href", o), o = n.href), n.setAttribute("href", o), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return r = i(window.location.href), function(o) {
      const s = oe.isString(o) ? i(o) : o;
      return s.protocol === r.protocol && s.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
);
function ute(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function dte(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, a = 0, o;
  return t = t !== void 0 ? t : 1e3, function(l) {
    const c = Date.now(), u = r[a];
    o || (o = c), n[i] = l, r[i] = c;
    let d = a, p = 0;
    for (; d !== i; )
      p += n[d++], d = d % e;
    if (i = (i + 1) % e, i === a && (a = (a + 1) % e), c - o < t)
      return;
    const f = u && c - u;
    return f ? Math.round(p * 1e3 / f) : void 0;
  };
}
function Cw(e, t) {
  let n = 0;
  const r = dte(50, 250);
  return (i) => {
    const a = i.loaded, o = i.lengthComputable ? i.total : void 0, s = a - n, l = r(s), c = a <= o;
    n = a;
    const u = {
      loaded: a,
      total: o,
      progress: o ? a / o : void 0,
      bytes: s,
      rate: l || void 0,
      estimated: l && o && c ? (o - a) / l : void 0,
      event: i
    };
    u[t ? "download" : "upload"] = !0, e(u);
  };
}
const fte = typeof XMLHttpRequest < "u", pte = fte && function(e) {
  return new Promise(function(n, r) {
    let i = e.data;
    const a = ci.from(e.headers).normalize();
    let { responseType: o, withXSRFToken: s } = e, l;
    function c() {
      e.cancelToken && e.cancelToken.unsubscribe(l), e.signal && e.signal.removeEventListener("abort", l);
    }
    let u;
    if (oe.isFormData(i)) {
      if (Ir.hasStandardBrowserEnv || Ir.hasStandardBrowserWebWorkerEnv)
        a.setContentType(!1);
      else if ((u = a.getContentType()) !== !1) {
        const [m, ...y] = u ? u.split(";").map((g) => g.trim()).filter(Boolean) : [];
        a.setContentType([m || "multipart/form-data", ...y].join("; "));
      }
    }
    let d = new XMLHttpRequest();
    if (e.auth) {
      const m = e.auth.username || "", y = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      a.set("Authorization", "Basic " + btoa(m + ":" + y));
    }
    const p = lT(e.baseURL, e.url);
    d.open(e.method.toUpperCase(), rT(p, e.params, e.paramsSerializer), !0), d.timeout = e.timeout;
    function f() {
      if (!d)
        return;
      const m = ci.from(
        "getAllResponseHeaders" in d && d.getAllResponseHeaders()
      ), g = {
        data: !o || o === "text" || o === "json" ? d.responseText : d.response,
        status: d.status,
        statusText: d.statusText,
        headers: m,
        config: e,
        request: d
      };
      ate(function(b) {
        n(b), c();
      }, function(b) {
        r(b), c();
      }, g), d = null;
    }
    if ("onloadend" in d ? d.onloadend = f : d.onreadystatechange = function() {
      !d || d.readyState !== 4 || d.status === 0 && !(d.responseURL && d.responseURL.indexOf("file:") === 0) || setTimeout(f);
    }, d.onabort = function() {
      d && (r(new xt("Request aborted", xt.ECONNABORTED, e, d)), d = null);
    }, d.onerror = function() {
      r(new xt("Network Error", xt.ERR_NETWORK, e, d)), d = null;
    }, d.ontimeout = function() {
      let y = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const g = e.transitional || iT;
      e.timeoutErrorMessage && (y = e.timeoutErrorMessage), r(new xt(
        y,
        g.clarifyTimeoutError ? xt.ETIMEDOUT : xt.ECONNABORTED,
        e,
        d
      )), d = null;
    }, Ir.hasStandardBrowserEnv && (s && oe.isFunction(s) && (s = s(e)), s || s !== !1 && cte(p))) {
      const m = e.xsrfHeaderName && e.xsrfCookieName && ote.read(e.xsrfCookieName);
      m && a.set(e.xsrfHeaderName, m);
    }
    i === void 0 && a.setContentType(null), "setRequestHeader" in d && oe.forEach(a.toJSON(), function(y, g) {
      d.setRequestHeader(g, y);
    }), oe.isUndefined(e.withCredentials) || (d.withCredentials = !!e.withCredentials), o && o !== "json" && (d.responseType = e.responseType), typeof e.onDownloadProgress == "function" && d.addEventListener("progress", Cw(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && d.upload && d.upload.addEventListener("progress", Cw(e.onUploadProgress)), (e.cancelToken || e.signal) && (l = (m) => {
      d && (r(!m || m.type ? new ql(null, e, d) : m), d.abort(), d = null);
    }, e.cancelToken && e.cancelToken.subscribe(l), e.signal && (e.signal.aborted ? l() : e.signal.addEventListener("abort", l)));
    const h = ute(p);
    if (h && Ir.protocols.indexOf(h) === -1) {
      r(new xt("Unsupported protocol " + h + ":", xt.ERR_BAD_REQUEST, e));
      return;
    }
    d.send(i || null);
  });
}, Hh = {
  http: Lee,
  xhr: pte
};
oe.forEach(Hh, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const Ow = (e) => `- ${e}`, hte = (e) => oe.isFunction(e) || e === null || e === !1, cT = {
  getAdapter: (e) => {
    e = oe.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    const i = {};
    for (let a = 0; a < t; a++) {
      n = e[a];
      let o;
      if (r = n, !hte(n) && (r = Hh[(o = String(n)).toLowerCase()], r === void 0))
        throw new xt(`Unknown adapter '${o}'`);
      if (r)
        break;
      i[o || "#" + a] = r;
    }
    if (!r) {
      const a = Object.entries(i).map(
        ([s, l]) => `adapter ${s} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let o = t ? a.length > 1 ? `since :
` + a.map(Ow).join(`
`) : " " + Ow(a[0]) : "as no adapter specified";
      throw new xt(
        "There is no suitable adapter to dispatch the request " + o,
        "ERR_NOT_SUPPORT"
      );
    }
    return r;
  },
  adapters: Hh
};
function Pp(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new ql(null, e);
}
function Aw(e) {
  return Pp(e), e.headers = ci.from(e.headers), e.data = Rp.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), cT.getAdapter(e.adapter || ty.adapter)(e).then(function(r) {
    return Pp(e), r.data = Rp.call(
      e,
      e.transformResponse,
      r
    ), r.headers = ci.from(r.headers), r;
  }, function(r) {
    return sT(r) || (Pp(e), r && r.response && (r.response.data = Rp.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = ci.from(r.response.headers))), Promise.reject(r);
  });
}
const $w = (e) => e instanceof ci ? { ...e } : e;
function Po(e, t) {
  t = t || {};
  const n = {};
  function r(c, u, d) {
    return oe.isPlainObject(c) && oe.isPlainObject(u) ? oe.merge.call({ caseless: d }, c, u) : oe.isPlainObject(u) ? oe.merge({}, u) : oe.isArray(u) ? u.slice() : u;
  }
  function i(c, u, d) {
    if (oe.isUndefined(u)) {
      if (!oe.isUndefined(c))
        return r(void 0, c, d);
    } else
      return r(c, u, d);
  }
  function a(c, u) {
    if (!oe.isUndefined(u))
      return r(void 0, u);
  }
  function o(c, u) {
    if (oe.isUndefined(u)) {
      if (!oe.isUndefined(c))
        return r(void 0, c);
    } else
      return r(void 0, u);
  }
  function s(c, u, d) {
    if (d in t)
      return r(c, u);
    if (d in e)
      return r(void 0, c);
  }
  const l = {
    url: a,
    method: a,
    data: a,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    withXSRFToken: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: s,
    headers: (c, u) => i($w(c), $w(u), !0)
  };
  return oe.forEach(Object.keys(Object.assign({}, e, t)), function(u) {
    const d = l[u] || i, p = d(e[u], t[u], u);
    oe.isUndefined(p) && d !== s || (n[u] = p);
  }), n;
}
const uT = "1.6.8", ny = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  ny[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const Rw = {};
ny.transitional = function(t, n, r) {
  function i(a, o) {
    return "[Axios v" + uT + "] Transitional option '" + a + "'" + o + (r ? ". " + r : "");
  }
  return (a, o, s) => {
    if (t === !1)
      throw new xt(
        i(o, " has been removed" + (n ? " in " + n : "")),
        xt.ERR_DEPRECATED
      );
    return n && !Rw[o] && (Rw[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(a, o, s) : !0;
  };
};
function mte(e, t, n) {
  if (typeof e != "object")
    throw new xt("options must be an object", xt.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const a = r[i], o = t[a];
    if (o) {
      const s = e[a], l = s === void 0 || o(s, a, e);
      if (l !== !0)
        throw new xt("option " + a + " must be " + l, xt.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new xt("Unknown option " + a, xt.ERR_BAD_OPTION);
  }
}
const Kh = {
  assertOptions: mte,
  validators: ny
}, Ei = Kh.validators;
let td = class {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new kw(),
      response: new kw()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (r) {
      if (r instanceof Error) {
        let i;
        Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error();
        const a = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        r.stack ? a && !String(r.stack).endsWith(a.replace(/^.+\n.+\n/, "")) && (r.stack += `
` + a) : r.stack = a;
      }
      throw r;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Po(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: a } = n;
    r !== void 0 && Kh.assertOptions(r, {
      silentJSONParsing: Ei.transitional(Ei.boolean),
      forcedJSONParsing: Ei.transitional(Ei.boolean),
      clarifyTimeoutError: Ei.transitional(Ei.boolean)
    }, !1), i != null && (oe.isFunction(i) ? n.paramsSerializer = {
      serialize: i
    } : Kh.assertOptions(i, {
      encode: Ei.function,
      serialize: Ei.function
    }, !0)), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let o = a && oe.merge(
      a.common,
      a[n.method]
    );
    a && oe.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (h) => {
        delete a[h];
      }
    ), n.headers = ci.concat(o, a);
    const s = [];
    let l = !0;
    this.interceptors.request.forEach(function(m) {
      typeof m.runWhen == "function" && m.runWhen(n) === !1 || (l = l && m.synchronous, s.unshift(m.fulfilled, m.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(m) {
      c.push(m.fulfilled, m.rejected);
    });
    let u, d = 0, p;
    if (!l) {
      const h = [Aw.bind(this), void 0];
      for (h.unshift.apply(h, s), h.push.apply(h, c), p = h.length, u = Promise.resolve(n); d < p; )
        u = u.then(h[d++], h[d++]);
      return u;
    }
    p = s.length;
    let f = n;
    for (d = 0; d < p; ) {
      const h = s[d++], m = s[d++];
      try {
        f = h(f);
      } catch (y) {
        m.call(this, y);
        break;
      }
    }
    try {
      u = Aw.call(this, f);
    } catch (h) {
      return Promise.reject(h);
    }
    for (d = 0, p = c.length; d < p; )
      u = u.then(c[d++], c[d++]);
    return u;
  }
  getUri(t) {
    t = Po(this.defaults, t);
    const n = lT(t.baseURL, t.url);
    return rT(n, t.params, t.paramsSerializer);
  }
};
oe.forEach(["delete", "get", "head", "options"], function(t) {
  td.prototype[t] = function(n, r) {
    return this.request(Po(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
oe.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(a, o, s) {
      return this.request(Po(s || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: o
      }));
    };
  }
  td.prototype[t] = n(), td.prototype[t + "Form"] = n(!0);
});
const jc = td;
let gte = class dT {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners)
        return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let a;
      const o = new Promise((s) => {
        r.subscribe(s), a = s;
      }).then(i);
      return o.cancel = function() {
        r.unsubscribe(a);
      }, o;
    }, t(function(a, o, s) {
      r.reason || (r.reason = new ql(a, o, s), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new dT(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
};
const yte = gte;
function vte(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function bte(e) {
  return oe.isObject(e) && e.isAxiosError === !0;
}
const Gh = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Gh).forEach(([e, t]) => {
  Gh[t] = e;
});
const wte = Gh;
function fT(e) {
  const t = new jc(e), n = Wk(jc.prototype.request, t);
  return oe.extend(n, jc.prototype, t, { allOwnKeys: !0 }), oe.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return fT(Po(e, i));
  }, n;
}
const rn = fT(ty);
rn.Axios = jc;
rn.CanceledError = ql;
rn.CancelToken = yte;
rn.isCancel = sT;
rn.VERSION = uT;
rn.toFormData = $f;
rn.AxiosError = xt;
rn.Cancel = rn.CanceledError;
rn.all = function(t) {
  return Promise.all(t);
};
rn.spread = vte;
rn.isAxiosError = bte;
rn.mergeConfig = Po;
rn.AxiosHeaders = ci;
rn.formToJSON = (e) => oT(oe.isHTMLForm(e) ? new FormData(e) : e);
rn.getAdapter = cT.getAdapter;
rn.HttpStatusCode = wte;
rn.default = rn;
const G = rn, {
  Axios: xte,
  AxiosError: _te,
  CanceledError: Ste,
  isCancel: Ete,
  CancelToken: kte,
  VERSION: Tte,
  all: Cte,
  Cancel: Ote,
  isAxiosError: Ate,
  spread: $te,
  toFormData: Rte,
  AxiosHeaders: Pte,
  HttpStatusCode: Ite,
  formToJSON: Mte,
  getAdapter: Nte,
  mergeConfig: Dte
} = G, Lte = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Axios: xte,
  AxiosError: _te,
  AxiosHeaders: Pte,
  Cancel: Ote,
  CancelToken: kte,
  CanceledError: Ste,
  HttpStatusCode: Ite,
  VERSION: Tte,
  all: Cte,
  default: G,
  formToJSON: Mte,
  getAdapter: Nte,
  isAxiosError: Ate,
  isCancel: Ete,
  mergeConfig: Dte,
  spread: $te,
  toFormData: Rte
}, Symbol.toStringTag, { value: "Module" }));
var as = {};
Object.defineProperty(as, "__esModule", {
  value: !0
});
var jte = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
  return typeof e;
} : function(e) {
  return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
}, Ute = typeof window < "u" && typeof window.document < "u", Fte = typeof process < "u" && process.versions != null && process.versions.node != null, Bte = (typeof self > "u" ? "undefined" : jte(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope", zte = typeof window < "u" && window.name === "nodejs" || typeof navigator < "u" && (navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom")), Zte = typeof Deno < "u" && typeof Deno.version < "u" && typeof Deno.version.deno < "u", pT = as.isBrowser = Ute;
as.isWebWorker = Bte;
var Jh = as.isNode = Fte;
as.isJsDom = zte;
as.isDeno = Zte;
var qte = Object.create, hT = Object.defineProperty, Wte = Object.getOwnPropertyDescriptor, Vte = Object.getOwnPropertyNames, Hte = Object.getPrototypeOf, Kte = Object.prototype.hasOwnProperty, mT = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), Gte = (e, t, n, r) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let i of Vte(t))
      !Kte.call(e, i) && i !== n && hT(e, i, { get: () => t[i], enumerable: !(r = Wte(t, i)) || r.enumerable });
  return e;
}, gT = (e, t, n) => (n = e != null ? qte(Hte(e)) : {}, Gte(t || !e || !e.__esModule ? hT(n, "default", { value: e, enumerable: !0 }) : n, e)), Jte = mT(() => {
}), Yte = mT(() => {
}), Xte = gT(Jte()), Qte = gT(Yte()), ene = "https://api.botpress.cloud", tne = 6e4, nne = "BP_API_URL", rne = "BP_BOT_ID", ine = "BP_INTEGRATION_ID", ane = "BP_WORKSPACE_ID", one = "BP_TOKEN";
function sne(e) {
  let t = lne(e), n = {};
  t.workspaceId && (n["x-workspace-id"] = t.workspaceId), t.botId && (n["x-bot-id"] = t.botId), t.integrationId && (n["x-integration-id"] = t.integrationId), t.token && (n.Authorization = `Bearer ${t.token}`), n = { ...n, ...t.headers };
  let r = t.apiUrl ?? ene, i = t.timeout ?? tne;
  return { apiUrl: r, timeout: i, withCredentials: pT, headers: n };
}
function lne(e) {
  return pT ? e : Jh ? cne(e) : e;
}
function cne(e) {
  let t = { ...e, apiUrl: e.apiUrl ?? process.env[nne], botId: e.botId ?? process.env[rne], integrationId: e.integrationId ?? process.env[ine], workspaceId: e.workspaceId ?? process.env[ane] }, n = t.token ?? process.env[one];
  return n && (t.token = n), t;
}
var Y = "https://api.botpress.cloud".replace(/\/+$/, ""), une = class {
  constructor(e, t = Y, n = G) {
    _(this, "configuration");
    this.basePath = t, this.axios = n, e && (this.configuration = e, this.basePath = e.basePath || this.basePath);
  }
}, dne = class extends Error {
  constructor(e, t) {
    super(t), this.field = e, this.name = "RequiredError";
  }
}, X = "https://example.com", se = function(e, t, n) {
  if (n == null)
    throw new dne(t, `Required parameter ${t} was null or undefined when calling ${e}.`);
};
function Yh(e, t, n = "") {
  t != null && (typeof t == "object" ? Array.isArray(t) ? t.forEach((r) => Yh(e, r, n)) : Object.keys(t).forEach((r) => Yh(e, t[r], `${n}${n !== "" ? "." : ""}${r}`)) : e.has(n) ? e.append(n, t) : e.set(n, t));
}
var Q = function(e, ...t) {
  let n = new URLSearchParams(e.search);
  Yh(n, t), e.search = n.toString();
}, Qe = function(e, t, n) {
  let r = typeof e != "string";
  return (r && n && n.isJsonMime ? n.isJsonMime(t.headers["Content-Type"]) : r) ? JSON.stringify(e !== void 0 ? e : {}) : e || "";
}, ee = function(e) {
  return e.pathname + e.search + e.hash;
}, te = function(e, t, n, r) {
  return (i = t, a = n) => {
    let o = { ...e.options, url: ((r == null ? void 0 : r.basePath) || a) + e.url };
    return i.request(o);
  };
}, fne = function(e) {
  return { addParticipant: async (t, n, r = {}) => {
    se("addParticipant", "id", t);
    let i = "/v1/chat/conversations/{id}/participants".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "POST", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, breakDownWorkspaceUsageByBot: async (t, n, r, i = {}) => {
    se("breakDownWorkspaceUsageByBot", "id", t), se("breakDownWorkspaceUsageByBot", "type", n);
    let a = "/v1/admin/workspaces/{id}/usages/by-bot".replace("{id}", encodeURIComponent(String(t))), o = new URL(a, X), s;
    e && (s = e.baseOptions);
    let l = { method: "GET", ...s, ...i }, c = {}, u = {};
    n !== void 0 && (u.type = n), r !== void 0 && (u.period = r), Q(o, u);
    let d = s && s.headers ? s.headers : {};
    return l.headers = { ...c, ...d, ...i.headers }, { url: ee(o), options: l };
  }, callAction: async (t, n = {}) => {
    let r = "/v1/chat/actions", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, changeAISpendQuota: async (t, n = {}) => {
    let r = "/v1/admin/quotas/ai-spend", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "PUT", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, chargeWorkspaceUnpaidInvoices: async (t, n, r = {}) => {
    se("chargeWorkspaceUnpaidInvoices", "id", t);
    let i = "/v1/admin/workspaces/{id}/billing/invoices/charge-unpaid".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "POST", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, checkHandleAvailability: async (t, n = {}) => {
    let r = "/v1/admin/workspaces/handle-availability", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "PUT", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, configureIntegration: async (t, n = {}) => {
    let r = "/v1/chat/integrations/configure", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createBot: async (t, n = {}) => {
    let r = "/v1/admin/bots", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createConversation: async (t, n = {}) => {
    let r = "/v1/chat/conversations", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createEvent: async (t, n = {}) => {
    let r = "/v1/chat/events", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createFile: async (t, n = {}) => {
    let r = "/v1/files", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createIntegration: async (t, n = {}) => {
    let r = "/v1/admin/integrations", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createIntegrationApiKey: async (t, n = {}) => {
    let r = "/v1/admin/integrations/iaks", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createMessage: async (t, n = {}) => {
    let r = "/v1/chat/messages", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createPersonalAccessToken: async (t, n = {}) => {
    let r = "/v1/admin/account/pats", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createTable: async (t, n = {}) => {
    let r = "/v1/tables", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createTableRows: async (t, n, r = {}) => {
    se("createTableRows", "table", t);
    let i = "/v1/tables/{table}/rows".replace("{table}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "POST", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, createTask: async (t, n = {}) => {
    let r = "/v1/chat/tasks", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createUser: async (t, n = {}) => {
    let r = "/v1/chat/users", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createWorkspace: async (t, n = {}) => {
    let r = "/v1/admin/workspaces", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, createWorkspaceMember: async (t, n = {}) => {
    let r = "/v1/admin/workspace-members", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, deleteBot: async (t, n = {}) => {
    se("deleteBot", "id", t);
    let r = "/v1/admin/bots/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "DELETE", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, deleteBotIssue: async (t, n, r = {}) => {
    se("deleteBotIssue", "id", t), se("deleteBotIssue", "issueId", n);
    let i = "/v1/admin/bots/{id}/issues/{issueId}".replace("{id}", encodeURIComponent(String(t))).replace("{issueId}", encodeURIComponent(String(n))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "DELETE", ...o, ...r }, l = {};
    Q(a, {});
    let c = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...c, ...r.headers }, { url: ee(a), options: s };
  }, deleteConversation: async (t, n = {}) => {
    se("deleteConversation", "id", t);
    let r = "/v1/chat/conversations/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "DELETE", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, deleteFile: async (t, n = {}) => {
    se("deleteFile", "id", t);
    let r = "/v1/files/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "DELETE", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, deleteIntegration: async (t, n = {}) => {
    se("deleteIntegration", "id", t);
    let r = "/v1/admin/integrations/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "DELETE", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, deleteIntegrationApiKey: async (t, n = {}) => {
    se("deleteIntegrationApiKey", "id", t);
    let r = "/v1/admin/integrations/iaks/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "DELETE", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, deleteMessage: async (t, n = {}) => {
    se("deleteMessage", "id", t);
    let r = "/v1/chat/messages/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "DELETE", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, deletePersonalAccessToken: async (t, n = {}) => {
    se("deletePersonalAccessToken", "id", t);
    let r = "/v1/admin/account/pats/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "DELETE", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, deleteTable: async (t, n = {}) => {
    se("deleteTable", "table", t);
    let r = "/v1/tables/{table}".replace("{table}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "DELETE", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, deleteTableRows: async (t, n, r = {}) => {
    se("deleteTableRows", "table", t);
    let i = "/v1/tables/{table}/rows/delete".replace("{table}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "POST", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, deleteTask: async (t, n = {}) => {
    se("deleteTask", "id", t);
    let r = "/v1/chat/tasks/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "DELETE", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, deleteUser: async (t, n = {}) => {
    se("deleteUser", "id", t);
    let r = "/v1/chat/users/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "DELETE", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, deleteWorkspace: async (t, n = {}) => {
    se("deleteWorkspace", "id", t);
    let r = "/v1/admin/workspaces/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "DELETE", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, deleteWorkspaceMember: async (t, n = {}) => {
    se("deleteWorkspaceMember", "id", t);
    let r = "/v1/admin/workspace-members/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "DELETE", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, duplicateTable: async (t, n, r = {}) => {
    se("duplicateTable", "sourceTableId", t);
    let i = "/v1/tables/{sourceTableId}/duplicate".replace("{sourceTableId}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "POST", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, findTableRows: async (t, n, r = {}) => {
    se("findTableRows", "table", t);
    let i = "/v1/tables/{table}/rows/find".replace("{table}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "POST", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, getAccount: async (t = {}) => {
    let n = "/v1/admin/account/me", r = new URL(n, X), i;
    e && (i = e.baseOptions);
    let a = { method: "GET", ...i, ...t }, o = {};
    Q(r, {});
    let s = i && i.headers ? i.headers : {};
    return a.headers = { ...o, ...s, ...t.headers }, { url: ee(r), options: a };
  }, getAccountPreference: async (t, n = {}) => {
    se("getAccountPreference", "key", t);
    let r = "/v1/admin/account/preferences/{key}".replace("{key}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getAllWorkspaceQuotaCompletion: async (t = {}) => {
    let n = "/v1/admin/workspaces/usages/quota-completion", r = new URL(n, X), i;
    e && (i = e.baseOptions);
    let a = { method: "GET", ...i, ...t }, o = {};
    Q(r, {});
    let s = i && i.headers ? i.headers : {};
    return a.headers = { ...o, ...s, ...t.headers }, { url: ee(r), options: a };
  }, getAuditRecords: async (t, n, r = {}) => {
    se("getAuditRecords", "id", t);
    let i = "/v1/admin/workspaces/{id}/audit-records".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "GET", ...o, ...r }, l = {}, c = {};
    n !== void 0 && (c.nextToken = n), Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, { url: ee(a), options: s };
  }, getBot: async (t, n = {}) => {
    se("getBot", "id", t);
    let r = "/v1/admin/bots/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getBotAnalytics: async (t, n, r, i = {}) => {
    se("getBotAnalytics", "id", t), se("getBotAnalytics", "startDate", n), se("getBotAnalytics", "endDate", r);
    let a = "/v1/admin/bots/{id}/analytics".replace("{id}", encodeURIComponent(String(t))), o = new URL(a, X), s;
    e && (s = e.baseOptions);
    let l = { method: "GET", ...s, ...i }, c = {}, u = {};
    n !== void 0 && (u.startDate = n), r !== void 0 && (u.endDate = r), Q(o, u);
    let d = s && s.headers ? s.headers : {};
    return l.headers = { ...c, ...d, ...i.headers }, { url: ee(o), options: l };
  }, getBotLogs: async (t, n, r, i, a = {}) => {
    se("getBotLogs", "id", t), se("getBotLogs", "timeStart", n), se("getBotLogs", "timeEnd", r);
    let o = "/v1/admin/bots/{id}/logs".replace("{id}", encodeURIComponent(String(t))), s = new URL(o, X), l;
    e && (l = e.baseOptions);
    let c = { method: "GET", ...l, ...a }, u = {}, d = {};
    n !== void 0 && (d.timeStart = n), r !== void 0 && (d.timeEnd = r), i !== void 0 && (d.nextToken = i), Q(s, d);
    let p = l && l.headers ? l.headers : {};
    return c.headers = { ...u, ...p, ...a.headers }, { url: ee(s), options: c };
  }, getBotWebchat: async (t, n, r = {}) => {
    se("getBotWebchat", "id", t), se("getBotWebchat", "type", n);
    let i = "/v1/admin/bots/{id}/webchat".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "GET", ...o, ...r }, l = {}, c = {};
    n !== void 0 && (c.type = n), Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, { url: ee(a), options: s };
  }, getConversation: async (t, n = {}) => {
    se("getConversation", "id", t);
    let r = "/v1/chat/conversations/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getEvent: async (t, n = {}) => {
    se("getEvent", "id", t);
    let r = "/v1/chat/events/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getFileContent: async (t, n = {}) => {
    se("getFileContent", "id", t);
    let r = "/v1/files/{id}/content".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getFileMetadata: async (t, n = {}) => {
    se("getFileMetadata", "id", t);
    let r = "/v1/files/{id}/metadata".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getIntegration: async (t, n = {}) => {
    se("getIntegration", "id", t);
    let r = "/v1/admin/integrations/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getIntegrationByName: async (t, n, r = {}) => {
    se("getIntegrationByName", "name", t), se("getIntegrationByName", "version", n);
    let i = "/v1/admin/integrations/{name}/{version}".replace("{name}", encodeURIComponent(String(t))).replace("{version}", encodeURIComponent(String(n))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "GET", ...o, ...r }, l = {};
    Q(a, {});
    let c = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...c, ...r.headers }, { url: ee(a), options: s };
  }, getIntegrationLogs: async (t, n, r, i, a = {}) => {
    se("getIntegrationLogs", "id", t), se("getIntegrationLogs", "timeStart", n), se("getIntegrationLogs", "timeEnd", r);
    let o = "/v1/admin/integrations/{id}/logs".replace("{id}", encodeURIComponent(String(t))), s = new URL(o, X), l;
    e && (l = e.baseOptions);
    let c = { method: "GET", ...l, ...a }, u = {}, d = {};
    n !== void 0 && (d.timeStart = n), r !== void 0 && (d.timeEnd = r), i !== void 0 && (d.nextToken = i), Q(s, d);
    let p = l && l.headers ? l.headers : {};
    return c.headers = { ...u, ...p, ...a.headers }, { url: ee(s), options: c };
  }, getMessage: async (t, n = {}) => {
    se("getMessage", "id", t);
    let r = "/v1/chat/messages/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getOrCreateConversation: async (t, n = {}) => {
    let r = "/v1/chat/conversations/get-or-create", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, getOrCreateMessage: async (t, n = {}) => {
    let r = "/v1/chat/messages/get-or-create", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, getOrCreateTable: async (t, n, r = {}) => {
    se("getOrCreateTable", "table", t);
    let i = "/v1/tables/{table}".replace("{table}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "POST", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, getOrCreateUser: async (t, n = {}) => {
    let r = "/v1/chat/users/get-or-create", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, getOrSetState: async (t, n, r, i, a = {}) => {
    se("getOrSetState", "type", t), se("getOrSetState", "id", n), se("getOrSetState", "name", r);
    let o = "/v1/chat/states/{type}/{id}/{name}/get-or-set".replace("{type}", encodeURIComponent(String(t))).replace("{id}", encodeURIComponent(String(n))).replace("{name}", encodeURIComponent(String(r))), s = new URL(o, X), l;
    e && (l = e.baseOptions);
    let c = { method: "POST", ...l, ...a }, u = {}, d = {};
    u["Content-Type"] = "application/json", Q(s, d);
    let p = l && l.headers ? l.headers : {};
    return c.headers = { ...u, ...p, ...a.headers }, c.data = Qe(i, c, e), { url: ee(s), options: c };
  }, getParticipant: async (t, n, r = {}) => {
    se("getParticipant", "id", t), se("getParticipant", "userId", n);
    let i = "/v1/chat/conversations/{id}/participants/{userId}".replace("{id}", encodeURIComponent(String(t))).replace("{userId}", encodeURIComponent(String(n))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "GET", ...o, ...r }, l = {};
    Q(a, {});
    let c = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...c, ...r.headers }, { url: ee(a), options: s };
  }, getPublicIntegration: async (t, n, r = {}) => {
    se("getPublicIntegration", "name", t), se("getPublicIntegration", "version", n);
    let i = "/v1/admin/hub/integrations/{name}/{version}".replace("{name}", encodeURIComponent(String(t))).replace("{version}", encodeURIComponent(String(n))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "GET", ...o, ...r }, l = {};
    Q(a, {});
    let c = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...c, ...r.headers }, { url: ee(a), options: s };
  }, getPublicIntegrationById: async (t, n = {}) => {
    se("getPublicIntegrationById", "id", t);
    let r = "/v1/admin/hub/integrations/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getPublicWorkspace: async (t, n = {}) => {
    se("getPublicWorkspace", "id", t);
    let r = "/v1/admin/workspaces/{id}/public".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getState: async (t, n, r, i = {}) => {
    se("getState", "type", t), se("getState", "id", n), se("getState", "name", r);
    let a = "/v1/chat/states/{type}/{id}/{name}".replace("{type}", encodeURIComponent(String(t))).replace("{id}", encodeURIComponent(String(n))).replace("{name}", encodeURIComponent(String(r))), o = new URL(a, X), s;
    e && (s = e.baseOptions);
    let l = { method: "GET", ...s, ...i }, c = {};
    Q(o, {});
    let u = s && s.headers ? s.headers : {};
    return l.headers = { ...c, ...u, ...i.headers }, { url: ee(o), options: l };
  }, getTable: async (t, n = {}) => {
    se("getTable", "table", t);
    let r = "/v1/tables/{table}".replace("{table}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getTableRow: async (t, n, r = {}) => {
    se("getTableRow", "table", t), se("getTableRow", "id", n);
    let i = "/v1/tables/{table}/row".replace("{table}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "GET", ...o, ...r }, l = {}, c = {};
    n !== void 0 && (c.id = n), Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, { url: ee(a), options: s };
  }, getTask: async (t, n = {}) => {
    se("getTask", "id", t);
    let r = "/v1/chat/tasks/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getUpcomingInvoice: async (t, n = {}) => {
    se("getUpcomingInvoice", "id", t);
    let r = "/v1/admin/workspaces/{id}/billing/upcoming-invoice".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getUsage: async (t, n, r, i = {}) => {
    se("getUsage", "type", t), se("getUsage", "id", n);
    let a = "/v1/admin/usages/{id}".replace("{id}", encodeURIComponent(String(n))), o = new URL(a, X), s;
    e && (s = e.baseOptions);
    let l = { method: "GET", ...s, ...i }, c = {}, u = {};
    t !== void 0 && (u.type = t), r !== void 0 && (u.period = r), Q(o, u);
    let d = s && s.headers ? s.headers : {};
    return l.headers = { ...c, ...d, ...i.headers }, { url: ee(o), options: l };
  }, getUser: async (t, n = {}) => {
    se("getUser", "id", t);
    let r = "/v1/chat/users/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getWorkspace: async (t, n = {}) => {
    se("getWorkspace", "id", t);
    let r = "/v1/admin/workspaces/{id}".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, getWorkspaceQuota: async (t, n, r, i = {}) => {
    se("getWorkspaceQuota", "id", t), se("getWorkspaceQuota", "type", n);
    let a = "/v1/admin/workspaces/{id}/quota".replace("{id}", encodeURIComponent(String(t))), o = new URL(a, X), s;
    e && (s = e.baseOptions);
    let l = { method: "GET", ...s, ...i }, c = {}, u = {};
    n !== void 0 && (u.type = n), r !== void 0 && (u.period = r), Q(o, u);
    let d = s && s.headers ? s.headers : {};
    return l.headers = { ...c, ...d, ...i.headers }, { url: ee(o), options: l };
  }, introspect: async (t, n = {}) => {
    let r = "/v1/admin/introspect", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, listActivities: async (t, n, r, i = {}) => {
    se("listActivities", "taskId", t), se("listActivities", "botId", n);
    let a = "/v1/admin/activities", o = new URL(a, X), s;
    e && (s = e.baseOptions);
    let l = { method: "GET", ...s, ...i }, c = {}, u = {};
    r !== void 0 && (u.nextToken = r), t !== void 0 && (u.taskId = t), n !== void 0 && (u.botId = n), Q(o, u);
    let d = s && s.headers ? s.headers : {};
    return l.headers = { ...c, ...d, ...i.headers }, { url: ee(o), options: l };
  }, listBotIssueEvents: async (t, n, r = {}) => {
    se("listBotIssueEvents", "id", t), se("listBotIssueEvents", "issueId", n);
    let i = "/v1/admin/bots/{id}/issues/{issueId}/events".replace("{id}", encodeURIComponent(String(t))).replace("{issueId}", encodeURIComponent(String(n))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "GET", ...o, ...r }, l = {};
    Q(a, {});
    let c = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...c, ...r.headers }, { url: ee(a), options: s };
  }, listBotIssues: async (t, n, r = {}) => {
    se("listBotIssues", "id", t);
    let i = "/v1/admin/bots/{id}/issues".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "GET", ...o, ...r }, l = {}, c = {};
    n !== void 0 && (c.nextToken = n), Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, { url: ee(a), options: s };
  }, listBots: async (t, n, r = {}) => {
    let i = "/v1/admin/bots", a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "GET", ...o, ...r }, l = {}, c = {};
    t !== void 0 && (c.dev = t), n !== void 0 && (c.nextToken = n), Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, { url: ee(a), options: s };
  }, listConversations: async (t, n, r, i = {}) => {
    let a = "/v1/chat/conversations", o = new URL(a, X), s;
    e && (s = e.baseOptions);
    let l = { method: "GET", ...s, ...i }, c = {}, u = {};
    t !== void 0 && (u.nextToken = t), n !== void 0 && (u.tags = n), r && (u.participantIds = r), Q(o, u);
    let d = s && s.headers ? s.headers : {};
    return l.headers = { ...c, ...d, ...i.headers }, { url: ee(o), options: l };
  }, listEvents: async (t, n, r, i, a, o, s = {}) => {
    let l = "/v1/chat/events", c = new URL(l, X), u;
    e && (u = e.baseOptions);
    let d = { method: "GET", ...u, ...s }, p = {}, f = {};
    t !== void 0 && (f.nextToken = t), n !== void 0 && (f.type = n), r !== void 0 && (f.conversationId = r), i !== void 0 && (f.userId = i), a !== void 0 && (f.messageId = a), o !== void 0 && (f.status = o), Q(c, f);
    let h = u && u.headers ? u.headers : {};
    return d.headers = { ...p, ...h, ...s.headers }, { url: ee(c), options: d };
  }, listFiles: async (t, n, r, i = {}) => {
    se("listFiles", "botId", t);
    let a = "/v1/files/bot/{botId}".replace("{botId}", encodeURIComponent(String(t))), o = new URL(a, X), s;
    e && (s = e.baseOptions);
    let l = { method: "GET", ...s, ...i }, c = {}, u = {};
    n !== void 0 && (u.nextToken = n), r !== void 0 && (u.tags = r), Q(o, u);
    let d = s && s.headers ? s.headers : {};
    return l.headers = { ...c, ...d, ...i.headers }, { url: ee(o), options: l };
  }, listIntegrationApiKeys: async (t, n = {}) => {
    se("listIntegrationApiKeys", "integrationId", t);
    let r = "/v1/admin/integrations/iaks", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {}, l = {};
    t !== void 0 && (l.integrationId = t), Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, { url: ee(i), options: o };
  }, listIntegrations: async (t, n, r, i, a = {}) => {
    let o = "/v1/admin/integrations", s = new URL(o, X), l;
    e && (l = e.baseOptions);
    let c = { method: "GET", ...l, ...a }, u = {}, d = {};
    t !== void 0 && (d.nextToken = t), n !== void 0 && (d.name = n), r !== void 0 && (d.version = r), i !== void 0 && (d.dev = i), Q(s, d);
    let p = l && l.headers ? l.headers : {};
    return c.headers = { ...u, ...p, ...a.headers }, { url: ee(s), options: c };
  }, listMessages: async (t, n, r, i = {}) => {
    let a = "/v1/chat/messages", o = new URL(a, X), s;
    e && (s = e.baseOptions);
    let l = { method: "GET", ...s, ...i }, c = {}, u = {};
    t !== void 0 && (u.nextToken = t), n !== void 0 && (u.conversationId = n), r !== void 0 && (u.tags = r), Q(o, u);
    let d = s && s.headers ? s.headers : {};
    return l.headers = { ...c, ...d, ...i.headers }, { url: ee(o), options: l };
  }, listParticipants: async (t, n, r = {}) => {
    se("listParticipants", "id", t);
    let i = "/v1/chat/conversations/{id}/participants".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "GET", ...o, ...r }, l = {}, c = {};
    n !== void 0 && (c.nextToken = n), Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, { url: ee(a), options: s };
  }, listPersonalAccessTokens: async (t = {}) => {
    let n = "/v1/admin/account/pats", r = new URL(n, X), i;
    e && (i = e.baseOptions);
    let a = { method: "GET", ...i, ...t }, o = {};
    Q(r, {});
    let s = i && i.headers ? i.headers : {};
    return a.headers = { ...o, ...s, ...t.headers }, { url: ee(r), options: a };
  }, listPublicIntegrations: async (t, n, r, i = {}) => {
    let a = "/v1/admin/hub/integrations", o = new URL(a, X), s;
    e && (s = e.baseOptions);
    let l = { method: "GET", ...s, ...i }, c = {}, u = {};
    t !== void 0 && (u.nextToken = t), n !== void 0 && (u.name = n), r !== void 0 && (u.version = r), Q(o, u);
    let d = s && s.headers ? s.headers : {};
    return l.headers = { ...c, ...d, ...i.headers }, { url: ee(o), options: l };
  }, listTables: async (t, n = {}) => {
    let r = "/v1/tables", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {}, l = {};
    t !== void 0 && (l.tags = t), Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, { url: ee(i), options: o };
  }, listTasks: async (t, n, r, i, a, o, s, l = {}) => {
    let c = "/v1/chat/tasks", u = new URL(c, X), d;
    e && (d = e.baseOptions);
    let p = { method: "GET", ...d, ...l }, f = {}, h = {};
    t !== void 0 && (h.nextToken = t), n !== void 0 && (h.tags = n), r !== void 0 && (h.conversationId = r), i !== void 0 && (h.userId = i), a !== void 0 && (h.parentTaskId = a), o && (h.status = o), s !== void 0 && (h.type = s), Q(u, h);
    let m = d && d.headers ? d.headers : {};
    return p.headers = { ...f, ...m, ...l.headers }, { url: ee(u), options: p };
  }, listUsageHistory: async (t, n, r = {}) => {
    se("listUsageHistory", "type", t), se("listUsageHistory", "id", n);
    let i = "/v1/admin/usages/{id}/history".replace("{id}", encodeURIComponent(String(n))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "GET", ...o, ...r }, l = {}, c = {};
    t !== void 0 && (c.type = t), Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, { url: ee(a), options: s };
  }, listUsers: async (t, n, r, i = {}) => {
    let a = "/v1/chat/users", o = new URL(a, X), s;
    e && (s = e.baseOptions);
    let l = { method: "GET", ...s, ...i }, c = {}, u = {};
    t !== void 0 && (u.nextToken = t), n !== void 0 && (u.conversationId = n), r !== void 0 && (u.tags = r), Q(o, u);
    let d = s && s.headers ? s.headers : {};
    return l.headers = { ...c, ...d, ...i.headers }, { url: ee(o), options: l };
  }, listWorkspaceInvoices: async (t, n = {}) => {
    se("listWorkspaceInvoices", "id", t);
    let r = "/v1/admin/workspaces/{id}/billing/invoices".replace("{id}", encodeURIComponent(String(t))), i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {};
    Q(i, {});
    let l = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...l, ...n.headers }, { url: ee(i), options: o };
  }, listWorkspaceMembers: async (t, n = {}) => {
    let r = "/v1/admin/workspace-members", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {}, l = {};
    t !== void 0 && (l.nextToken = t), Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, { url: ee(i), options: o };
  }, listWorkspaceQuotas: async (t, n, r = {}) => {
    se("listWorkspaceQuotas", "id", t);
    let i = "/v1/admin/workspaces/{id}/quotas".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "GET", ...o, ...r }, l = {}, c = {};
    n !== void 0 && (c.period = n), Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, { url: ee(a), options: s };
  }, listWorkspaceUsages: async (t, n, r, i = {}) => {
    se("listWorkspaceUsages", "id", t), se("listWorkspaceUsages", "type", n);
    let a = "/v1/admin/workspaces/{id}/usages".replace("{id}", encodeURIComponent(String(t))), o = new URL(a, X), s;
    e && (s = e.baseOptions);
    let l = { method: "GET", ...s, ...i }, c = {}, u = {};
    n !== void 0 && (u.type = n), r !== void 0 && (u.period = r), Q(o, u);
    let d = s && s.headers ? s.headers : {};
    return l.headers = { ...c, ...d, ...i.headers }, { url: ee(o), options: l };
  }, listWorkspaces: async (t, n = {}) => {
    let r = "/v1/admin/workspaces", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "GET", ...a, ...n }, s = {}, l = {};
    t !== void 0 && (l.nextToken = t), Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, { url: ee(i), options: o };
  }, patchState: async (t, n, r, i, a = {}) => {
    se("patchState", "type", t), se("patchState", "id", n), se("patchState", "name", r);
    let o = "/v1/chat/states/{type}/{id}/{name}".replace("{type}", encodeURIComponent(String(t))).replace("{id}", encodeURIComponent(String(n))).replace("{name}", encodeURIComponent(String(r))), s = new URL(o, X), l;
    e && (l = e.baseOptions);
    let c = { method: "PATCH", ...l, ...a }, u = {}, d = {};
    u["Content-Type"] = "application/json", Q(s, d);
    let p = l && l.headers ? l.headers : {};
    return c.headers = { ...u, ...p, ...a.headers }, c.data = Qe(i, c, e), { url: ee(s), options: c };
  }, removeParticipant: async (t, n, r = {}) => {
    se("removeParticipant", "id", t), se("removeParticipant", "userId", n);
    let i = "/v1/chat/conversations/{id}/participants/{userId}".replace("{id}", encodeURIComponent(String(t))).replace("{userId}", encodeURIComponent(String(n))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "DELETE", ...o, ...r }, l = {};
    Q(a, {});
    let c = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...c, ...r.headers }, { url: ee(a), options: s };
  }, renameTableColumn: async (t, n, r = {}) => {
    se("renameTableColumn", "table", t);
    let i = "/v1/tables/{table}/column".replace("{table}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, runVrl: async (t, n = {}) => {
    let r = "/v1/admin/helper/vrl", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, searchFiles: async (t, n, r, i, a, o = {}) => {
    se("searchFiles", "botId", t), se("searchFiles", "query", n);
    let s = "/v1/files/bot/{botId}/search".replace("{botId}", encodeURIComponent(String(t))), l = new URL(s, X), c;
    e && (c = e.baseOptions);
    let u = { method: "GET", ...c, ...o }, d = {}, p = {};
    r !== void 0 && (p.tags = r), n !== void 0 && (p.query = n), i !== void 0 && (p.contextDepth = i), a !== void 0 && (p.limit = a), Q(l, p);
    let f = c && c.headers ? c.headers : {};
    return u.headers = { ...d, ...f, ...o.headers }, { url: ee(l), options: u };
  }, setAccountPreference: async (t, n, r = {}) => {
    se("setAccountPreference", "key", t);
    let i = "/v1/admin/account/preferences/{key}".replace("{key}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "POST", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, setState: async (t, n, r, i, a = {}) => {
    se("setState", "type", t), se("setState", "id", n), se("setState", "name", r);
    let o = "/v1/chat/states/{type}/{id}/{name}".replace("{type}", encodeURIComponent(String(t))).replace("{id}", encodeURIComponent(String(n))).replace("{name}", encodeURIComponent(String(r))), s = new URL(o, X), l;
    e && (l = e.baseOptions);
    let c = { method: "POST", ...l, ...a }, u = {}, d = {};
    u["Content-Type"] = "application/json", Q(s, d);
    let p = l && l.headers ? l.headers : {};
    return c.headers = { ...u, ...p, ...a.headers }, c.data = Qe(i, c, e), { url: ee(s), options: c };
  }, setWorkspacePaymentMethod: async (t, n, r = {}) => {
    se("setWorkspacePaymentMethod", "id", t);
    let i = "/v1/admin/workspaces/{id}/billing/payment-method".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, trackAnalytics: async (t, n = {}) => {
    let r = "/v1/chat/analytics", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "POST", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, transferBot: async (t, n, r = {}) => {
    se("transferBot", "id", t);
    let i = "/v1/admin/bots/{id}/transfer".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "POST", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, updateAccount: async (t, n = {}) => {
    let r = "/v1/admin/account/me", i = new URL(r, X), a;
    e && (a = e.baseOptions);
    let o = { method: "PUT", ...a, ...n }, s = {}, l = {};
    s["Content-Type"] = "application/json", Q(i, l);
    let c = a && a.headers ? a.headers : {};
    return o.headers = { ...s, ...c, ...n.headers }, o.data = Qe(t, o, e), { url: ee(i), options: o };
  }, updateBot: async (t, n, r = {}) => {
    se("updateBot", "id", t);
    let i = "/v1/admin/bots/{id}".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, updateConversation: async (t, n, r = {}) => {
    se("updateConversation", "id", t);
    let i = "/v1/chat/conversations/{id}".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, updateFileMetadata: async (t, n, r = {}) => {
    se("updateFileMetadata", "id", t);
    let i = "/v1/files/{id}/metadata".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, updateIntegration: async (t, n, r = {}) => {
    se("updateIntegration", "id", t);
    let i = "/v1/admin/integrations/{id}".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, updateMessage: async (t, n, r = {}) => {
    se("updateMessage", "id", t);
    let i = "/v1/chat/messages/{id}".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, updateTable: async (t, n, r = {}) => {
    se("updateTable", "table", t);
    let i = "/v1/tables/{table}".replace("{table}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, updateTableRows: async (t, n, r = {}) => {
    se("updateTableRows", "table", t);
    let i = "/v1/tables/{table}/rows".replace("{table}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, updateTask: async (t, n, r = {}) => {
    se("updateTask", "id", t);
    let i = "/v1/chat/tasks/{id}".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, updateUser: async (t, n, r = {}) => {
    se("updateUser", "id", t);
    let i = "/v1/chat/users/{id}".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, updateWorkspace: async (t, n, r = {}) => {
    se("updateWorkspace", "id", t);
    let i = "/v1/admin/workspaces/{id}".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, updateWorkspaceMember: async (t, n, r = {}) => {
    se("updateWorkspaceMember", "id", t);
    let i = "/v1/admin/workspace-members/{id}".replace("{id}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "PUT", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  }, upsertTableRows: async (t, n, r = {}) => {
    se("upsertTableRows", "table", t);
    let i = "/v1/tables/{table}/rows/upsert".replace("{table}", encodeURIComponent(String(t))), a = new URL(i, X), o;
    e && (o = e.baseOptions);
    let s = { method: "POST", ...o, ...r }, l = {}, c = {};
    l["Content-Type"] = "application/json", Q(a, c);
    let u = o && o.headers ? o.headers : {};
    return s.headers = { ...l, ...u, ...r.headers }, s.data = Qe(n, s, e), { url: ee(a), options: s };
  } };
}, ne = function(e) {
  let t = fne(e);
  return { async addParticipant(n, r, i) {
    let a = await t.addParticipant(n, r, i);
    return te(a, G, Y, e);
  }, async breakDownWorkspaceUsageByBot(n, r, i, a) {
    let o = await t.breakDownWorkspaceUsageByBot(n, r, i, a);
    return te(o, G, Y, e);
  }, async callAction(n, r) {
    let i = await t.callAction(n, r);
    return te(i, G, Y, e);
  }, async changeAISpendQuota(n, r) {
    let i = await t.changeAISpendQuota(n, r);
    return te(i, G, Y, e);
  }, async chargeWorkspaceUnpaidInvoices(n, r, i) {
    let a = await t.chargeWorkspaceUnpaidInvoices(n, r, i);
    return te(a, G, Y, e);
  }, async checkHandleAvailability(n, r) {
    let i = await t.checkHandleAvailability(n, r);
    return te(i, G, Y, e);
  }, async configureIntegration(n, r) {
    let i = await t.configureIntegration(n, r);
    return te(i, G, Y, e);
  }, async createBot(n, r) {
    let i = await t.createBot(n, r);
    return te(i, G, Y, e);
  }, async createConversation(n, r) {
    let i = await t.createConversation(n, r);
    return te(i, G, Y, e);
  }, async createEvent(n, r) {
    let i = await t.createEvent(n, r);
    return te(i, G, Y, e);
  }, async createFile(n, r) {
    let i = await t.createFile(n, r);
    return te(i, G, Y, e);
  }, async createIntegration(n, r) {
    let i = await t.createIntegration(n, r);
    return te(i, G, Y, e);
  }, async createIntegrationApiKey(n, r) {
    let i = await t.createIntegrationApiKey(n, r);
    return te(i, G, Y, e);
  }, async createMessage(n, r) {
    let i = await t.createMessage(n, r);
    return te(i, G, Y, e);
  }, async createPersonalAccessToken(n, r) {
    let i = await t.createPersonalAccessToken(n, r);
    return te(i, G, Y, e);
  }, async createTable(n, r) {
    let i = await t.createTable(n, r);
    return te(i, G, Y, e);
  }, async createTableRows(n, r, i) {
    let a = await t.createTableRows(n, r, i);
    return te(a, G, Y, e);
  }, async createTask(n, r) {
    let i = await t.createTask(n, r);
    return te(i, G, Y, e);
  }, async createUser(n, r) {
    let i = await t.createUser(n, r);
    return te(i, G, Y, e);
  }, async createWorkspace(n, r) {
    let i = await t.createWorkspace(n, r);
    return te(i, G, Y, e);
  }, async createWorkspaceMember(n, r) {
    let i = await t.createWorkspaceMember(n, r);
    return te(i, G, Y, e);
  }, async deleteBot(n, r) {
    let i = await t.deleteBot(n, r);
    return te(i, G, Y, e);
  }, async deleteBotIssue(n, r, i) {
    let a = await t.deleteBotIssue(n, r, i);
    return te(a, G, Y, e);
  }, async deleteConversation(n, r) {
    let i = await t.deleteConversation(n, r);
    return te(i, G, Y, e);
  }, async deleteFile(n, r) {
    let i = await t.deleteFile(n, r);
    return te(i, G, Y, e);
  }, async deleteIntegration(n, r) {
    let i = await t.deleteIntegration(n, r);
    return te(i, G, Y, e);
  }, async deleteIntegrationApiKey(n, r) {
    let i = await t.deleteIntegrationApiKey(n, r);
    return te(i, G, Y, e);
  }, async deleteMessage(n, r) {
    let i = await t.deleteMessage(n, r);
    return te(i, G, Y, e);
  }, async deletePersonalAccessToken(n, r) {
    let i = await t.deletePersonalAccessToken(n, r);
    return te(i, G, Y, e);
  }, async deleteTable(n, r) {
    let i = await t.deleteTable(n, r);
    return te(i, G, Y, e);
  }, async deleteTableRows(n, r, i) {
    let a = await t.deleteTableRows(n, r, i);
    return te(a, G, Y, e);
  }, async deleteTask(n, r) {
    let i = await t.deleteTask(n, r);
    return te(i, G, Y, e);
  }, async deleteUser(n, r) {
    let i = await t.deleteUser(n, r);
    return te(i, G, Y, e);
  }, async deleteWorkspace(n, r) {
    let i = await t.deleteWorkspace(n, r);
    return te(i, G, Y, e);
  }, async deleteWorkspaceMember(n, r) {
    let i = await t.deleteWorkspaceMember(n, r);
    return te(i, G, Y, e);
  }, async duplicateTable(n, r, i) {
    let a = await t.duplicateTable(n, r, i);
    return te(a, G, Y, e);
  }, async findTableRows(n, r, i) {
    let a = await t.findTableRows(n, r, i);
    return te(a, G, Y, e);
  }, async getAccount(n) {
    let r = await t.getAccount(n);
    return te(r, G, Y, e);
  }, async getAccountPreference(n, r) {
    let i = await t.getAccountPreference(n, r);
    return te(i, G, Y, e);
  }, async getAllWorkspaceQuotaCompletion(n) {
    let r = await t.getAllWorkspaceQuotaCompletion(n);
    return te(r, G, Y, e);
  }, async getAuditRecords(n, r, i) {
    let a = await t.getAuditRecords(n, r, i);
    return te(a, G, Y, e);
  }, async getBot(n, r) {
    let i = await t.getBot(n, r);
    return te(i, G, Y, e);
  }, async getBotAnalytics(n, r, i, a) {
    let o = await t.getBotAnalytics(n, r, i, a);
    return te(o, G, Y, e);
  }, async getBotLogs(n, r, i, a, o) {
    let s = await t.getBotLogs(n, r, i, a, o);
    return te(s, G, Y, e);
  }, async getBotWebchat(n, r, i) {
    let a = await t.getBotWebchat(n, r, i);
    return te(a, G, Y, e);
  }, async getConversation(n, r) {
    let i = await t.getConversation(n, r);
    return te(i, G, Y, e);
  }, async getEvent(n, r) {
    let i = await t.getEvent(n, r);
    return te(i, G, Y, e);
  }, async getFileContent(n, r) {
    let i = await t.getFileContent(n, r);
    return te(i, G, Y, e);
  }, async getFileMetadata(n, r) {
    let i = await t.getFileMetadata(n, r);
    return te(i, G, Y, e);
  }, async getIntegration(n, r) {
    let i = await t.getIntegration(n, r);
    return te(i, G, Y, e);
  }, async getIntegrationByName(n, r, i) {
    let a = await t.getIntegrationByName(n, r, i);
    return te(a, G, Y, e);
  }, async getIntegrationLogs(n, r, i, a, o) {
    let s = await t.getIntegrationLogs(n, r, i, a, o);
    return te(s, G, Y, e);
  }, async getMessage(n, r) {
    let i = await t.getMessage(n, r);
    return te(i, G, Y, e);
  }, async getOrCreateConversation(n, r) {
    let i = await t.getOrCreateConversation(n, r);
    return te(i, G, Y, e);
  }, async getOrCreateMessage(n, r) {
    let i = await t.getOrCreateMessage(n, r);
    return te(i, G, Y, e);
  }, async getOrCreateTable(n, r, i) {
    let a = await t.getOrCreateTable(n, r, i);
    return te(a, G, Y, e);
  }, async getOrCreateUser(n, r) {
    let i = await t.getOrCreateUser(n, r);
    return te(i, G, Y, e);
  }, async getOrSetState(n, r, i, a, o) {
    let s = await t.getOrSetState(n, r, i, a, o);
    return te(s, G, Y, e);
  }, async getParticipant(n, r, i) {
    let a = await t.getParticipant(n, r, i);
    return te(a, G, Y, e);
  }, async getPublicIntegration(n, r, i) {
    let a = await t.getPublicIntegration(n, r, i);
    return te(a, G, Y, e);
  }, async getPublicIntegrationById(n, r) {
    let i = await t.getPublicIntegrationById(n, r);
    return te(i, G, Y, e);
  }, async getPublicWorkspace(n, r) {
    let i = await t.getPublicWorkspace(n, r);
    return te(i, G, Y, e);
  }, async getState(n, r, i, a) {
    let o = await t.getState(n, r, i, a);
    return te(o, G, Y, e);
  }, async getTable(n, r) {
    let i = await t.getTable(n, r);
    return te(i, G, Y, e);
  }, async getTableRow(n, r, i) {
    let a = await t.getTableRow(n, r, i);
    return te(a, G, Y, e);
  }, async getTask(n, r) {
    let i = await t.getTask(n, r);
    return te(i, G, Y, e);
  }, async getUpcomingInvoice(n, r) {
    let i = await t.getUpcomingInvoice(n, r);
    return te(i, G, Y, e);
  }, async getUsage(n, r, i, a) {
    let o = await t.getUsage(n, r, i, a);
    return te(o, G, Y, e);
  }, async getUser(n, r) {
    let i = await t.getUser(n, r);
    return te(i, G, Y, e);
  }, async getWorkspace(n, r) {
    let i = await t.getWorkspace(n, r);
    return te(i, G, Y, e);
  }, async getWorkspaceQuota(n, r, i, a) {
    let o = await t.getWorkspaceQuota(n, r, i, a);
    return te(o, G, Y, e);
  }, async introspect(n, r) {
    let i = await t.introspect(n, r);
    return te(i, G, Y, e);
  }, async listActivities(n, r, i, a) {
    let o = await t.listActivities(n, r, i, a);
    return te(o, G, Y, e);
  }, async listBotIssueEvents(n, r, i) {
    let a = await t.listBotIssueEvents(n, r, i);
    return te(a, G, Y, e);
  }, async listBotIssues(n, r, i) {
    let a = await t.listBotIssues(n, r, i);
    return te(a, G, Y, e);
  }, async listBots(n, r, i) {
    let a = await t.listBots(n, r, i);
    return te(a, G, Y, e);
  }, async listConversations(n, r, i, a) {
    let o = await t.listConversations(n, r, i, a);
    return te(o, G, Y, e);
  }, async listEvents(n, r, i, a, o, s, l) {
    let c = await t.listEvents(n, r, i, a, o, s, l);
    return te(c, G, Y, e);
  }, async listFiles(n, r, i, a) {
    let o = await t.listFiles(n, r, i, a);
    return te(o, G, Y, e);
  }, async listIntegrationApiKeys(n, r) {
    let i = await t.listIntegrationApiKeys(n, r);
    return te(i, G, Y, e);
  }, async listIntegrations(n, r, i, a, o) {
    let s = await t.listIntegrations(n, r, i, a, o);
    return te(s, G, Y, e);
  }, async listMessages(n, r, i, a) {
    let o = await t.listMessages(n, r, i, a);
    return te(o, G, Y, e);
  }, async listParticipants(n, r, i) {
    let a = await t.listParticipants(n, r, i);
    return te(a, G, Y, e);
  }, async listPersonalAccessTokens(n) {
    let r = await t.listPersonalAccessTokens(n);
    return te(r, G, Y, e);
  }, async listPublicIntegrations(n, r, i, a) {
    let o = await t.listPublicIntegrations(n, r, i, a);
    return te(o, G, Y, e);
  }, async listTables(n, r) {
    let i = await t.listTables(n, r);
    return te(i, G, Y, e);
  }, async listTasks(n, r, i, a, o, s, l, c) {
    let u = await t.listTasks(n, r, i, a, o, s, l, c);
    return te(u, G, Y, e);
  }, async listUsageHistory(n, r, i) {
    let a = await t.listUsageHistory(n, r, i);
    return te(a, G, Y, e);
  }, async listUsers(n, r, i, a) {
    let o = await t.listUsers(n, r, i, a);
    return te(o, G, Y, e);
  }, async listWorkspaceInvoices(n, r) {
    let i = await t.listWorkspaceInvoices(n, r);
    return te(i, G, Y, e);
  }, async listWorkspaceMembers(n, r) {
    let i = await t.listWorkspaceMembers(n, r);
    return te(i, G, Y, e);
  }, async listWorkspaceQuotas(n, r, i) {
    let a = await t.listWorkspaceQuotas(n, r, i);
    return te(a, G, Y, e);
  }, async listWorkspaceUsages(n, r, i, a) {
    let o = await t.listWorkspaceUsages(n, r, i, a);
    return te(o, G, Y, e);
  }, async listWorkspaces(n, r) {
    let i = await t.listWorkspaces(n, r);
    return te(i, G, Y, e);
  }, async patchState(n, r, i, a, o) {
    let s = await t.patchState(n, r, i, a, o);
    return te(s, G, Y, e);
  }, async removeParticipant(n, r, i) {
    let a = await t.removeParticipant(n, r, i);
    return te(a, G, Y, e);
  }, async renameTableColumn(n, r, i) {
    let a = await t.renameTableColumn(n, r, i);
    return te(a, G, Y, e);
  }, async runVrl(n, r) {
    let i = await t.runVrl(n, r);
    return te(i, G, Y, e);
  }, async searchFiles(n, r, i, a, o, s) {
    let l = await t.searchFiles(n, r, i, a, o, s);
    return te(l, G, Y, e);
  }, async setAccountPreference(n, r, i) {
    let a = await t.setAccountPreference(n, r, i);
    return te(a, G, Y, e);
  }, async setState(n, r, i, a, o) {
    let s = await t.setState(n, r, i, a, o);
    return te(s, G, Y, e);
  }, async setWorkspacePaymentMethod(n, r, i) {
    let a = await t.setWorkspacePaymentMethod(n, r, i);
    return te(a, G, Y, e);
  }, async trackAnalytics(n, r) {
    let i = await t.trackAnalytics(n, r);
    return te(i, G, Y, e);
  }, async transferBot(n, r, i) {
    let a = await t.transferBot(n, r, i);
    return te(a, G, Y, e);
  }, async updateAccount(n, r) {
    let i = await t.updateAccount(n, r);
    return te(i, G, Y, e);
  }, async updateBot(n, r, i) {
    let a = await t.updateBot(n, r, i);
    return te(a, G, Y, e);
  }, async updateConversation(n, r, i) {
    let a = await t.updateConversation(n, r, i);
    return te(a, G, Y, e);
  }, async updateFileMetadata(n, r, i) {
    let a = await t.updateFileMetadata(n, r, i);
    return te(a, G, Y, e);
  }, async updateIntegration(n, r, i) {
    let a = await t.updateIntegration(n, r, i);
    return te(a, G, Y, e);
  }, async updateMessage(n, r, i) {
    let a = await t.updateMessage(n, r, i);
    return te(a, G, Y, e);
  }, async updateTable(n, r, i) {
    let a = await t.updateTable(n, r, i);
    return te(a, G, Y, e);
  }, async updateTableRows(n, r, i) {
    let a = await t.updateTableRows(n, r, i);
    return te(a, G, Y, e);
  }, async updateTask(n, r, i) {
    let a = await t.updateTask(n, r, i);
    return te(a, G, Y, e);
  }, async updateUser(n, r, i) {
    let a = await t.updateUser(n, r, i);
    return te(a, G, Y, e);
  }, async updateWorkspace(n, r, i) {
    let a = await t.updateWorkspace(n, r, i);
    return te(a, G, Y, e);
  }, async updateWorkspaceMember(n, r, i) {
    let a = await t.updateWorkspaceMember(n, r, i);
    return te(a, G, Y, e);
  }, async upsertTableRows(n, r, i) {
    let a = await t.upsertTableRows(n, r, i);
    return te(a, G, Y, e);
  } };
}, pne = class extends une {
  addParticipant(e, t) {
    return ne(this.configuration).addParticipant(e.id, e.addParticipantBody, t).then((n) => n(this.axios, this.basePath));
  }
  breakDownWorkspaceUsageByBot(e, t) {
    return ne(this.configuration).breakDownWorkspaceUsageByBot(e.id, e.type, e.period, t).then((n) => n(this.axios, this.basePath));
  }
  callAction(e = {}, t) {
    return ne(this.configuration).callAction(e.callActionBody, t).then((n) => n(this.axios, this.basePath));
  }
  changeAISpendQuota(e = {}, t) {
    return ne(this.configuration).changeAISpendQuota(e.changeAISpendQuotaBody, t).then((n) => n(this.axios, this.basePath));
  }
  chargeWorkspaceUnpaidInvoices(e, t) {
    return ne(this.configuration).chargeWorkspaceUnpaidInvoices(e.id, e.chargeWorkspaceUnpaidInvoicesBody, t).then((n) => n(this.axios, this.basePath));
  }
  checkHandleAvailability(e = {}, t) {
    return ne(this.configuration).checkHandleAvailability(e.checkHandleAvailabilityBody, t).then((n) => n(this.axios, this.basePath));
  }
  configureIntegration(e = {}, t) {
    return ne(this.configuration).configureIntegration(e.configureIntegrationBody, t).then((n) => n(this.axios, this.basePath));
  }
  createBot(e = {}, t) {
    return ne(this.configuration).createBot(e.createBotBody, t).then((n) => n(this.axios, this.basePath));
  }
  createConversation(e = {}, t) {
    return ne(this.configuration).createConversation(e.createConversationBody, t).then((n) => n(this.axios, this.basePath));
  }
  createEvent(e = {}, t) {
    return ne(this.configuration).createEvent(e.createEventBody, t).then((n) => n(this.axios, this.basePath));
  }
  createFile(e = {}, t) {
    return ne(this.configuration).createFile(e.createFileBody, t).then((n) => n(this.axios, this.basePath));
  }
  createIntegration(e = {}, t) {
    return ne(this.configuration).createIntegration(e.createIntegrationBody, t).then((n) => n(this.axios, this.basePath));
  }
  createIntegrationApiKey(e = {}, t) {
    return ne(this.configuration).createIntegrationApiKey(e.createIntegrationApiKeyBody, t).then((n) => n(this.axios, this.basePath));
  }
  createMessage(e = {}, t) {
    return ne(this.configuration).createMessage(e.createMessageBody, t).then((n) => n(this.axios, this.basePath));
  }
  createPersonalAccessToken(e = {}, t) {
    return ne(this.configuration).createPersonalAccessToken(e.createPersonalAccessTokenBody, t).then((n) => n(this.axios, this.basePath));
  }
  createTable(e = {}, t) {
    return ne(this.configuration).createTable(e.createTableBody, t).then((n) => n(this.axios, this.basePath));
  }
  createTableRows(e, t) {
    return ne(this.configuration).createTableRows(e.table, e.createTableRowsBody, t).then((n) => n(this.axios, this.basePath));
  }
  createTask(e = {}, t) {
    return ne(this.configuration).createTask(e.createTaskBody, t).then((n) => n(this.axios, this.basePath));
  }
  createUser(e = {}, t) {
    return ne(this.configuration).createUser(e.createUserBody, t).then((n) => n(this.axios, this.basePath));
  }
  createWorkspace(e = {}, t) {
    return ne(this.configuration).createWorkspace(e.createWorkspaceBody, t).then((n) => n(this.axios, this.basePath));
  }
  createWorkspaceMember(e = {}, t) {
    return ne(this.configuration).createWorkspaceMember(e.createWorkspaceMemberBody, t).then((n) => n(this.axios, this.basePath));
  }
  deleteBot(e, t) {
    return ne(this.configuration).deleteBot(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  deleteBotIssue(e, t) {
    return ne(this.configuration).deleteBotIssue(e.id, e.issueId, t).then((n) => n(this.axios, this.basePath));
  }
  deleteConversation(e, t) {
    return ne(this.configuration).deleteConversation(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  deleteFile(e, t) {
    return ne(this.configuration).deleteFile(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  deleteIntegration(e, t) {
    return ne(this.configuration).deleteIntegration(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  deleteIntegrationApiKey(e, t) {
    return ne(this.configuration).deleteIntegrationApiKey(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  deleteMessage(e, t) {
    return ne(this.configuration).deleteMessage(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  deletePersonalAccessToken(e, t) {
    return ne(this.configuration).deletePersonalAccessToken(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  deleteTable(e, t) {
    return ne(this.configuration).deleteTable(e.table, t).then((n) => n(this.axios, this.basePath));
  }
  deleteTableRows(e, t) {
    return ne(this.configuration).deleteTableRows(e.table, e.deleteTableRowsBody, t).then((n) => n(this.axios, this.basePath));
  }
  deleteTask(e, t) {
    return ne(this.configuration).deleteTask(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  deleteUser(e, t) {
    return ne(this.configuration).deleteUser(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  deleteWorkspace(e, t) {
    return ne(this.configuration).deleteWorkspace(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  deleteWorkspaceMember(e, t) {
    return ne(this.configuration).deleteWorkspaceMember(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  duplicateTable(e, t) {
    return ne(this.configuration).duplicateTable(e.sourceTableId, e.duplicateTableBody, t).then((n) => n(this.axios, this.basePath));
  }
  findTableRows(e, t) {
    return ne(this.configuration).findTableRows(e.table, e.findTableRowsBody, t).then((n) => n(this.axios, this.basePath));
  }
  getAccount(e) {
    return ne(this.configuration).getAccount(e).then((t) => t(this.axios, this.basePath));
  }
  getAccountPreference(e, t) {
    return ne(this.configuration).getAccountPreference(e.key, t).then((n) => n(this.axios, this.basePath));
  }
  getAllWorkspaceQuotaCompletion(e) {
    return ne(this.configuration).getAllWorkspaceQuotaCompletion(e).then((t) => t(this.axios, this.basePath));
  }
  getAuditRecords(e, t) {
    return ne(this.configuration).getAuditRecords(e.id, e.nextToken, t).then((n) => n(this.axios, this.basePath));
  }
  getBot(e, t) {
    return ne(this.configuration).getBot(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getBotAnalytics(e, t) {
    return ne(this.configuration).getBotAnalytics(e.id, e.startDate, e.endDate, t).then((n) => n(this.axios, this.basePath));
  }
  getBotLogs(e, t) {
    return ne(this.configuration).getBotLogs(e.id, e.timeStart, e.timeEnd, e.nextToken, t).then((n) => n(this.axios, this.basePath));
  }
  getBotWebchat(e, t) {
    return ne(this.configuration).getBotWebchat(e.id, e.type, t).then((n) => n(this.axios, this.basePath));
  }
  getConversation(e, t) {
    return ne(this.configuration).getConversation(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getEvent(e, t) {
    return ne(this.configuration).getEvent(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getFileContent(e, t) {
    return ne(this.configuration).getFileContent(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getFileMetadata(e, t) {
    return ne(this.configuration).getFileMetadata(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getIntegration(e, t) {
    return ne(this.configuration).getIntegration(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getIntegrationByName(e, t) {
    return ne(this.configuration).getIntegrationByName(e.name, e.version, t).then((n) => n(this.axios, this.basePath));
  }
  getIntegrationLogs(e, t) {
    return ne(this.configuration).getIntegrationLogs(e.id, e.timeStart, e.timeEnd, e.nextToken, t).then((n) => n(this.axios, this.basePath));
  }
  getMessage(e, t) {
    return ne(this.configuration).getMessage(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getOrCreateConversation(e = {}, t) {
    return ne(this.configuration).getOrCreateConversation(e.getOrCreateConversationBody, t).then((n) => n(this.axios, this.basePath));
  }
  getOrCreateMessage(e = {}, t) {
    return ne(this.configuration).getOrCreateMessage(e.getOrCreateMessageBody, t).then((n) => n(this.axios, this.basePath));
  }
  getOrCreateTable(e, t) {
    return ne(this.configuration).getOrCreateTable(e.table, e.getOrCreateTableBody, t).then((n) => n(this.axios, this.basePath));
  }
  getOrCreateUser(e = {}, t) {
    return ne(this.configuration).getOrCreateUser(e.getOrCreateUserBody, t).then((n) => n(this.axios, this.basePath));
  }
  getOrSetState(e, t) {
    return ne(this.configuration).getOrSetState(e.type, e.id, e.name, e.getOrSetStateBody, t).then((n) => n(this.axios, this.basePath));
  }
  getParticipant(e, t) {
    return ne(this.configuration).getParticipant(e.id, e.userId, t).then((n) => n(this.axios, this.basePath));
  }
  getPublicIntegration(e, t) {
    return ne(this.configuration).getPublicIntegration(e.name, e.version, t).then((n) => n(this.axios, this.basePath));
  }
  getPublicIntegrationById(e, t) {
    return ne(this.configuration).getPublicIntegrationById(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getPublicWorkspace(e, t) {
    return ne(this.configuration).getPublicWorkspace(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getState(e, t) {
    return ne(this.configuration).getState(e.type, e.id, e.name, t).then((n) => n(this.axios, this.basePath));
  }
  getTable(e, t) {
    return ne(this.configuration).getTable(e.table, t).then((n) => n(this.axios, this.basePath));
  }
  getTableRow(e, t) {
    return ne(this.configuration).getTableRow(e.table, e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getTask(e, t) {
    return ne(this.configuration).getTask(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getUpcomingInvoice(e, t) {
    return ne(this.configuration).getUpcomingInvoice(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getUsage(e, t) {
    return ne(this.configuration).getUsage(e.type, e.id, e.period, t).then((n) => n(this.axios, this.basePath));
  }
  getUser(e, t) {
    return ne(this.configuration).getUser(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getWorkspace(e, t) {
    return ne(this.configuration).getWorkspace(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  getWorkspaceQuota(e, t) {
    return ne(this.configuration).getWorkspaceQuota(e.id, e.type, e.period, t).then((n) => n(this.axios, this.basePath));
  }
  introspect(e = {}, t) {
    return ne(this.configuration).introspect(e.introspectBody, t).then((n) => n(this.axios, this.basePath));
  }
  listActivities(e, t) {
    return ne(this.configuration).listActivities(e.taskId, e.botId, e.nextToken, t).then((n) => n(this.axios, this.basePath));
  }
  listBotIssueEvents(e, t) {
    return ne(this.configuration).listBotIssueEvents(e.id, e.issueId, t).then((n) => n(this.axios, this.basePath));
  }
  listBotIssues(e, t) {
    return ne(this.configuration).listBotIssues(e.id, e.nextToken, t).then((n) => n(this.axios, this.basePath));
  }
  listBots(e = {}, t) {
    return ne(this.configuration).listBots(e.dev, e.nextToken, t).then((n) => n(this.axios, this.basePath));
  }
  listConversations(e = {}, t) {
    return ne(this.configuration).listConversations(e.nextToken, e.tags, e.participantIds, t).then((n) => n(this.axios, this.basePath));
  }
  listEvents(e = {}, t) {
    return ne(this.configuration).listEvents(e.nextToken, e.type, e.conversationId, e.userId, e.messageId, e.status, t).then((n) => n(this.axios, this.basePath));
  }
  listFiles(e, t) {
    return ne(this.configuration).listFiles(e.botId, e.nextToken, e.tags, t).then((n) => n(this.axios, this.basePath));
  }
  listIntegrationApiKeys(e, t) {
    return ne(this.configuration).listIntegrationApiKeys(e.integrationId, t).then((n) => n(this.axios, this.basePath));
  }
  listIntegrations(e = {}, t) {
    return ne(this.configuration).listIntegrations(e.nextToken, e.name, e.version, e.dev, t).then((n) => n(this.axios, this.basePath));
  }
  listMessages(e = {}, t) {
    return ne(this.configuration).listMessages(e.nextToken, e.conversationId, e.tags, t).then((n) => n(this.axios, this.basePath));
  }
  listParticipants(e, t) {
    return ne(this.configuration).listParticipants(e.id, e.nextToken, t).then((n) => n(this.axios, this.basePath));
  }
  listPersonalAccessTokens(e) {
    return ne(this.configuration).listPersonalAccessTokens(e).then((t) => t(this.axios, this.basePath));
  }
  listPublicIntegrations(e = {}, t) {
    return ne(this.configuration).listPublicIntegrations(e.nextToken, e.name, e.version, t).then((n) => n(this.axios, this.basePath));
  }
  listTables(e = {}, t) {
    return ne(this.configuration).listTables(e.tags, t).then((n) => n(this.axios, this.basePath));
  }
  listTasks(e = {}, t) {
    return ne(this.configuration).listTasks(e.nextToken, e.tags, e.conversationId, e.userId, e.parentTaskId, e.status, e.type, t).then((n) => n(this.axios, this.basePath));
  }
  listUsageHistory(e, t) {
    return ne(this.configuration).listUsageHistory(e.type, e.id, t).then((n) => n(this.axios, this.basePath));
  }
  listUsers(e = {}, t) {
    return ne(this.configuration).listUsers(e.nextToken, e.conversationId, e.tags, t).then((n) => n(this.axios, this.basePath));
  }
  listWorkspaceInvoices(e, t) {
    return ne(this.configuration).listWorkspaceInvoices(e.id, t).then((n) => n(this.axios, this.basePath));
  }
  listWorkspaceMembers(e = {}, t) {
    return ne(this.configuration).listWorkspaceMembers(e.nextToken, t).then((n) => n(this.axios, this.basePath));
  }
  listWorkspaceQuotas(e, t) {
    return ne(this.configuration).listWorkspaceQuotas(e.id, e.period, t).then((n) => n(this.axios, this.basePath));
  }
  listWorkspaceUsages(e, t) {
    return ne(this.configuration).listWorkspaceUsages(e.id, e.type, e.period, t).then((n) => n(this.axios, this.basePath));
  }
  listWorkspaces(e = {}, t) {
    return ne(this.configuration).listWorkspaces(e.nextToken, t).then((n) => n(this.axios, this.basePath));
  }
  patchState(e, t) {
    return ne(this.configuration).patchState(e.type, e.id, e.name, e.patchStateBody, t).then((n) => n(this.axios, this.basePath));
  }
  removeParticipant(e, t) {
    return ne(this.configuration).removeParticipant(e.id, e.userId, t).then((n) => n(this.axios, this.basePath));
  }
  renameTableColumn(e, t) {
    return ne(this.configuration).renameTableColumn(e.table, e.renameTableColumnBody, t).then((n) => n(this.axios, this.basePath));
  }
  runVrl(e = {}, t) {
    return ne(this.configuration).runVrl(e.runVrlBody, t).then((n) => n(this.axios, this.basePath));
  }
  searchFiles(e, t) {
    return ne(this.configuration).searchFiles(e.botId, e.query, e.tags, e.contextDepth, e.limit, t).then((n) => n(this.axios, this.basePath));
  }
  setAccountPreference(e, t) {
    return ne(this.configuration).setAccountPreference(e.key, e.setAccountPreferenceBody, t).then((n) => n(this.axios, this.basePath));
  }
  setState(e, t) {
    return ne(this.configuration).setState(e.type, e.id, e.name, e.setStateBody, t).then((n) => n(this.axios, this.basePath));
  }
  setWorkspacePaymentMethod(e, t) {
    return ne(this.configuration).setWorkspacePaymentMethod(e.id, e.setWorkspacePaymentMethodBody, t).then((n) => n(this.axios, this.basePath));
  }
  trackAnalytics(e = {}, t) {
    return ne(this.configuration).trackAnalytics(e.trackAnalyticsBody, t).then((n) => n(this.axios, this.basePath));
  }
  transferBot(e, t) {
    return ne(this.configuration).transferBot(e.id, e.transferBotBody, t).then((n) => n(this.axios, this.basePath));
  }
  updateAccount(e = {}, t) {
    return ne(this.configuration).updateAccount(e.updateAccountBody, t).then((n) => n(this.axios, this.basePath));
  }
  updateBot(e, t) {
    return ne(this.configuration).updateBot(e.id, e.updateBotBody, t).then((n) => n(this.axios, this.basePath));
  }
  updateConversation(e, t) {
    return ne(this.configuration).updateConversation(e.id, e.updateConversationBody, t).then((n) => n(this.axios, this.basePath));
  }
  updateFileMetadata(e, t) {
    return ne(this.configuration).updateFileMetadata(e.id, e.updateFileMetadataBody, t).then((n) => n(this.axios, this.basePath));
  }
  updateIntegration(e, t) {
    return ne(this.configuration).updateIntegration(e.id, e.updateIntegrationBody, t).then((n) => n(this.axios, this.basePath));
  }
  updateMessage(e, t) {
    return ne(this.configuration).updateMessage(e.id, e.updateMessageBody, t).then((n) => n(this.axios, this.basePath));
  }
  updateTable(e, t) {
    return ne(this.configuration).updateTable(e.table, e.updateTableBody, t).then((n) => n(this.axios, this.basePath));
  }
  updateTableRows(e, t) {
    return ne(this.configuration).updateTableRows(e.table, e.updateTableRowsBody, t).then((n) => n(this.axios, this.basePath));
  }
  updateTask(e, t) {
    return ne(this.configuration).updateTask(e.id, e.updateTaskBody, t).then((n) => n(this.axios, this.basePath));
  }
  updateUser(e, t) {
    return ne(this.configuration).updateUser(e.id, e.updateUserBody, t).then((n) => n(this.axios, this.basePath));
  }
  updateWorkspace(e, t) {
    return ne(this.configuration).updateWorkspace(e.id, e.updateWorkspaceBody, t).then((n) => n(this.axios, this.basePath));
  }
  updateWorkspaceMember(e, t) {
    return ne(this.configuration).updateWorkspaceMember(e.id, e.updateWorkspaceMemberBody, t).then((n) => n(this.axios, this.basePath));
  }
  upsertTableRows(e, t) {
    return ne(this.configuration).upsertTableRows(e.table, e.upsertTableRowsBody, t).then((n) => n(this.axios, this.basePath));
  }
}, hne = { getRandomValues: (e) => new Uint8Array(e.map(() => Math.floor(Math.random() * 256))) }, Xh = typeof window < "u" && typeof window.document < "u" ? window.crypto : Yg;
Xh.getRandomValues || (Xh = hne);
var Ut = class extends Error {
  constructor(t, n, r, i, a, o) {
    super(i);
    _(this, "isApiError", !0);
    this.code = t, this.description = n, this.type = r, this.message = i, this.error = a, this.id = o, this.id || (this.id = Ut.generateId());
  }
  format() {
    return `[${this.type}] ${this.message} (Error ID: ${this.id})`;
  }
  toJSON() {
    return { id: this.id, code: this.code, type: this.type, message: this.message };
  }
  static generateId() {
    let t = this.getPrefix(), n = (/* @__PURE__ */ new Date()).toISOString().replace(/[\-:TZ]/g, "").split(".")[0], r = 4, i = Array.from(Xh.getRandomValues(new Uint8Array(r))).map((a) => a.toString(16).padStart(2, "0")).join("").toUpperCase();
    return `${t}_${n}x${i}`;
  }
  static getPrefix() {
    return typeof window < "u" && typeof window.document < "u" ? "err_bwsr" : "err";
  }
}, mne = (e) => typeof e == "object" && !Array.isArray(e) && e !== null, yT = (e) => e instanceof Ut || mne(e) && e.isApiError === !0, Io = class extends Ut {
  constructor(e, t, n) {
    super(500, "An unknown error occurred", "Unknown", e, t, n);
  }
}, vT = class extends Ut {
  constructor(e, t, n) {
    super(500, "An internal error occurred", "Internal", e, t, n);
  }
}, bT = class extends Ut {
  constructor(e, t, n) {
    super(401, "The request requires to be authenticated.", "Unauthorized", e, t, n);
  }
}, wT = class extends Ut {
  constructor(e, t, n) {
    super(403, "The requested action can't be peform by this resource.", "Forbidden", e, t, n);
  }
}, xT = class extends Ut {
  constructor(e, t, n) {
    super(413, "The request payload is too large.", "PayloadTooLarge", e, t, n);
  }
}, _T = class extends Ut {
  constructor(e, t, n) {
    super(400, "The request payload is invalid.", "InvalidPayload", e, t, n);
  }
}, ST = class extends Ut {
  constructor(e, t, n) {
    super(415, "The request is invalid because the content-type is not supported.", "UnsupportedMediaType", e, t, n);
  }
}, ET = class extends Ut {
  constructor(e, t, n) {
    super(405, "The requested method does not exist.", "MethodNotFound", e, t, n);
  }
}, kT = class extends Ut {
  constructor(e, t, n) {
    super(404, "The requested resource does not exist.", "ResourceNotFound", e, t, n);
  }
}, TT = class extends Ut {
  constructor(e, t, n) {
    super(400, "The provided JSON schema is invalid.", "InvalidJsonSchema", e, t, n);
  }
}, CT = class extends Ut {
  constructor(e, t, n) {
    super(400, "The provided data doesn't respect the provided JSON schema.", "InvalidDataFormat", e, t, n);
  }
}, OT = class extends Ut {
  constructor(e, t, n) {
    super(400, "The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.", "InvalidIdentifier", e, t, n);
  }
}, AT = class extends Ut {
  constructor(e, t, n) {
    super(409, "The resource is related with a different resource that the one referenced in the request. This is usually caused when providing two resource identifiers that aren't linked together.", "RelationConflict", e, t, n);
  }
}, $T = class extends Ut {
  constructor(e, t, n) {
    super(409, "The resource cannot be deleted because it's referenced by another resource", "ReferenceConstraint", e, t, n);
  }
}, RT = class extends Ut {
  constructor(e, t, n) {
    super(400, "The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.", "ReferenceNotFound", e, t, n);
  }
}, PT = class extends Ut {
  constructor(e, t, n) {
    super(400, "The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.", "InvalidQuery", e, t, n);
  }
}, IT = class extends Ut {
  constructor(e, t, n) {
    super(400, "An error happened during the execution of a runtime (bot or integration).", "Runtime", e, t, n);
  }
}, MT = class extends Ut {
  constructor(t, n, r) {
    super(409, "The record attempted to be created already exists.", "AlreadyExists", t, n, r);
  }
}, NT = class extends Ut {
  constructor(e, t, n) {
    super(429, "The request has been rate limited.", "RateLimited", e, t, n);
  }
}, DT = class extends Ut {
  constructor(e, t, n) {
    super(402, "A payment is required to perform this request.", "PaymentRequired", e, t, n);
  }
}, LT = class extends Ut {
  constructor(e, t, n) {
    super(403, "The request exceeds the allowed quota. Quotas are a soft limit that can be increased.", "QuotaExceeded", e, t, n);
  }
}, jT = class extends Ut {
  constructor(e, t, n) {
    super(413, "The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.", "LimitExceeded", e, t, n);
  }
}, UT = class extends Ut {
  constructor(e, t, n) {
    super(400, "Request payload contains breaking changes which is not allowed for this resource without a version increment.", "BreakingChanges", e, t, n);
  }
}, gne = { Unknown: Io, Internal: vT, Unauthorized: bT, Forbidden: wT, PayloadTooLarge: xT, InvalidPayload: _T, UnsupportedMediaType: ST, MethodNotFound: ET, ResourceNotFound: kT, InvalidJsonSchema: TT, InvalidDataFormat: CT, InvalidIdentifier: OT, RelationConflict: AT, ReferenceConstraint: $T, ReferenceNotFound: RT, InvalidQuery: PT, Runtime: IT, AlreadyExists: MT, RateLimited: NT, PaymentRequired: DT, QuotaExceeded: LT, LimitExceeded: jT, BreakingChanges: UT }, Qh = (e) => yT(e) ? e : e instanceof Error ? new Io(e.message, e) : typeof e == "string" ? new Io(e) : yne(e);
function yne(e) {
  if (typeof e == "object" && "code" in e && "type" in e && "id" in e && "message" in e && typeof e.type == "string" && typeof e.message == "string") {
    let t = gne[e.type];
    return t ? new t(e.message, void 0, e.id || "UNKNOWN") : new Io(`An unclassified API error occurred: ${e.message} (Type: ${e.type}, Code: ${e.code})`);
  }
  return new Io("An invalid error occurred: " + JSON.stringify(e));
}
var vne = class {
  constructor(e, t, n) {
    _(this, "_innerClient");
    _(this, "createConversation", (e) => this._innerClient.createConversation({ createConversationBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getConversation", (e) => this._innerClient.getConversation(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listConversations", (e) => this._innerClient.listConversations(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getOrCreateConversation", (e) => this._innerClient.getOrCreateConversation({ getOrCreateConversationBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "updateConversation", ({ id: e, ...t }) => this._innerClient.updateConversation({ id: e, updateConversationBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "deleteConversation", (e) => this._innerClient.deleteConversation(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listParticipants", (e) => this._innerClient.listParticipants(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "addParticipant", ({ id: e, ...t }) => this._innerClient.addParticipant({ id: e, addParticipantBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "getParticipant", (e) => this._innerClient.getParticipant(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "removeParticipant", (e) => this._innerClient.removeParticipant(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "createEvent", (e) => this._innerClient.createEvent({ createEventBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getEvent", (e) => this._innerClient.getEvent(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listEvents", (e) => this._innerClient.listEvents(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "createMessage", (e) => this._innerClient.createMessage({ createMessageBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getOrCreateMessage", (e) => this._innerClient.getOrCreateMessage({ getOrCreateMessageBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getMessage", (e) => this._innerClient.getMessage(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "updateMessage", ({ id: e, ...t }) => this._innerClient.updateMessage({ id: e, updateMessageBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "listMessages", (e) => this._innerClient.listMessages(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "deleteMessage", (e) => this._innerClient.deleteMessage(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "createUser", (e) => this._innerClient.createUser({ createUserBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getUser", (e) => this._innerClient.getUser(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listUsers", (e) => this._innerClient.listUsers(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getOrCreateUser", (e) => this._innerClient.getOrCreateUser({ getOrCreateUserBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "updateUser", ({ id: e, ...t }) => this._innerClient.updateUser({ id: e, updateUserBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "deleteUser", (e) => this._innerClient.deleteUser(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getState", (e) => this._innerClient.getState(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "setState", ({ type: e, id: t, name: n, ...r }) => this._innerClient.setState({ type: e, id: t, name: n, setStateBody: r }).then((i) => i.data).catch((i) => {
      throw re(i);
    }));
    _(this, "getOrSetState", ({ type: e, id: t, name: n, ...r }) => this._innerClient.getOrSetState({ type: e, id: t, name: n, getOrSetStateBody: r }).then((i) => i.data).catch((i) => {
      throw re(i);
    }));
    _(this, "patchState", ({ type: e, id: t, name: n, ...r }) => this._innerClient.patchState({ type: e, id: t, name: n, patchStateBody: r }).then((i) => i.data).catch((i) => {
      throw re(i);
    }));
    _(this, "callAction", (e) => this._innerClient.callAction({ callActionBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "configureIntegration", (e) => this._innerClient.configureIntegration({ configureIntegrationBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getTask", (e) => this._innerClient.getTask(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "createTask", (e) => this._innerClient.createTask({ createTaskBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "updateTask", ({ id: e, ...t }) => this._innerClient.updateTask({ id: e, updateTaskBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "deleteTask", (e) => this._innerClient.deleteTask(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listTasks", (e) => this._innerClient.listTasks(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "trackAnalytics", (e) => this._innerClient.trackAnalytics({ trackAnalyticsBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "runVrl", (e) => this._innerClient.runVrl({ runVrlBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getAccount", () => this._innerClient.getAccount().then((e) => e.data).catch((e) => {
      throw re(e);
    }));
    _(this, "updateAccount", (e) => this._innerClient.updateAccount({ updateAccountBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listPersonalAccessTokens", () => this._innerClient.listPersonalAccessTokens().then((e) => e.data).catch((e) => {
      throw re(e);
    }));
    _(this, "createPersonalAccessToken", (e) => this._innerClient.createPersonalAccessToken({ createPersonalAccessTokenBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "deletePersonalAccessToken", (e) => this._innerClient.deletePersonalAccessToken(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "setAccountPreference", ({ key: e, ...t }) => this._innerClient.setAccountPreference({ key: e, setAccountPreferenceBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "getAccountPreference", (e) => this._innerClient.getAccountPreference(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listPublicIntegrations", (e) => this._innerClient.listPublicIntegrations(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getPublicIntegrationById", (e) => this._innerClient.getPublicIntegrationById(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getPublicIntegration", (e) => this._innerClient.getPublicIntegration(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "createBot", (e) => this._innerClient.createBot({ createBotBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "updateBot", ({ id: e, ...t }) => this._innerClient.updateBot({ id: e, updateBotBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "transferBot", ({ id: e, ...t }) => this._innerClient.transferBot({ id: e, transferBotBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "listBots", (e) => this._innerClient.listBots(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getBot", (e) => this._innerClient.getBot(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "deleteBot", (e) => this._innerClient.deleteBot(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getBotLogs", (e) => this._innerClient.getBotLogs(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getBotWebchat", (e) => this._innerClient.getBotWebchat(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getBotAnalytics", (e) => this._innerClient.getBotAnalytics(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listBotIssues", (e) => this._innerClient.listBotIssues(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "deleteBotIssue", (e) => this._innerClient.deleteBotIssue(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listBotIssueEvents", (e) => this._innerClient.listBotIssueEvents(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "setWorkspacePaymentMethod", ({ id: e, ...t }) => this._innerClient.setWorkspacePaymentMethod({ id: e, setWorkspacePaymentMethodBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "listWorkspaceInvoices", (e) => this._innerClient.listWorkspaceInvoices(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getUpcomingInvoice", (e) => this._innerClient.getUpcomingInvoice(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "chargeWorkspaceUnpaidInvoices", ({ id: e, ...t }) => this._innerClient.chargeWorkspaceUnpaidInvoices({ id: e, chargeWorkspaceUnpaidInvoicesBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "createWorkspace", (e) => this._innerClient.createWorkspace({ createWorkspaceBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getPublicWorkspace", (e) => this._innerClient.getPublicWorkspace(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getWorkspace", (e) => this._innerClient.getWorkspace(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listWorkspaceUsages", (e) => this._innerClient.listWorkspaceUsages(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "breakDownWorkspaceUsageByBot", (e) => this._innerClient.breakDownWorkspaceUsageByBot(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getAllWorkspaceQuotaCompletion", () => this._innerClient.getAllWorkspaceQuotaCompletion().then((e) => e.data).catch((e) => {
      throw re(e);
    }));
    _(this, "getWorkspaceQuota", (e) => this._innerClient.getWorkspaceQuota(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listWorkspaceQuotas", (e) => this._innerClient.listWorkspaceQuotas(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "updateWorkspace", ({ id: e, ...t }) => this._innerClient.updateWorkspace({ id: e, updateWorkspaceBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "checkHandleAvailability", (e) => this._innerClient.checkHandleAvailability({ checkHandleAvailabilityBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listWorkspaces", (e) => this._innerClient.listWorkspaces(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "deleteWorkspace", (e) => this._innerClient.deleteWorkspace(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getAuditRecords", (e) => this._innerClient.getAuditRecords(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listWorkspaceMembers", (e) => this._innerClient.listWorkspaceMembers(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "deleteWorkspaceMember", (e) => this._innerClient.deleteWorkspaceMember(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "createWorkspaceMember", (e) => this._innerClient.createWorkspaceMember({ createWorkspaceMemberBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "updateWorkspaceMember", ({ id: e, ...t }) => this._innerClient.updateWorkspaceMember({ id: e, updateWorkspaceMemberBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "listIntegrationApiKeys", (e) => this._innerClient.listIntegrationApiKeys(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "createIntegrationApiKey", (e) => this._innerClient.createIntegrationApiKey({ createIntegrationApiKeyBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "deleteIntegrationApiKey", (e) => this._innerClient.deleteIntegrationApiKey(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "createIntegration", (e) => this._innerClient.createIntegration({ createIntegrationBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "updateIntegration", ({ id: e, ...t }) => this._innerClient.updateIntegration({ id: e, updateIntegrationBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "listIntegrations", (e) => this._innerClient.listIntegrations(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getIntegration", (e) => this._innerClient.getIntegration(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getIntegrationLogs", (e) => this._innerClient.getIntegrationLogs(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getIntegrationByName", (e) => this._innerClient.getIntegrationByName(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "deleteIntegration", (e) => this._innerClient.deleteIntegration(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getUsage", (e) => this._innerClient.getUsage(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listUsageHistory", (e) => this._innerClient.listUsageHistory(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "changeAISpendQuota", (e) => this._innerClient.changeAISpendQuota({ changeAISpendQuotaBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listActivities", (e) => this._innerClient.listActivities(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "introspect", (e) => this._innerClient.introspect({ introspectBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "createFile", (e) => this._innerClient.createFile({ createFileBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "deleteFile", (e) => this._innerClient.deleteFile(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listFiles", (e) => this._innerClient.listFiles(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getFileMetadata", (e) => this._innerClient.getFileMetadata(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getFileContent", (e) => this._innerClient.getFileContent(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "updateFileMetadata", ({ id: e, ...t }) => this._innerClient.updateFileMetadata({ id: e, updateFileMetadataBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "searchFiles", (e) => this._innerClient.searchFiles(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "listTables", (e) => this._innerClient.listTables(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getTable", (e) => this._innerClient.getTable(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getOrCreateTable", ({ table: e, ...t }) => this._innerClient.getOrCreateTable({ table: e, getOrCreateTableBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "createTable", (e) => this._innerClient.createTable({ createTableBody: e }).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "duplicateTable", ({ sourceTableId: e, ...t }) => this._innerClient.duplicateTable({ sourceTableId: e, duplicateTableBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "updateTable", ({ table: e, ...t }) => this._innerClient.updateTable({ table: e, updateTableBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "renameTableColumn", ({ table: e, ...t }) => this._innerClient.renameTableColumn({ table: e, renameTableColumnBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "deleteTable", (e) => this._innerClient.deleteTable(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "getTableRow", (e) => this._innerClient.getTableRow(e).then((t) => t.data).catch((t) => {
      throw re(t);
    }));
    _(this, "findTableRows", ({ table: e, ...t }) => this._innerClient.findTableRows({ table: e, findTableRowsBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "createTableRows", ({ table: e, ...t }) => this._innerClient.createTableRows({ table: e, createTableRowsBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "deleteTableRows", ({ table: e, ...t }) => this._innerClient.deleteTableRows({ table: e, deleteTableRowsBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "updateTableRows", ({ table: e, ...t }) => this._innerClient.updateTableRows({ table: e, updateTableRowsBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    _(this, "upsertTableRows", ({ table: e, ...t }) => this._innerClient.upsertTableRows({ table: e, upsertTableRowsBody: t }).then((n) => n.data).catch((n) => {
      throw re(n);
    }));
    this._innerClient = new pne(e, t, n);
  }
};
function re(e) {
  var t;
  return G.isAxiosError(e) && ((t = e.response) != null && t.data) ? Qh(e.response.data) : Qh(e);
}
var FT = 100 * 1024 * 1024, bne = FT, wne = FT, xne = class extends vne {
  constructor(t = {}) {
    let n = sne(t), r = _ne(n);
    super(void 0, n.apiUrl, r);
    _(this, "config");
    this.config = n;
  }
};
function _ne(e) {
  let { headers: t, withCredentials: n, timeout: r } = e;
  return G.create({ headers: t, withCredentials: n, timeout: r, maxBodyLength: bne, maxContentLength: wne, httpAgent: Jh ? new Xte.default.Agent({ keepAlive: !0 }) : void 0, httpsAgent: Jh ? new Qte.default.Agent({ keepAlive: !0 }) : void 0 });
}
const Sne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AlreadyExistsError: MT,
  BreakingChangesError: UT,
  Client: xne,
  ForbiddenError: wT,
  InternalError: vT,
  InvalidDataFormatError: CT,
  InvalidIdentifierError: OT,
  InvalidJsonSchemaError: TT,
  InvalidPayloadError: _T,
  InvalidQueryError: PT,
  LimitExceededError: jT,
  MethodNotFoundError: ET,
  PayloadTooLargeError: xT,
  PaymentRequiredError: DT,
  QuotaExceededError: LT,
  RateLimitedError: NT,
  ReferenceConstraintError: $T,
  ReferenceNotFoundError: RT,
  RelationConflictError: AT,
  ResourceNotFoundError: kT,
  RuntimeError: IT,
  UnauthorizedError: bT,
  UnknownError: Io,
  UnsupportedMediaTypeError: ST,
  axios: Lte,
  errorFrom: Qh,
  isApiError: yT
}, Symbol.toStringTag, { value: "Module" })), Ip = /* @__PURE__ */ _m(Sne);
(function(e) {
  var t = Object.create, n = Object.defineProperty, r = Object.getOwnPropertyDescriptor, i = Object.getOwnPropertyNames, a = Object.getPrototypeOf, o = Object.prototype.hasOwnProperty, s = (C, _e) => {
    for (var Ae in _e)
      n(C, Ae, { get: _e[Ae], enumerable: !0 });
  }, l = (C, _e, Ae, je) => {
    if (_e && typeof _e == "object" || typeof _e == "function")
      for (let Se of i(_e))
        !o.call(C, Se) && Se !== Ae && n(C, Se, { get: () => _e[Se], enumerable: !(je = r(_e, Se)) || je.enumerable });
    return C;
  }, c = (C, _e, Ae) => (l(C, _e, "default"), Ae && l(Ae, _e, "default")), u = (C, _e, Ae) => (Ae = C != null ? t(a(C)) : {}, l(_e || !C || !C.__esModule ? n(Ae, "default", { value: C, enumerable: !0 }) : Ae, C)), d = (C) => l(n({}, "__esModule", { value: !0 }), C), p = {};
  s(p, { Bot: () => ea, BotSpecificClient: () => Zt, Integration: () => At, IntegrationDefinition: () => N, IntegrationSpecificClient: () => pe, RuntimeError: () => Oe.RuntimeError, botIdHeader: () => V, botUserIdHeader: () => W, configurationHeader: () => ie, integrationIdHeader: () => de, isApiError: () => Oe.isApiError, messages: () => f, operationHeader: () => ve, parseBody: () => Pe, serve: () => qe, studioComponentDefinitions: () => g, typeHeader: () => E, webhookIdHeader: () => x, z: () => m.z }), e.exports = d(p);
  var f = {};
  s(f, { defaults: () => j });
  var h = {};
  s(h, { default: () => v, studioComponentDefinitions: () => g, z: () => m.z });
  var m = cc;
  c(h, cc);
  var y = m.z.object({ allowDynamicVariable: m.z.boolean().optional(), horizontal: m.z.boolean().optional() }), g = { string: { textInput: { id: "textInput", params: y.extend({ multiLine: m.z.boolean().optional(), growVertically: m.z.boolean().optional(), suggestions: m.z.array(m.z.string()).optional() }) }, dropdown: { id: "dropdown", params: y.extend({ filterable: m.z.boolean().optional() }) }, radiogroup: { id: "radiogroup", params: y.extend({}) }, datepicker: { id: "datepicker", params: y.extend({ dateFormat: m.z.string().optional(), minDate: m.z.string().optional(), maxDate: m.z.string().optional(), defaultTimezone: m.z.string().optional(), disableTimezoneSelection: m.z.boolean().optional(), highlightCurrentDay: m.z.boolean().optional(), showShortcutButtons: m.z.boolean().optional(), showOutsideDaysOfMonth: m.z.boolean().optional(), firstDayOfWeek: m.z.number().optional(), canChangeMonth: m.z.boolean().optional(), showWeekNumbers: m.z.boolean().optional() }) }, timepicker: { id: "timepicker", params: y.extend({ useAMPM: m.z.boolean().optional(), timeFormat: m.z.string().optional(), minTime: m.z.string().optional(), maxTime: m.z.string().optional(), showArrowButtons: m.z.boolean().optional(), precision: m.z.enum(["minute", "second", "millisecond"]).optional() }) }, variablepicker: { id: "variablepicker", params: m.z.object({ type: m.z.enum(["any", "string", "number", "boolean", "object", "pattern", "date", "array", "target", "time", "enum"]), horizontal: m.z.boolean().optional() }) }, richTextEditor: { id: "richTextEditor", params: m.z.object({ allowDynamicVariable: m.z.boolean().optional(), resizable: m.z.boolean().optional() }) }, JSONInput: { id: "JSONInput", params: y.extend({ showPreview: m.z.boolean().optional(), showValidationError: m.z.boolean().optional() }) }, fileInput: { id: "fileInput", params: y.extend({ fileTypes: m.z.array(m.z.enum(["image", "audio", "video"])).optional(), showUploadedFiles: m.z.boolean().optional() }) } }, number: { numberInput: { id: "numberInput", params: y.extend({ allowNumericCharactersOnly: m.z.boolean().optional(), stepSize: m.z.number().optional() }) }, slider: { id: "slider", params: m.z.object({ horizontal: m.z.boolean().optional(), stepSize: m.z.number().optional() }) } }, boolean: { switch: { id: "switch", params: y } }, array: { optionList: { id: "optionList", params: y }, stringList: { id: "stringList", params: y } }, object: { collapsible: { id: "collapsible", params: m.z.object({ defaultOpen: m.z.boolean().optional() }) } }, discriminatedUnion: {} }, v = m.z, b = m.z.string().min(1), T = m.z.object({ text: b }), O = m.z.object({ markdown: b }), S = m.z.object({ imageUrl: b }), P = m.z.object({ audioUrl: b }), M = m.z.object({ videoUrl: b }), L = m.z.object({ fileUrl: b, title: b.optional() }), k = m.z.object({ latitude: m.z.number(), longitude: m.z.number(), address: m.z.string().optional(), title: m.z.string().optional() }), I = m.z.object({ title: b, subtitle: b.optional(), imageUrl: b.optional(), actions: m.z.array(m.z.object({ action: m.z.enum(["postback", "url", "say"]), label: b, value: b })) }), B = m.z.object({ text: b, options: m.z.array(m.z.object({ label: b, value: b })) }), U = m.z.object({ items: m.z.array(I) }), z = m.z.discriminatedUnion("type", [m.z.object({ type: m.z.literal("text"), payload: T }), m.z.object({ type: m.z.literal("markdown"), payload: O }), m.z.object({ type: m.z.literal("image"), payload: S }), m.z.object({ type: m.z.literal("audio"), payload: P }), m.z.object({ type: m.z.literal("video"), payload: M }), m.z.object({ type: m.z.literal("file"), payload: L }), m.z.object({ type: m.z.literal("location"), payload: k })]), D = m.z.object({ items: m.z.array(z) }), j = { text: { schema: T }, markdown: { schema: O }, image: { schema: S }, audio: { schema: P }, video: { schema: M }, file: { schema: L }, location: { schema: k }, carousel: { schema: U }, card: { schema: I }, dropdown: { schema: B }, choice: { schema: B }, bloc: { schema: D } }, V = "x-bot-id", W = "x-bot-user-id", de = "x-integration-id", x = "x-webhook-id", ie = "x-bp-configuration", ve = "x-bp-operation", E = "x-bp-type", ke = qh, Ze = console;
  function Pe(C) {
    if (!C.body)
      throw new Error("Missing body");
    return JSON.parse(C.body);
  }
  async function qe(C, _e = 8072, Ae = he) {
    let je = (0, ke.createServer)(async (Se, $e) => {
      try {
        let lt = await rt(Se);
        if (lt.path === "/health") {
          $e.writeHead(200).end("ok");
          return;
        }
        let ht = await C(lt);
        $e.writeHead((ht == null ? void 0 : ht.status) ?? 200, (ht == null ? void 0 : ht.headers) ?? {}).end((ht == null ? void 0 : ht.body) ?? "{}");
      } catch (lt) {
        Ze.error("Error while handling request", { error: (lt == null ? void 0 : lt.message) ?? "Internal error occured" }), $e.writeHead(500).end(JSON.stringify({ error: (lt == null ? void 0 : lt.message) ?? "Internal error occured" }));
      }
    });
    return je.listen(_e, () => Ae(_e)), je;
  }
  async function rt(C) {
    var Se;
    let _e = await be(C), Ae = {};
    for (let $e = 0; $e < C.rawHeaders.length; $e += 2) {
      let lt = C.rawHeaders[$e].toLowerCase(), ht = C.rawHeaders[$e + 1];
      Ae[lt] = ht;
    }
    let je = new URL(C.url ?? "", C.headers.host ? `http://${C.headers.host}` : "http://botpress.cloud");
    return { body: _e, path: je.pathname, query: Ve(je.search, "?"), headers: Ae, method: ((Se = C.method) == null ? void 0 : Se.toUpperCase()) ?? "GET" };
  }
  function Ve(C, _e) {
    return C.indexOf(_e) === 0 ? C.slice(_e.length) : C;
  }
  async function be(C) {
    return new Promise((_e, Ae) => {
      if (C.method !== "POST" && C.method !== "PUT" && C.method !== "PATCH")
        return _e(void 0);
      let je = "";
      C.on("data", (Se) => je += Se.toString()), C.on("error", (Se) => Ae(Se)), C.on("end", () => _e(je));
    });
  }
  function he(C) {
    Ze.info(`Listening on port ${C}`);
  }
  c(p, h, e.exports);
  var Oe = Ip, we = cc, Fe = we.z.enum(["webhook_received", "message_created", "action_triggered", "register", "unregister", "ping", "create_user", "create_conversation"]), st = (C) => {
    let _e = C[V], Ae = C[W], je = C[de], Se = C[x], $e = C[ie], lt = Fe.parse(C[ve]);
    if (!_e)
      throw new Error("Missing bot headers");
    if (!Ae)
      throw new Error("Missing bot user headers");
    if (!je)
      throw new Error("Missing integration headers");
    if (!Se)
      throw new Error("Missing webhook headers");
    if (!$e)
      throw new Error("Missing configuration headers");
    if (!lt)
      throw new Error("Missing operation headers");
    return { botId: _e, botUserId: Ae, integrationId: je, webhookId: Se, operation: lt, configuration: $e ? JSON.parse(Buffer.from($e, "base64").toString("utf-8")) : {} };
  }, N = class {
    constructor(C) {
      _(this, "name");
      _(this, "version");
      _(this, "title");
      _(this, "description");
      _(this, "icon");
      _(this, "readme");
      _(this, "configuration");
      _(this, "events");
      _(this, "actions");
      _(this, "channels");
      _(this, "states");
      _(this, "user");
      _(this, "secrets");
      _(this, "identifier");
      _(this, "entities");
      this.props = C, this.name = C.name, this.version = C.version, this.icon = C.icon, this.readme = C.readme, this.title = C.title, this.identifier = C.identifier, this.description = C.description, this.configuration = C.configuration, this.events = C.events, this.actions = C.actions, this.channels = C.channels, this.states = C.states, this.user = C.user, this.secrets = C.secrets, this.entities = C.entities;
    }
  }, le = Ip, pe = class {
    constructor(C) {
      _(this, "createConversation", (C) => this.client.createConversation(C));
      _(this, "getConversation", (C) => this.client.getConversation(C));
      _(this, "listConversations", (C) => this.client.listConversations(C));
      _(this, "getOrCreateConversation", (C) => this.client.getOrCreateConversation(C));
      _(this, "updateConversation", (C) => this.client.updateConversation(C));
      _(this, "deleteConversation", (C) => this.client.deleteConversation(C));
      _(this, "listParticipants", (C) => this.client.listParticipants(C));
      _(this, "addParticipant", (C) => this.client.addParticipant(C));
      _(this, "getParticipant", (C) => this.client.getParticipant(C));
      _(this, "removeParticipant", (C) => this.client.removeParticipant(C));
      _(this, "createEvent", (C) => this.client.createEvent(C));
      _(this, "getEvent", (C) => this.client.getEvent(C));
      _(this, "listEvents", (C) => this.client.listEvents(C));
      _(this, "createMessage", (C) => this.client.createMessage(C));
      _(this, "getOrCreateMessage", (C) => this.client.getOrCreateMessage(C));
      _(this, "getMessage", (C) => this.client.getMessage(C));
      _(this, "updateMessage", (C) => this.client.updateMessage(C));
      _(this, "listMessages", (C) => this.client.listMessages(C));
      _(this, "deleteMessage", (C) => this.client.deleteMessage(C));
      _(this, "createUser", (C) => this.client.createUser(C));
      _(this, "getUser", (C) => this.client.getUser(C));
      _(this, "listUsers", (C) => this.client.listUsers(C));
      _(this, "getOrCreateUser", (C) => this.client.getOrCreateUser(C));
      _(this, "updateUser", (C) => this.client.updateUser(C));
      _(this, "deleteUser", (C) => this.client.deleteUser(C));
      _(this, "getState", (C) => this.client.getState(C));
      _(this, "setState", (C) => this.client.setState(C));
      _(this, "getOrSetState", (C) => this.client.getOrSetState(C));
      _(this, "patchState", (C) => this.client.patchState(C));
      _(this, "configureIntegration", (C) => this.client.configureIntegration(C));
      this.client = C;
    }
  }, ue = u(qh), Le = (C) => {
    if (process.env.BP_LOG_FORMAT === "json")
      return JSON.stringify({ msg: ue.default.format(...C), visible_to_bot_owner: !0 });
    {
      let [_e, ...Ae] = C;
      return ue.default.format(`[For Bot Owner] ${_e}`, ...Ae);
    }
  }, Me = { forBot: () => ({ info: (...C) => {
    console.info(Le(C));
  }, warn: (...C) => {
    console.warn(Le(C));
  }, error: (...C) => {
    console.error(Le(C));
  }, debug: (...C) => {
    console.debug(Le(C));
  } }) }, Ke = (C) => async (_e) => {
    let Ae = st(_e.headers), je = new pe(new le.Client({ botId: Ae.botId, integrationId: Ae.integrationId })), Se = { ctx: Ae, req: _e, client: je, logger: Me, instance: C };
    try {
      let $e;
      switch (Ae.operation) {
        case "webhook_received":
          $e = await tt(Se);
          break;
        case "register":
          $e = await Z(Se);
          break;
        case "unregister":
          $e = await J(Se);
          break;
        case "message_created":
          $e = await it(Se);
          break;
        case "action_triggered":
          $e = await zt(Se);
          break;
        case "ping":
          $e = await gt(Se);
          break;
        case "create_user":
          $e = await ce(Se);
          break;
        case "create_conversation":
          $e = await Ne(Se);
          break;
        default:
          throw new Error(`Unknown operation ${Ae.operation}`);
      }
      return $e ? { ...$e, status: $e.status ?? 200 } : { status: 200 };
    } catch ($e) {
      if ((0, le.isApiError)($e)) {
        let lt = new le.RuntimeError($e.message, $e);
        return { status: lt.code, body: JSON.stringify(lt.toJSON()) };
      }
      throw $e;
    }
  }, gt = async (C) => {
  }, tt = async ({ client: C, ctx: _e, req: Ae, logger: je, instance: Se }) => {
    let { req: $e } = Pe(Ae);
    return Se.webhook({ client: C, ctx: _e, req: $e, logger: je });
  }, Z = async ({ client: C, ctx: _e, req: Ae, logger: je, instance: Se }) => {
    if (!Se.register)
      return;
    let { webhookUrl: $e } = Pe(Ae);
    await Se.register({ client: C, ctx: _e, webhookUrl: $e, logger: je });
  }, J = async ({ client: C, ctx: _e, req: Ae, logger: je, instance: Se }) => {
    if (!Se.unregister)
      return;
    let { webhookUrl: $e } = Pe(Ae);
    await Se.unregister({ ctx: _e, webhookUrl: $e, client: C, logger: je });
  }, ce = async ({ client: C, ctx: _e, req: Ae, logger: je, instance: Se }) => {
    if (!Se.createUser)
      return;
    let { tags: $e } = Pe(Ae);
    return await Se.createUser({ ctx: _e, client: C, tags: $e, logger: je });
  }, Ne = async ({ client: C, ctx: _e, req: Ae, logger: je, instance: Se }) => {
    if (!Se.createConversation)
      return;
    let { channel: $e, tags: lt } = Pe(Ae);
    return await Se.createConversation({ ctx: _e, client: C, channel: $e, tags: lt, logger: je });
  }, it = async ({ ctx: C, req: _e, client: Ae, logger: je, instance: Se }) => {
    let { conversation: $e, user: lt, type: ht, payload: Dt, message: Vt } = Pe(_e), Fn = Se.channels[$e.channel];
    if (!Fn)
      throw new Error(`Channel ${$e.channel} not found`);
    let fr = Fn.messages[ht];
    if (!fr)
      throw new Error(`Message of type ${ht} not found in channel ${$e.channel}`);
    await fr({ ctx: C, conversation: $e, message: Vt, user: lt, type: ht, client: Ae, payload: Dt, ack: async ({ tags: zf }) => {
      await Ae.updateMessage({ id: Vt.id, tags: zf });
    }, logger: je });
  }, zt = async ({ req: C, ctx: _e, client: Ae, logger: je, instance: Se }) => {
    let { input: $e, type: lt } = Pe(C);
    if (!lt)
      throw new Error("Missing action type");
    let ht = Se.actions[lt];
    if (!ht)
      throw new Error(`Action ${lt} not found`);
    let Dt = await ht({ ctx: _e, input: $e, client: Ae, type: lt, logger: je });
    return { body: JSON.stringify({ output: Dt }) };
  }, At = class {
    constructor(C) {
      _(this, "props");
      _(this, "actions");
      _(this, "channels");
      _(this, "register");
      _(this, "unregister");
      _(this, "createUser");
      _(this, "createConversation");
      _(this, "webhook");
      _(this, "handler", Ke(this));
      _(this, "start", (C) => qe(this.handler, C));
      this.props = C, this.actions = C.actions, this.channels = C.channels, this.register = C.register, this.unregister = C.unregister, this.createUser = C.createUser, this.createConversation = C.createConversation, this.webhook = C.handler;
    }
  }, Ct = u(Ip), Zt = class {
    constructor(C) {
      _(this, "getConversation", (C) => this.client.getConversation(C));
      _(this, "listConversations", (C) => this.client.listConversations(C));
      _(this, "updateConversation", (C) => this.client.updateConversation(C));
      _(this, "deleteConversation", (C) => this.client.deleteConversation(C));
      _(this, "listParticipants", (C) => this.client.listParticipants(C));
      _(this, "addParticipant", (C) => this.client.addParticipant(C));
      _(this, "getParticipant", (C) => this.client.getParticipant(C));
      _(this, "removeParticipant", (C) => this.client.removeParticipant(C));
      _(this, "getEvent", (C) => this.client.getEvent(C));
      _(this, "listEvents", (C) => this.client.listEvents(C));
      _(this, "createMessage", (C) => this.client.createMessage(C));
      _(this, "getOrCreateMessage", (C) => this.client.getOrCreateMessage(C));
      _(this, "getMessage", (C) => this.client.getMessage(C));
      _(this, "updateMessage", (C) => this.client.updateMessage(C));
      _(this, "listMessages", (C) => this.client.listMessages(C));
      _(this, "deleteMessage", (C) => this.client.deleteMessage(C));
      _(this, "getUser", (C) => this.client.getUser(C));
      _(this, "listUsers", (C) => this.client.listUsers(C));
      _(this, "updateUser", (C) => this.client.updateUser(C));
      _(this, "deleteUser", (C) => this.client.deleteUser(C));
      _(this, "getState", (C) => this.client.getState(C).then((_e) => ({ state: { ..._e.state, payload: _e.state.payload } })));
      _(this, "setState", (C) => this.client.setState(C).then((_e) => ({ state: { ..._e.state, payload: _e.state.payload } })));
      _(this, "getOrSetState", (C) => this.client.getOrSetState(C).then((_e) => ({ state: { ..._e.state, payload: _e.state.payload } })));
      _(this, "patchState", (C) => this.client.patchState(C).then((_e) => ({ state: { ..._e.state, payload: _e.state.payload } })));
      _(this, "callAction", (C) => this.client.callAction(C));
      _(this, "createConversation", (C) => this.client.createConversation(C));
      _(this, "getOrCreateConversation", (C) => this.client.getOrCreateConversation(C));
      _(this, "createUser", (C) => this.client.createUser(C));
      _(this, "getOrCreateUser", (C) => this.client.getOrCreateUser(C));
      this.client = C;
    }
  }, Sn = cc, qt = Sn.z.enum(["event_received", "register", "unregister", "ping", "action_triggered"]), Yt = (C) => {
    let _e = C[V], Ae = C[ie], je = C[E], Se = qt.parse(C[ve]);
    if (!_e)
      throw new Error("Missing bot headers");
    if (!je)
      throw new Error("Missing type headers");
    if (!Ae)
      throw new Error("Missing configuration headers");
    if (!Se)
      throw new Error("Missing operation headers");
    return { botId: _e, operation: Se, type: je, configuration: Ae ? JSON.parse(Buffer.from(Ae, "base64").toString("utf-8")) : {} };
  }, fn = (C) => async (_e) => {
    let Ae = Yt(_e.headers);
    Ae.operation !== "ping" && Ze.info(`Received ${Ae.operation} operation for bot ${Ae.botId} of type ${Ae.type}`);
    let je = new Zt(new Ct.Client({ botId: Ae.botId })), Se = { req: _e, ctx: Ae, client: je, instance: C };
    switch (Ae.operation) {
      case "action_triggered":
        throw new Error(`Operation ${Ae.operation} not supported yet`);
      case "event_received":
        await Cr(Se);
        break;
      case "register":
        await Gr();
        break;
      case "unregister":
        await rr();
        break;
      case "ping":
        await an();
        break;
      default:
        throw new Error(`Unknown operation ${Ae.operation}`);
    }
    return { status: 200 };
  }, an = async (C) => {
  }, Gr = async (C) => {
  }, rr = async (C) => {
  }, Cr = async ({ ctx: C, req: _e, client: Ae, instance: je }) => {
    Ze.debug(`Received event ${C.type}`);
    let Se = Pe(_e), $e = Se.event;
    switch (C.type) {
      case "message_created":
        let lt = { user: $e.payload.user, conversation: $e.payload.conversation, message: $e.payload.message, states: $e.payload.states, event: $e };
        await Promise.all(je.messageHandlers.map((Vt) => Vt({ client: Ae, ctx: C, ...lt })));
        break;
      case "state_expired":
        let ht = { state: $e.payload.state };
        await Promise.all(je.stateExpiredHandlers.map((Vt) => Vt({ client: Ae, ctx: C, ...ht })));
        break;
      default:
        let Dt = { event: Se.event };
        await Promise.all(je.eventHandlers.map((Vt) => Vt({ client: Ae, ctx: C, ...Dt })));
    }
  }, ea = class {
    constructor(C) {
      _(this, "_state", { messageHandlers: [], eventHandlers: [], stateExpiredHandlers: [] });
      _(this, "props");
      _(this, "message", (C) => {
        this._state.messageHandlers.push(C);
      });
      _(this, "event", (C) => {
        this._state.eventHandlers.push(C);
      });
      _(this, "stateExpired", (C) => {
        this._state.stateExpiredHandlers.push(C);
      });
      _(this, "handler", fn(this._state));
      _(this, "start", (C) => qe(this.handler, C));
      this.props = C;
    }
  };
})(h1);
var H = h1.exports;
const { defaults: Hr } = H.messages, kr = { className: H.z.string().describe("CSS className to apply to the message").optional() }, BT = Hr.audio.schema.extend({ ...kr, type: H.z.literal("audio") }), ry = Hr.card.schema.extend({
  type: H.z.literal("card"),
  subtitle: H.z.string().optional(),
  imageUrl: H.z.string().optional(),
  ...kr
}), Ene = ry.omit({ type: !0 }), zT = H.z.object({
  items: H.z.array(Ene),
  ...kr,
  type: H.z.literal("carousel")
}), ZT = Hr.choice.schema.extend({
  text: H.z.string(),
  ...kr,
  type: H.z.literal("choice"),
  disableFreeText: H.z.boolean().optional()
}), qT = Hr.dropdown.schema.extend({
  text: H.z.string(),
  ...kr,
  type: H.z.literal("dropdown")
}), WT = Hr.file.schema.extend({ ...kr, type: H.z.literal("file") }), VT = Hr.image.schema.extend({ ...kr, type: H.z.literal("image") }), HT = Hr.location.schema.extend({ ...kr, type: H.z.literal("location") }), KT = Hr.markdown.schema.extend({ ...kr, type: H.z.literal("markdown") }), GT = Hr.text.schema.extend({ ...kr, type: H.z.literal("text") }), JT = Hr.video.schema.extend({ ...kr, type: H.z.literal("video") }), YT = H.z.union([
  BT,
  ry,
  zT,
  ZT,
  qT,
  WT,
  VT,
  HT,
  KT,
  GT,
  JT
]), XT = H.z.object({
  type: H.z.literal("webchat_visibility"),
  data: H.z.object({
    visibility: H.z.union([H.z.literal("show"), H.z.literal("hide"), H.z.literal("toggle")])
  })
}), QT = H.z.object({
  type: H.z.literal("webchat_config"),
  data: H.z.object({
    config: H.z.record(H.z.any())
  })
}), eC = H.z.object({
  type: H.z.literal("custom"),
  data: H.z.object({
    event: H.z.record(H.z.any())
  })
}), tC = H.z.union([XT, QT, eC]), kne = tC, Tne = H.z.object({
  type: H.z.literal("message_created"),
  data: YT
}), Cne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audioSchema: BT,
  cardSchema: ry,
  carouselSchema: zT,
  choiceSchema: ZT,
  customSchema: eC,
  dropdownSchema: qT,
  fileSchema: WT,
  imageSchema: VT,
  locationSchema: HT,
  markdownSchema: KT,
  messageCreatedSchema: Tne,
  messageSchema: YT,
  textSchema: GT,
  triggerSchema: tC,
  triggerSignalSchema: kne,
  videoSchema: JT,
  webchatConfigSchema: QT,
  webchatVisibilitySchema: XT
}, Symbol.toStringTag, { value: "Module" })), Kr = H.z.object({ className: H.z.string().optional(), avatarUrl: H.z.string().url().optional() }), nC = Kr.extend({
  type: H.z.literal("audio"),
  audio: H.z.string(),
  title: H.z.string().optional()
}), One = H.z.union([
  H.z.object({
    title: H.z.string(),
    action: H.z.literal("Say something"),
    text: H.z.string()
  }),
  H.z.object({
    title: H.z.string(),
    action: H.z.literal("Open URL"),
    url: H.z.string()
  }),
  H.z.object({
    title: H.z.string(),
    action: H.z.literal("Postback"),
    payload: H.z.string()
  })
]), iy = Kr.extend({
  type: H.z.literal("card"),
  title: H.z.string(),
  subtitle: H.z.string().optional(),
  image: H.z.string().optional(),
  actions: H.z.array(One)
  // not sure if this is optional - fleur
}), rC = Kr.extend({
  type: H.z.literal("carousel"),
  items: H.z.array(iy)
}), iC = Kr.extend({
  type: H.z.literal("dropdown"),
  message: H.z.string().optional(),
  options: H.z.array(H.z.object({ label: H.z.string(), value: H.z.string() })),
  allowCreation: H.z.boolean().optional(),
  placeholderText: H.z.string().optional(),
  allowMultiple: H.z.boolean().optional(),
  buttonText: H.z.string().optional(),
  width: H.z.number().optional(),
  displayInKeyboard: H.z.boolean().optional(),
  markdown: H.z.boolean().optional(),
  text: H.z.string().optional()
}), aC = Kr.extend({
  type: H.z.literal("file"),
  file: H.z.string(),
  title: H.z.string().optional()
}), oC = Kr.extend({
  type: H.z.literal("image"),
  image: H.z.string()
}), sC = Kr.extend({
  type: H.z.literal("location"),
  latitude: H.z.number(),
  longitude: H.z.number(),
  address: H.z.string().optional(),
  title: H.z.string().optional()
}), lC = Kr.extend({
  type: H.z.literal("single-choice"),
  text: H.z.string(),
  disableFreeText: H.z.boolean().optional(),
  choices: H.z.array(H.z.object({ title: H.z.string(), value: H.z.string() }))
}), cC = Kr.extend({
  type: H.z.literal("text"),
  text: H.z.string(),
  markdown: H.z.boolean().optional()
}), uC = Kr.extend({
  type: H.z.literal("video"),
  video: H.z.string(),
  title: H.z.string().optional()
}), dC = H.z.object({
  type: H.z.literal("quick_reply"),
  text: H.z.string(),
  payload: H.z.string().optional()
}), nd = H.z.union([
  nC,
  iy,
  rC,
  iC,
  aC,
  oC,
  sC,
  lC,
  cC,
  uC,
  dC
]), fC = H.z.object({
  type: H.z.literal("webchat-visibility"),
  visibility: H.z.union([H.z.literal("show"), H.z.literal("hide"), H.z.literal("toggle")])
}), pC = H.z.object({
  type: H.z.literal("webchat-config"),
  config: H.z.record(H.z.any())
}), hC = H.z.object({
  type: H.z.literal("custom-event"),
  event: H.z.record(H.z.any())
}), mC = H.z.union([fC, pC, hC]), Ane = H.z.object({
  type: H.z.literal("trigger"),
  trigger: mC
}), $ne = nd, Rne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audioSchema: nC,
  cardSchema: iy,
  carouselSchame: rC,
  customEventSchema: hC,
  dropdownSchema: iC,
  fileSchema: aC,
  imageSchema: oC,
  locationSchema: sC,
  messageSchema: nd,
  messageSignalSchema: $ne,
  quickReplySchema: dC,
  singleChoiceSchema: lC,
  textSchema: cC,
  triggerSchema: mC,
  triggerSignalSchema: Ane,
  videoSchema: uC,
  webchatConfigSchema: pC,
  webchatVisibilitySchema: fC
}, Symbol.toStringTag, { value: "Module" })), gC = (e) => ({
  type: "card",
  title: e.title,
  subtitle: e.subtitle,
  image: e.imageUrl,
  actions: e.actions.map(Pne)
}), Pne = (e) => {
  switch (e.action) {
    case "postback":
      return { title: e.label, action: "Postback", payload: e.value };
    case "url":
      return { title: e.label, action: "Open URL", url: e.value };
    case "say":
      return { title: e.label, action: "Say something", text: e.value };
    default:
      throw new Error(`Unknown action type ${e.action}`);
  }
}, yC = (e) => ({
  ...e,
  type: "audio",
  audio: e.audioUrl
}), vC = (e) => gC(e), bC = (e) => ({
  ...e,
  type: "carousel",
  items: e.items.map(gC)
}), wC = (e) => ({
  ...e,
  type: "single-choice",
  text: e.text,
  choices: e.options.map((t) => ({ title: t.label, value: t.value })),
  disableFreeText: e.disableFreeText
}), xC = (e) => ({
  ...e,
  type: "dropdown",
  message: e.text,
  options: e.options.map((t) => ({ label: t.label, value: t.value }))
}), _C = (e) => ({
  ...e,
  type: "file",
  file: e.fileUrl,
  title: e.title
}), SC = (e) => ({
  ...e,
  type: "image",
  image: e.imageUrl
}), EC = (e) => ({
  ...e,
  type: "location",
  latitude: e.latitude,
  longitude: e.longitude
}), kC = (e) => ({
  ...e,
  type: "text",
  text: e.markdown,
  markdown: !0
}), TC = (e) => ({
  ...e,
  type: "text",
  text: e.text,
  markdown: !0
}), CC = (e) => ({
  ...e,
  type: "video",
  video: e.videoUrl
}), Ine = (e) => {
  switch (e.type) {
    case "audio":
      return yC(e);
    case "card":
      return vC(e);
    case "carousel":
      return bC(e);
    case "choice":
      return wC(e);
    case "dropdown":
      return xC(e);
    case "file":
      return _C(e);
    case "image":
      return SC(e);
    case "location":
      return EC(e);
    case "markdown":
      return kC(e);
    case "text":
      return TC(e);
    case "video":
      return CC(e);
    default:
      throw new Error("Unsuported message type");
  }
}, OC = (e) => ({
  type: "webchat-visibility",
  visibility: e.data.visibility
}), AC = (e) => ({
  type: "webchat-config",
  config: e.data.config
}), $C = (e) => ({
  type: "custom-event",
  event: e.data.event
}), Mne = (e) => {
  switch (e.type) {
    case "webchat_visibility":
      return OC(e);
    case "webchat_config":
      return AC(e);
    case "custom":
      return $C(e);
    default:
      throw new Error("unknown trigger type");
  }
}, Nne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  audioAdapter: yC,
  cardAdapter: vC,
  carouselAdapter: bC,
  choiceAdapter: wC,
  customAdapter: $C,
  dropdownAdapter: xC,
  fileAdapter: _C,
  imageAdapter: SC,
  locationAdapter: EC,
  markdownAdapter: kC,
  messageAdapter: Ine,
  textAdapter: TC,
  triggerAdapter: Mne,
  videoAdapter: CC,
  webchatConfigAdapter: AC,
  webchatVisibilityAdapter: OC
}, Symbol.toStringTag, { value: "Module" })), RC = (e) => ({
  type: "card",
  title: e.title,
  subtitle: e.subtitle,
  imageUrl: e.image,
  actions: e.actions.map(Dne)
}), Dne = (e) => {
  switch (e.action) {
    case "Postback":
      return { label: e.title, action: "postback", value: e.payload };
    case "Open URL":
      return { label: e.title, action: "url", value: e.url };
    case "Say something":
      return { label: e.title, action: "say", value: e.text };
    default:
      throw new Error("Unknown action type");
  }
}, Lne = (e) => ({
  ...e,
  type: "audio",
  audioUrl: e.audio
}), jne = (e) => RC(e), Une = (e) => ({
  ...e,
  type: "carousel",
  items: e.items.map(RC)
}), Fne = (e) => ({
  ...e,
  type: "dropdown",
  text: e.message ?? "",
  options: e.options.map((t) => ({ label: t.label, value: t.value }))
}), Bne = (e) => ({
  ...e,
  type: "file",
  fileUrl: e.file,
  title: e.title
}), zne = (e) => ({
  ...e,
  type: "image",
  imageUrl: e.image
}), Zne = (e) => ({
  ...e,
  type: "location",
  latitude: e.latitude,
  longitude: e.longitude
}), qne = (e) => ({
  ...e,
  type: "choice",
  text: e.text,
  options: e.choices.map((t) => ({ label: t.title, value: t.value })),
  disableFreeText: e.disableFreeText
}), Wne = (e) => ({
  ...e,
  type: "text",
  text: e.text
}), Vne = (e) => ({
  ...e,
  type: "video",
  videoUrl: e.video
}), Hne = (e) => ({
  ...e,
  type: "text",
  text: e.text ?? e.payload
}), Kne = (e) => {
  switch (e.type) {
    case "audio":
      return Lne(e);
    case "card":
      return jne(e);
    case "carousel":
      return Une(e);
    case "dropdown":
      return Fne(e);
    case "file":
      return Bne(e);
    case "image":
      return zne(e);
    case "location":
      return Zne(e);
    case "single-choice":
      return qne(e);
    case "text":
      return Wne(e);
    case "video":
      return Vne(e);
    case "quick_reply":
      return Hne(e);
    default:
      throw new Error("Unsuported message type");
  }
}, Gne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  messageAdapter: Kne
}, Symbol.toStringTag, { value: "Module" })), Jne = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  messaging: Rne,
  messagingToWebChat: Gne,
  webchat: Cne,
  webchatToMessaging: Nne
}, Symbol.toStringTag, { value: "Module" }));
let uc;
const Yne = new Uint8Array(16);
function Xne() {
  if (!uc && (uc = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !uc))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return uc(Yne);
}
const vn = [];
for (let e = 0; e < 256; ++e)
  vn.push((e + 256).toString(16).slice(1));
function Qne(e, t = 0) {
  return vn[e[t + 0]] + vn[e[t + 1]] + vn[e[t + 2]] + vn[e[t + 3]] + "-" + vn[e[t + 4]] + vn[e[t + 5]] + "-" + vn[e[t + 6]] + vn[e[t + 7]] + "-" + vn[e[t + 8]] + vn[e[t + 9]] + "-" + vn[e[t + 10]] + vn[e[t + 11]] + vn[e[t + 12]] + vn[e[t + 13]] + vn[e[t + 14]] + vn[e[t + 15]];
}
const ere = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), Pw = {
  randomUUID: ere
};
function tre(e, t, n) {
  if (Pw.randomUUID && !t && !e)
    return Pw.randomUUID();
  e = e || {};
  const r = e.random || (e.rng || Xne)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, t) {
    n = n || 0;
    for (let i = 0; i < 16; ++i)
      t[n + i] = r[i];
    return t;
  }
  return Qne(r);
}
const Pf = (e) => ({
  block: e,
  type: "bubble"
}), nre = (e) => e.action === "Say something" ? {
  type: "button",
  variant: "action",
  text: e.title,
  buttonValue: e.text,
  reusable: !0
} : e.action === "Open URL" ? {
  type: "button",
  variant: "link",
  text: e.title,
  buttonValue: e.url,
  reusable: !0
} : {
  type: "button",
  variant: "action",
  text: e.title,
  buttonValue: e.payload,
  reusable: !0
}, PC = ({
  title: e,
  image: t,
  actions: n,
  subtitle: r
}) => {
  const i = [];
  return t && i.push({
    type: "image",
    url: t
  }), e && i.push({
    type: "text",
    text: `## ${e}`
  }), r && i.push({
    type: "text",
    text: r
  }), n.length > 0 && i.push({
    type: "row",
    blocks: n.map(nre)
  }), {
    type: "column",
    horizontalAlignment: "center",
    blocks: [...i]
  };
}, rre = ({ choices: e, text: t }) => {
  const n = tre(), r = Pf({
    type: "text",
    text: t
  });
  return e.length === 0 ? r : {
    type: "column",
    horizontalAlignment: "left",
    blocks: [
      r,
      {
        type: "row",
        blocks: e.map(({ title: i, value: a }) => ({
          type: "button",
          variant: "action",
          text: i,
          buttonValue: a,
          groupId: n
        }))
      }
    ]
  };
}, ire = ({ options: e, text: t }) => {
  const n = [
    {
      type: "dropdown",
      label: t ?? "Select an option",
      options: e
    }
  ];
  return t && n.unshift({
    type: "text",
    text: t
  }), {
    type: "column",
    blocks: n
  };
}, IC = ({ type: e, audio: t }) => ({
  payload: { type: e, url: t }
}), MC = (e) => ({
  payload: Pf(PC(e))
}), NC = ({ items: e }) => ({
  payload: {
    type: "carousel",
    blocks: e.map(PC)
  }
}), DC = (e) => ({
  disableInput: e.disableFreeText,
  payload: rre(e)
}), LC = (e) => ({
  disableInput: !0,
  payload: Pf(ire(e))
}), jC = ({ file: e, ...t }) => ({
  payload: {
    url: e,
    ...t
  }
}), UC = ({ type: e, image: t }) => ({
  payload: { type: e, url: t }
}), FC = ({ type: e, latitude: t, longitude: n, title: r, address: i }) => ({
  payload: {
    type: e,
    latitude: t,
    longitude: n,
    title: r ?? i ?? "View on map"
  }
}), are = ({ text: e, payload: t }) => ({
  payload: {
    type: "text",
    text: e ?? t
  }
}), ay = ({ type: e, text: t }) => ({
  payload: Pf({ type: e, text: t })
}), BC = ({ type: e, video: t }) => ({
  payload: { type: e, url: t }
}), Iw = (e) => {
  switch (e.type) {
    case "audio":
      return IC(e);
    case "card":
      return MC(e);
    case "carousel":
      return NC(e);
    case "single-choice":
      return DC(e);
    case "dropdown":
      return LC(e);
    case "file":
      return jC(e);
    case "image":
      return UC(e);
    case "location":
      return FC(e);
    case "quick_reply":
      return are(e);
    case "text":
      return ay(e);
    case "video":
      return BC(e);
    default:
      throw new Error("Unsuported message type");
  }
}, { webchatToMessaging: Tr } = Jne, ore = (e) => {
  const t = Tr.audioAdapter(e);
  return IC(t);
}, sre = (e) => {
  const t = Tr.cardAdapter(e);
  return MC(t);
}, lre = (e) => {
  const t = Tr.carouselAdapter(e);
  return NC(t);
}, cre = (e) => {
  const t = Tr.choiceAdapter(e);
  return DC(t);
}, ure = (e) => {
  const t = Tr.dropdownAdapter(e);
  return LC(t);
}, dre = (e) => {
  const t = Tr.fileAdapter(e);
  return jC(t);
}, fre = (e) => {
  const t = Tr.imageAdapter(e);
  return UC(t);
}, pre = (e) => {
  const t = Tr.locationAdapter(e);
  return FC(t);
}, hre = (e) => {
  const t = Tr.markdownAdapter(e);
  return ay(t);
}, mre = (e) => {
  const t = Tr.textAdapter(e);
  return ay(t);
}, gre = (e) => {
  const t = Tr.videoAdapter(e);
  return BC(t);
}, yre = (e) => {
  switch (e.type) {
    case "audio":
      return ore(e);
    case "card":
      return sre(e);
    case "carousel":
      return lre(e);
    case "choice":
      return cre(e);
    case "dropdown":
      return ure(e);
    case "file":
      return dre(e);
    case "image":
      return fre(e);
    case "location":
      return pre(e);
    case "markdown":
      return hre(e);
    case "text":
      return mre(e);
    case "video":
      return gre(e);
    default:
      throw new Error("Unsuported message type");
  }
};
class vre {
  constructor(t) {
    _(this, "socket");
    _(this, "clientId");
    _(this, "apiUrl");
    _(this, "userId");
    _(this, "conversationId");
    _(this, "userToken");
    _(this, "connected", !1);
    _(this, "emitter");
    _(this, "on");
    _(this, "mode", "messaging");
    this.socket = new V_.MessagingSocket(t), this.emitter = new Em(), this.clientId = t.clientId, this.apiUrl = t.url, this.on = this.emitter.on.bind(this.emitter), this.socket.on("message", (n) => {
      const r = n.payload;
      if (r.type === "trigger")
        switch (r.trigger.type) {
          case "webchat-visibility":
            this.emitter.emit("webchatVisibility", r.trigger.visibility);
            break;
          case "webchat-config":
            this.emitter.emit("webchatConfig", r.trigger.config);
            break;
          case "custom-event":
            this.emitter.emit("customEvent", r.trigger.event);
            break;
        }
      else {
        const i = nd.parse(r), { payload: a, disableInput: o } = Iw(i);
        this.emitter.emit("message", {
          ...n,
          payload: a,
          disableInput: o
        });
      }
    }), this.socket.on("conversation", (n) => {
      this.emitter.emit("conversation", n);
    });
  }
  async connect(t, n) {
    if (this.connected)
      return;
    this.connected = !0;
    const r = await this.socket.connect(t, n).catch((i) => {
      throw this.connected = !1, i;
    });
    return this.userId = r.userId, this.userToken = r.userToken, r;
  }
  async disconnect() {
    await this.socket.disconnect(), this.connected = !1;
  }
  async getUser() {
    throw new Error("Get user is not supported in messaging mode");
  }
  async updateUser() {
    throw new Error("Update user is not supported in messaging mode");
  }
  async sendMessage(t) {
    this.conversationId || await this.newConversation(), await this.socket.sendText(t), this.emitter.emit("messageSent", t);
  }
  async sendEvent(t) {
    this.conversationId || await this.newConversation(), await this.socket.sendPayload({ type: "trigger", payload: t });
  }
  async switchConversation(t) {
    await this.socket.switchConversation(t), this.conversationId = t;
  }
  async conversationExists(t) {
    return (await this.socket.listConversations()).some((r) => r.id === t);
  }
  async newConversation() {
    const { id: t } = await this.socket.createConversation();
    await this.socket.startConversation(), this.conversationId = t;
  }
  async listMessages(t) {
    return (await this.socket.listMessages(t)).map((r) => {
      const i = nd.parse(r.payload), { payload: a, disableInput: o } = Iw(i);
      return {
        ...r,
        payload: a,
        disableInput: o
      };
    });
  }
}
function zC(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: ZC } = Object.prototype, { getPrototypeOf: oy } = Object, sy = ((e) => (t) => {
  const n = ZC.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), bi = (e) => (e = e.toLowerCase(), (t) => sy(t) === e), If = (e) => (t) => typeof t === e, { isArray: os } = Array, Vs = If("undefined");
function bre(e) {
  return e !== null && !Vs(e) && e.constructor !== null && !Vs(e.constructor) && Ca(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const qC = bi("ArrayBuffer");
function wre(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && qC(e.buffer), t;
}
const xre = If("string"), Ca = If("function"), WC = If("number"), ly = (e) => e !== null && typeof e == "object", _re = (e) => e === !0 || e === !1, Uc = (e) => {
  if (sy(e) !== "object")
    return !1;
  const t = oy(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}, Sre = bi("Date"), Ere = bi("File"), kre = bi("Blob"), Tre = bi("FileList"), Cre = (e) => ly(e) && Ca(e.pipe), Ore = (e) => {
  const t = "[object FormData]";
  return e && (typeof FormData == "function" && e instanceof FormData || ZC.call(e) === t || Ca(e.toString) && e.toString() === t);
}, Are = bi("URLSearchParams"), $re = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Wl(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let r, i;
  if (typeof e != "object" && (e = [e]), os(e))
    for (r = 0, i = e.length; r < i; r++)
      t.call(null, e[r], r, e);
  else {
    const a = n ? Object.getOwnPropertyNames(e) : Object.keys(e), o = a.length;
    let s;
    for (r = 0; r < o; r++)
      s = a[r], t.call(null, e[s], s, e);
  }
}
function VC(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let r = n.length, i;
  for (; r-- > 0; )
    if (i = n[r], t === i.toLowerCase())
      return i;
  return null;
}
const HC = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), KC = (e) => !Vs(e) && e !== HC;
function em() {
  const { caseless: e } = KC(this) && this || {}, t = {}, n = (r, i) => {
    const a = e && VC(t, i) || i;
    Uc(t[a]) && Uc(r) ? t[a] = em(t[a], r) : Uc(r) ? t[a] = em({}, r) : os(r) ? t[a] = r.slice() : t[a] = r;
  };
  for (let r = 0, i = arguments.length; r < i; r++)
    arguments[r] && Wl(arguments[r], n);
  return t;
}
const Rre = (e, t, n, { allOwnKeys: r } = {}) => (Wl(t, (i, a) => {
  n && Ca(i) ? e[a] = zC(i, n) : e[a] = i;
}, { allOwnKeys: r }), e), Pre = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), Ire = (e, t, n, r) => {
  e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, Mre = (e, t, n, r) => {
  let i, a, o;
  const s = {};
  if (t = t || {}, e == null)
    return t;
  do {
    for (i = Object.getOwnPropertyNames(e), a = i.length; a-- > 0; )
      o = i[a], (!r || r(o, e, t)) && !s[o] && (t[o] = e[o], s[o] = !0);
    e = n !== !1 && oy(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, Nre = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const r = e.indexOf(t, n);
  return r !== -1 && r === n;
}, Dre = (e) => {
  if (!e)
    return null;
  if (os(e))
    return e;
  let t = e.length;
  if (!WC(t))
    return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, Lre = ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && oy(Uint8Array)), jre = (e, t) => {
  const r = (e && e[Symbol.iterator]).call(e);
  let i;
  for (; (i = r.next()) && !i.done; ) {
    const a = i.value;
    t.call(e, a[0], a[1]);
  }
}, Ure = (e, t) => {
  let n;
  const r = [];
  for (; (n = e.exec(t)) !== null; )
    r.push(n);
  return r;
}, Fre = bi("HTMLFormElement"), Bre = (e) => e.toLowerCase().replace(
  /[_-\s]([a-z\d])(\w*)/g,
  function(n, r, i) {
    return r.toUpperCase() + i;
  }
), Mw = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), zre = bi("RegExp"), GC = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), r = {};
  Wl(n, (i, a) => {
    t(i, a, e) !== !1 && (r[a] = i);
  }), Object.defineProperties(e, r);
}, Zre = (e) => {
  GC(e, (t, n) => {
    if (Ca(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const r = e[n];
    if (Ca(r)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, qre = (e, t) => {
  const n = {}, r = (i) => {
    i.forEach((a) => {
      n[a] = !0;
    });
  };
  return os(e) ? r(e) : r(String(e).split(t)), n;
}, Wre = () => {
}, Vre = (e, t) => (e = +e, Number.isFinite(e) ? e : t), Hre = (e) => {
  const t = new Array(10), n = (r, i) => {
    if (ly(r)) {
      if (t.indexOf(r) >= 0)
        return;
      if (!("toJSON" in r)) {
        t[i] = r;
        const a = os(r) ? [] : {};
        return Wl(r, (o, s) => {
          const l = n(o, i + 1);
          !Vs(l) && (a[s] = l);
        }), t[i] = void 0, a;
      }
    }
    return r;
  };
  return n(e, 0);
}, ae = {
  isArray: os,
  isArrayBuffer: qC,
  isBuffer: bre,
  isFormData: Ore,
  isArrayBufferView: wre,
  isString: xre,
  isNumber: WC,
  isBoolean: _re,
  isObject: ly,
  isPlainObject: Uc,
  isUndefined: Vs,
  isDate: Sre,
  isFile: Ere,
  isBlob: kre,
  isRegExp: zre,
  isFunction: Ca,
  isStream: Cre,
  isURLSearchParams: Are,
  isTypedArray: Lre,
  isFileList: Tre,
  forEach: Wl,
  merge: em,
  extend: Rre,
  trim: $re,
  stripBOM: Pre,
  inherits: Ire,
  toFlatObject: Mre,
  kindOf: sy,
  kindOfTest: bi,
  endsWith: Nre,
  toArray: Dre,
  forEachEntry: jre,
  matchAll: Ure,
  isHTMLForm: Fre,
  hasOwnProperty: Mw,
  hasOwnProp: Mw,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: GC,
  freezeMethods: Zre,
  toObjectSet: qre,
  toCamelCase: Bre,
  noop: Wre,
  toFiniteNumber: Vre,
  findKey: VC,
  global: HC,
  isContextDefined: KC,
  toJSONObject: Hre
};
function St(e, t, n, r, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i);
}
ae.inherits(St, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: ae.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const JC = St.prototype, YC = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  YC[e] = { value: e };
});
Object.defineProperties(St, YC);
Object.defineProperty(JC, "isAxiosError", { value: !0 });
St.from = (e, t, n, r, i, a) => {
  const o = Object.create(JC);
  return ae.toFlatObject(e, o, function(l) {
    return l !== Error.prototype;
  }, (s) => s !== "isAxiosError"), St.call(o, e.message, t, n, r, i), o.cause = e, o.name = e.name, a && Object.assign(o, a), o;
};
var Kre = typeof self == "object" ? self.FormData : window.FormData;
const Gre = /* @__PURE__ */ Ki(Kre);
function tm(e) {
  return ae.isPlainObject(e) || ae.isArray(e);
}
function XC(e) {
  return ae.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function Nw(e, t, n) {
  return e ? e.concat(t).map(function(i, a) {
    return i = XC(i), !n && a ? "[" + i + "]" : i;
  }).join(n ? "." : "") : t;
}
function Jre(e) {
  return ae.isArray(e) && !e.some(tm);
}
const Yre = ae.toFlatObject(ae, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function Xre(e) {
  return e && ae.isFunction(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator];
}
function Mf(e, t, n) {
  if (!ae.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new (Gre || FormData)(), n = ae.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(m, y) {
    return !ae.isUndefined(y[m]);
  });
  const r = n.metaTokens, i = n.visitor || u, a = n.dots, o = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && Xre(t);
  if (!ae.isFunction(i))
    throw new TypeError("visitor must be a function");
  function c(h) {
    if (h === null)
      return "";
    if (ae.isDate(h))
      return h.toISOString();
    if (!l && ae.isBlob(h))
      throw new St("Blob is not supported. Use a Buffer instead.");
    return ae.isArrayBuffer(h) || ae.isTypedArray(h) ? l && typeof Blob == "function" ? new Blob([h]) : Buffer.from(h) : h;
  }
  function u(h, m, y) {
    let g = h;
    if (h && !y && typeof h == "object") {
      if (ae.endsWith(m, "{}"))
        m = r ? m : m.slice(0, -2), h = JSON.stringify(h);
      else if (ae.isArray(h) && Jre(h) || ae.isFileList(h) || ae.endsWith(m, "[]") && (g = ae.toArray(h)))
        return m = XC(m), g.forEach(function(b, T) {
          !(ae.isUndefined(b) || b === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            o === !0 ? Nw([m], T, a) : o === null ? m : m + "[]",
            c(b)
          );
        }), !1;
    }
    return tm(h) ? !0 : (t.append(Nw(y, m, a), c(h)), !1);
  }
  const d = [], p = Object.assign(Yre, {
    defaultVisitor: u,
    convertValue: c,
    isVisitable: tm
  });
  function f(h, m) {
    if (!ae.isUndefined(h)) {
      if (d.indexOf(h) !== -1)
        throw Error("Circular reference detected in " + m.join("."));
      d.push(h), ae.forEach(h, function(g, v) {
        (!(ae.isUndefined(g) || g === null) && i.call(
          t,
          g,
          ae.isString(v) ? v.trim() : v,
          m,
          p
        )) === !0 && f(g, m ? m.concat(v) : [v]);
      }), d.pop();
    }
  }
  if (!ae.isObject(e))
    throw new TypeError("data must be an object");
  return f(e), t;
}
function Dw(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(r) {
    return t[r];
  });
}
function cy(e, t) {
  this._pairs = [], e && Mf(e, this, t);
}
const QC = cy.prototype;
QC.append = function(t, n) {
  this._pairs.push([t, n]);
};
QC.toString = function(t) {
  const n = t ? function(r) {
    return t.call(this, r, Dw);
  } : Dw;
  return this._pairs.map(function(i) {
    return n(i[0]) + "=" + n(i[1]);
  }, "").join("&");
};
function Qre(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function eO(e, t, n) {
  if (!t)
    return e;
  const r = n && n.encode || Qre, i = n && n.serialize;
  let a;
  if (i ? a = i(t, n) : a = ae.isURLSearchParams(t) ? t.toString() : new cy(t, n).toString(r), a) {
    const o = e.indexOf("#");
    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + a;
  }
  return e;
}
class eie {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, r) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: r ? r.synchronous : !1,
      runWhen: r ? r.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    ae.forEach(this.handlers, function(r) {
      r !== null && t(r);
    });
  }
}
const Lw = eie, tO = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, tie = typeof URLSearchParams < "u" ? URLSearchParams : cy, nie = FormData, rie = (() => {
  let e;
  return typeof navigator < "u" && ((e = navigator.product) === "ReactNative" || e === "NativeScript" || e === "NS") ? !1 : typeof window < "u" && typeof document < "u";
})(), iie = (() => typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), Mr = {
  isBrowser: !0,
  classes: {
    URLSearchParams: tie,
    FormData: nie,
    Blob
  },
  isStandardBrowserEnv: rie,
  isStandardBrowserWebWorkerEnv: iie,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function aie(e, t) {
  return Mf(e, new Mr.classes.URLSearchParams(), Object.assign({
    visitor: function(n, r, i, a) {
      return Mr.isNode && ae.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : a.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function oie(e) {
  return ae.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function sie(e) {
  const t = {}, n = Object.keys(e);
  let r;
  const i = n.length;
  let a;
  for (r = 0; r < i; r++)
    a = n[r], t[a] = e[a];
  return t;
}
function nO(e) {
  function t(n, r, i, a) {
    let o = n[a++];
    const s = Number.isFinite(+o), l = a >= n.length;
    return o = !o && ae.isArray(i) ? i.length : o, l ? (ae.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !s) : ((!i[o] || !ae.isObject(i[o])) && (i[o] = []), t(n, r, i[o], a) && ae.isArray(i[o]) && (i[o] = sie(i[o])), !s);
  }
  if (ae.isFormData(e) && ae.isFunction(e.entries)) {
    const n = {};
    return ae.forEachEntry(e, (r, i) => {
      t(oie(r), i, n, 0);
    }), n;
  }
  return null;
}
const lie = {
  "Content-Type": void 0
};
function cie(e, t, n) {
  if (ae.isString(e))
    try {
      return (t || JSON.parse)(e), ae.trim(e);
    } catch (r) {
      if (r.name !== "SyntaxError")
        throw r;
    }
  return (n || JSON.stringify)(e);
}
const Nf = {
  transitional: tO,
  adapter: ["xhr", "http"],
  transformRequest: [function(t, n) {
    const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, a = ae.isObject(t);
    if (a && ae.isHTMLForm(t) && (t = new FormData(t)), ae.isFormData(t))
      return i && i ? JSON.stringify(nO(t)) : t;
    if (ae.isArrayBuffer(t) || ae.isBuffer(t) || ae.isStream(t) || ae.isFile(t) || ae.isBlob(t))
      return t;
    if (ae.isArrayBufferView(t))
      return t.buffer;
    if (ae.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let s;
    if (a) {
      if (r.indexOf("application/x-www-form-urlencoded") > -1)
        return aie(t, this.formSerializer).toString();
      if ((s = ae.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
        const l = this.env && this.env.FormData;
        return Mf(
          s ? { "files[]": t } : t,
          l && new l(),
          this.formSerializer
        );
      }
    }
    return a || i ? (n.setContentType("application/json", !1), cie(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || Nf.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json";
    if (t && ae.isString(t) && (r && !this.responseType || i)) {
      const o = !(n && n.silentJSONParsing) && i;
      try {
        return JSON.parse(t);
      } catch (s) {
        if (o)
          throw s.name === "SyntaxError" ? St.from(s, St.ERR_BAD_RESPONSE, this, null, this.response) : s;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Mr.classes.FormData,
    Blob: Mr.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*"
    }
  }
};
ae.forEach(["delete", "get", "head"], function(t) {
  Nf.headers[t] = {};
});
ae.forEach(["post", "put", "patch"], function(t) {
  Nf.headers[t] = ae.merge(lie);
});
const uy = Nf, uie = ae.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), die = (e) => {
  const t = {};
  let n, r, i;
  return e && e.split(`
`).forEach(function(o) {
    i = o.indexOf(":"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || t[n] && uie[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r);
  }), t;
}, jw = Symbol("internals");
function ms(e) {
  return e && String(e).trim().toLowerCase();
}
function Fc(e) {
  return e === !1 || e == null ? e : ae.isArray(e) ? e.map(Fc) : String(e);
}
function fie(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let r;
  for (; r = n.exec(e); )
    t[r[1]] = r[2];
  return t;
}
function pie(e) {
  return /^[-_a-zA-Z]+$/.test(e.trim());
}
function Uw(e, t, n, r) {
  if (ae.isFunction(r))
    return r.call(this, t, n);
  if (ae.isString(t)) {
    if (ae.isString(r))
      return t.indexOf(r) !== -1;
    if (ae.isRegExp(r))
      return r.test(t);
  }
}
function hie(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r);
}
function mie(e, t) {
  const n = ae.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((r) => {
    Object.defineProperty(e, r + n, {
      value: function(i, a, o) {
        return this[r].call(this, t, i, a, o);
      },
      configurable: !0
    });
  });
}
class Df {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, r) {
    const i = this;
    function a(s, l, c) {
      const u = ms(l);
      if (!u)
        throw new Error("header name must be a non-empty string");
      const d = ae.findKey(i, u);
      (!d || i[d] === void 0 || c === !0 || c === void 0 && i[d] !== !1) && (i[d || l] = Fc(s));
    }
    const o = (s, l) => ae.forEach(s, (c, u) => a(c, u, l));
    return ae.isPlainObject(t) || t instanceof this.constructor ? o(t, n) : ae.isString(t) && (t = t.trim()) && !pie(t) ? o(die(t), n) : t != null && a(n, t, r), this;
  }
  get(t, n) {
    if (t = ms(t), t) {
      const r = ae.findKey(this, t);
      if (r) {
        const i = this[r];
        if (!n)
          return i;
        if (n === !0)
          return fie(i);
        if (ae.isFunction(n))
          return n.call(this, i, r);
        if (ae.isRegExp(n))
          return n.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = ms(t), t) {
      const r = ae.findKey(this, t);
      return !!(r && (!n || Uw(this, this[r], r, n)));
    }
    return !1;
  }
  delete(t, n) {
    const r = this;
    let i = !1;
    function a(o) {
      if (o = ms(o), o) {
        const s = ae.findKey(r, o);
        s && (!n || Uw(r, r[s], s, n)) && (delete r[s], i = !0);
      }
    }
    return ae.isArray(t) ? t.forEach(a) : a(t), i;
  }
  clear() {
    return Object.keys(this).forEach(this.delete.bind(this));
  }
  normalize(t) {
    const n = this, r = {};
    return ae.forEach(this, (i, a) => {
      const o = ae.findKey(r, a);
      if (o) {
        n[o] = Fc(i), delete n[a];
        return;
      }
      const s = t ? hie(a) : String(a).trim();
      s !== a && delete n[a], n[s] = Fc(i), r[s] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return ae.forEach(this, (r, i) => {
      r != null && r !== !1 && (n[i] = t && ae.isArray(r) ? r.join(", ") : r);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const r = new this(t);
    return n.forEach((i) => r.set(i)), r;
  }
  static accessor(t) {
    const r = (this[jw] = this[jw] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function a(o) {
      const s = ms(o);
      r[s] || (mie(i, o), r[s] = !0);
    }
    return ae.isArray(t) ? t.forEach(a) : a(t), this;
  }
}
Df.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent"]);
ae.freezeMethods(Df.prototype);
ae.freezeMethods(Df);
const ui = Df;
function Mp(e, t) {
  const n = this || uy, r = t || n, i = ui.from(r.headers);
  let a = r.data;
  return ae.forEach(e, function(s) {
    a = s.call(n, a, i.normalize(), t ? t.status : void 0);
  }), i.normalize(), a;
}
function rO(e) {
  return !!(e && e.__CANCEL__);
}
function Vl(e, t, n) {
  St.call(this, e ?? "canceled", St.ERR_CANCELED, t, n), this.name = "CanceledError";
}
ae.inherits(Vl, St, {
  __CANCEL__: !0
});
const gie = null;
function yie(e, t, n) {
  const r = n.config.validateStatus;
  !n.status || !r || r(n.status) ? e(n) : t(new St(
    "Request failed with status code " + n.status,
    [St.ERR_BAD_REQUEST, St.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
const vie = Mr.isStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function() {
    return {
      write: function(n, r, i, a, o, s) {
        const l = [];
        l.push(n + "=" + encodeURIComponent(r)), ae.isNumber(i) && l.push("expires=" + new Date(i).toGMTString()), ae.isString(a) && l.push("path=" + a), ae.isString(o) && l.push("domain=" + o), s === !0 && l.push("secure"), document.cookie = l.join("; ");
      },
      read: function(n) {
        const r = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
        return r ? decodeURIComponent(r[3]) : null;
      },
      remove: function(n) {
        this.write(n, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function() {
    return {
      write: function() {
      },
      read: function() {
        return null;
      },
      remove: function() {
      }
    };
  }()
);
function bie(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function wie(e, t) {
  return t ? e.replace(/\/+$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function iO(e, t) {
  return e && !bie(t) ? wie(e, t) : t;
}
const xie = Mr.isStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function() {
    const t = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement("a");
    let r;
    function i(a) {
      let o = a;
      return t && (n.setAttribute("href", o), o = n.href), n.setAttribute("href", o), {
        href: n.href,
        protocol: n.protocol ? n.protocol.replace(/:$/, "") : "",
        host: n.host,
        search: n.search ? n.search.replace(/^\?/, "") : "",
        hash: n.hash ? n.hash.replace(/^#/, "") : "",
        hostname: n.hostname,
        port: n.port,
        pathname: n.pathname.charAt(0) === "/" ? n.pathname : "/" + n.pathname
      };
    }
    return r = i(window.location.href), function(o) {
      const s = ae.isString(o) ? i(o) : o;
      return s.protocol === r.protocol && s.host === r.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function() {
    return function() {
      return !0;
    };
  }()
);
function _ie(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function Sie(e, t) {
  e = e || 10;
  const n = new Array(e), r = new Array(e);
  let i = 0, a = 0, o;
  return t = t !== void 0 ? t : 1e3, function(l) {
    const c = Date.now(), u = r[a];
    o || (o = c), n[i] = l, r[i] = c;
    let d = a, p = 0;
    for (; d !== i; )
      p += n[d++], d = d % e;
    if (i = (i + 1) % e, i === a && (a = (a + 1) % e), c - o < t)
      return;
    const f = u && c - u;
    return f ? Math.round(p * 1e3 / f) : void 0;
  };
}
function Fw(e, t) {
  let n = 0;
  const r = Sie(50, 250);
  return (i) => {
    const a = i.loaded, o = i.lengthComputable ? i.total : void 0, s = a - n, l = r(s), c = a <= o;
    n = a;
    const u = {
      loaded: a,
      total: o,
      progress: o ? a / o : void 0,
      bytes: s,
      rate: l || void 0,
      estimated: l && o && c ? (o - a) / l : void 0,
      event: i
    };
    u[t ? "download" : "upload"] = !0, e(u);
  };
}
const Eie = typeof XMLHttpRequest < "u", kie = Eie && function(e) {
  return new Promise(function(n, r) {
    let i = e.data;
    const a = ui.from(e.headers).normalize(), o = e.responseType;
    let s;
    function l() {
      e.cancelToken && e.cancelToken.unsubscribe(s), e.signal && e.signal.removeEventListener("abort", s);
    }
    ae.isFormData(i) && (Mr.isStandardBrowserEnv || Mr.isStandardBrowserWebWorkerEnv) && a.setContentType(!1);
    let c = new XMLHttpRequest();
    if (e.auth) {
      const f = e.auth.username || "", h = e.auth.password ? unescape(encodeURIComponent(e.auth.password)) : "";
      a.set("Authorization", "Basic " + btoa(f + ":" + h));
    }
    const u = iO(e.baseURL, e.url);
    c.open(e.method.toUpperCase(), eO(u, e.params, e.paramsSerializer), !0), c.timeout = e.timeout;
    function d() {
      if (!c)
        return;
      const f = ui.from(
        "getAllResponseHeaders" in c && c.getAllResponseHeaders()
      ), m = {
        data: !o || o === "text" || o === "json" ? c.responseText : c.response,
        status: c.status,
        statusText: c.statusText,
        headers: f,
        config: e,
        request: c
      };
      yie(function(g) {
        n(g), l();
      }, function(g) {
        r(g), l();
      }, m), c = null;
    }
    if ("onloadend" in c ? c.onloadend = d : c.onreadystatechange = function() {
      !c || c.readyState !== 4 || c.status === 0 && !(c.responseURL && c.responseURL.indexOf("file:") === 0) || setTimeout(d);
    }, c.onabort = function() {
      c && (r(new St("Request aborted", St.ECONNABORTED, e, c)), c = null);
    }, c.onerror = function() {
      r(new St("Network Error", St.ERR_NETWORK, e, c)), c = null;
    }, c.ontimeout = function() {
      let h = e.timeout ? "timeout of " + e.timeout + "ms exceeded" : "timeout exceeded";
      const m = e.transitional || tO;
      e.timeoutErrorMessage && (h = e.timeoutErrorMessage), r(new St(
        h,
        m.clarifyTimeoutError ? St.ETIMEDOUT : St.ECONNABORTED,
        e,
        c
      )), c = null;
    }, Mr.isStandardBrowserEnv) {
      const f = (e.withCredentials || xie(u)) && e.xsrfCookieName && vie.read(e.xsrfCookieName);
      f && a.set(e.xsrfHeaderName, f);
    }
    i === void 0 && a.setContentType(null), "setRequestHeader" in c && ae.forEach(a.toJSON(), function(h, m) {
      c.setRequestHeader(m, h);
    }), ae.isUndefined(e.withCredentials) || (c.withCredentials = !!e.withCredentials), o && o !== "json" && (c.responseType = e.responseType), typeof e.onDownloadProgress == "function" && c.addEventListener("progress", Fw(e.onDownloadProgress, !0)), typeof e.onUploadProgress == "function" && c.upload && c.upload.addEventListener("progress", Fw(e.onUploadProgress)), (e.cancelToken || e.signal) && (s = (f) => {
      c && (r(!f || f.type ? new Vl(null, e, c) : f), c.abort(), c = null);
    }, e.cancelToken && e.cancelToken.subscribe(s), e.signal && (e.signal.aborted ? s() : e.signal.addEventListener("abort", s)));
    const p = _ie(u);
    if (p && Mr.protocols.indexOf(p) === -1) {
      r(new St("Unsupported protocol " + p + ":", St.ERR_BAD_REQUEST, e));
      return;
    }
    c.send(i || null);
  });
}, Bc = {
  http: gie,
  xhr: kie
};
ae.forEach(Bc, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const Tie = {
  getAdapter: (e) => {
    e = ae.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, r;
    for (let i = 0; i < t && (n = e[i], !(r = ae.isString(n) ? Bc[n.toLowerCase()] : n)); i++)
      ;
    if (!r)
      throw r === !1 ? new St(
        `Adapter ${n} is not supported by the environment`,
        "ERR_NOT_SUPPORT"
      ) : new Error(
        ae.hasOwnProp(Bc, n) ? `Adapter '${n}' is not available in the build` : `Unknown adapter '${n}'`
      );
    if (!ae.isFunction(r))
      throw new TypeError("adapter is not a function");
    return r;
  },
  adapters: Bc
};
function Np(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new Vl(null, e);
}
function Bw(e) {
  return Np(e), e.headers = ui.from(e.headers), e.data = Mp.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), Tie.getAdapter(e.adapter || uy.adapter)(e).then(function(r) {
    return Np(e), r.data = Mp.call(
      e,
      e.transformResponse,
      r
    ), r.headers = ui.from(r.headers), r;
  }, function(r) {
    return rO(r) || (Np(e), r && r.response && (r.response.data = Mp.call(
      e,
      e.transformResponse,
      r.response
    ), r.response.headers = ui.from(r.response.headers))), Promise.reject(r);
  });
}
const zw = (e) => e instanceof ui ? e.toJSON() : e;
function Mo(e, t) {
  t = t || {};
  const n = {};
  function r(c, u, d) {
    return ae.isPlainObject(c) && ae.isPlainObject(u) ? ae.merge.call({ caseless: d }, c, u) : ae.isPlainObject(u) ? ae.merge({}, u) : ae.isArray(u) ? u.slice() : u;
  }
  function i(c, u, d) {
    if (ae.isUndefined(u)) {
      if (!ae.isUndefined(c))
        return r(void 0, c, d);
    } else
      return r(c, u, d);
  }
  function a(c, u) {
    if (!ae.isUndefined(u))
      return r(void 0, u);
  }
  function o(c, u) {
    if (ae.isUndefined(u)) {
      if (!ae.isUndefined(c))
        return r(void 0, c);
    } else
      return r(void 0, u);
  }
  function s(c, u, d) {
    if (d in t)
      return r(c, u);
    if (d in e)
      return r(void 0, c);
  }
  const l = {
    url: a,
    method: a,
    data: a,
    baseURL: o,
    transformRequest: o,
    transformResponse: o,
    paramsSerializer: o,
    timeout: o,
    timeoutMessage: o,
    withCredentials: o,
    adapter: o,
    responseType: o,
    xsrfCookieName: o,
    xsrfHeaderName: o,
    onUploadProgress: o,
    onDownloadProgress: o,
    decompress: o,
    maxContentLength: o,
    maxBodyLength: o,
    beforeRedirect: o,
    transport: o,
    httpAgent: o,
    httpsAgent: o,
    cancelToken: o,
    socketPath: o,
    responseEncoding: o,
    validateStatus: s,
    headers: (c, u) => i(zw(c), zw(u), !0)
  };
  return ae.forEach(Object.keys(e).concat(Object.keys(t)), function(u) {
    const d = l[u] || i, p = d(e[u], t[u], u);
    ae.isUndefined(p) && d !== s || (n[u] = p);
  }), n;
}
const aO = "1.2.5", dy = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  dy[e] = function(r) {
    return typeof r === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const Zw = {};
dy.transitional = function(t, n, r) {
  function i(a, o) {
    return "[Axios v" + aO + "] Transitional option '" + a + "'" + o + (r ? ". " + r : "");
  }
  return (a, o, s) => {
    if (t === !1)
      throw new St(
        i(o, " has been removed" + (n ? " in " + n : "")),
        St.ERR_DEPRECATED
      );
    return n && !Zw[o] && (Zw[o] = !0, console.warn(
      i(
        o,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(a, o, s) : !0;
  };
};
function Cie(e, t, n) {
  if (typeof e != "object")
    throw new St("options must be an object", St.ERR_BAD_OPTION_VALUE);
  const r = Object.keys(e);
  let i = r.length;
  for (; i-- > 0; ) {
    const a = r[i], o = t[a];
    if (o) {
      const s = e[a], l = s === void 0 || o(s, a, e);
      if (l !== !0)
        throw new St("option " + a + " must be " + l, St.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new St("Unknown option " + a, St.ERR_BAD_OPTION);
  }
}
const nm = {
  assertOptions: Cie,
  validators: dy
}, ki = nm.validators;
class rd {
  constructor(t) {
    this.defaults = t, this.interceptors = {
      request: new Lw(),
      response: new Lw()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = Mo(this.defaults, n);
    const { transitional: r, paramsSerializer: i, headers: a } = n;
    r !== void 0 && nm.assertOptions(r, {
      silentJSONParsing: ki.transitional(ki.boolean),
      forcedJSONParsing: ki.transitional(ki.boolean),
      clarifyTimeoutError: ki.transitional(ki.boolean)
    }, !1), i !== void 0 && nm.assertOptions(i, {
      encode: ki.function,
      serialize: ki.function
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let o;
    o = a && ae.merge(
      a.common,
      a[n.method]
    ), o && ae.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (h) => {
        delete a[h];
      }
    ), n.headers = ui.concat(o, a);
    const s = [];
    let l = !0;
    this.interceptors.request.forEach(function(m) {
      typeof m.runWhen == "function" && m.runWhen(n) === !1 || (l = l && m.synchronous, s.unshift(m.fulfilled, m.rejected));
    });
    const c = [];
    this.interceptors.response.forEach(function(m) {
      c.push(m.fulfilled, m.rejected);
    });
    let u, d = 0, p;
    if (!l) {
      const h = [Bw.bind(this), void 0];
      for (h.unshift.apply(h, s), h.push.apply(h, c), p = h.length, u = Promise.resolve(n); d < p; )
        u = u.then(h[d++], h[d++]);
      return u;
    }
    p = s.length;
    let f = n;
    for (d = 0; d < p; ) {
      const h = s[d++], m = s[d++];
      try {
        f = h(f);
      } catch (y) {
        m.call(this, y);
        break;
      }
    }
    try {
      u = Bw.call(this, f);
    } catch (h) {
      return Promise.reject(h);
    }
    for (d = 0, p = c.length; d < p; )
      u = u.then(c[d++], c[d++]);
    return u;
  }
  getUri(t) {
    t = Mo(this.defaults, t);
    const n = iO(t.baseURL, t.url);
    return eO(n, t.params, t.paramsSerializer);
  }
}
ae.forEach(["delete", "get", "head", "options"], function(t) {
  rd.prototype[t] = function(n, r) {
    return this.request(Mo(r || {}, {
      method: t,
      url: n,
      data: (r || {}).data
    }));
  };
});
ae.forEach(["post", "put", "patch"], function(t) {
  function n(r) {
    return function(a, o, s) {
      return this.request(Mo(s || {}, {
        method: t,
        headers: r ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: a,
        data: o
      }));
    };
  }
  rd.prototype[t] = n(), rd.prototype[t + "Form"] = n(!0);
});
const zc = rd;
class fy {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(a) {
      n = a;
    });
    const r = this;
    this.promise.then((i) => {
      if (!r._listeners)
        return;
      let a = r._listeners.length;
      for (; a-- > 0; )
        r._listeners[a](i);
      r._listeners = null;
    }), this.promise.then = (i) => {
      let a;
      const o = new Promise((s) => {
        r.subscribe(s), a = s;
      }).then(i);
      return o.cancel = function() {
        r.unsubscribe(a);
      }, o;
    }, t(function(a, o, s) {
      r.reason || (r.reason = new Vl(a, o, s), n(r.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new fy(function(i) {
        t = i;
      }),
      cancel: t
    };
  }
}
const Oie = fy;
function Aie(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function $ie(e) {
  return ae.isObject(e) && e.isAxiosError === !0;
}
const rm = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(rm).forEach(([e, t]) => {
  rm[t] = e;
});
const Rie = rm;
function oO(e) {
  const t = new zc(e), n = zC(zc.prototype.request, t);
  return ae.extend(n, zc.prototype, t, { allOwnKeys: !0 }), ae.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(i) {
    return oO(Mo(e, i));
  }, n;
}
const dn = oO(uy);
dn.Axios = zc;
dn.CanceledError = Vl;
dn.CancelToken = Oie;
dn.isCancel = rO;
dn.VERSION = aO;
dn.toFormData = Mf;
dn.AxiosError = St;
dn.Cancel = dn.CanceledError;
dn.all = function(t) {
  return Promise.all(t);
};
dn.spread = Aie;
dn.isAxiosError = $ie;
dn.mergeConfig = Mo;
dn.AxiosHeaders = ui;
dn.formToJSON = (e) => nO(ae.isHTMLForm(e) ? new FormData(e) : e);
dn.HttpStatusCode = Rie;
dn.default = dn;
const sO = dn, Pie = {
  // Fallback in case crypto isn't available.
  getRandomValues: (e) => new Uint8Array(e.map(() => Math.floor(Math.random() * 256)))
};
let im = typeof window < "u" && typeof window.document < "u" ? window.crypto : Yg;
im.getRandomValues || (im = Pie);
class Nt extends Error {
  constructor(n, r, i, a, o, s) {
    super(a);
    _(this, "isApiError", !0);
    this.code = n, this.description = r, this.type = i, this.message = a, this.error = o, this.id = s, this.id || (this.id = Nt.generateId());
  }
  format() {
    return `[${this.type}] ${this.message} (Error ID: ${this.id})`;
  }
  toJSON() {
    return {
      id: this.id,
      code: this.code,
      type: this.type,
      message: this.message
    };
  }
  static generateId() {
    const n = this.getPrefix(), r = (/* @__PURE__ */ new Date()).toISOString().replace(/[\-:TZ]/g, "").split(".")[0], i = 4, a = Array.from(im.getRandomValues(new Uint8Array(i))).map((o) => o.toString(16).padStart(2, "0")).join("").toUpperCase();
    return `${n}_${r}x${a}`;
  }
  static getPrefix() {
    return typeof window < "u" && typeof window.document < "u" ? "err_bwsr" : "err";
  }
}
const Iie = (e) => typeof e == "object" && !Array.isArray(e) && e !== null, am = (e) => e instanceof Nt || Iie(e) && e.isApiError === !0;
class Hs extends Nt {
  constructor(t, n, r) {
    super(500, "An unknown error occurred", "Unknown", t, n, r);
  }
}
class Mie extends Nt {
  constructor(t, n, r) {
    super(500, "An internal error occurred", "Internal", t, n, r);
  }
}
class Nie extends Nt {
  constructor(t, n, r) {
    super(401, "The request requires to be authenticated.", "Unauthorized", t, n, r);
  }
}
class Die extends Nt {
  constructor(t, n, r) {
    super(403, "The requested action can't be peform by this resource.", "Forbidden", t, n, r);
  }
}
class Lie extends Nt {
  constructor(t, n, r) {
    super(413, "The request payload is too large.", "PayloadTooLarge", t, n, r);
  }
}
class jie extends Nt {
  constructor(t, n, r) {
    super(400, "The request payload is invalid.", "InvalidPayload", t, n, r);
  }
}
class Uie extends Nt {
  constructor(t, n, r) {
    super(415, "The request is invalid because the content-type is not supported.", "UnsupportedMediaType", t, n, r);
  }
}
class Fie extends Nt {
  constructor(t, n, r) {
    super(405, "The requested method does not exist.", "MethodNotFound", t, n, r);
  }
}
class Bie extends Nt {
  constructor(t, n, r) {
    super(404, "The requested resource does not exist.", "ResourceNotFound", t, n, r);
  }
}
class zie extends Nt {
  constructor(t, n, r) {
    super(400, "The provided JSON schema is invalid.", "InvalidJsonSchema", t, n, r);
  }
}
class Zie extends Nt {
  constructor(t, n, r) {
    super(400, "The provided data doesn't respect the provided JSON schema.", "InvalidDataFormat", t, n, r);
  }
}
class qie extends Nt {
  constructor(t, n, r) {
    super(400, "The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.", "InvalidIdentifier", t, n, r);
  }
}
class Wie extends Nt {
  constructor(t, n, r) {
    super(409, "The resource is related with a different resource that the one referenced in the request. This is usually caused when providing two resource identifiers that aren't linked together.", "RelationConflict", t, n, r);
  }
}
class Vie extends Nt {
  constructor(t, n, r) {
    super(409, "The resource cannot be deleted because it's referenced by another resource", "ReferenceConstraint", t, n, r);
  }
}
class Hie extends Nt {
  constructor(t, n, r) {
    super(400, "The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.", "ReferenceNotFound", t, n, r);
  }
}
class Kie extends Nt {
  constructor(t, n, r) {
    super(400, "The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.", "InvalidQuery", t, n, r);
  }
}
class Gie extends Nt {
  constructor(t, n, r) {
    super(400, "An error happened during the execution of a runtime (bot or integration).", "Runtime", t, n, r);
  }
}
class Jie extends Nt {
  constructor(t, n, r) {
    super(409, "The record attempted to be created already exists.", "AlreadyExists", t, n, r);
  }
}
class Yie extends Nt {
  constructor(t, n, r) {
    super(429, "The request has been rate limited.", "RateLimited", t, n, r);
  }
}
class Xie extends Nt {
  constructor(t, n, r) {
    super(402, "A payment is required to perform this request.", "PaymentRequired", t, n, r);
  }
}
class Qie extends Nt {
  constructor(t, n, r) {
    super(403, "The request exceeds the allowed quota. Quotas are a soft limit that can be increased.", "QuotaExceeded", t, n, r);
  }
}
class eae extends Nt {
  constructor(t, n, r) {
    super(413, "The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.", "LimitExceeded", t, n, r);
  }
}
class tae extends Nt {
  constructor(t, n, r) {
    super(400, "Request payload contains breaking changes which is not allowed for this resource without a version increment.", "BreakingChanges", t, n, r);
  }
}
const nae = {
  Unknown: Hs,
  Internal: Mie,
  Unauthorized: Nie,
  Forbidden: Die,
  PayloadTooLarge: Lie,
  InvalidPayload: jie,
  UnsupportedMediaType: Uie,
  MethodNotFound: Fie,
  ResourceNotFound: Bie,
  InvalidJsonSchema: zie,
  InvalidDataFormat: Zie,
  InvalidIdentifier: qie,
  RelationConflict: Wie,
  ReferenceConstraint: Vie,
  ReferenceNotFound: Hie,
  InvalidQuery: Kie,
  Runtime: Gie,
  AlreadyExists: Jie,
  RateLimited: Yie,
  PaymentRequired: Xie,
  QuotaExceeded: Qie,
  LimitExceeded: eae,
  BreakingChanges: tae
}, qw = (e) => am(e) ? e : e instanceof Error ? new Hs(e.message, e) : typeof e == "string" ? new Hs(e) : rae(e);
function rae(e) {
  if (typeof e == "object" && "code" in e && "type" in e && "id" in e && "message" in e && typeof e.type == "string" && typeof e.message == "string") {
    const t = nae[e.type];
    return t ? new t(e.message, void 0, e.id || "UNKNOWN") : new Hs(`An unclassified API error occurred: ${e.message} (Type: ${e.type}, Code: ${e.code})`);
  }
  return new Hs("An invalid error occurred: " + JSON.stringify(e));
}
var iae = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var t = {}, n = Symbol("test"), r = Object(n);
  if (typeof n == "string" || Object.prototype.toString.call(n) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
    return !1;
  var i = 42;
  t[n] = i;
  for (n in t)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
    return !1;
  var a = Object.getOwnPropertySymbols(t);
  if (a.length !== 1 || a[0] !== n || !Object.prototype.propertyIsEnumerable.call(t, n))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var o = Object.getOwnPropertyDescriptor(t, n);
    if (o.value !== i || o.enumerable !== !0)
      return !1;
  }
  return !0;
}, Ww = typeof Symbol < "u" && Symbol, aae = iae, oae = function() {
  return typeof Ww != "function" || typeof Symbol != "function" || typeof Ww("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : aae();
}, Vw = {
  foo: {}
}, sae = Object, lae = function() {
  return { __proto__: Vw }.foo === Vw.foo && !({ __proto__: null } instanceof sae);
}, cae = "Function.prototype.bind called on incompatible ", uae = Object.prototype.toString, dae = Math.max, fae = "[object Function]", Hw = function(t, n) {
  for (var r = [], i = 0; i < t.length; i += 1)
    r[i] = t[i];
  for (var a = 0; a < n.length; a += 1)
    r[a + t.length] = n[a];
  return r;
}, pae = function(t, n) {
  for (var r = [], i = n || 0, a = 0; i < t.length; i += 1, a += 1)
    r[a] = t[i];
  return r;
}, hae = function(e, t) {
  for (var n = "", r = 0; r < e.length; r += 1)
    n += e[r], r + 1 < e.length && (n += t);
  return n;
}, mae = function(t) {
  var n = this;
  if (typeof n != "function" || uae.apply(n) !== fae)
    throw new TypeError(cae + n);
  for (var r = pae(arguments, 1), i, a = function() {
    if (this instanceof i) {
      var u = n.apply(
        this,
        Hw(r, arguments)
      );
      return Object(u) === u ? u : this;
    }
    return n.apply(
      t,
      Hw(r, arguments)
    );
  }, o = dae(0, n.length - r.length), s = [], l = 0; l < o; l++)
    s[l] = "$" + l;
  if (i = Function("binder", "return function (" + hae(s, ",") + "){ return binder.apply(this,arguments); }")(a), n.prototype) {
    var c = function() {
    };
    c.prototype = n.prototype, i.prototype = new c(), c.prototype = null;
  }
  return i;
}, gae = mae, py = Function.prototype.bind || gae, yae = py, vae = yae.call(Function.call, Object.prototype.hasOwnProperty), vt, No = SyntaxError, lO = Function, ho = TypeError, Dp = function(e) {
  try {
    return lO('"use strict"; return (' + e + ").constructor;")();
  } catch {
  }
}, ma = Object.getOwnPropertyDescriptor;
if (ma)
  try {
    ma({}, "");
  } catch {
    ma = null;
  }
var Lp = function() {
  throw new ho();
}, bae = ma ? function() {
  try {
    return arguments.callee, Lp;
  } catch {
    try {
      return ma(arguments, "callee").get;
    } catch {
      return Lp;
    }
  }
}() : Lp, Za = oae(), wae = lae(), hn = Object.getPrototypeOf || (wae ? function(e) {
  return e.__proto__;
} : null), Xa = {}, xae = typeof Uint8Array > "u" || !hn ? vt : hn(Uint8Array), ga = {
  "%AggregateError%": typeof AggregateError > "u" ? vt : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? vt : ArrayBuffer,
  "%ArrayIteratorPrototype%": Za && hn ? hn([][Symbol.iterator]()) : vt,
  "%AsyncFromSyncIteratorPrototype%": vt,
  "%AsyncFunction%": Xa,
  "%AsyncGenerator%": Xa,
  "%AsyncGeneratorFunction%": Xa,
  "%AsyncIteratorPrototype%": Xa,
  "%Atomics%": typeof Atomics > "u" ? vt : Atomics,
  "%BigInt%": typeof BigInt > "u" ? vt : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? vt : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? vt : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? vt : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? vt : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? vt : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? vt : FinalizationRegistry,
  "%Function%": lO,
  "%GeneratorFunction%": Xa,
  "%Int8Array%": typeof Int8Array > "u" ? vt : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? vt : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? vt : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": Za && hn ? hn(hn([][Symbol.iterator]())) : vt,
  "%JSON%": typeof JSON == "object" ? JSON : vt,
  "%Map%": typeof Map > "u" ? vt : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !Za || !hn ? vt : hn((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": Object,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? vt : Promise,
  "%Proxy%": typeof Proxy > "u" ? vt : Proxy,
  "%RangeError%": RangeError,
  "%ReferenceError%": ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? vt : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? vt : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !Za || !hn ? vt : hn((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? vt : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": Za && hn ? hn(""[Symbol.iterator]()) : vt,
  "%Symbol%": Za ? Symbol : vt,
  "%SyntaxError%": No,
  "%ThrowTypeError%": bae,
  "%TypedArray%": xae,
  "%TypeError%": ho,
  "%Uint8Array%": typeof Uint8Array > "u" ? vt : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? vt : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? vt : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? vt : Uint32Array,
  "%URIError%": URIError,
  "%WeakMap%": typeof WeakMap > "u" ? vt : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? vt : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? vt : WeakSet
};
if (hn)
  try {
    null.error;
  } catch (e) {
    var _ae = hn(hn(e));
    ga["%Error.prototype%"] = _ae;
  }
var Sae = function e(t) {
  var n;
  if (t === "%AsyncFunction%")
    n = Dp("async function () {}");
  else if (t === "%GeneratorFunction%")
    n = Dp("function* () {}");
  else if (t === "%AsyncGeneratorFunction%")
    n = Dp("async function* () {}");
  else if (t === "%AsyncGenerator%") {
    var r = e("%AsyncGeneratorFunction%");
    r && (n = r.prototype);
  } else if (t === "%AsyncIteratorPrototype%") {
    var i = e("%AsyncGenerator%");
    i && hn && (n = hn(i.prototype));
  }
  return ga[t] = n, n;
}, Kw = {
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, Hl = py, id = vae, Eae = Hl.call(Function.call, Array.prototype.concat), kae = Hl.call(Function.apply, Array.prototype.splice), Gw = Hl.call(Function.call, String.prototype.replace), ad = Hl.call(Function.call, String.prototype.slice), Tae = Hl.call(Function.call, RegExp.prototype.exec), Cae = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Oae = /\\(\\)?/g, Aae = function(t) {
  var n = ad(t, 0, 1), r = ad(t, -1);
  if (n === "%" && r !== "%")
    throw new No("invalid intrinsic syntax, expected closing `%`");
  if (r === "%" && n !== "%")
    throw new No("invalid intrinsic syntax, expected opening `%`");
  var i = [];
  return Gw(t, Cae, function(a, o, s, l) {
    i[i.length] = s ? Gw(l, Oae, "$1") : o || a;
  }), i;
}, $ae = function(t, n) {
  var r = t, i;
  if (id(Kw, r) && (i = Kw[r], r = "%" + i[0] + "%"), id(ga, r)) {
    var a = ga[r];
    if (a === Xa && (a = Sae(r)), typeof a > "u" && !n)
      throw new ho("intrinsic " + t + " exists, but is not available. Please file an issue!");
    return {
      alias: i,
      name: r,
      value: a
    };
  }
  throw new No("intrinsic " + t + " does not exist!");
}, hy = function(t, n) {
  if (typeof t != "string" || t.length === 0)
    throw new ho("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof n != "boolean")
    throw new ho('"allowMissing" argument must be a boolean');
  if (Tae(/^%?[^%]*%?$/, t) === null)
    throw new No("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var r = Aae(t), i = r.length > 0 ? r[0] : "", a = $ae("%" + i + "%", n), o = a.name, s = a.value, l = !1, c = a.alias;
  c && (i = c[0], kae(r, Eae([0, 1], c)));
  for (var u = 1, d = !0; u < r.length; u += 1) {
    var p = r[u], f = ad(p, 0, 1), h = ad(p, -1);
    if ((f === '"' || f === "'" || f === "`" || h === '"' || h === "'" || h === "`") && f !== h)
      throw new No("property names with quotes must have matching quotes");
    if ((p === "constructor" || !d) && (l = !0), i += "." + p, o = "%" + i + "%", id(ga, o))
      s = ga[o];
    else if (s != null) {
      if (!(p in s)) {
        if (!n)
          throw new ho("base intrinsic for " + t + " exists, but the property is not available.");
        return;
      }
      if (ma && u + 1 >= r.length) {
        var m = ma(s, p);
        d = !!m, d && "get" in m && !("originalValue" in m.get) ? s = m.get : s = s[p];
      } else
        d = id(s, p), s = s[p];
      d && !l && (ga[o] = s);
    }
  }
  return s;
}, cO = { exports: {} };
(function(e) {
  var t = py, n = hy, r = n("%Function.prototype.apply%"), i = n("%Function.prototype.call%"), a = n("%Reflect.apply%", !0) || t.call(i, r), o = n("%Object.getOwnPropertyDescriptor%", !0), s = n("%Object.defineProperty%", !0), l = n("%Math.max%");
  if (s)
    try {
      s({}, "a", { value: 1 });
    } catch {
      s = null;
    }
  e.exports = function(d) {
    var p = a(t, i, arguments);
    if (o && s) {
      var f = o(p, "length");
      f.configurable && s(
        p,
        "length",
        { value: 1 + l(0, d.length - (arguments.length - 1)) }
      );
    }
    return p;
  };
  var c = function() {
    return a(t, r, arguments);
  };
  s ? s(e.exports, "apply", { value: c }) : e.exports.apply = c;
})(cO);
var Rae = cO.exports, uO = hy, dO = Rae, Pae = dO(uO("String.prototype.indexOf")), Iae = function(t, n) {
  var r = uO(t, !!n);
  return typeof r == "function" && Pae(t, ".prototype.") > -1 ? dO(r) : r;
}, my = typeof Map == "function" && Map.prototype, jp = Object.getOwnPropertyDescriptor && my ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, od = my && jp && typeof jp.get == "function" ? jp.get : null, Jw = my && Map.prototype.forEach, gy = typeof Set == "function" && Set.prototype, Up = Object.getOwnPropertyDescriptor && gy ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, sd = gy && Up && typeof Up.get == "function" ? Up.get : null, Yw = gy && Set.prototype.forEach, Mae = typeof WeakMap == "function" && WeakMap.prototype, Os = Mae ? WeakMap.prototype.has : null, Nae = typeof WeakSet == "function" && WeakSet.prototype, As = Nae ? WeakSet.prototype.has : null, Dae = typeof WeakRef == "function" && WeakRef.prototype, Xw = Dae ? WeakRef.prototype.deref : null, Lae = Boolean.prototype.valueOf, jae = Object.prototype.toString, Uae = Function.prototype.toString, Fae = String.prototype.match, yy = String.prototype.slice, Ni = String.prototype.replace, Bae = String.prototype.toUpperCase, Qw = String.prototype.toLowerCase, fO = RegExp.prototype.test, e0 = Array.prototype.concat, $r = Array.prototype.join, zae = Array.prototype.slice, t0 = Math.floor, om = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, Fp = Object.getOwnPropertySymbols, sm = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, Do = typeof Symbol == "function" && typeof Symbol.iterator == "object", Rn = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === Do || "symbol") ? Symbol.toStringTag : null, pO = Object.prototype.propertyIsEnumerable, n0 = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
  return e.__proto__;
} : null);
function r0(e, t) {
  if (e === 1 / 0 || e === -1 / 0 || e !== e || e && e > -1e3 && e < 1e3 || fO.call(/e/, t))
    return t;
  var n = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
  if (typeof e == "number") {
    var r = e < 0 ? -t0(-e) : t0(e);
    if (r !== e) {
      var i = String(r), a = yy.call(t, i.length + 1);
      return Ni.call(i, n, "$&_") + "." + Ni.call(Ni.call(a, /([0-9]{3})/g, "$&_"), /_$/, "");
    }
  }
  return Ni.call(t, n, "$&_");
}
var lm = qh, i0 = lm.custom, a0 = mO(i0) ? i0 : null, Zae = function e(t, n, r, i) {
  var a = n || {};
  if ($i(a, "quoteStyle") && a.quoteStyle !== "single" && a.quoteStyle !== "double")
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  if ($i(a, "maxStringLength") && (typeof a.maxStringLength == "number" ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : a.maxStringLength !== null))
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  var o = $i(a, "customInspect") ? a.customInspect : !0;
  if (typeof o != "boolean" && o !== "symbol")
    throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
  if ($i(a, "indent") && a.indent !== null && a.indent !== "	" && !(parseInt(a.indent, 10) === a.indent && a.indent > 0))
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  if ($i(a, "numericSeparator") && typeof a.numericSeparator != "boolean")
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  var s = a.numericSeparator;
  if (typeof t > "u")
    return "undefined";
  if (t === null)
    return "null";
  if (typeof t == "boolean")
    return t ? "true" : "false";
  if (typeof t == "string")
    return yO(t, a);
  if (typeof t == "number") {
    if (t === 0)
      return 1 / 0 / t > 0 ? "0" : "-0";
    var l = String(t);
    return s ? r0(t, l) : l;
  }
  if (typeof t == "bigint") {
    var c = String(t) + "n";
    return s ? r0(t, c) : c;
  }
  var u = typeof a.depth > "u" ? 5 : a.depth;
  if (typeof r > "u" && (r = 0), r >= u && u > 0 && typeof t == "object")
    return cm(t) ? "[Array]" : "[Object]";
  var d = soe(a, r);
  if (typeof i > "u")
    i = [];
  else if (gO(i, t) >= 0)
    return "[Circular]";
  function p(U, z, D) {
    if (z && (i = zae.call(i), i.push(z)), D) {
      var j = {
        depth: a.depth
      };
      return $i(a, "quoteStyle") && (j.quoteStyle = a.quoteStyle), e(U, j, r + 1, i);
    }
    return e(U, a, r + 1, i);
  }
  if (typeof t == "function" && !o0(t)) {
    var f = Xae(t), h = dc(t, p);
    return "[Function" + (f ? ": " + f : " (anonymous)") + "]" + (h.length > 0 ? " { " + $r.call(h, ", ") + " }" : "");
  }
  if (mO(t)) {
    var m = Do ? Ni.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : sm.call(t);
    return typeof t == "object" && !Do ? gs(m) : m;
  }
  if (ioe(t)) {
    for (var y = "<" + Qw.call(String(t.nodeName)), g = t.attributes || [], v = 0; v < g.length; v++)
      y += " " + g[v].name + "=" + hO(qae(g[v].value), "double", a);
    return y += ">", t.childNodes && t.childNodes.length && (y += "..."), y += "</" + Qw.call(String(t.nodeName)) + ">", y;
  }
  if (cm(t)) {
    if (t.length === 0)
      return "[]";
    var b = dc(t, p);
    return d && !ooe(b) ? "[" + um(b, d) + "]" : "[ " + $r.call(b, ", ") + " ]";
  }
  if (Vae(t)) {
    var T = dc(t, p);
    return !("cause" in Error.prototype) && "cause" in t && !pO.call(t, "cause") ? "{ [" + String(t) + "] " + $r.call(e0.call("[cause]: " + p(t.cause), T), ", ") + " }" : T.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + $r.call(T, ", ") + " }";
  }
  if (typeof t == "object" && o) {
    if (a0 && typeof t[a0] == "function" && lm)
      return lm(t, { depth: u - r });
    if (o !== "symbol" && typeof t.inspect == "function")
      return t.inspect();
  }
  if (Qae(t)) {
    var O = [];
    return Jw && Jw.call(t, function(U, z) {
      O.push(p(z, t, !0) + " => " + p(U, t));
    }), s0("Map", od.call(t), O, d);
  }
  if (noe(t)) {
    var S = [];
    return Yw && Yw.call(t, function(U) {
      S.push(p(U, t));
    }), s0("Set", sd.call(t), S, d);
  }
  if (eoe(t))
    return Bp("WeakMap");
  if (roe(t))
    return Bp("WeakSet");
  if (toe(t))
    return Bp("WeakRef");
  if (Kae(t))
    return gs(p(Number(t)));
  if (Jae(t))
    return gs(p(om.call(t)));
  if (Gae(t))
    return gs(Lae.call(t));
  if (Hae(t))
    return gs(p(String(t)));
  if (!Wae(t) && !o0(t)) {
    var P = dc(t, p), M = n0 ? n0(t) === Object.prototype : t instanceof Object || t.constructor === Object, L = t instanceof Object ? "" : "null prototype", k = !M && Rn && Object(t) === t && Rn in t ? yy.call(Xi(t), 8, -1) : L ? "Object" : "", I = M || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : "", B = I + (k || L ? "[" + $r.call(e0.call([], k || [], L || []), ": ") + "] " : "");
    return P.length === 0 ? B + "{}" : d ? B + "{" + um(P, d) + "}" : B + "{ " + $r.call(P, ", ") + " }";
  }
  return String(t);
};
function hO(e, t, n) {
  var r = (n.quoteStyle || t) === "double" ? '"' : "'";
  return r + e + r;
}
function qae(e) {
  return Ni.call(String(e), /"/g, "&quot;");
}
function cm(e) {
  return Xi(e) === "[object Array]" && (!Rn || !(typeof e == "object" && Rn in e));
}
function Wae(e) {
  return Xi(e) === "[object Date]" && (!Rn || !(typeof e == "object" && Rn in e));
}
function o0(e) {
  return Xi(e) === "[object RegExp]" && (!Rn || !(typeof e == "object" && Rn in e));
}
function Vae(e) {
  return Xi(e) === "[object Error]" && (!Rn || !(typeof e == "object" && Rn in e));
}
function Hae(e) {
  return Xi(e) === "[object String]" && (!Rn || !(typeof e == "object" && Rn in e));
}
function Kae(e) {
  return Xi(e) === "[object Number]" && (!Rn || !(typeof e == "object" && Rn in e));
}
function Gae(e) {
  return Xi(e) === "[object Boolean]" && (!Rn || !(typeof e == "object" && Rn in e));
}
function mO(e) {
  if (Do)
    return e && typeof e == "object" && e instanceof Symbol;
  if (typeof e == "symbol")
    return !0;
  if (!e || typeof e != "object" || !sm)
    return !1;
  try {
    return sm.call(e), !0;
  } catch {
  }
  return !1;
}
function Jae(e) {
  if (!e || typeof e != "object" || !om)
    return !1;
  try {
    return om.call(e), !0;
  } catch {
  }
  return !1;
}
var Yae = Object.prototype.hasOwnProperty || function(e) {
  return e in this;
};
function $i(e, t) {
  return Yae.call(e, t);
}
function Xi(e) {
  return jae.call(e);
}
function Xae(e) {
  if (e.name)
    return e.name;
  var t = Fae.call(Uae.call(e), /^function\s*([\w$]+)/);
  return t ? t[1] : null;
}
function gO(e, t) {
  if (e.indexOf)
    return e.indexOf(t);
  for (var n = 0, r = e.length; n < r; n++)
    if (e[n] === t)
      return n;
  return -1;
}
function Qae(e) {
  if (!od || !e || typeof e != "object")
    return !1;
  try {
    od.call(e);
    try {
      sd.call(e);
    } catch {
      return !0;
    }
    return e instanceof Map;
  } catch {
  }
  return !1;
}
function eoe(e) {
  if (!Os || !e || typeof e != "object")
    return !1;
  try {
    Os.call(e, Os);
    try {
      As.call(e, As);
    } catch {
      return !0;
    }
    return e instanceof WeakMap;
  } catch {
  }
  return !1;
}
function toe(e) {
  if (!Xw || !e || typeof e != "object")
    return !1;
  try {
    return Xw.call(e), !0;
  } catch {
  }
  return !1;
}
function noe(e) {
  if (!sd || !e || typeof e != "object")
    return !1;
  try {
    sd.call(e);
    try {
      od.call(e);
    } catch {
      return !0;
    }
    return e instanceof Set;
  } catch {
  }
  return !1;
}
function roe(e) {
  if (!As || !e || typeof e != "object")
    return !1;
  try {
    As.call(e, As);
    try {
      Os.call(e, Os);
    } catch {
      return !0;
    }
    return e instanceof WeakSet;
  } catch {
  }
  return !1;
}
function ioe(e) {
  return !e || typeof e != "object" ? !1 : typeof HTMLElement < "u" && e instanceof HTMLElement ? !0 : typeof e.nodeName == "string" && typeof e.getAttribute == "function";
}
function yO(e, t) {
  if (e.length > t.maxStringLength) {
    var n = e.length - t.maxStringLength, r = "... " + n + " more character" + (n > 1 ? "s" : "");
    return yO(yy.call(e, 0, t.maxStringLength), t) + r;
  }
  var i = Ni.call(Ni.call(e, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, aoe);
  return hO(i, "single", t);
}
function aoe(e) {
  var t = e.charCodeAt(0), n = {
    8: "b",
    9: "t",
    10: "n",
    12: "f",
    13: "r"
  }[t];
  return n ? "\\" + n : "\\x" + (t < 16 ? "0" : "") + Bae.call(t.toString(16));
}
function gs(e) {
  return "Object(" + e + ")";
}
function Bp(e) {
  return e + " { ? }";
}
function s0(e, t, n, r) {
  var i = r ? um(n, r) : $r.call(n, ", ");
  return e + " (" + t + ") {" + i + "}";
}
function ooe(e) {
  for (var t = 0; t < e.length; t++)
    if (gO(e[t], `
`) >= 0)
      return !1;
  return !0;
}
function soe(e, t) {
  var n;
  if (e.indent === "	")
    n = "	";
  else if (typeof e.indent == "number" && e.indent > 0)
    n = $r.call(Array(e.indent + 1), " ");
  else
    return null;
  return {
    base: n,
    prev: $r.call(Array(t + 1), n)
  };
}
function um(e, t) {
  if (e.length === 0)
    return "";
  var n = `
` + t.prev + t.base;
  return n + $r.call(e, "," + n) + `
` + t.prev;
}
function dc(e, t) {
  var n = cm(e), r = [];
  if (n) {
    r.length = e.length;
    for (var i = 0; i < e.length; i++)
      r[i] = $i(e, i) ? t(e[i], e) : "";
  }
  var a = typeof Fp == "function" ? Fp(e) : [], o;
  if (Do) {
    o = {};
    for (var s = 0; s < a.length; s++)
      o["$" + a[s]] = a[s];
  }
  for (var l in e)
    $i(e, l) && (n && String(Number(l)) === l && l < e.length || Do && o["$" + l] instanceof Symbol || (fO.call(/[^\w$]/, l) ? r.push(t(l, e) + ": " + t(e[l], e)) : r.push(l + ": " + t(e[l], e))));
  if (typeof Fp == "function")
    for (var c = 0; c < a.length; c++)
      pO.call(e, a[c]) && r.push("[" + t(a[c]) + "]: " + t(e[a[c]], e));
  return r;
}
var vy = hy, ss = Iae, loe = Zae, coe = vy("%TypeError%"), fc = vy("%WeakMap%", !0), pc = vy("%Map%", !0), uoe = ss("WeakMap.prototype.get", !0), doe = ss("WeakMap.prototype.set", !0), foe = ss("WeakMap.prototype.has", !0), poe = ss("Map.prototype.get", !0), hoe = ss("Map.prototype.set", !0), moe = ss("Map.prototype.has", !0), by = function(e, t) {
  for (var n = e, r; (r = n.next) !== null; n = r)
    if (r.key === t)
      return n.next = r.next, r.next = e.next, e.next = r, r;
}, goe = function(e, t) {
  var n = by(e, t);
  return n && n.value;
}, yoe = function(e, t, n) {
  var r = by(e, t);
  r ? r.value = n : e.next = {
    // eslint-disable-line no-param-reassign
    key: t,
    next: e.next,
    value: n
  };
}, voe = function(e, t) {
  return !!by(e, t);
}, boe = function() {
  var t, n, r, i = {
    assert: function(a) {
      if (!i.has(a))
        throw new coe("Side channel does not contain " + loe(a));
    },
    get: function(a) {
      if (fc && a && (typeof a == "object" || typeof a == "function")) {
        if (t)
          return uoe(t, a);
      } else if (pc) {
        if (n)
          return poe(n, a);
      } else if (r)
        return goe(r, a);
    },
    has: function(a) {
      if (fc && a && (typeof a == "object" || typeof a == "function")) {
        if (t)
          return foe(t, a);
      } else if (pc) {
        if (n)
          return moe(n, a);
      } else if (r)
        return voe(r, a);
      return !1;
    },
    set: function(a, o) {
      fc && a && (typeof a == "object" || typeof a == "function") ? (t || (t = new fc()), doe(t, a, o)) : pc ? (n || (n = new pc()), hoe(n, a, o)) : (r || (r = { key: {}, next: null }), yoe(r, a, o));
    }
  };
  return i;
}, woe = String.prototype.replace, xoe = /%20/g, zp = {
  RFC1738: "RFC1738",
  RFC3986: "RFC3986"
}, wy = {
  default: zp.RFC3986,
  formatters: {
    RFC1738: function(e) {
      return woe.call(e, xoe, "+");
    },
    RFC3986: function(e) {
      return String(e);
    }
  },
  RFC1738: zp.RFC1738,
  RFC3986: zp.RFC3986
}, _oe = wy, Zp = Object.prototype.hasOwnProperty, da = Array.isArray, Or = function() {
  for (var e = [], t = 0; t < 256; ++t)
    e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
  return e;
}(), Soe = function(t) {
  for (; t.length > 1; ) {
    var n = t.pop(), r = n.obj[n.prop];
    if (da(r)) {
      for (var i = [], a = 0; a < r.length; ++a)
        typeof r[a] < "u" && i.push(r[a]);
      n.obj[n.prop] = i;
    }
  }
}, vO = function(t, n) {
  for (var r = n && n.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, i = 0; i < t.length; ++i)
    typeof t[i] < "u" && (r[i] = t[i]);
  return r;
}, Eoe = function e(t, n, r) {
  if (!n)
    return t;
  if (typeof n != "object") {
    if (da(t))
      t.push(n);
    else if (t && typeof t == "object")
      (r && (r.plainObjects || r.allowPrototypes) || !Zp.call(Object.prototype, n)) && (t[n] = !0);
    else
      return [t, n];
    return t;
  }
  if (!t || typeof t != "object")
    return [t].concat(n);
  var i = t;
  return da(t) && !da(n) && (i = vO(t, r)), da(t) && da(n) ? (n.forEach(function(a, o) {
    if (Zp.call(t, o)) {
      var s = t[o];
      s && typeof s == "object" && a && typeof a == "object" ? t[o] = e(s, a, r) : t.push(a);
    } else
      t[o] = a;
  }), t) : Object.keys(n).reduce(function(a, o) {
    var s = n[o];
    return Zp.call(a, o) ? a[o] = e(a[o], s, r) : a[o] = s, a;
  }, i);
}, koe = function(t, n) {
  return Object.keys(n).reduce(function(r, i) {
    return r[i] = n[i], r;
  }, t);
}, Toe = function(e, t, n) {
  var r = e.replace(/\+/g, " ");
  if (n === "iso-8859-1")
    return r.replace(/%[0-9a-f]{2}/gi, unescape);
  try {
    return decodeURIComponent(r);
  } catch {
    return r;
  }
}, Coe = function(t, n, r, i, a) {
  if (t.length === 0)
    return t;
  var o = t;
  if (typeof t == "symbol" ? o = Symbol.prototype.toString.call(t) : typeof t != "string" && (o = String(t)), r === "iso-8859-1")
    return escape(o).replace(/%u[0-9a-f]{4}/gi, function(u) {
      return "%26%23" + parseInt(u.slice(2), 16) + "%3B";
    });
  for (var s = "", l = 0; l < o.length; ++l) {
    var c = o.charCodeAt(l);
    if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || a === _oe.RFC1738 && (c === 40 || c === 41)) {
      s += o.charAt(l);
      continue;
    }
    if (c < 128) {
      s = s + Or[c];
      continue;
    }
    if (c < 2048) {
      s = s + (Or[192 | c >> 6] + Or[128 | c & 63]);
      continue;
    }
    if (c < 55296 || c >= 57344) {
      s = s + (Or[224 | c >> 12] + Or[128 | c >> 6 & 63] + Or[128 | c & 63]);
      continue;
    }
    l += 1, c = 65536 + ((c & 1023) << 10 | o.charCodeAt(l) & 1023), s += Or[240 | c >> 18] + Or[128 | c >> 12 & 63] + Or[128 | c >> 6 & 63] + Or[128 | c & 63];
  }
  return s;
}, Ooe = function(t) {
  for (var n = [{ obj: { o: t }, prop: "o" }], r = [], i = 0; i < n.length; ++i)
    for (var a = n[i], o = a.obj[a.prop], s = Object.keys(o), l = 0; l < s.length; ++l) {
      var c = s[l], u = o[c];
      typeof u == "object" && u !== null && r.indexOf(u) === -1 && (n.push({ obj: o, prop: c }), r.push(u));
    }
  return Soe(n), t;
}, Aoe = function(t) {
  return Object.prototype.toString.call(t) === "[object RegExp]";
}, $oe = function(t) {
  return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t));
}, Roe = function(t, n) {
  return [].concat(t, n);
}, Poe = function(t, n) {
  if (da(t)) {
    for (var r = [], i = 0; i < t.length; i += 1)
      r.push(n(t[i]));
    return r;
  }
  return n(t);
}, bO = {
  arrayToObject: vO,
  assign: koe,
  combine: Roe,
  compact: Ooe,
  decode: Toe,
  encode: Coe,
  isBuffer: $oe,
  isRegExp: Aoe,
  maybeMap: Poe,
  merge: Eoe
}, wO = boe, Zc = bO, $s = wy, Ioe = Object.prototype.hasOwnProperty, l0 = {
  brackets: function(t) {
    return t + "[]";
  },
  comma: "comma",
  indices: function(t, n) {
    return t + "[" + n + "]";
  },
  repeat: function(t) {
    return t;
  }
}, ri = Array.isArray, Moe = Array.prototype.push, xO = function(e, t) {
  Moe.apply(e, ri(t) ? t : [t]);
}, Noe = Date.prototype.toISOString, c0 = $s.default, En = {
  addQueryPrefix: !1,
  allowDots: !1,
  charset: "utf-8",
  charsetSentinel: !1,
  delimiter: "&",
  encode: !0,
  encoder: Zc.encode,
  encodeValuesOnly: !1,
  format: c0,
  formatter: $s.formatters[c0],
  // deprecated
  indices: !1,
  serializeDate: function(t) {
    return Noe.call(t);
  },
  skipNulls: !1,
  strictNullHandling: !1
}, Doe = function(t) {
  return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint";
}, qp = {}, Loe = function e(t, n, r, i, a, o, s, l, c, u, d, p, f, h, m, y) {
  for (var g = t, v = y, b = 0, T = !1; (v = v.get(qp)) !== void 0 && !T; ) {
    var O = v.get(t);
    if (b += 1, typeof O < "u") {
      if (O === b)
        throw new RangeError("Cyclic object value");
      T = !0;
    }
    typeof v.get(qp) > "u" && (b = 0);
  }
  if (typeof l == "function" ? g = l(n, g) : g instanceof Date ? g = d(g) : r === "comma" && ri(g) && (g = Zc.maybeMap(g, function(j) {
    return j instanceof Date ? d(j) : j;
  })), g === null) {
    if (a)
      return s && !h ? s(n, En.encoder, m, "key", p) : n;
    g = "";
  }
  if (Doe(g) || Zc.isBuffer(g)) {
    if (s) {
      var S = h ? n : s(n, En.encoder, m, "key", p);
      return [f(S) + "=" + f(s(g, En.encoder, m, "value", p))];
    }
    return [f(n) + "=" + f(String(g))];
  }
  var P = [];
  if (typeof g > "u")
    return P;
  var M;
  if (r === "comma" && ri(g))
    h && s && (g = Zc.maybeMap(g, s)), M = [{ value: g.length > 0 ? g.join(",") || null : void 0 }];
  else if (ri(l))
    M = l;
  else {
    var L = Object.keys(g);
    M = c ? L.sort(c) : L;
  }
  for (var k = i && ri(g) && g.length === 1 ? n + "[]" : n, I = 0; I < M.length; ++I) {
    var B = M[I], U = typeof B == "object" && typeof B.value < "u" ? B.value : g[B];
    if (!(o && U === null)) {
      var z = ri(g) ? typeof r == "function" ? r(k, B) : k : k + (u ? "." + B : "[" + B + "]");
      y.set(t, b);
      var D = wO();
      D.set(qp, y), xO(P, e(
        U,
        z,
        r,
        i,
        a,
        o,
        r === "comma" && h && ri(g) ? null : s,
        l,
        c,
        u,
        d,
        p,
        f,
        h,
        m,
        D
      ));
    }
  }
  return P;
}, joe = function(t) {
  if (!t)
    return En;
  if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function")
    throw new TypeError("Encoder has to be a function.");
  var n = t.charset || En.charset;
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var r = $s.default;
  if (typeof t.format < "u") {
    if (!Ioe.call($s.formatters, t.format))
      throw new TypeError("Unknown format option provided.");
    r = t.format;
  }
  var i = $s.formatters[r], a = En.filter;
  return (typeof t.filter == "function" || ri(t.filter)) && (a = t.filter), {
    addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : En.addQueryPrefix,
    allowDots: typeof t.allowDots > "u" ? En.allowDots : !!t.allowDots,
    charset: n,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : En.charsetSentinel,
    delimiter: typeof t.delimiter > "u" ? En.delimiter : t.delimiter,
    encode: typeof t.encode == "boolean" ? t.encode : En.encode,
    encoder: typeof t.encoder == "function" ? t.encoder : En.encoder,
    encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : En.encodeValuesOnly,
    filter: a,
    format: r,
    formatter: i,
    serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : En.serializeDate,
    skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : En.skipNulls,
    sort: typeof t.sort == "function" ? t.sort : null,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : En.strictNullHandling
  };
}, Uoe = function(e, t) {
  var n = e, r = joe(t), i, a;
  typeof r.filter == "function" ? (a = r.filter, n = a("", n)) : ri(r.filter) && (a = r.filter, i = a);
  var o = [];
  if (typeof n != "object" || n === null)
    return "";
  var s;
  t && t.arrayFormat in l0 ? s = t.arrayFormat : t && "indices" in t ? s = t.indices ? "indices" : "repeat" : s = "indices";
  var l = l0[s];
  if (t && "commaRoundTrip" in t && typeof t.commaRoundTrip != "boolean")
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  var c = l === "comma" && t && t.commaRoundTrip;
  i || (i = Object.keys(n)), r.sort && i.sort(r.sort);
  for (var u = wO(), d = 0; d < i.length; ++d) {
    var p = i[d];
    r.skipNulls && n[p] === null || xO(o, Loe(
      n[p],
      p,
      l,
      c,
      r.strictNullHandling,
      r.skipNulls,
      r.encode ? r.encoder : null,
      r.filter,
      r.sort,
      r.allowDots,
      r.serializeDate,
      r.format,
      r.formatter,
      r.encodeValuesOnly,
      r.charset,
      u
    ));
  }
  var f = o.join(r.delimiter), h = r.addQueryPrefix === !0 ? "?" : "";
  return r.charsetSentinel && (r.charset === "iso-8859-1" ? h += "utf8=%26%2310003%3B&" : h += "utf8=%E2%9C%93&"), f.length > 0 ? h + f : "";
}, Lo = bO, dm = Object.prototype.hasOwnProperty, Foe = Array.isArray, pn = {
  allowDots: !1,
  allowPrototypes: !1,
  allowSparse: !1,
  arrayLimit: 20,
  charset: "utf-8",
  charsetSentinel: !1,
  comma: !1,
  decoder: Lo.decode,
  delimiter: "&",
  depth: 5,
  ignoreQueryPrefix: !1,
  interpretNumericEntities: !1,
  parameterLimit: 1e3,
  parseArrays: !0,
  plainObjects: !1,
  strictNullHandling: !1
}, Boe = function(e) {
  return e.replace(/&#(\d+);/g, function(t, n) {
    return String.fromCharCode(parseInt(n, 10));
  });
}, _O = function(e, t) {
  return e && typeof e == "string" && t.comma && e.indexOf(",") > -1 ? e.split(",") : e;
}, zoe = "utf8=%26%2310003%3B", Zoe = "utf8=%E2%9C%93", qoe = function(t, n) {
  var r = { __proto__: null }, i = n.ignoreQueryPrefix ? t.replace(/^\?/, "") : t, a = n.parameterLimit === 1 / 0 ? void 0 : n.parameterLimit, o = i.split(n.delimiter, a), s = -1, l, c = n.charset;
  if (n.charsetSentinel)
    for (l = 0; l < o.length; ++l)
      o[l].indexOf("utf8=") === 0 && (o[l] === Zoe ? c = "utf-8" : o[l] === zoe && (c = "iso-8859-1"), s = l, l = o.length);
  for (l = 0; l < o.length; ++l)
    if (l !== s) {
      var u = o[l], d = u.indexOf("]="), p = d === -1 ? u.indexOf("=") : d + 1, f, h;
      p === -1 ? (f = n.decoder(u, pn.decoder, c, "key"), h = n.strictNullHandling ? null : "") : (f = n.decoder(u.slice(0, p), pn.decoder, c, "key"), h = Lo.maybeMap(
        _O(u.slice(p + 1), n),
        function(m) {
          return n.decoder(m, pn.decoder, c, "value");
        }
      )), h && n.interpretNumericEntities && c === "iso-8859-1" && (h = Boe(h)), u.indexOf("[]=") > -1 && (h = Foe(h) ? [h] : h), dm.call(r, f) ? r[f] = Lo.combine(r[f], h) : r[f] = h;
    }
  return r;
}, Woe = function(e, t, n, r) {
  for (var i = r ? t : _O(t, n), a = e.length - 1; a >= 0; --a) {
    var o, s = e[a];
    if (s === "[]" && n.parseArrays)
      o = [].concat(i);
    else {
      o = n.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var l = s.charAt(0) === "[" && s.charAt(s.length - 1) === "]" ? s.slice(1, -1) : s, c = parseInt(l, 10);
      !n.parseArrays && l === "" ? o = { 0: i } : !isNaN(c) && s !== l && String(c) === l && c >= 0 && n.parseArrays && c <= n.arrayLimit ? (o = [], o[c] = i) : l !== "__proto__" && (o[l] = i);
    }
    i = o;
  }
  return i;
}, Voe = function(t, n, r, i) {
  if (t) {
    var a = r.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t, o = /(\[[^[\]]*])/, s = /(\[[^[\]]*])/g, l = r.depth > 0 && o.exec(a), c = l ? a.slice(0, l.index) : a, u = [];
    if (c) {
      if (!r.plainObjects && dm.call(Object.prototype, c) && !r.allowPrototypes)
        return;
      u.push(c);
    }
    for (var d = 0; r.depth > 0 && (l = s.exec(a)) !== null && d < r.depth; ) {
      if (d += 1, !r.plainObjects && dm.call(Object.prototype, l[1].slice(1, -1)) && !r.allowPrototypes)
        return;
      u.push(l[1]);
    }
    return l && u.push("[" + a.slice(l.index) + "]"), Woe(u, n, r, i);
  }
}, Hoe = function(t) {
  if (!t)
    return pn;
  if (t.decoder !== null && t.decoder !== void 0 && typeof t.decoder != "function")
    throw new TypeError("Decoder has to be a function.");
  if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  var n = typeof t.charset > "u" ? pn.charset : t.charset;
  return {
    allowDots: typeof t.allowDots > "u" ? pn.allowDots : !!t.allowDots,
    allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : pn.allowPrototypes,
    allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : pn.allowSparse,
    arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : pn.arrayLimit,
    charset: n,
    charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : pn.charsetSentinel,
    comma: typeof t.comma == "boolean" ? t.comma : pn.comma,
    decoder: typeof t.decoder == "function" ? t.decoder : pn.decoder,
    delimiter: typeof t.delimiter == "string" || Lo.isRegExp(t.delimiter) ? t.delimiter : pn.delimiter,
    // eslint-disable-next-line no-implicit-coercion, no-extra-parens
    depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : pn.depth,
    ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
    interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : pn.interpretNumericEntities,
    parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : pn.parameterLimit,
    parseArrays: t.parseArrays !== !1,
    plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : pn.plainObjects,
    strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : pn.strictNullHandling
  };
}, Koe = function(e, t) {
  var n = Hoe(t);
  if (e === "" || e === null || typeof e > "u")
    return n.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
  for (var r = typeof e == "string" ? qoe(e, n) : e, i = n.plainObjects ? /* @__PURE__ */ Object.create(null) : {}, a = Object.keys(r), o = 0; o < a.length; ++o) {
    var s = a[o], l = Voe(s, r[s], n, typeof e == "string");
    i = Lo.merge(i, l, n);
  }
  return n.allowSparse === !0 ? i : Lo.compact(i);
}, Goe = Uoe, Joe = Koe, Yoe = wy, Xoe = {
  formats: Yoe,
  parse: Joe,
  stringify: Goe
};
const Qoe = /* @__PURE__ */ Ki(Xoe), ese = (e) => e[1] !== void 0, sn = (e) => {
  const { method: t, path: n, query: r, headers: i, body: a } = e, o = Object.entries(i).filter(ese), s = Object.fromEntries(o), l = Qoe.stringify(r, { encode: !0, arrayFormat: "repeat", allowDots: !0 }), c = l ? [n, l].join("?") : n;
  return {
    method: t,
    url: c,
    headers: s,
    data: a
  };
}, tse = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: { userId: e.userId }
}), nse = (e) => ({
  path: "/conversations",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { _: e._ }
}), rse = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), ise = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), ase = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants/${encodeURIComponent(e.userId)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id, userId: e.userId },
  body: {}
}), ose = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/messages`,
  headers: { "x-user-key": e["x-user-key"] },
  query: { nextToken: e.nextToken },
  params: { id: e.id },
  body: {}
}), sse = (e) => ({
  path: "/conversations",
  headers: { "x-user-key": e["x-user-key"] },
  query: { nextToken: e.nextToken },
  params: {},
  body: {}
}), lse = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants`,
  headers: { "x-user-key": e["x-user-key"] },
  query: { nextToken: e.nextToken },
  params: { id: e.id },
  body: {}
}), cse = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/listen`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), use = (e) => ({
  path: `/conversations/${encodeURIComponent(e.id)}/participants/${encodeURIComponent(e.userId)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id, userId: e.userId },
  body: {}
}), dse = (e) => ({
  path: "/messages",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { payload: e.payload, conversationId: e.conversationId }
}), fse = (e) => ({
  path: `/messages/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), pse = (e) => ({
  path: `/messages/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
}), hse = (e) => ({
  path: "/users",
  headers: {},
  query: {},
  params: {},
  body: { name: e.name, pictureUrl: e.pictureUrl, userData: e.userData }
}), mse = (e) => ({
  path: "/users/me",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: {}
}), gse = (e) => ({
  path: "/users/me",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: {}
}), yse = (e) => ({
  path: "/users/me",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { name: e.name, pictureUrl: e.pictureUrl, userData: e.userData }
}), vse = (e) => ({
  path: "/events",
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: {},
  body: { payload: e.payload, conversationId: e.conversationId }
}), bse = (e) => ({
  path: `/events/${encodeURIComponent(e.id)}`,
  headers: { "x-user-key": e["x-user-key"] },
  query: {},
  params: { id: e.id },
  body: {}
});
let wse = class {
  constructor(t, n = {}) {
    _(this, "addParticipant", async (t) => {
      const { path: n, headers: r, query: i, body: a } = tse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "post",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "createConversation", async (t) => {
      const { path: n, headers: r, query: i, body: a } = nse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "post",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "deleteConversation", async (t) => {
      const { path: n, headers: r, query: i, body: a } = rse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "delete",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "getConversation", async (t) => {
      const { path: n, headers: r, query: i, body: a } = ise(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "getParticipant", async (t) => {
      const { path: n, headers: r, query: i, body: a } = ase(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "listConversationMessages", async (t) => {
      const { path: n, headers: r, query: i, body: a } = ose(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "listConversations", async (t) => {
      const { path: n, headers: r, query: i, body: a } = sse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "listParticipants", async (t) => {
      const { path: n, headers: r, query: i, body: a } = lse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "listenConversation", async (t) => {
      const { path: n, headers: r, query: i, body: a } = cse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "removeParticipant", async (t) => {
      const { path: n, headers: r, query: i, body: a } = use(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "delete",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "createMessage", async (t) => {
      const { path: n, headers: r, query: i, body: a } = dse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "post",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "deleteMessage", async (t) => {
      const { path: n, headers: r, query: i, body: a } = fse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "delete",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "getMessage", async (t) => {
      const { path: n, headers: r, query: i, body: a } = pse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "createUser", async (t) => {
      const { path: n, headers: r, query: i, body: a } = hse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "post",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "deleteUser", async (t) => {
      const { path: n, headers: r, query: i, body: a } = mse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "delete",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "getUser", async (t) => {
      const { path: n, headers: r, query: i, body: a } = gse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "updateUser", async (t) => {
      const { path: n, headers: r, query: i, body: a } = yse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "put",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "createEvent", async (t) => {
      const { path: n, headers: r, query: i, body: a } = vse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "post",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    _(this, "getEvent", async (t) => {
      const { path: n, headers: r, query: i, body: a } = bse(t), s = (this.props.toAxiosRequest ?? sn)({
        method: "get",
        path: n,
        headers: { ...r },
        query: { ...i },
        body: a
      });
      return this.axiosInstance.request(s).then((l) => l.data).catch((l) => {
        throw ln(l);
      });
    });
    this.axiosInstance = t, this.props = n;
  }
};
function ln(e) {
  var t;
  return sO.isAxiosError(e) && ((t = e.response) != null && t.data) ? qw(e.response.data) : qw(e);
}
class SO {
  constructor() {
    _(this, "listeners", {});
  }
  emit(t, n) {
    const r = this.listeners[t];
    if (r)
      for (const i of [...r])
        i(n);
  }
  onceOrMore(t, n) {
    const r = (i) => {
      n(i) === "stop-listening" && this.off(t, r);
    };
    this.on(t, r);
  }
  once(t, n) {
    const r = (i) => {
      this.off(t, r), n(i);
    };
    this.on(t, r);
  }
  on(t, n) {
    this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push(n);
  }
  off(t, n) {
    const r = this.listeners[t];
    if (!r)
      return;
    const i = r.indexOf(n);
    i !== -1 && r.splice(i, 1);
  }
  cleanup() {
    this.listeners = {};
  }
}
var fm = { exports: {} };
/** @license
 * eventsource.js
 * Available under MIT License (MIT)
 * https://github.com/Yaffle/EventSource/
 */
(function(e, t) {
  (function(n) {
    var r = n.setTimeout, i = n.clearTimeout, a = n.XMLHttpRequest, o = n.XDomainRequest, s = n.ActiveXObject, l = n.EventSource, c = n.document, u = n.Promise, d = n.fetch, p = n.Response, f = n.TextDecoder, h = n.TextEncoder, m = n.AbortController;
    if (typeof window < "u" && typeof c < "u" && !("readyState" in c) && c.body == null && (c.readyState = "loading", window.addEventListener("load", function(N) {
      c.readyState = "complete";
    }, !1)), a == null && s != null && (a = function() {
      return new s("Microsoft.XMLHTTP");
    }), Object.create == null && (Object.create = function(N) {
      function le() {
      }
      return le.prototype = N, new le();
    }), Date.now || (Date.now = function() {
      return (/* @__PURE__ */ new Date()).getTime();
    }), m == null) {
      var y = d;
      d = function(N, le) {
        var pe = le.signal;
        return y(N, { headers: le.headers, credentials: le.credentials, cache: le.cache }).then(function(ue) {
          var Le = ue.body.getReader();
          return pe._reader = Le, pe._aborted && pe._reader.cancel(), {
            status: ue.status,
            statusText: ue.statusText,
            headers: ue.headers,
            body: {
              getReader: function() {
                return Le;
              }
            }
          };
        });
      }, m = function() {
        this.signal = {
          _reader: null,
          _aborted: !1
        }, this.abort = function() {
          this.signal._reader != null && this.signal._reader.cancel(), this.signal._aborted = !0;
        };
      };
    }
    function g() {
      this.bitsNeeded = 0, this.codePoint = 0;
    }
    g.prototype.decode = function(N) {
      function le(Z, J, ce) {
        if (ce === 1)
          return Z >= 128 >> J && Z << J <= 2047;
        if (ce === 2)
          return Z >= 2048 >> J && Z << J <= 55295 || Z >= 57344 >> J && Z << J <= 65535;
        if (ce === 3)
          return Z >= 65536 >> J && Z << J <= 1114111;
        throw new Error();
      }
      function pe(Z, J) {
        if (Z === 6 * 1)
          return J >> 6 > 15 ? 3 : J > 31 ? 2 : 1;
        if (Z === 6 * 2)
          return J > 15 ? 3 : 2;
        if (Z === 6 * 3)
          return 3;
        throw new Error();
      }
      for (var ue = 65533, Le = "", Me = this.bitsNeeded, Ke = this.codePoint, gt = 0; gt < N.length; gt += 1) {
        var tt = N[gt];
        Me !== 0 && (tt < 128 || tt > 191 || !le(Ke << 6 | tt & 63, Me - 6, pe(Me, Ke))) && (Me = 0, Ke = ue, Le += String.fromCharCode(Ke)), Me === 0 ? (tt >= 0 && tt <= 127 ? (Me = 0, Ke = tt) : tt >= 192 && tt <= 223 ? (Me = 6 * 1, Ke = tt & 31) : tt >= 224 && tt <= 239 ? (Me = 6 * 2, Ke = tt & 15) : tt >= 240 && tt <= 247 ? (Me = 6 * 3, Ke = tt & 7) : (Me = 0, Ke = ue), Me !== 0 && !le(Ke, Me, pe(Me, Ke)) && (Me = 0, Ke = ue)) : (Me -= 6, Ke = Ke << 6 | tt & 63), Me === 0 && (Ke <= 65535 ? Le += String.fromCharCode(Ke) : (Le += String.fromCharCode(55296 + (Ke - 65535 - 1 >> 10)), Le += String.fromCharCode(56320 + (Ke - 65535 - 1 & 1023))));
      }
      return this.bitsNeeded = Me, this.codePoint = Ke, Le;
    };
    var v = function() {
      try {
        return new f().decode(new h().encode("test"), { stream: !0 }) === "test";
      } catch (N) {
        console.debug("TextDecoder does not support streaming option. Using polyfill instead: " + N);
      }
      return !1;
    };
    (f == null || h == null || !v()) && (f = g);
    var b = function() {
    };
    function T(N) {
      this.withCredentials = !1, this.readyState = 0, this.status = 0, this.statusText = "", this.responseText = "", this.onprogress = b, this.onload = b, this.onerror = b, this.onreadystatechange = b, this._contentType = "", this._xhr = N, this._sendTimeout = 0, this._abort = b;
    }
    T.prototype.open = function(N, le) {
      this._abort(!0);
      var pe = this, ue = this._xhr, Le = 1, Me = 0;
      this._abort = function(ce) {
        pe._sendTimeout !== 0 && (i(pe._sendTimeout), pe._sendTimeout = 0), (Le === 1 || Le === 2 || Le === 3) && (Le = 4, ue.onload = b, ue.onerror = b, ue.onabort = b, ue.onprogress = b, ue.onreadystatechange = b, ue.abort(), Me !== 0 && (i(Me), Me = 0), ce || (pe.readyState = 4, pe.onabort(null), pe.onreadystatechange())), Le = 0;
      };
      var Ke = function() {
        if (Le === 1) {
          var ce = 0, Ne = "", it = void 0;
          if ("contentType" in ue)
            ce = 200, Ne = "OK", it = ue.contentType;
          else
            try {
              ce = ue.status, Ne = ue.statusText, it = ue.getResponseHeader("Content-Type");
            } catch {
              ce = 0, Ne = "", it = void 0;
            }
          ce !== 0 && (Le = 2, pe.readyState = 2, pe.status = ce, pe.statusText = Ne, pe._contentType = it, pe.onreadystatechange());
        }
      }, gt = function() {
        if (Ke(), Le === 2 || Le === 3) {
          Le = 3;
          var ce = "";
          try {
            ce = ue.responseText;
          } catch {
          }
          pe.readyState = 3, pe.responseText = ce, pe.onprogress();
        }
      }, tt = function(ce, Ne) {
        if ((Ne == null || Ne.preventDefault == null) && (Ne = {
          preventDefault: b
        }), gt(), Le === 1 || Le === 2 || Le === 3) {
          if (Le = 4, Me !== 0 && (i(Me), Me = 0), pe.readyState = 4, ce === "load")
            pe.onload(Ne);
          else if (ce === "error")
            pe.onerror(Ne);
          else if (ce === "abort")
            pe.onabort(Ne);
          else
            throw new TypeError();
          pe.onreadystatechange();
        }
      }, Z = function(ce) {
        ue != null && (ue.readyState === 4 ? (!("onload" in ue) || !("onerror" in ue) || !("onabort" in ue)) && tt(ue.responseText === "" ? "error" : "load", ce) : ue.readyState === 3 ? "onprogress" in ue || gt() : ue.readyState === 2 && Ke());
      }, J = function() {
        Me = r(function() {
          J();
        }, 500), ue.readyState === 3 && gt();
      };
      "onload" in ue && (ue.onload = function(ce) {
        tt("load", ce);
      }), "onerror" in ue && (ue.onerror = function(ce) {
        tt("error", ce);
      }), "onabort" in ue && (ue.onabort = function(ce) {
        tt("abort", ce);
      }), "onprogress" in ue && (ue.onprogress = gt), "onreadystatechange" in ue && (ue.onreadystatechange = function(ce) {
        Z(ce);
      }), ("contentType" in ue || !("ontimeout" in a.prototype)) && (le += (le.indexOf("?") === -1 ? "?" : "&") + "padding=true"), ue.open(N, le, !0), "readyState" in ue && (Me = r(function() {
        J();
      }, 0));
    }, T.prototype.abort = function() {
      this._abort(!1);
    }, T.prototype.getResponseHeader = function(N) {
      return this._contentType;
    }, T.prototype.setRequestHeader = function(N, le) {
      var pe = this._xhr;
      "setRequestHeader" in pe && pe.setRequestHeader(N, le);
    }, T.prototype.getAllResponseHeaders = function() {
      return this._xhr.getAllResponseHeaders != null && this._xhr.getAllResponseHeaders() || "";
    }, T.prototype.send = function() {
      if ((!("ontimeout" in a.prototype) || !("sendAsBinary" in a.prototype) && !("mozAnon" in a.prototype)) && c != null && c.readyState != null && c.readyState !== "complete") {
        var N = this;
        N._sendTimeout = r(function() {
          N._sendTimeout = 0, N.send();
        }, 4);
        return;
      }
      var le = this._xhr;
      "withCredentials" in le && (le.withCredentials = this.withCredentials);
      try {
        le.send(void 0);
      } catch (pe) {
        throw pe;
      }
    };
    function O(N) {
      return N.replace(/[A-Z]/g, function(le) {
        return String.fromCharCode(le.charCodeAt(0) + 32);
      });
    }
    function S(N) {
      for (var le = /* @__PURE__ */ Object.create(null), pe = N.split(`\r
`), ue = 0; ue < pe.length; ue += 1) {
        var Le = pe[ue], Me = Le.split(": "), Ke = Me.shift(), gt = Me.join(": ");
        le[O(Ke)] = gt;
      }
      this._map = le;
    }
    S.prototype.get = function(N) {
      return this._map[O(N)];
    }, a != null && a.HEADERS_RECEIVED == null && (a.HEADERS_RECEIVED = 2);
    function P() {
    }
    P.prototype.open = function(N, le, pe, ue, Le, Me, Ke) {
      N.open("GET", Le);
      var gt = 0;
      N.onprogress = function() {
        var Z = N.responseText, J = Z.slice(gt);
        gt += J.length, pe(J);
      }, N.onerror = function(Z) {
        Z.preventDefault(), ue(new Error("NetworkError"));
      }, N.onload = function() {
        ue(null);
      }, N.onabort = function() {
        ue(null);
      }, N.onreadystatechange = function() {
        if (N.readyState === a.HEADERS_RECEIVED) {
          var Z = N.status, J = N.statusText, ce = N.getResponseHeader("Content-Type"), Ne = N.getAllResponseHeaders();
          le(Z, J, ce, new S(Ne));
        }
      }, N.withCredentials = Me;
      for (var tt in Ke)
        Object.prototype.hasOwnProperty.call(Ke, tt) && N.setRequestHeader(tt, Ke[tt]);
      return N.send(), N;
    };
    function M(N) {
      this._headers = N;
    }
    M.prototype.get = function(N) {
      return this._headers.get(N);
    };
    function L() {
    }
    L.prototype.open = function(N, le, pe, ue, Le, Me, Ke) {
      var gt = null, tt = new m(), Z = tt.signal, J = new f();
      return d(Le, {
        headers: Ke,
        credentials: Me ? "include" : "same-origin",
        signal: Z,
        cache: "no-store"
      }).then(function(ce) {
        return gt = ce.body.getReader(), le(ce.status, ce.statusText, ce.headers.get("Content-Type"), new M(ce.headers)), new u(function(Ne, it) {
          var zt = function() {
            gt.read().then(function(At) {
              if (At.done)
                Ne(void 0);
              else {
                var Ct = J.decode(At.value, { stream: !0 });
                pe(Ct), zt();
              }
            }).catch(function(At) {
              it(At);
            });
          };
          zt();
        });
      }).catch(function(ce) {
        if (ce.name !== "AbortError")
          return ce;
      }).then(function(ce) {
        ue(ce);
      }), {
        abort: function() {
          gt != null && gt.cancel(), tt.abort();
        }
      };
    };
    function k() {
      this._listeners = /* @__PURE__ */ Object.create(null);
    }
    function I(N) {
      r(function() {
        throw N;
      }, 0);
    }
    k.prototype.dispatchEvent = function(N) {
      N.target = this;
      var le = this._listeners[N.type];
      if (le != null)
        for (var pe = le.length, ue = 0; ue < pe; ue += 1) {
          var Le = le[ue];
          try {
            typeof Le.handleEvent == "function" ? Le.handleEvent(N) : Le.call(this, N);
          } catch (Me) {
            I(Me);
          }
        }
    }, k.prototype.addEventListener = function(N, le) {
      N = String(N);
      var pe = this._listeners, ue = pe[N];
      ue == null && (ue = [], pe[N] = ue);
      for (var Le = !1, Me = 0; Me < ue.length; Me += 1)
        ue[Me] === le && (Le = !0);
      Le || ue.push(le);
    }, k.prototype.removeEventListener = function(N, le) {
      N = String(N);
      var pe = this._listeners, ue = pe[N];
      if (ue != null) {
        for (var Le = [], Me = 0; Me < ue.length; Me += 1)
          ue[Me] !== le && Le.push(ue[Me]);
        Le.length === 0 ? delete pe[N] : pe[N] = Le;
      }
    };
    function B(N) {
      this.type = N, this.target = void 0;
    }
    function U(N, le) {
      B.call(this, N), this.data = le.data, this.lastEventId = le.lastEventId;
    }
    U.prototype = Object.create(B.prototype);
    function z(N, le) {
      B.call(this, N), this.status = le.status, this.statusText = le.statusText, this.headers = le.headers;
    }
    z.prototype = Object.create(B.prototype);
    function D(N, le) {
      B.call(this, N), this.error = le.error;
    }
    D.prototype = Object.create(B.prototype);
    var j = -1, V = 0, W = 1, de = 2, x = -1, ie = 0, ve = 1, E = 2, ke = 3, Ze = /^text\/event\-stream(;.*)?$/i, Pe = 1e3, qe = 18e6, rt = function(N, le) {
      var pe = N == null ? le : parseInt(N, 10);
      return pe !== pe && (pe = le), Ve(pe);
    }, Ve = function(N) {
      return Math.min(Math.max(N, Pe), qe);
    }, be = function(N, le, pe) {
      try {
        typeof le == "function" && le.call(N, pe);
      } catch (ue) {
        I(ue);
      }
    };
    function he(N, le) {
      k.call(this), le = le || {}, this.onopen = void 0, this.onmessage = void 0, this.onerror = void 0, this.url = void 0, this.readyState = void 0, this.withCredentials = void 0, this.headers = void 0, this._close = void 0, Fe(this, N, le);
    }
    function Oe() {
      return a != null && "withCredentials" in a.prototype || o == null ? new a() : new o();
    }
    var we = d != null && p != null && "body" in p.prototype;
    function Fe(N, le, pe) {
      le = String(le);
      var ue = !!pe.withCredentials, Le = pe.lastEventIdQueryParameterName || "lastEventId", Me = Ve(1e3), Ke = rt(pe.heartbeatTimeout, 45e3), gt = "", tt = Me, Z = !1, J = 0, ce = pe.headers || {}, Ne = pe.Transport, it = we && Ne == null ? void 0 : new T(Ne != null ? new Ne() : Oe()), zt = Ne != null && typeof Ne != "string" ? new Ne() : it == null ? new L() : new P(), At = void 0, Ct = 0, Zt = j, Sn = "", qt = "", Yt = "", fn = "", an = ie, Gr = 0, rr = 0, Cr = function(je, Se, $e, lt) {
        if (Zt === V)
          if (je === 200 && $e != null && Ze.test($e)) {
            Zt = W, Z = Date.now(), tt = Me, N.readyState = W;
            var ht = new z("open", {
              status: je,
              statusText: Se,
              headers: lt
            });
            N.dispatchEvent(ht), be(N, N.onopen, ht);
          } else {
            var Dt = "";
            je !== 200 ? (Se && (Se = Se.replace(/\s+/g, " ")), Dt = "EventSource's response has a status " + je + " " + Se + " that is not 200. Aborting the connection.") : Dt = "EventSource's response has a Content-Type specifying an unsupported type: " + ($e == null ? "-" : $e.replace(/\s+/g, " ")) + ". Aborting the connection.", _e();
            var ht = new z("error", {
              status: je,
              statusText: Se,
              headers: lt
            });
            N.dispatchEvent(ht), be(N, N.onerror, ht), console.error(Dt);
          }
      }, ea = function(je) {
        if (Zt === W) {
          for (var Se = -1, $e = 0; $e < je.length; $e += 1) {
            var lt = je.charCodeAt($e);
            (lt === `
`.charCodeAt(0) || lt === "\r".charCodeAt(0)) && (Se = $e);
          }
          var ht = (Se !== -1 ? fn : "") + je.slice(0, Se + 1);
          fn = (Se === -1 ? fn : "") + je.slice(Se + 1), je !== "" && (Z = Date.now(), J += je.length);
          for (var Dt = 0; Dt < ht.length; Dt += 1) {
            var lt = ht.charCodeAt(Dt);
            if (an === x && lt === `
`.charCodeAt(0))
              an = ie;
            else if (an === x && (an = ie), lt === "\r".charCodeAt(0) || lt === `
`.charCodeAt(0)) {
              if (an !== ie) {
                an === ve && (rr = Dt + 1);
                var Vt = ht.slice(Gr, rr - 1), Fn = ht.slice(rr + (rr < Dt && ht.charCodeAt(rr) === " ".charCodeAt(0) ? 1 : 0), Dt);
                Vt === "data" ? (Sn += `
`, Sn += Fn) : Vt === "id" ? qt = Fn : Vt === "event" ? Yt = Fn : Vt === "retry" ? (Me = rt(Fn, Me), tt = Me) : Vt === "heartbeatTimeout" && (Ke = rt(Fn, Ke), Ct !== 0 && (i(Ct), Ct = r(function() {
                  Ae();
                }, Ke)));
              }
              if (an === ie) {
                if (Sn !== "") {
                  gt = qt, Yt === "" && (Yt = "message");
                  var fr = new U(Yt, {
                    data: Sn.slice(1),
                    lastEventId: qt
                  });
                  if (N.dispatchEvent(fr), Yt === "open" ? be(N, N.onopen, fr) : Yt === "message" ? be(N, N.onmessage, fr) : Yt === "error" && be(N, N.onerror, fr), Zt === de)
                    return;
                }
                Sn = "", Yt = "";
              }
              an = lt === "\r".charCodeAt(0) ? x : ie;
            } else
              an === ie && (Gr = Dt, an = ve), an === ve ? lt === ":".charCodeAt(0) && (rr = Dt + 1, an = E) : an === E && (an = ke);
          }
        }
      }, C = function(je) {
        if (Zt === W || Zt === V) {
          Zt = j, Ct !== 0 && (i(Ct), Ct = 0), Ct = r(function() {
            Ae();
          }, tt), tt = Ve(Math.min(Me * 16, tt * 2)), N.readyState = V;
          var Se = new D("error", { error: je });
          N.dispatchEvent(Se), be(N, N.onerror, Se), je != null && console.error(je);
        }
      }, _e = function() {
        Zt = de, At != null && (At.abort(), At = void 0), Ct !== 0 && (i(Ct), Ct = 0), N.readyState = de;
      }, Ae = function() {
        if (Ct = 0, Zt !== j) {
          if (!Z && At != null)
            C(new Error("No activity within " + Ke + " milliseconds. " + (Zt === V ? "No response received." : J + " chars received.") + " Reconnecting.")), At != null && (At.abort(), At = void 0);
          else {
            var je = Math.max((Z || Date.now()) + Ke - Date.now(), 1);
            Z = !1, Ct = r(function() {
              Ae();
            }, je);
          }
          return;
        }
        Z = !1, J = 0, Ct = r(function() {
          Ae();
        }, Ke), Zt = V, Sn = "", Yt = "", qt = gt, fn = "", Gr = 0, rr = 0, an = ie;
        var Se = le;
        if (le.slice(0, 5) !== "data:" && le.slice(0, 5) !== "blob:" && gt !== "") {
          var $e = le.indexOf("?");
          Se = $e === -1 ? le : le.slice(0, $e + 1) + le.slice($e + 1).replace(/(?:^|&)([^=&]*)(?:=[^&]*)?/g, function(Fn, fr) {
            return fr === Le ? "" : Fn;
          }), Se += (le.indexOf("?") === -1 ? "?" : "&") + Le + "=" + encodeURIComponent(gt);
        }
        var lt = N.withCredentials, ht = {};
        ht.Accept = "text/event-stream";
        var Dt = N.headers;
        if (Dt != null)
          for (var Vt in Dt)
            Object.prototype.hasOwnProperty.call(Dt, Vt) && (ht[Vt] = Dt[Vt]);
        try {
          At = zt.open(it, Cr, ea, C, Se, lt, ht);
        } catch (Fn) {
          throw _e(), Fn;
        }
      };
      N.url = le, N.readyState = V, N.withCredentials = ue, N.headers = ce, N._close = _e, Ae();
    }
    he.prototype = Object.create(k.prototype), he.prototype.CONNECTING = V, he.prototype.OPEN = W, he.prototype.CLOSED = de, he.prototype.close = function() {
      this._close();
    }, he.CONNECTING = V, he.OPEN = W, he.CLOSED = de, he.prototype.withCredentials = void 0;
    var st = l;
    a != null && (l == null || !("withCredentials" in l.prototype)) && (st = he), function(N) {
      {
        var le = N(t);
        le !== void 0 && (e.exports = le);
      }
    }(function(N) {
      N.EventSourcePolyfill = he, N.NativeEventSource = l, N.EventSource = st;
    });
  })(typeof globalThis > "u" ? typeof window < "u" ? window : typeof self < "u" ? self : Je : globalThis);
})(fm, fm.exports);
var xse = fm.exports;
const _se = /* @__PURE__ */ Ki(xse), Sse = (e, t = {}) => {
  const n = new _se.EventSourcePolyfill(e, { headers: t.headers }), r = new SO();
  return n.onopen = (i) => r.emit("open", i), n.onmessage = (i) => r.emit("message", i), n.onerror = (i) => r.emit("error", i), {
    emitter: r,
    source: n
  };
}, Ese = async (e, t = {}) => {
  const { emitter: n, source: r } = Sse(e, t);
  return await new Promise((i, a) => {
    n.on("open", () => {
      i();
    }), n.on("error", (o) => {
      a(o);
    });
  }).finally(() => n.cleanup()), {
    on: n.on.bind(n),
    close: () => {
      n.cleanup(), r.close();
    }
  };
};
var Et;
(function(e) {
  e.assertEqual = (i) => i;
  function t(i) {
  }
  e.assertIs = t;
  function n(i) {
    throw new Error();
  }
  e.assertNever = n, e.arrayToEnum = (i) => {
    const a = {};
    for (const o of i)
      a[o] = o;
    return a;
  }, e.getValidEnumValues = (i) => {
    const a = e.objectKeys(i).filter((s) => typeof i[i[s]] != "number"), o = {};
    for (const s of a)
      o[s] = i[s];
    return e.objectValues(o);
  }, e.objectValues = (i) => e.objectKeys(i).map(function(a) {
    return i[a];
  }), e.objectKeys = typeof Object.keys == "function" ? (i) => Object.keys(i) : (i) => {
    const a = [];
    for (const o in i)
      Object.prototype.hasOwnProperty.call(i, o) && a.push(o);
    return a;
  }, e.find = (i, a) => {
    for (const o of i)
      if (a(o))
        return o;
  }, e.isInteger = typeof Number.isInteger == "function" ? (i) => Number.isInteger(i) : (i) => typeof i == "number" && isFinite(i) && Math.floor(i) === i;
  function r(i, a = " | ") {
    return i.map((o) => typeof o == "string" ? `'${o}'` : o).join(a);
  }
  e.joinValues = r, e.jsonStringifyReplacer = (i, a) => typeof a == "bigint" ? a.toString() : a;
})(Et || (Et = {}));
var pm;
(function(e) {
  e.mergeShapes = (t, n) => ({
    ...t,
    ...n
    // second overwrites first
  });
})(pm || (pm = {}));
const Re = Et.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), Ii = (e) => {
  switch (typeof e) {
    case "undefined":
      return Re.undefined;
    case "string":
      return Re.string;
    case "number":
      return isNaN(e) ? Re.nan : Re.number;
    case "boolean":
      return Re.boolean;
    case "function":
      return Re.function;
    case "bigint":
      return Re.bigint;
    case "symbol":
      return Re.symbol;
    case "object":
      return Array.isArray(e) ? Re.array : e === null ? Re.null : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? Re.promise : typeof Map < "u" && e instanceof Map ? Re.map : typeof Set < "u" && e instanceof Set ? Re.set : typeof Date < "u" && e instanceof Date ? Re.date : Re.object;
    default:
      return Re.unknown;
  }
}, ye = Et.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]), kse = (e) => JSON.stringify(e, null, 2).replace(/"([^"]+)":/g, "$1:");
class wr extends Error {
  constructor(t) {
    super(), this.issues = [], this.addIssue = (r) => {
      this.issues = [...this.issues, r];
    }, this.addIssues = (r = []) => {
      this.issues = [...this.issues, ...r];
    };
    const n = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, n) : this.__proto__ = n, this.name = "ZodError", this.issues = t;
  }
  get errors() {
    return this.issues;
  }
  format(t) {
    const n = t || function(a) {
      return a.message;
    }, r = { _errors: [] }, i = (a) => {
      for (const o of a.issues)
        if (o.code === "invalid_union")
          o.unionErrors.map(i);
        else if (o.code === "invalid_return_type")
          i(o.returnTypeError);
        else if (o.code === "invalid_arguments")
          i(o.argumentsError);
        else if (o.path.length === 0)
          r._errors.push(n(o));
        else {
          let s = r, l = 0;
          for (; l < o.path.length; ) {
            const c = o.path[l];
            l === o.path.length - 1 ? (s[c] = s[c] || { _errors: [] }, s[c]._errors.push(n(o))) : s[c] = s[c] || { _errors: [] }, s = s[c], l++;
          }
        }
    };
    return i(this), r;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, Et.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(t = (n) => n.message) {
    const n = {}, r = [];
    for (const i of this.issues)
      i.path.length > 0 ? (n[i.path[0]] = n[i.path[0]] || [], n[i.path[0]].push(t(i))) : r.push(t(i));
    return { formErrors: r, fieldErrors: n };
  }
  get formErrors() {
    return this.flatten();
  }
}
wr.create = (e) => new wr(e);
const Ks = (e, t) => {
  let n;
  switch (e.code) {
    case ye.invalid_type:
      e.received === Re.undefined ? n = "Required" : n = `Expected ${e.expected}, received ${e.received}`;
      break;
    case ye.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(e.expected, Et.jsonStringifyReplacer)}`;
      break;
    case ye.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${Et.joinValues(e.keys, ", ")}`;
      break;
    case ye.invalid_union:
      n = "Invalid input";
      break;
    case ye.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${Et.joinValues(e.options)}`;
      break;
    case ye.invalid_enum_value:
      n = `Invalid enum value. Expected ${Et.joinValues(e.options)}, received '${e.received}'`;
      break;
    case ye.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case ye.invalid_return_type:
      n = "Invalid function return type";
      break;
    case ye.invalid_date:
      n = "Invalid date";
      break;
    case ye.invalid_string:
      typeof e.validation == "object" ? "includes" in e.validation ? (n = `Invalid input: must include "${e.validation.includes}"`, typeof e.validation.position == "number" && (n = `${n} at one or more positions greater than or equal to ${e.validation.position}`)) : "startsWith" in e.validation ? n = `Invalid input: must start with "${e.validation.startsWith}"` : "endsWith" in e.validation ? n = `Invalid input: must end with "${e.validation.endsWith}"` : Et.assertNever(e.validation) : e.validation !== "regex" ? n = `Invalid ${e.validation}` : n = "Invalid";
      break;
    case ye.too_small:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "more than"} ${e.minimum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at least" : "over"} ${e.minimum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${e.minimum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly equal to " : e.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(e.minimum))}` : n = "Invalid input";
      break;
    case ye.too_big:
      e.type === "array" ? n = `Array must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "less than"} ${e.maximum} element(s)` : e.type === "string" ? n = `String must contain ${e.exact ? "exactly" : e.inclusive ? "at most" : "under"} ${e.maximum} character(s)` : e.type === "number" ? n = `Number must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "bigint" ? n = `BigInt must be ${e.exact ? "exactly" : e.inclusive ? "less than or equal to" : "less than"} ${e.maximum}` : e.type === "date" ? n = `Date must be ${e.exact ? "exactly" : e.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(e.maximum))}` : n = "Invalid input";
      break;
    case ye.custom:
      n = "Invalid input";
      break;
    case ye.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case ye.not_multiple_of:
      n = `Number must be a multiple of ${e.multipleOf}`;
      break;
    case ye.not_finite:
      n = "Number must be finite";
      break;
    default:
      n = t.defaultError, Et.assertNever(e);
  }
  return { message: n };
};
let EO = Ks;
function Tse(e) {
  EO = e;
}
function ld() {
  return EO;
}
const cd = (e) => {
  const { data: t, path: n, errorMaps: r, issueData: i } = e, a = [...n, ...i.path || []], o = {
    ...i,
    path: a
  };
  let s = "";
  const l = r.filter((c) => !!c).slice().reverse();
  for (const c of l)
    s = c(o, { data: t, defaultError: s }).message;
  return {
    ...i,
    path: a,
    message: i.message || s
  };
}, Cse = [];
function Ie(e, t) {
  const n = cd({
    issueData: t,
    data: e.data,
    path: e.path,
    errorMaps: [
      e.common.contextualErrorMap,
      e.schemaErrorMap,
      ld(),
      Ks
      // then global default map
    ].filter((r) => !!r)
  });
  e.common.issues.push(n);
}
class Pn {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(t, n) {
    const r = [];
    for (const i of n) {
      if (i.status === "aborted")
        return ct;
      i.status === "dirty" && t.dirty(), r.push(i.value);
    }
    return { status: t.value, value: r };
  }
  static async mergeObjectAsync(t, n) {
    const r = [];
    for (const i of n)
      r.push({
        key: await i.key,
        value: await i.value
      });
    return Pn.mergeObjectSync(t, r);
  }
  static mergeObjectSync(t, n) {
    const r = {};
    for (const i of n) {
      const { key: a, value: o } = i;
      if (a.status === "aborted" || o.status === "aborted")
        return ct;
      a.status === "dirty" && t.dirty(), o.status === "dirty" && t.dirty(), a.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (r[a.value] = o.value);
    }
    return { status: t.value, value: r };
  }
}
const ct = Object.freeze({
  status: "aborted"
}), kO = (e) => ({ status: "dirty", value: e }), Un = (e) => ({ status: "valid", value: e }), hm = (e) => e.status === "aborted", mm = (e) => e.status === "dirty", Gs = (e) => e.status === "valid", ud = (e) => typeof Promise < "u" && e instanceof Promise;
var He;
(function(e) {
  e.errToObj = (t) => typeof t == "string" ? { message: t } : t || {}, e.toString = (t) => typeof t == "string" ? t : t == null ? void 0 : t.message;
})(He || (He = {}));
class Ur {
  constructor(t, n, r, i) {
    this._cachedPath = [], this.parent = t, this.data = n, this._path = r, this._key = i;
  }
  get path() {
    return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}
const u0 = (e, t) => {
  if (Gs(t))
    return { success: !0, data: t.value };
  if (!e.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      const n = new wr(e.common.issues);
      return this._error = n, this._error;
    }
  };
};
function dt(e) {
  if (!e)
    return {};
  const { errorMap: t, invalid_type_error: n, required_error: r, description: i } = e;
  if (t && (n || r))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return t ? { errorMap: t, description: i } : { errorMap: (o, s) => o.code !== "invalid_type" ? { message: s.defaultError } : typeof s.data > "u" ? { message: r ?? s.defaultError } : { message: n ?? s.defaultError }, description: i };
}
class pt {
  constructor(t) {
    this.spa = this.safeParseAsync, this._def = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(t) {
    return Ii(t.data);
  }
  _getOrReturnCtx(t, n) {
    return n || {
      common: t.parent.common,
      data: t.data,
      parsedType: Ii(t.data),
      schemaErrorMap: this._def.errorMap,
      path: t.path,
      parent: t.parent
    };
  }
  _processInputParams(t) {
    return {
      status: new Pn(),
      ctx: {
        common: t.parent.common,
        data: t.data,
        parsedType: Ii(t.data),
        schemaErrorMap: this._def.errorMap,
        path: t.path,
        parent: t.parent
      }
    };
  }
  _parseSync(t) {
    const n = this._parse(t);
    if (ud(n))
      throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(t) {
    const n = this._parse(t);
    return Promise.resolve(n);
  }
  parse(t, n) {
    const r = this.safeParse(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  safeParse(t, n) {
    var r;
    const i = {
      common: {
        issues: [],
        async: (r = n == null ? void 0 : n.async) !== null && r !== void 0 ? r : !1,
        contextualErrorMap: n == null ? void 0 : n.errorMap
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Ii(t)
    }, a = this._parseSync({ data: t, path: i.path, parent: i });
    return u0(i, a);
  }
  async parseAsync(t, n) {
    const r = await this.safeParseAsync(t, n);
    if (r.success)
      return r.data;
    throw r.error;
  }
  async safeParseAsync(t, n) {
    const r = {
      common: {
        issues: [],
        contextualErrorMap: n == null ? void 0 : n.errorMap,
        async: !0
      },
      path: (n == null ? void 0 : n.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: t,
      parsedType: Ii(t)
    }, i = this._parse({ data: t, path: r.path, parent: r }), a = await (ud(i) ? i : Promise.resolve(i));
    return u0(r, a);
  }
  refine(t, n) {
    const r = (i) => typeof n == "string" || typeof n > "u" ? { message: n } : typeof n == "function" ? n(i) : n;
    return this._refinement((i, a) => {
      const o = t(i), s = () => a.addIssue({
        code: ye.custom,
        ...r(i)
      });
      return typeof Promise < "u" && o instanceof Promise ? o.then((l) => l ? !0 : (s(), !1)) : o ? !0 : (s(), !1);
    });
  }
  refinement(t, n) {
    return this._refinement((r, i) => t(r) ? !0 : (i.addIssue(typeof n == "function" ? n(r, i) : n), !1));
  }
  _refinement(t) {
    return new Sr({
      schema: this,
      typeName: et.ZodEffects,
      effect: { type: "refinement", refinement: t }
    });
  }
  superRefine(t) {
    return this._refinement(t);
  }
  optional() {
    return di.create(this, this._def);
  }
  nullable() {
    return $a.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return xr.create(this, this._def);
  }
  promise() {
    return Uo.create(this, this._def);
  }
  or(t) {
    return Qs.create([this, t], this._def);
  }
  and(t) {
    return el.create(this, t, this._def);
  }
  transform(t) {
    return new Sr({
      ...dt(this._def),
      schema: this,
      typeName: et.ZodEffects,
      effect: { type: "transform", transform: t }
    });
  }
  default(t) {
    const n = typeof t == "function" ? t : () => t;
    return new al({
      ...dt(this._def),
      innerType: this,
      defaultValue: n,
      typeName: et.ZodDefault
    });
  }
  brand() {
    return new CO({
      typeName: et.ZodBranded,
      type: this,
      ...dt(this._def)
    });
  }
  catch(t) {
    const n = typeof t == "function" ? t : () => t;
    return new hd({
      ...dt(this._def),
      innerType: this,
      catchValue: n,
      typeName: et.ZodCatch
    });
  }
  describe(t) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: t
    });
  }
  pipe(t) {
    return Kl.create(this, t);
  }
  readonly() {
    return gd.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const Ose = /^c[^\s-]{8,}$/i, Ase = /^[a-z][a-z0-9]*$/, $se = /^[0-9A-HJKMNP-TV-Z]{26}$/, Rse = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Pse = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Ise = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let Wp;
const Mse = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/, Nse = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, Dse = (e) => e.precision ? e.offset ? new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`) : new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${e.precision}}Z$`) : e.precision === 0 ? e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$") : e.offset ? new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$") : new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$");
function Lse(e, t) {
  return !!((t === "v4" || !t) && Mse.test(e) || (t === "v6" || !t) && Nse.test(e));
}
class gr extends pt {
  _parse(t) {
    if (this._def.coerce && (t.data = String(t.data)), this._getType(t) !== Re.string) {
      const a = this._getOrReturnCtx(t);
      return Ie(
        a,
        {
          code: ye.invalid_type,
          expected: Re.string,
          received: a.parsedType
        }
        //
      ), ct;
    }
    const r = new Pn();
    let i;
    for (const a of this._def.checks)
      if (a.kind === "min")
        t.data.length < a.value && (i = this._getOrReturnCtx(t, i), Ie(i, {
          code: ye.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "max")
        t.data.length > a.value && (i = this._getOrReturnCtx(t, i), Ie(i, {
          code: ye.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: a.message
        }), r.dirty());
      else if (a.kind === "length") {
        const o = t.data.length > a.value, s = t.data.length < a.value;
        (o || s) && (i = this._getOrReturnCtx(t, i), o ? Ie(i, {
          code: ye.too_big,
          maximum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }) : s && Ie(i, {
          code: ye.too_small,
          minimum: a.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: a.message
        }), r.dirty());
      } else if (a.kind === "email")
        Pse.test(t.data) || (i = this._getOrReturnCtx(t, i), Ie(i, {
          validation: "email",
          code: ye.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "emoji")
        Wp || (Wp = new RegExp(Ise, "u")), Wp.test(t.data) || (i = this._getOrReturnCtx(t, i), Ie(i, {
          validation: "emoji",
          code: ye.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "uuid")
        Rse.test(t.data) || (i = this._getOrReturnCtx(t, i), Ie(i, {
          validation: "uuid",
          code: ye.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid")
        Ose.test(t.data) || (i = this._getOrReturnCtx(t, i), Ie(i, {
          validation: "cuid",
          code: ye.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "cuid2")
        Ase.test(t.data) || (i = this._getOrReturnCtx(t, i), Ie(i, {
          validation: "cuid2",
          code: ye.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "ulid")
        $se.test(t.data) || (i = this._getOrReturnCtx(t, i), Ie(i, {
          validation: "ulid",
          code: ye.invalid_string,
          message: a.message
        }), r.dirty());
      else if (a.kind === "url")
        try {
          new URL(t.data);
        } catch {
          i = this._getOrReturnCtx(t, i), Ie(i, {
            validation: "url",
            code: ye.invalid_string,
            message: a.message
          }), r.dirty();
        }
      else
        a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(t.data) || (i = this._getOrReturnCtx(t, i), Ie(i, {
          validation: "regex",
          code: ye.invalid_string,
          message: a.message
        }), r.dirty())) : a.kind === "trim" ? t.data = t.data.trim() : a.kind === "includes" ? t.data.includes(a.value, a.position) || (i = this._getOrReturnCtx(t, i), Ie(i, {
          code: ye.invalid_string,
          validation: { includes: a.value, position: a.position },
          message: a.message
        }), r.dirty()) : a.kind === "toLowerCase" ? t.data = t.data.toLowerCase() : a.kind === "toUpperCase" ? t.data = t.data.toUpperCase() : a.kind === "startsWith" ? t.data.startsWith(a.value) || (i = this._getOrReturnCtx(t, i), Ie(i, {
          code: ye.invalid_string,
          validation: { startsWith: a.value },
          message: a.message
        }), r.dirty()) : a.kind === "endsWith" ? t.data.endsWith(a.value) || (i = this._getOrReturnCtx(t, i), Ie(i, {
          code: ye.invalid_string,
          validation: { endsWith: a.value },
          message: a.message
        }), r.dirty()) : a.kind === "datetime" ? Dse(a).test(t.data) || (i = this._getOrReturnCtx(t, i), Ie(i, {
          code: ye.invalid_string,
          validation: "datetime",
          message: a.message
        }), r.dirty()) : a.kind === "ip" ? Lse(t.data, a.version) || (i = this._getOrReturnCtx(t, i), Ie(i, {
          validation: "ip",
          code: ye.invalid_string,
          message: a.message
        }), r.dirty()) : Et.assertNever(a);
    return { status: r.value, value: t.data };
  }
  _regex(t, n, r) {
    return this.refinement((i) => t.test(i), {
      validation: n,
      code: ye.invalid_string,
      ...He.errToObj(r)
    });
  }
  _addCheck(t) {
    return new gr({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  email(t) {
    return this._addCheck({ kind: "email", ...He.errToObj(t) });
  }
  url(t) {
    return this._addCheck({ kind: "url", ...He.errToObj(t) });
  }
  emoji(t) {
    return this._addCheck({ kind: "emoji", ...He.errToObj(t) });
  }
  uuid(t) {
    return this._addCheck({ kind: "uuid", ...He.errToObj(t) });
  }
  cuid(t) {
    return this._addCheck({ kind: "cuid", ...He.errToObj(t) });
  }
  cuid2(t) {
    return this._addCheck({ kind: "cuid2", ...He.errToObj(t) });
  }
  ulid(t) {
    return this._addCheck({ kind: "ulid", ...He.errToObj(t) });
  }
  ip(t) {
    return this._addCheck({ kind: "ip", ...He.errToObj(t) });
  }
  datetime(t) {
    var n;
    return typeof t == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      message: t
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof (t == null ? void 0 : t.precision) > "u" ? null : t == null ? void 0 : t.precision,
      offset: (n = t == null ? void 0 : t.offset) !== null && n !== void 0 ? n : !1,
      ...He.errToObj(t == null ? void 0 : t.message)
    });
  }
  regex(t, n) {
    return this._addCheck({
      kind: "regex",
      regex: t,
      ...He.errToObj(n)
    });
  }
  includes(t, n) {
    return this._addCheck({
      kind: "includes",
      value: t,
      position: n == null ? void 0 : n.position,
      ...He.errToObj(n == null ? void 0 : n.message)
    });
  }
  startsWith(t, n) {
    return this._addCheck({
      kind: "startsWith",
      value: t,
      ...He.errToObj(n)
    });
  }
  endsWith(t, n) {
    return this._addCheck({
      kind: "endsWith",
      value: t,
      ...He.errToObj(n)
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t,
      ...He.errToObj(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t,
      ...He.errToObj(n)
    });
  }
  length(t, n) {
    return this._addCheck({
      kind: "length",
      value: t,
      ...He.errToObj(n)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(t) {
    return this.min(1, He.errToObj(t));
  }
  trim() {
    return new gr({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new gr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new gr({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((t) => t.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((t) => t.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((t) => t.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((t) => t.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((t) => t.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((t) => t.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((t) => t.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((t) => t.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((t) => t.kind === "ip");
  }
  get minLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxLength() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
gr.create = (e) => {
  var t;
  return new gr({
    checks: [],
    typeName: et.ZodString,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...dt(e)
  });
};
function jse(e, t) {
  const n = (e.toString().split(".")[1] || "").length, r = (t.toString().split(".")[1] || "").length, i = n > r ? n : r, a = parseInt(e.toFixed(i).replace(".", "")), o = parseInt(t.toFixed(i).replace(".", ""));
  return a % o / Math.pow(10, i);
}
class Wi extends pt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = Number(t.data)), this._getType(t) !== Re.number) {
      const a = this._getOrReturnCtx(t);
      return Ie(a, {
        code: ye.invalid_type,
        expected: Re.number,
        received: a.parsedType
      }), ct;
    }
    let r;
    const i = new Pn();
    for (const a of this._def.checks)
      a.kind === "int" ? Et.isInteger(t.data) || (r = this._getOrReturnCtx(t, r), Ie(r, {
        code: ye.invalid_type,
        expected: "integer",
        received: "float",
        message: a.message
      }), i.dirty()) : a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), Ie(r, {
        code: ye.too_small,
        minimum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), Ie(r, {
        code: ye.too_big,
        maximum: a.value,
        type: "number",
        inclusive: a.inclusive,
        exact: !1,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? jse(t.data, a.value) !== 0 && (r = this._getOrReturnCtx(t, r), Ie(r, {
        code: ye.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : a.kind === "finite" ? Number.isFinite(t.data) || (r = this._getOrReturnCtx(t, r), Ie(r, {
        code: ye.not_finite,
        message: a.message
      }), i.dirty()) : Et.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, He.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, He.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, He.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, He.toString(n));
  }
  setLimit(t, n, r, i) {
    return new Wi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: He.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Wi({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  int(t) {
    return this._addCheck({
      kind: "int",
      message: He.toString(t)
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: He.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: He.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: He.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: He.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: He.toString(n)
    });
  }
  finite(t) {
    return this._addCheck({
      kind: "finite",
      message: He.toString(t)
    });
  }
  safe(t) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: He.toString(t)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: He.toString(t)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
  get isInt() {
    return !!this._def.checks.find((t) => t.kind === "int" || t.kind === "multipleOf" && Et.isInteger(t.value));
  }
  get isFinite() {
    let t = null, n = null;
    for (const r of this._def.checks) {
      if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf")
        return !0;
      r.kind === "min" ? (n === null || r.value > n) && (n = r.value) : r.kind === "max" && (t === null || r.value < t) && (t = r.value);
    }
    return Number.isFinite(n) && Number.isFinite(t);
  }
}
Wi.create = (e) => new Wi({
  checks: [],
  typeName: et.ZodNumber,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...dt(e)
});
class Vi extends pt {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(t) {
    if (this._def.coerce && (t.data = BigInt(t.data)), this._getType(t) !== Re.bigint) {
      const a = this._getOrReturnCtx(t);
      return Ie(a, {
        code: ye.invalid_type,
        expected: Re.bigint,
        received: a.parsedType
      }), ct;
    }
    let r;
    const i = new Pn();
    for (const a of this._def.checks)
      a.kind === "min" ? (a.inclusive ? t.data < a.value : t.data <= a.value) && (r = this._getOrReturnCtx(t, r), Ie(r, {
        code: ye.too_small,
        type: "bigint",
        minimum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "max" ? (a.inclusive ? t.data > a.value : t.data >= a.value) && (r = this._getOrReturnCtx(t, r), Ie(r, {
        code: ye.too_big,
        type: "bigint",
        maximum: a.value,
        inclusive: a.inclusive,
        message: a.message
      }), i.dirty()) : a.kind === "multipleOf" ? t.data % a.value !== BigInt(0) && (r = this._getOrReturnCtx(t, r), Ie(r, {
        code: ye.not_multiple_of,
        multipleOf: a.value,
        message: a.message
      }), i.dirty()) : Et.assertNever(a);
    return { status: i.value, value: t.data };
  }
  gte(t, n) {
    return this.setLimit("min", t, !0, He.toString(n));
  }
  gt(t, n) {
    return this.setLimit("min", t, !1, He.toString(n));
  }
  lte(t, n) {
    return this.setLimit("max", t, !0, He.toString(n));
  }
  lt(t, n) {
    return this.setLimit("max", t, !1, He.toString(n));
  }
  setLimit(t, n, r, i) {
    return new Vi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: t,
          value: n,
          inclusive: r,
          message: He.toString(i)
        }
      ]
    });
  }
  _addCheck(t) {
    return new Vi({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  positive(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: He.toString(t)
    });
  }
  negative(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: He.toString(t)
    });
  }
  nonpositive(t) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: He.toString(t)
    });
  }
  nonnegative(t) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: He.toString(t)
    });
  }
  multipleOf(t, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: t,
      message: He.toString(n)
    });
  }
  get minValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t;
  }
  get maxValue() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t;
  }
}
Vi.create = (e) => {
  var t;
  return new Vi({
    checks: [],
    typeName: et.ZodBigInt,
    coerce: (t = e == null ? void 0 : e.coerce) !== null && t !== void 0 ? t : !1,
    ...dt(e)
  });
};
class Js extends pt {
  _parse(t) {
    if (this._def.coerce && (t.data = !!t.data), this._getType(t) !== Re.boolean) {
      const r = this._getOrReturnCtx(t);
      return Ie(r, {
        code: ye.invalid_type,
        expected: Re.boolean,
        received: r.parsedType
      }), ct;
    }
    return Un(t.data);
  }
}
Js.create = (e) => new Js({
  typeName: et.ZodBoolean,
  coerce: (e == null ? void 0 : e.coerce) || !1,
  ...dt(e)
});
class Oa extends pt {
  _parse(t) {
    if (this._def.coerce && (t.data = new Date(t.data)), this._getType(t) !== Re.date) {
      const a = this._getOrReturnCtx(t);
      return Ie(a, {
        code: ye.invalid_type,
        expected: Re.date,
        received: a.parsedType
      }), ct;
    }
    if (isNaN(t.data.getTime())) {
      const a = this._getOrReturnCtx(t);
      return Ie(a, {
        code: ye.invalid_date
      }), ct;
    }
    const r = new Pn();
    let i;
    for (const a of this._def.checks)
      a.kind === "min" ? t.data.getTime() < a.value && (i = this._getOrReturnCtx(t, i), Ie(i, {
        code: ye.too_small,
        message: a.message,
        inclusive: !0,
        exact: !1,
        minimum: a.value,
        type: "date"
      }), r.dirty()) : a.kind === "max" ? t.data.getTime() > a.value && (i = this._getOrReturnCtx(t, i), Ie(i, {
        code: ye.too_big,
        message: a.message,
        inclusive: !0,
        exact: !1,
        maximum: a.value,
        type: "date"
      }), r.dirty()) : Et.assertNever(a);
    return {
      status: r.value,
      value: new Date(t.data.getTime())
    };
  }
  _addCheck(t) {
    return new Oa({
      ...this._def,
      checks: [...this._def.checks, t]
    });
  }
  min(t, n) {
    return this._addCheck({
      kind: "min",
      value: t.getTime(),
      message: He.toString(n)
    });
  }
  max(t, n) {
    return this._addCheck({
      kind: "max",
      value: t.getTime(),
      message: He.toString(n)
    });
  }
  get minDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "min" && (t === null || n.value > t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
  get maxDate() {
    let t = null;
    for (const n of this._def.checks)
      n.kind === "max" && (t === null || n.value < t) && (t = n.value);
    return t != null ? new Date(t) : null;
  }
}
Oa.create = (e) => new Oa({
  checks: [],
  coerce: (e == null ? void 0 : e.coerce) || !1,
  typeName: et.ZodDate,
  ...dt(e)
});
class dd extends pt {
  _parse(t) {
    if (this._getType(t) !== Re.symbol) {
      const r = this._getOrReturnCtx(t);
      return Ie(r, {
        code: ye.invalid_type,
        expected: Re.symbol,
        received: r.parsedType
      }), ct;
    }
    return Un(t.data);
  }
}
dd.create = (e) => new dd({
  typeName: et.ZodSymbol,
  ...dt(e)
});
class Ys extends pt {
  _parse(t) {
    if (this._getType(t) !== Re.undefined) {
      const r = this._getOrReturnCtx(t);
      return Ie(r, {
        code: ye.invalid_type,
        expected: Re.undefined,
        received: r.parsedType
      }), ct;
    }
    return Un(t.data);
  }
}
Ys.create = (e) => new Ys({
  typeName: et.ZodUndefined,
  ...dt(e)
});
class Xs extends pt {
  _parse(t) {
    if (this._getType(t) !== Re.null) {
      const r = this._getOrReturnCtx(t);
      return Ie(r, {
        code: ye.invalid_type,
        expected: Re.null,
        received: r.parsedType
      }), ct;
    }
    return Un(t.data);
  }
}
Xs.create = (e) => new Xs({
  typeName: et.ZodNull,
  ...dt(e)
});
class jo extends pt {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(t) {
    return Un(t.data);
  }
}
jo.create = (e) => new jo({
  typeName: et.ZodAny,
  ...dt(e)
});
class ya extends pt {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(t) {
    return Un(t.data);
  }
}
ya.create = (e) => new ya({
  typeName: et.ZodUnknown,
  ...dt(e)
});
class gi extends pt {
  _parse(t) {
    const n = this._getOrReturnCtx(t);
    return Ie(n, {
      code: ye.invalid_type,
      expected: Re.never,
      received: n.parsedType
    }), ct;
  }
}
gi.create = (e) => new gi({
  typeName: et.ZodNever,
  ...dt(e)
});
class fd extends pt {
  _parse(t) {
    if (this._getType(t) !== Re.undefined) {
      const r = this._getOrReturnCtx(t);
      return Ie(r, {
        code: ye.invalid_type,
        expected: Re.void,
        received: r.parsedType
      }), ct;
    }
    return Un(t.data);
  }
}
fd.create = (e) => new fd({
  typeName: et.ZodVoid,
  ...dt(e)
});
class xr extends pt {
  _parse(t) {
    const { ctx: n, status: r } = this._processInputParams(t), i = this._def;
    if (n.parsedType !== Re.array)
      return Ie(n, {
        code: ye.invalid_type,
        expected: Re.array,
        received: n.parsedType
      }), ct;
    if (i.exactLength !== null) {
      const o = n.data.length > i.exactLength.value, s = n.data.length < i.exactLength.value;
      (o || s) && (Ie(n, {
        code: o ? ye.too_big : ye.too_small,
        minimum: s ? i.exactLength.value : void 0,
        maximum: o ? i.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: i.exactLength.message
      }), r.dirty());
    }
    if (i.minLength !== null && n.data.length < i.minLength.value && (Ie(n, {
      code: ye.too_small,
      minimum: i.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.minLength.message
    }), r.dirty()), i.maxLength !== null && n.data.length > i.maxLength.value && (Ie(n, {
      code: ye.too_big,
      maximum: i.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: i.maxLength.message
    }), r.dirty()), n.common.async)
      return Promise.all([...n.data].map((o, s) => i.type._parseAsync(new Ur(n, o, n.path, s)))).then((o) => Pn.mergeArray(r, o));
    const a = [...n.data].map((o, s) => i.type._parseSync(new Ur(n, o, n.path, s)));
    return Pn.mergeArray(r, a);
  }
  get element() {
    return this._def.type;
  }
  min(t, n) {
    return new xr({
      ...this._def,
      minLength: { value: t, message: He.toString(n) }
    });
  }
  max(t, n) {
    return new xr({
      ...this._def,
      maxLength: { value: t, message: He.toString(n) }
    });
  }
  length(t, n) {
    return new xr({
      ...this._def,
      exactLength: { value: t, message: He.toString(n) }
    });
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
xr.create = (e, t) => new xr({
  type: e,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: et.ZodArray,
  ...dt(t)
});
function Qa(e) {
  if (e instanceof Bt) {
    const t = {};
    for (const n in e.shape) {
      const r = e.shape[n];
      t[n] = di.create(Qa(r));
    }
    return new Bt({
      ...e._def,
      shape: () => t
    });
  } else
    return e instanceof xr ? new xr({
      ...e._def,
      type: Qa(e.element)
    }) : e instanceof di ? di.create(Qa(e.unwrap())) : e instanceof $a ? $a.create(Qa(e.unwrap())) : e instanceof Fr ? Fr.create(e.items.map((t) => Qa(t))) : e;
}
class Bt extends pt {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const t = this._def.shape(), n = Et.objectKeys(t);
    return this._cached = { shape: t, keys: n };
  }
  _parse(t) {
    if (this._getType(t) !== Re.object) {
      const c = this._getOrReturnCtx(t);
      return Ie(c, {
        code: ye.invalid_type,
        expected: Re.object,
        received: c.parsedType
      }), ct;
    }
    const { status: r, ctx: i } = this._processInputParams(t), { shape: a, keys: o } = this._getCached(), s = [];
    if (!(this._def.catchall instanceof gi && this._def.unknownKeys === "strip"))
      for (const c in i.data)
        o.includes(c) || s.push(c);
    const l = [];
    for (const c of o) {
      const u = a[c], d = i.data[c];
      l.push({
        key: { status: "valid", value: c },
        value: u._parse(new Ur(i, d, i.path, c)),
        alwaysSet: c in i.data
      });
    }
    if (this._def.catchall instanceof gi) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of s)
          l.push({
            key: { status: "valid", value: u },
            value: { status: "valid", value: i.data[u] }
          });
      else if (c === "strict")
        s.length > 0 && (Ie(i, {
          code: ye.unrecognized_keys,
          keys: s
        }), r.dirty());
      else if (c !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of s) {
        const d = i.data[u];
        l.push({
          key: { status: "valid", value: u },
          value: c._parse(
            new Ur(i, d, i.path, u)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: u in i.data
        });
      }
    }
    return i.common.async ? Promise.resolve().then(async () => {
      const c = [];
      for (const u of l) {
        const d = await u.key;
        c.push({
          key: d,
          value: await u.value,
          alwaysSet: u.alwaysSet
        });
      }
      return c;
    }).then((c) => Pn.mergeObjectSync(r, c)) : Pn.mergeObjectSync(r, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(t) {
    return He.errToObj, new Bt({
      ...this._def,
      unknownKeys: "strict",
      ...t !== void 0 ? {
        errorMap: (n, r) => {
          var i, a, o, s;
          const l = (o = (a = (i = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(i, n, r).message) !== null && o !== void 0 ? o : r.defaultError;
          return n.code === "unrecognized_keys" ? {
            message: (s = He.errToObj(t).message) !== null && s !== void 0 ? s : l
          } : {
            message: l
          };
        }
      } : {}
    });
  }
  strip() {
    return new Bt({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new Bt({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(t) {
    return new Bt({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...t
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(t) {
    return new Bt({
      unknownKeys: t._def.unknownKeys,
      catchall: t._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...t._def.shape()
      }),
      typeName: et.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(t, n) {
    return this.augment({ [t]: n });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(t) {
    return new Bt({
      ...this._def,
      catchall: t
    });
  }
  pick(t) {
    const n = {};
    return Et.objectKeys(t).forEach((r) => {
      t[r] && this.shape[r] && (n[r] = this.shape[r]);
    }), new Bt({
      ...this._def,
      shape: () => n
    });
  }
  omit(t) {
    const n = {};
    return Et.objectKeys(this.shape).forEach((r) => {
      t[r] || (n[r] = this.shape[r]);
    }), new Bt({
      ...this._def,
      shape: () => n
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return Qa(this);
  }
  partial(t) {
    const n = {};
    return Et.objectKeys(this.shape).forEach((r) => {
      const i = this.shape[r];
      t && !t[r] ? n[r] = i : n[r] = i.optional();
    }), new Bt({
      ...this._def,
      shape: () => n
    });
  }
  required(t) {
    const n = {};
    return Et.objectKeys(this.shape).forEach((r) => {
      if (t && !t[r])
        n[r] = this.shape[r];
      else {
        let a = this.shape[r];
        for (; a instanceof di; )
          a = a._def.innerType;
        n[r] = a;
      }
    }), new Bt({
      ...this._def,
      shape: () => n
    });
  }
  keyof() {
    return TO(Et.objectKeys(this.shape));
  }
}
Bt.create = (e, t) => new Bt({
  shape: () => e,
  unknownKeys: "strip",
  catchall: gi.create(),
  typeName: et.ZodObject,
  ...dt(t)
});
Bt.strictCreate = (e, t) => new Bt({
  shape: () => e,
  unknownKeys: "strict",
  catchall: gi.create(),
  typeName: et.ZodObject,
  ...dt(t)
});
Bt.lazycreate = (e, t) => new Bt({
  shape: e,
  unknownKeys: "strip",
  catchall: gi.create(),
  typeName: et.ZodObject,
  ...dt(t)
});
class Qs extends pt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = this._def.options;
    function i(a) {
      for (const s of a)
        if (s.result.status === "valid")
          return s.result;
      for (const s of a)
        if (s.result.status === "dirty")
          return n.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((s) => new wr(s.ctx.common.issues));
      return Ie(n, {
        code: ye.invalid_union,
        unionErrors: o
      }), ct;
    }
    if (n.common.async)
      return Promise.all(r.map(async (a) => {
        const o = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await a._parseAsync({
            data: n.data,
            path: n.path,
            parent: o
          }),
          ctx: o
        };
      })).then(i);
    {
      let a;
      const o = [];
      for (const l of r) {
        const c = {
          ...n,
          common: {
            ...n.common,
            issues: []
          },
          parent: null
        }, u = l._parseSync({
          data: n.data,
          path: n.path,
          parent: c
        });
        if (u.status === "valid")
          return u;
        u.status === "dirty" && !a && (a = { result: u, ctx: c }), c.common.issues.length && o.push(c.common.issues);
      }
      if (a)
        return n.common.issues.push(...a.ctx.common.issues), a.result;
      const s = o.map((l) => new wr(l));
      return Ie(n, {
        code: ye.invalid_union,
        unionErrors: s
      }), ct;
    }
  }
  get options() {
    return this._def.options;
  }
}
Qs.create = (e, t) => new Qs({
  options: e,
  typeName: et.ZodUnion,
  ...dt(t)
});
const qc = (e) => e instanceof nl ? qc(e.schema) : e instanceof Sr ? qc(e.innerType()) : e instanceof rl ? [e.value] : e instanceof Hi ? e.options : e instanceof il ? Object.keys(e.enum) : e instanceof al ? qc(e._def.innerType) : e instanceof Ys ? [void 0] : e instanceof Xs ? [null] : null;
class Lf extends pt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Re.object)
      return Ie(n, {
        code: ye.invalid_type,
        expected: Re.object,
        received: n.parsedType
      }), ct;
    const r = this.discriminator, i = n.data[r], a = this.optionsMap.get(i);
    return a ? n.common.async ? a._parseAsync({
      data: n.data,
      path: n.path,
      parent: n
    }) : a._parseSync({
      data: n.data,
      path: n.path,
      parent: n
    }) : (Ie(n, {
      code: ye.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [r]
    }), ct);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(t, n, r) {
    const i = /* @__PURE__ */ new Map();
    for (const a of n) {
      const o = qc(a.shape[t]);
      if (!o)
        throw new Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
      for (const s of o) {
        if (i.has(s))
          throw new Error(`Discriminator property ${String(t)} has duplicate value ${String(s)}`);
        i.set(s, a);
      }
    }
    return new Lf({
      typeName: et.ZodDiscriminatedUnion,
      discriminator: t,
      options: n,
      optionsMap: i,
      ...dt(r)
    });
  }
}
function gm(e, t) {
  const n = Ii(e), r = Ii(t);
  if (e === t)
    return { valid: !0, data: e };
  if (n === Re.object && r === Re.object) {
    const i = Et.objectKeys(t), a = Et.objectKeys(e).filter((s) => i.indexOf(s) !== -1), o = { ...e, ...t };
    for (const s of a) {
      const l = gm(e[s], t[s]);
      if (!l.valid)
        return { valid: !1 };
      o[s] = l.data;
    }
    return { valid: !0, data: o };
  } else if (n === Re.array && r === Re.array) {
    if (e.length !== t.length)
      return { valid: !1 };
    const i = [];
    for (let a = 0; a < e.length; a++) {
      const o = e[a], s = t[a], l = gm(o, s);
      if (!l.valid)
        return { valid: !1 };
      i.push(l.data);
    }
    return { valid: !0, data: i };
  } else
    return n === Re.date && r === Re.date && +e == +t ? { valid: !0, data: e } : { valid: !1 };
}
class el extends pt {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = (a, o) => {
      if (hm(a) || hm(o))
        return ct;
      const s = gm(a.value, o.value);
      return s.valid ? ((mm(a) || mm(o)) && n.dirty(), { status: n.value, value: s.data }) : (Ie(r, {
        code: ye.invalid_intersection_types
      }), ct);
    };
    return r.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      }),
      this._def.right._parseAsync({
        data: r.data,
        path: r.path,
        parent: r
      })
    ]).then(([a, o]) => i(a, o)) : i(this._def.left._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }), this._def.right._parseSync({
      data: r.data,
      path: r.path,
      parent: r
    }));
  }
}
el.create = (e, t, n) => new el({
  left: e,
  right: t,
  typeName: et.ZodIntersection,
  ...dt(n)
});
class Fr extends pt {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Re.array)
      return Ie(r, {
        code: ye.invalid_type,
        expected: Re.array,
        received: r.parsedType
      }), ct;
    if (r.data.length < this._def.items.length)
      return Ie(r, {
        code: ye.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), ct;
    !this._def.rest && r.data.length > this._def.items.length && (Ie(r, {
      code: ye.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), n.dirty());
    const a = [...r.data].map((o, s) => {
      const l = this._def.items[s] || this._def.rest;
      return l ? l._parse(new Ur(r, o, r.path, s)) : null;
    }).filter((o) => !!o);
    return r.common.async ? Promise.all(a).then((o) => Pn.mergeArray(n, o)) : Pn.mergeArray(n, a);
  }
  get items() {
    return this._def.items;
  }
  rest(t) {
    return new Fr({
      ...this._def,
      rest: t
    });
  }
}
Fr.create = (e, t) => {
  if (!Array.isArray(e))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Fr({
    items: e,
    typeName: et.ZodTuple,
    rest: null,
    ...dt(t)
  });
};
class tl extends pt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Re.object)
      return Ie(r, {
        code: ye.invalid_type,
        expected: Re.object,
        received: r.parsedType
      }), ct;
    const i = [], a = this._def.keyType, o = this._def.valueType;
    for (const s in r.data)
      i.push({
        key: a._parse(new Ur(r, s, r.path, s)),
        value: o._parse(new Ur(r, r.data[s], r.path, s))
      });
    return r.common.async ? Pn.mergeObjectAsync(n, i) : Pn.mergeObjectSync(n, i);
  }
  get element() {
    return this._def.valueType;
  }
  static create(t, n, r) {
    return n instanceof pt ? new tl({
      keyType: t,
      valueType: n,
      typeName: et.ZodRecord,
      ...dt(r)
    }) : new tl({
      keyType: gr.create(),
      valueType: t,
      typeName: et.ZodRecord,
      ...dt(n)
    });
  }
}
class pd extends pt {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Re.map)
      return Ie(r, {
        code: ye.invalid_type,
        expected: Re.map,
        received: r.parsedType
      }), ct;
    const i = this._def.keyType, a = this._def.valueType, o = [...r.data.entries()].map(([s, l], c) => ({
      key: i._parse(new Ur(r, s, r.path, [c, "key"])),
      value: a._parse(new Ur(r, l, r.path, [c, "value"]))
    }));
    if (r.common.async) {
      const s = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const l of o) {
          const c = await l.key, u = await l.value;
          if (c.status === "aborted" || u.status === "aborted")
            return ct;
          (c.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(c.value, u.value);
        }
        return { status: n.value, value: s };
      });
    } else {
      const s = /* @__PURE__ */ new Map();
      for (const l of o) {
        const c = l.key, u = l.value;
        if (c.status === "aborted" || u.status === "aborted")
          return ct;
        (c.status === "dirty" || u.status === "dirty") && n.dirty(), s.set(c.value, u.value);
      }
      return { status: n.value, value: s };
    }
  }
}
pd.create = (e, t, n) => new pd({
  valueType: t,
  keyType: e,
  typeName: et.ZodMap,
  ...dt(n)
});
class Aa extends pt {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.parsedType !== Re.set)
      return Ie(r, {
        code: ye.invalid_type,
        expected: Re.set,
        received: r.parsedType
      }), ct;
    const i = this._def;
    i.minSize !== null && r.data.size < i.minSize.value && (Ie(r, {
      code: ye.too_small,
      minimum: i.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.minSize.message
    }), n.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (Ie(r, {
      code: ye.too_big,
      maximum: i.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: i.maxSize.message
    }), n.dirty());
    const a = this._def.valueType;
    function o(l) {
      const c = /* @__PURE__ */ new Set();
      for (const u of l) {
        if (u.status === "aborted")
          return ct;
        u.status === "dirty" && n.dirty(), c.add(u.value);
      }
      return { status: n.value, value: c };
    }
    const s = [...r.data.values()].map((l, c) => a._parse(new Ur(r, l, r.path, c)));
    return r.common.async ? Promise.all(s).then((l) => o(l)) : o(s);
  }
  min(t, n) {
    return new Aa({
      ...this._def,
      minSize: { value: t, message: He.toString(n) }
    });
  }
  max(t, n) {
    return new Aa({
      ...this._def,
      maxSize: { value: t, message: He.toString(n) }
    });
  }
  size(t, n) {
    return this.min(t, n).max(t, n);
  }
  nonempty(t) {
    return this.min(1, t);
  }
}
Aa.create = (e, t) => new Aa({
  valueType: e,
  minSize: null,
  maxSize: null,
  typeName: et.ZodSet,
  ...dt(t)
});
class mo extends pt {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Re.function)
      return Ie(n, {
        code: ye.invalid_type,
        expected: Re.function,
        received: n.parsedType
      }), ct;
    function r(s, l) {
      return cd({
        data: s,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          ld(),
          Ks
        ].filter((c) => !!c),
        issueData: {
          code: ye.invalid_arguments,
          argumentsError: l
        }
      });
    }
    function i(s, l) {
      return cd({
        data: s,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          ld(),
          Ks
        ].filter((c) => !!c),
        issueData: {
          code: ye.invalid_return_type,
          returnTypeError: l
        }
      });
    }
    const a = { errorMap: n.common.contextualErrorMap }, o = n.data;
    if (this._def.returns instanceof Uo) {
      const s = this;
      return Un(async function(...l) {
        const c = new wr([]), u = await s._def.args.parseAsync(l, a).catch((f) => {
          throw c.addIssue(r(l, f)), c;
        }), d = await Reflect.apply(o, this, u);
        return await s._def.returns._def.type.parseAsync(d, a).catch((f) => {
          throw c.addIssue(i(d, f)), c;
        });
      });
    } else {
      const s = this;
      return Un(function(...l) {
        const c = s._def.args.safeParse(l, a);
        if (!c.success)
          throw new wr([r(l, c.error)]);
        const u = Reflect.apply(o, this, c.data), d = s._def.returns.safeParse(u, a);
        if (!d.success)
          throw new wr([i(u, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...t) {
    return new mo({
      ...this._def,
      args: Fr.create(t).rest(ya.create())
    });
  }
  returns(t) {
    return new mo({
      ...this._def,
      returns: t
    });
  }
  implement(t) {
    return this.parse(t);
  }
  strictImplement(t) {
    return this.parse(t);
  }
  static create(t, n, r) {
    return new mo({
      args: t || Fr.create([]).rest(ya.create()),
      returns: n || ya.create(),
      typeName: et.ZodFunction,
      ...dt(r)
    });
  }
}
class nl extends pt {
  get schema() {
    return this._def.getter();
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    return this._def.getter()._parse({ data: n.data, path: n.path, parent: n });
  }
}
nl.create = (e, t) => new nl({
  getter: e,
  typeName: et.ZodLazy,
  ...dt(t)
});
class rl extends pt {
  _parse(t) {
    if (t.data !== this._def.value) {
      const n = this._getOrReturnCtx(t);
      return Ie(n, {
        received: n.data,
        code: ye.invalid_literal,
        expected: this._def.value
      }), ct;
    }
    return { status: "valid", value: t.data };
  }
  get value() {
    return this._def.value;
  }
}
rl.create = (e, t) => new rl({
  value: e,
  typeName: et.ZodLiteral,
  ...dt(t)
});
function TO(e, t) {
  return new Hi({
    values: e,
    typeName: et.ZodEnum,
    ...dt(t)
  });
}
class Hi extends pt {
  _parse(t) {
    if (typeof t.data != "string") {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return Ie(n, {
        expected: Et.joinValues(r),
        received: n.parsedType,
        code: ye.invalid_type
      }), ct;
    }
    if (this._def.values.indexOf(t.data) === -1) {
      const n = this._getOrReturnCtx(t), r = this._def.values;
      return Ie(n, {
        received: n.data,
        code: ye.invalid_enum_value,
        options: r
      }), ct;
    }
    return Un(t.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Values() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  get Enum() {
    const t = {};
    for (const n of this._def.values)
      t[n] = n;
    return t;
  }
  extract(t) {
    return Hi.create(t);
  }
  exclude(t) {
    return Hi.create(this.options.filter((n) => !t.includes(n)));
  }
}
Hi.create = TO;
class il extends pt {
  _parse(t) {
    const n = Et.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(t);
    if (r.parsedType !== Re.string && r.parsedType !== Re.number) {
      const i = Et.objectValues(n);
      return Ie(r, {
        expected: Et.joinValues(i),
        received: r.parsedType,
        code: ye.invalid_type
      }), ct;
    }
    if (n.indexOf(t.data) === -1) {
      const i = Et.objectValues(n);
      return Ie(r, {
        received: r.data,
        code: ye.invalid_enum_value,
        options: i
      }), ct;
    }
    return Un(t.data);
  }
  get enum() {
    return this._def.values;
  }
}
il.create = (e, t) => new il({
  values: e,
  typeName: et.ZodNativeEnum,
  ...dt(t)
});
class Uo extends pt {
  unwrap() {
    return this._def.type;
  }
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    if (n.parsedType !== Re.promise && n.common.async === !1)
      return Ie(n, {
        code: ye.invalid_type,
        expected: Re.promise,
        received: n.parsedType
      }), ct;
    const r = n.parsedType === Re.promise ? n.data : Promise.resolve(n.data);
    return Un(r.then((i) => this._def.type.parseAsync(i, {
      path: n.path,
      errorMap: n.common.contextualErrorMap
    })));
  }
}
Uo.create = (e, t) => new Uo({
  type: e,
  typeName: et.ZodPromise,
  ...dt(t)
});
class Sr extends pt {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === et.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t), i = this._def.effect || null, a = {
      addIssue: (o) => {
        Ie(r, o), o.fatal ? n.abort() : n.dirty();
      },
      get path() {
        return r.path;
      }
    };
    if (a.addIssue = a.addIssue.bind(a), i.type === "preprocess") {
      const o = i.transform(r.data, a);
      return r.common.issues.length ? {
        status: "dirty",
        value: r.data
      } : r.common.async ? Promise.resolve(o).then((s) => this._def.schema._parseAsync({
        data: s,
        path: r.path,
        parent: r
      })) : this._def.schema._parseSync({
        data: o,
        path: r.path,
        parent: r
      });
    }
    if (i.type === "refinement") {
      const o = (s) => {
        const l = i.refinement(s, a);
        if (r.common.async)
          return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return s;
      };
      if (r.common.async === !1) {
        const s = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return s.status === "aborted" ? ct : (s.status === "dirty" && n.dirty(), o(s.value), { status: n.value, value: s.value });
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((s) => s.status === "aborted" ? ct : (s.status === "dirty" && n.dirty(), o(s.value).then(() => ({ status: n.value, value: s.value }))));
    }
    if (i.type === "transform")
      if (r.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: r.data,
          path: r.path,
          parent: r
        });
        if (!Gs(o))
          return o;
        const s = i.transform(o.value, a);
        if (s instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: n.value, value: s };
      } else
        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) => Gs(o) ? Promise.resolve(i.transform(o.value, a)).then((s) => ({ status: n.value, value: s })) : o);
    Et.assertNever(i);
  }
}
Sr.create = (e, t, n) => new Sr({
  schema: e,
  typeName: et.ZodEffects,
  effect: t,
  ...dt(n)
});
Sr.createWithPreprocess = (e, t, n) => new Sr({
  schema: t,
  effect: { type: "preprocess", transform: e },
  typeName: et.ZodEffects,
  ...dt(n)
});
class di extends pt {
  _parse(t) {
    return this._getType(t) === Re.undefined ? Un(void 0) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
di.create = (e, t) => new di({
  innerType: e,
  typeName: et.ZodOptional,
  ...dt(t)
});
class $a extends pt {
  _parse(t) {
    return this._getType(t) === Re.null ? Un(null) : this._def.innerType._parse(t);
  }
  unwrap() {
    return this._def.innerType;
  }
}
$a.create = (e, t) => new $a({
  innerType: e,
  typeName: et.ZodNullable,
  ...dt(t)
});
class al extends pt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t);
    let r = n.data;
    return n.parsedType === Re.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
al.create = (e, t) => new al({
  innerType: e,
  typeName: et.ZodDefault,
  defaultValue: typeof t.default == "function" ? t.default : () => t.default,
  ...dt(t)
});
class hd extends pt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = {
      ...n,
      common: {
        ...n.common,
        issues: []
      }
    }, i = this._def.innerType._parse({
      data: r.data,
      path: r.path,
      parent: {
        ...r
      }
    });
    return ud(i) ? i.then((a) => ({
      status: "valid",
      value: a.status === "valid" ? a.value : this._def.catchValue({
        get error() {
          return new wr(r.common.issues);
        },
        input: r.data
      })
    })) : {
      status: "valid",
      value: i.status === "valid" ? i.value : this._def.catchValue({
        get error() {
          return new wr(r.common.issues);
        },
        input: r.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
hd.create = (e, t) => new hd({
  innerType: e,
  typeName: et.ZodCatch,
  catchValue: typeof t.catch == "function" ? t.catch : () => t.catch,
  ...dt(t)
});
class md extends pt {
  _parse(t) {
    if (this._getType(t) !== Re.nan) {
      const r = this._getOrReturnCtx(t);
      return Ie(r, {
        code: ye.invalid_type,
        expected: Re.nan,
        received: r.parsedType
      }), ct;
    }
    return { status: "valid", value: t.data };
  }
}
md.create = (e) => new md({
  typeName: et.ZodNaN,
  ...dt(e)
});
const Use = Symbol("zod_brand");
class CO extends pt {
  _parse(t) {
    const { ctx: n } = this._processInputParams(t), r = n.data;
    return this._def.type._parse({
      data: r,
      path: n.path,
      parent: n
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class Kl extends pt {
  _parse(t) {
    const { status: n, ctx: r } = this._processInputParams(t);
    if (r.common.async)
      return (async () => {
        const a = await this._def.in._parseAsync({
          data: r.data,
          path: r.path,
          parent: r
        });
        return a.status === "aborted" ? ct : a.status === "dirty" ? (n.dirty(), kO(a.value)) : this._def.out._parseAsync({
          data: a.value,
          path: r.path,
          parent: r
        });
      })();
    {
      const i = this._def.in._parseSync({
        data: r.data,
        path: r.path,
        parent: r
      });
      return i.status === "aborted" ? ct : i.status === "dirty" ? (n.dirty(), {
        status: "dirty",
        value: i.value
      }) : this._def.out._parseSync({
        data: i.value,
        path: r.path,
        parent: r
      });
    }
  }
  static create(t, n) {
    return new Kl({
      in: t,
      out: n,
      typeName: et.ZodPipeline
    });
  }
}
class gd extends pt {
  _parse(t) {
    const n = this._def.innerType._parse(t);
    return Gs(n) && (n.value = Object.freeze(n.value)), n;
  }
}
gd.create = (e, t) => new gd({
  innerType: e,
  typeName: et.ZodReadonly,
  ...dt(t)
});
const OO = (e, t = {}, n) => e ? jo.create().superRefine((r, i) => {
  var a, o;
  if (!e(r)) {
    const s = typeof t == "function" ? t(r) : typeof t == "string" ? { message: t } : t, l = (o = (a = s.fatal) !== null && a !== void 0 ? a : n) !== null && o !== void 0 ? o : !0, c = typeof s == "string" ? { message: s } : s;
    i.addIssue({ code: "custom", ...c, fatal: l });
  }
}) : jo.create(), Fse = {
  object: Bt.lazycreate
};
var et;
(function(e) {
  e.ZodString = "ZodString", e.ZodNumber = "ZodNumber", e.ZodNaN = "ZodNaN", e.ZodBigInt = "ZodBigInt", e.ZodBoolean = "ZodBoolean", e.ZodDate = "ZodDate", e.ZodSymbol = "ZodSymbol", e.ZodUndefined = "ZodUndefined", e.ZodNull = "ZodNull", e.ZodAny = "ZodAny", e.ZodUnknown = "ZodUnknown", e.ZodNever = "ZodNever", e.ZodVoid = "ZodVoid", e.ZodArray = "ZodArray", e.ZodObject = "ZodObject", e.ZodUnion = "ZodUnion", e.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", e.ZodIntersection = "ZodIntersection", e.ZodTuple = "ZodTuple", e.ZodRecord = "ZodRecord", e.ZodMap = "ZodMap", e.ZodSet = "ZodSet", e.ZodFunction = "ZodFunction", e.ZodLazy = "ZodLazy", e.ZodLiteral = "ZodLiteral", e.ZodEnum = "ZodEnum", e.ZodEffects = "ZodEffects", e.ZodNativeEnum = "ZodNativeEnum", e.ZodOptional = "ZodOptional", e.ZodNullable = "ZodNullable", e.ZodDefault = "ZodDefault", e.ZodCatch = "ZodCatch", e.ZodPromise = "ZodPromise", e.ZodBranded = "ZodBranded", e.ZodPipeline = "ZodPipeline", e.ZodReadonly = "ZodReadonly";
})(et || (et = {}));
const Bse = (e, t = {
  message: `Input not instance of ${e.name}`
}) => OO((n) => n instanceof e, t), AO = gr.create, $O = Wi.create, zse = md.create, Zse = Vi.create, RO = Js.create, qse = Oa.create, Wse = dd.create, Vse = Ys.create, Hse = Xs.create, Kse = jo.create, Gse = ya.create, Jse = gi.create, Yse = fd.create, Xse = xr.create, Qse = Bt.create, ele = Bt.strictCreate, tle = Qs.create, nle = Lf.create, rle = el.create, ile = Fr.create, ale = tl.create, ole = pd.create, sle = Aa.create, lle = mo.create, cle = nl.create, ule = rl.create, dle = Hi.create, fle = il.create, ple = Uo.create, d0 = Sr.create, hle = di.create, mle = $a.create, gle = Sr.createWithPreprocess, yle = Kl.create, vle = () => AO().optional(), ble = () => $O().optional(), wle = () => RO().optional(), xle = {
  string: (e) => gr.create({ ...e, coerce: !0 }),
  number: (e) => Wi.create({ ...e, coerce: !0 }),
  boolean: (e) => Js.create({
    ...e,
    coerce: !0
  }),
  bigint: (e) => Vi.create({ ...e, coerce: !0 }),
  date: (e) => Oa.create({ ...e, coerce: !0 })
}, _le = ct;
var q = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: Ks,
  setErrorMap: Tse,
  getErrorMap: ld,
  makeIssue: cd,
  EMPTY_PATH: Cse,
  addIssueToContext: Ie,
  ParseStatus: Pn,
  INVALID: ct,
  DIRTY: kO,
  OK: Un,
  isAborted: hm,
  isDirty: mm,
  isValid: Gs,
  isAsync: ud,
  get util() {
    return Et;
  },
  get objectUtil() {
    return pm;
  },
  ZodParsedType: Re,
  getParsedType: Ii,
  ZodType: pt,
  ZodString: gr,
  ZodNumber: Wi,
  ZodBigInt: Vi,
  ZodBoolean: Js,
  ZodDate: Oa,
  ZodSymbol: dd,
  ZodUndefined: Ys,
  ZodNull: Xs,
  ZodAny: jo,
  ZodUnknown: ya,
  ZodNever: gi,
  ZodVoid: fd,
  ZodArray: xr,
  ZodObject: Bt,
  ZodUnion: Qs,
  ZodDiscriminatedUnion: Lf,
  ZodIntersection: el,
  ZodTuple: Fr,
  ZodRecord: tl,
  ZodMap: pd,
  ZodSet: Aa,
  ZodFunction: mo,
  ZodLazy: nl,
  ZodLiteral: rl,
  ZodEnum: Hi,
  ZodNativeEnum: il,
  ZodPromise: Uo,
  ZodEffects: Sr,
  ZodTransformer: Sr,
  ZodOptional: di,
  ZodNullable: $a,
  ZodDefault: al,
  ZodCatch: hd,
  ZodNaN: md,
  BRAND: Use,
  ZodBranded: CO,
  ZodPipeline: Kl,
  ZodReadonly: gd,
  custom: OO,
  Schema: pt,
  ZodSchema: pt,
  late: Fse,
  get ZodFirstPartyTypeKind() {
    return et;
  },
  coerce: xle,
  any: Kse,
  array: Xse,
  bigint: Zse,
  boolean: RO,
  date: qse,
  discriminatedUnion: nle,
  effect: d0,
  enum: dle,
  function: lle,
  instanceof: Bse,
  intersection: rle,
  lazy: cle,
  literal: ule,
  map: ole,
  nan: zse,
  nativeEnum: fle,
  never: Jse,
  null: Hse,
  nullable: mle,
  number: $O,
  object: Qse,
  oboolean: wle,
  onumber: ble,
  optional: hle,
  ostring: vle,
  pipeline: yle,
  preprocess: gle,
  promise: ple,
  record: ale,
  set: sle,
  strictObject: ele,
  string: AO,
  symbol: Wse,
  transformer: d0,
  tuple: ile,
  undefined: Vse,
  union: tle,
  unknown: Gse,
  void: Yse,
  NEVER: _le,
  ZodIssueCode: ye,
  quotelessJson: kse,
  ZodError: wr
});
const Sle = q.object({
  type: q.literal("message_created"),
  data: q.object({
    id: q.string(),
    createdAt: q.string().datetime(),
    payload: q.union([
      q.object({
        audioUrl: q.string().min(1),
        className: q.string().describe("CSS className to apply to the message").optional(),
        type: q.literal("audio")
      }),
      q.object({
        title: q.string().min(1),
        subtitle: q.string().optional(),
        imageUrl: q.string().optional(),
        actions: q.array(
          q.object({
            action: q.enum(["postback", "url", "say"]),
            label: q.string().min(1),
            value: q.string().min(1)
          })
        ),
        type: q.literal("card"),
        className: q.string().describe("CSS className to apply to the message").optional()
      }),
      q.object({
        items: q.array(
          q.object({
            title: q.string().min(1),
            subtitle: q.string().optional(),
            imageUrl: q.string().optional(),
            actions: q.array(
              q.object({
                action: q.enum(["postback", "url", "say"]),
                label: q.string().min(1),
                value: q.string().min(1)
              })
            ),
            className: q.string().describe("CSS className to apply to the message").optional()
          })
        ),
        className: q.string().describe("CSS className to apply to the message").optional(),
        type: q.literal("carousel")
      }),
      q.object({
        text: q.string(),
        options: q.array(
          q.object({
            label: q.string().min(1),
            value: q.string().min(1)
          })
        ),
        className: q.string().describe("CSS className to apply to the message").optional(),
        type: q.literal("choice"),
        disableFreeText: q.boolean().optional()
      }),
      q.object({
        text: q.string(),
        options: q.array(
          q.object({
            label: q.string().min(1),
            value: q.string().min(1)
          })
        ),
        className: q.string().describe("CSS className to apply to the message").optional(),
        type: q.literal("dropdown")
      }),
      q.object({
        fileUrl: q.string().min(1),
        title: q.string().min(1).optional(),
        className: q.string().describe("CSS className to apply to the message").optional(),
        type: q.literal("file")
      }),
      q.object({
        imageUrl: q.string().min(1),
        className: q.string().describe("CSS className to apply to the message").optional(),
        type: q.literal("image")
      }),
      q.object({
        latitude: q.number(),
        longitude: q.number(),
        address: q.string().optional(),
        title: q.string().optional(),
        className: q.string().describe("CSS className to apply to the message").optional(),
        type: q.literal("location")
      }),
      q.object({
        markdown: q.string().min(1),
        className: q.string().describe("CSS className to apply to the message").optional(),
        type: q.literal("markdown")
      }),
      q.object({
        text: q.string().min(1),
        className: q.string().describe("CSS className to apply to the message").optional(),
        type: q.literal("text")
      }),
      q.object({
        videoUrl: q.string().min(1),
        className: q.string().describe("CSS className to apply to the message").optional(),
        type: q.literal("video")
      })
    ]),
    userId: q.string(),
    conversationId: q.string()
  })
}), Ele = q.object({
  type: q.literal("webchat_visibility"),
  data: q.object({ visibility: q.enum(["show", "hide", "toggle"]) })
}), kle = q.object({
  type: q.literal("webchat_config"),
  data: q.object({ config: q.record(q.any()) })
}), Tle = q.object({
  type: q.literal("custom"),
  data: q.object({ event: q.record(q.any()) })
}), Cle = {
  messageCreated: Sle,
  webchatVisibility: Ele,
  webchatConfig: kle,
  custom: Tle
}, f0 = "unknown error", bd = class bd extends SO {
  constructor(n) {
    super();
    _(this, "_state", { status: "disconnected" });
    _(this, "connect", async () => {
      if (this._state.status === "connected")
        return;
      if (this._state.status === "connecting") {
        await this._state.connectionPromise;
        return;
      }
      const n = this._connect();
      this._state = { status: "connecting", connectionPromise: n }, await n;
    });
    _(this, "disconnect", async () => {
      if (this._state.status === "disconnected")
        return;
      let n;
      this._state.status === "connecting" ? n = await this._state.connectionPromise : n = this._state.source, this._disconnectSync(n);
    });
    _(this, "_connect", async () => {
      const n = await Ese(`${this._props.url}/conversations/${this._props.conversationId}/listen`, {
        headers: { "x-user-key": this._props.userKey }
      });
      return n.on("message", this._handleMessage), n.on("error", this._handleError(n)), this._state = { status: "connected", source: n }, n;
    });
    _(this, "_disconnectSync", (n) => {
      n.close(), this._state = { status: "disconnected" };
    });
    _(this, "_handleMessage", (n) => {
      const r = this._parseSignal(n.data);
      this.emit(r.type, r.data);
    });
    _(this, "_handleError", (n) => (r) => {
      this._disconnectSync(n);
      const i = this._toError(r);
      this.emit("error", i);
    });
    _(this, "_parseSignal", (n) => {
      for (const r of Object.values(Cle)) {
        const i = this._safeJsonParse(n), a = r.safeParse(i);
        if (a.success)
          return a.data;
      }
      return {
        type: "unknown",
        data: n
      };
    });
    _(this, "_safeJsonParse", (n) => {
      try {
        return JSON.parse(n);
      } catch {
        return n;
      }
    });
    _(this, "_toError", (n) => {
      if (n instanceof Error)
        return n;
      if (typeof n == "string")
        return new Error(n);
      if (n === null)
        return new Error(f0);
      if (typeof n == "object" && "message" in n)
        return this._toError(n.message);
      try {
        const r = JSON.stringify(n);
        return new Error(r);
      } catch {
        return new Error(f0);
      }
    });
    this._props = n;
  }
  get status() {
    return this._state.status;
  }
};
_(bd, "listen", async (n) => {
  const r = new bd(n);
  return await r.connect(), r;
});
let ym = bd;
const PO = 100 * 1024 * 1024, Ole = PO, Ale = PO, $le = 6e4;
class Rle {
  constructor(t) {
    _(this, "_auto");
    _(this, "createConversation", (t) => this._auto.createConversation(t));
    _(this, "getConversation", (t) => this._auto.getConversation(t));
    _(this, "deleteConversation", (t) => this._auto.deleteConversation(t));
    _(this, "listConversations", (t) => this._auto.listConversations(t));
    _(this, "listConversationMessages", (t) => this._auto.listConversationMessages(t));
    _(this, "addParticipant", (t) => this._auto.addParticipant(t));
    _(this, "removeParticipant", (t) => this._auto.removeParticipant(t));
    _(this, "getParticipant", (t) => this._auto.getParticipant(t));
    _(this, "listParticipants", (t) => this._auto.listParticipants(t));
    _(this, "createMessage", (t) => this._auto.createMessage(t));
    _(this, "getMessage", (t) => this._auto.getMessage(t));
    _(this, "deleteMessage", (t) => this._auto.deleteMessage(t));
    _(this, "createUser", (t) => this._auto.createUser(t));
    _(this, "getUser", (t) => this._auto.getUser(t));
    _(this, "updateUser", (t) => this._auto.updateUser(t));
    _(this, "deleteUser", (t) => this._auto.deleteUser(t));
    _(this, "createEvent", (t) => this._auto.createEvent(t));
    _(this, "getEvent", (t) => this._auto.getEvent(t));
    _(this, "listenConversation", async ({
      id: t,
      "x-user-key": n
    }) => await ym.listen({
      url: this.props.apiUrl,
      conversationId: t,
      userKey: n
    }));
    this.props = t;
    const { apiUrl: n } = t, r = {
      ...t.headers
    }, i = t.timeout ?? $le, a = sO.create({
      baseURL: n,
      headers: r,
      withCredentials: !0,
      timeout: i,
      maxBodyLength: Ole,
      maxContentLength: Ale
    });
    this._auto = new wse(a);
  }
}
const yd = {
  disconnected: 0,
  user_creating: 1,
  user_created: 2,
  conversation_creating: 3,
  conversation_created: 4
}, ar = (e, t) => e.status === t, Qr = (e, t) => yd[e.status] < yd[t], p0 = (e, t) => yd[e.status] >= yd[t];
class Ti extends Error {
  constructor(t) {
    super(`Unexpected state: ${t.status}`), this.state = t;
  }
}
class Ple extends Em {
  constructor(n) {
    super();
    _(this, "_client");
    _(this, "_webhookId");
    _(this, "_apiUrl");
    _(this, "_state", { status: "disconnected" });
    _(this, "mode", "pushpin");
    _(this, "_initialConnect", async (n) => {
      if (p0(this._state, "user_created"))
        throw new Error("Client is already connected. Please disconnect first.");
      if (ar(this._state, "user_creating"))
        return;
      this._state = {
        status: "user_creating"
      };
      const {
        user: { id: r },
        key: i
      } = await this._client.createUser({
        name: void 0,
        // TODO: allow passing name and pictureUrl
        pictureUrl: void 0,
        userData: n
      });
      return this._state = {
        status: "user_created",
        userId: r,
        userKey: i
      }, {
        userId: r,
        userToken: i
      };
    });
    _(this, "_reConnect", async (n, r) => {
      if (p0(this._state, "user_created")) {
        if (this._state.userId !== n.userId)
          throw new Error("Client is already connected. Please disconnect first.");
        return n;
      }
      return ar(this._state, "user_creating") || (this._state = {
        status: "user_created",
        userId: n.userId,
        userKey: n.userToken
      }, await this._client.updateUser({
        "x-user-key": n.userToken,
        name: void 0,
        // TODO: allow passing name and pictureUrl
        pictureUrl: void 0,
        userData: r
      })), n;
    });
    _(this, "_mapMessage", (n) => {
      const { payload: r, disableInput: i } = yre(n.payload);
      return {
        id: n.id,
        conversationId: n.conversationId,
        authorId: n.userId,
        sentOn: new Date(n.createdAt),
        payload: r,
        disableInput: i
      };
    });
    const r = `${n.apiUrl}/${n.clientId}`;
    this._webhookId = n.clientId, this._apiUrl = r, this._client = new Rle({
      apiUrl: r
    });
  }
  get apiUrl() {
    return this._apiUrl;
  }
  get clientId() {
    return this._webhookId;
  }
  get userId() {
    if (!Qr(this._state, "user_created"))
      return this._state.userId;
  }
  async getUser() {
    if (Qr(this._state, "user_created"))
      throw new Ti(this._state);
    const { user: n } = await this._client.getUser({ "x-user-key": this._state.userKey });
    return { data: n.data };
  }
  async updateUser(n) {
    if (Qr(this._state, "user_created"))
      throw new Ti(this._state);
    const { user: r } = await this._client.updateUser({
      "x-user-key": this._state.userKey,
      userData: n.data
    });
    return r;
  }
  get conversationId() {
    if (!Qr(this._state, "conversation_created"))
      return this._state.conversationId;
  }
  async connect(n, r) {
    return n ? await this.userExists(n) ? this._reConnect(n, r) : this._initialConnect(r) : this._initialConnect(r);
  }
  async disconnect() {
    ar(this._state, "conversation_created") ? this._state.signalEmitter.cleanup() : ar(this._state, "conversation_creating") && console.warn("zombie conversation..."), this._state = { status: "disconnected" };
  }
  async sendMessage(n) {
    if (Qr(this._state, "user_created"))
      throw new Ti(this._state);
    if (ar(this._state, "conversation_creating"))
      throw new Ti(this._state);
    let r;
    ar(this._state, "conversation_created") ? r = this._state : (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, r = await this._createNewConversation(this._state)), await this._client.createMessage({
      "x-user-key": r.userKey,
      conversationId: r.conversationId,
      payload: {
        type: "text",
        text: n
      }
    }), this.emit("messageSent", n);
  }
  async sendEvent(n) {
    if (Qr(this._state, "user_created"))
      throw new Ti(this._state);
    if (ar(this._state, "conversation_creating"))
      throw new Ti(this._state);
    let r;
    ar(this._state, "conversation_created") ? r = this._state : (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, r = await this._createNewConversation(this._state)), await this._client.createEvent({
      "x-user-key": r.userKey,
      conversationId: r.conversationId,
      payload: {
        type: "custom",
        data: n
      }
    });
  }
  async switchConversation(n) {
    if (Qr(this._state, "user_created"))
      throw new Ti(this._state);
    ar(this._state, "conversation_created") && this._state.conversationId === n || ar(this._state, "conversation_creating") || (this._state = {
      status: "conversation_creating",
      userId: this._state.userId,
      userKey: this._state.userKey
    }, await this._connectConversation(this._state, n));
  }
  async conversationExists(n) {
    if (Qr(this._state, "user_created"))
      return !1;
    try {
      return await this._client.getConversation({
        "x-user-key": this._state.userKey,
        id: n
      }), !0;
    } catch (r) {
      if (am(r) && r.code === 404)
        return !1;
      throw r;
    }
  }
  async userExists({ userToken: n }) {
    try {
      return await this._client.getUser({
        "x-user-key": n
      }), !0;
    } catch (r) {
      const i = (a) => a.code === 404 || a.code === 401;
      if (am(r) && i(r))
        return !1;
      throw r;
    }
  }
  async newConversation() {
    if (Qr(this._state, "user_created"))
      throw new Ti(this._state);
    ar(this._state, "conversation_creating") || (this._state = { status: "conversation_creating", userId: this._state.userId, userKey: this._state.userKey }, await this._createNewConversation(this._state));
  }
  async _createNewConversation(n) {
    const {
      conversation: { id: r }
    } = await this._client.createConversation({ "x-user-key": n.userKey }), i = await this._connectConversation(n, r);
    return await this._client.createEvent({
      "x-user-key": n.userKey,
      conversationId: r,
      payload: { type: "conversation_started", data: {} }
    }), i;
  }
  async listMessages() {
    if (!ar(this._state, "conversation_created"))
      return [];
    const { conversationId: n, userKey: r } = this._state, i = [];
    let a;
    do {
      const o = await this._client.listConversationMessages({ id: n, "x-user-key": r, nextToken: a });
      i.push(...o.messages), a = o.meta.nextToken;
    } while (a);
    return i.map(this._mapMessage);
  }
  async _connectConversation(n, r) {
    const i = await this._client.listenConversation({ id: r, "x-user-key": n.userKey });
    return i.on("unknown", (a) => {
      typeof a == "string" && a === "ping" || console.debug("unknown event", a);
    }), i.on("message_created", (a) => {
      a.userId !== n.userId && this.emit("message", this._mapMessage(a));
    }), i.on("error", () => {
      this._state = { status: "user_created", userId: n.userId, userKey: n.userKey }, this.emit("error", new Error("Connection to conversation lost"));
    }), i.on("webchat_visibility", (a) => {
      this.emit("webchatVisibility", a.visibility);
    }), i.on("webchat_config", (a) => {
      this.emit("webchatConfig", a.config);
    }), i.on("custom", (a) => {
      this.emit("customEvent", a.event);
    }), this.emit("conversation", r), this._state = {
      status: "conversation_created",
      userId: n.userId,
      userKey: n.userKey,
      conversationId: r,
      signalEmitter: i
    }, this._state;
  }
}
const Ile = ({
  clientId: e,
  apiUrl: t = "https://webchat.botpress.cloud",
  mode: n = "pushpin"
}) => n === "messaging" ? new vre({
  url: t,
  clientId: e
}) : new Ple({
  apiUrl: t,
  clientId: e
}), ffe = ({
  clientId: e,
  apiUrl: t = "https://webchat.botpress.cloud",
  mode: n = "pushpin"
}) => {
  const [r] = De(Ile({ clientId: e, apiUrl: t, mode: n }));
  return r;
}, Mle = (e, t, n = 120) => {
  Be(() => {
    if (e) {
      e.style.height = "0px";
      const r = Math.min(e.scrollHeight, n);
      e.style.height = r + "px";
    }
  }, [e, t]);
}, Nle = Bo(
  ze((e, t) => {
    const {
      state: n,
      theme: { composer: r },
      client: i
    } = It(), [a, o] = De(""), [s, l] = De(-1);
    if (n.isReadOnly || !i)
      return null;
    const c = () => {
      a && (i.sendMessage(a), o(""), l(-1));
    };
    return /* @__PURE__ */ F.jsx(Vx.Provider, { value: { value: a, setValue: o, historyIndex: s, setHistoryIndex: l, sendMessage: c }, children: /* @__PURE__ */ F.jsx("div", { "data-disabled": n.disableComposer, ...e, ...r == null ? void 0 : r.container, ref: t }) });
  })
), Dle = Bo((e) => {
  const {
    state: t,
    theme: { composer: n },
    configuration: r
  } = It(), { value: i, setValue: a, historyIndex: o, setHistoryIndex: s, sendMessage: l } = Hx(), c = Xe(null), u = Oi((y) => y.user), d = Oi((y) => y.messageHistory), [p, f] = De(!1);
  Mle(c.current, i), Be(() => {
    c.current && (c.current.selectionStart = c.current.value.length, c.current.selectionEnd = c.current.value.length);
  }, [i]);
  function h({ key: y }) {
    y === "Shift" && f(!0);
  }
  function m({ key: y }) {
    y === "Shift" && f(!1);
  }
  return Be(() => (window.addEventListener("keydown", h), window.addEventListener("keyup", m), () => {
    window.removeEventListener("keydown", h), window.removeEventListener("keyup", m);
  }), []), /* @__PURE__ */ F.jsx(
    "textarea",
    {
      ...n == null ? void 0 : n.input,
      placeholder: (r == null ? void 0 : r.composerPlaceholder) ?? "Type your message...",
      disabled: t.disableComposer,
      ref: c,
      value: i,
      "data-has-value": !!i,
      onChange: (y) => a(y.target.value),
      onKeyDown: (y) => {
        if (!t.disableComposer) {
          if (y.key === "Enter" && (y.preventDefault(), p ? (a(i + `
`), setTimeout(() => {
            var g;
            return (g = c.current) == null ? void 0 : g.scroll({ behavior: "instant", top: c.current.scrollHeight });
          }, 0)) : l()), y.key === "ArrowUp") {
            y.preventDefault();
            const g = d[(u == null ? void 0 : u.userId) ?? ""] ?? [];
            o < g.length - 1 && a(g[o + 1]), s(() => Math.min(o + 1, g.length - 1));
          }
          if (y.key === "ArrowDown") {
            y.preventDefault();
            const g = d[(u == null ? void 0 : u.userId) ?? ""] ?? [];
            a(o === 0 ? "" : g[o - 1]), s(() => Math.max(o - 1, -1));
          }
        }
      },
      ...e
    }
  );
}), Lle = Bo(
  ze(({ icon: e = J2, ...t }, n) => {
    var o, s;
    const { value: r, sendMessage: i } = Hx(), {
      theme: { composer: a }
    } = It();
    return /* @__PURE__ */ F.jsx("button", { ref: n, ...t, ...(o = a == null ? void 0 : a.button) == null ? void 0 : o.container, disabled: !r, onClick: i, children: /* @__PURE__ */ F.jsx(e, { ...(s = a == null ? void 0 : a.button) == null ? void 0 : s.icon }) });
  })
), jle = ({ children: e }) => {
  const [t, n] = De(!1), [r, i] = De(""), [a, o] = De(null), s = ({ title: c, content: u }) => {
    i(c), o(u), n(!0);
  }, l = () => {
    n(!1);
  };
  return /* @__PURE__ */ F.jsxs(Gx.Provider, { value: { hideModal: l, showModal: s, title: r, content: a, open: t }, children: [
    /* @__PURE__ */ F.jsx(Ra, { open: t, onOpenChange: n, children: /* @__PURE__ */ F.jsx(Ra.Content, { title: r, children: a }) }),
    e
  ] });
}, pfe = ({
  theme: e = {},
  renderers: t,
  client: n,
  children: r,
  configuration: i = {},
  userData: a,
  closeWindow: o,
  ...s
}) => {
  const [l, c] = De(0), [u, d] = De([]), [p, f] = De({
    disableComposer: !1,
    ...s.defaultState,
    connected: !0
  }), [h, m] = De(i), [y, g] = De(e), v = Oi((k) => k.addMessageToHistory), b = Oi((k) => k.setConversationId), T = Oi((k) => k.user), O = Oi((k) => k.conversationId), S = Oi((k) => k.setUser), P = Oi((k) => k.setClientMode), M = Xe(null), L = {
    ...s,
    value: {
      theme: y,
      renderers: { ...q_, ...t },
      messages: u,
      messageContainerRef: M,
      setMessages: d,
      eventEmitter: PA,
      configuration: i,
      setConfiguration: m,
      state: p,
      closeWindow: o,
      setState: (k) => f({ ...p, ...k }),
      setTheme: g,
      client: n ? {
        ...n,
        sendMessage: async (k) => {
          await n.sendMessage(k), d((I) => [
            ...I,
            {
              direction: "outgoing",
              sender: { name: "You" },
              timestamp: /* @__PURE__ */ new Date(),
              disableInput: !1,
              block: { type: "bubble", block: { type: "text", text: k } }
            }
          ]), n.userId && v({ message: k, userId: n.userId });
        },
        on: n.on,
        restartConversation: async () => {
          await n.newConversation(), d([]);
        }
      } : void 0
    }
  };
  return ha(() => {
    n && P(n.mode);
  }), ha(() => {
    if (n)
      return n.on("message", (k) => {
        try {
          const { payload: I, disableInput: B } = k;
          d((U) => [
            ...U,
            {
              direction: "incoming",
              sender: { name: h.botName ?? "Bot", avatar: h.botAvatar },
              timestamp: new Date(k.sentOn),
              block: I,
              disableInput: B
            }
          ]);
        } catch {
          console.error("Invalid message payload");
        }
      });
  }), wh(async () => {
    if (n)
      return n.on("error", () => {
        console.log("client disconnected"), c((k) => k + 1);
      });
  }), ha(() => {
    if (n)
      return n.on("conversation", (k) => {
        b(k);
      });
  }), wh(async () => {
    if (!n)
      return;
    let k;
    try {
      k = await n.connect(T, a), f((B) => ({ ...B, connected: !0 }));
    } catch {
      f((U) => ({ ...U, connected: !1 }));
      return;
    }
    S(k), O && await n.conversationExists(O) ? await n.switchConversation(O) : await n.newConversation();
    const I = [];
    for (const B of await n.listMessages())
      try {
        const { payload: U, authorId: z, sentOn: D, disableInput: j } = B, V = z === n.userId ? "outgoing" : "incoming";
        I.push({
          direction: V,
          sender: V === "outgoing" ? { name: "You" } : { name: h.botName ?? "Bot", avatar: h.botAvatar },
          timestamp: new Date(D),
          block: U,
          disableInput: j
        });
      } catch {
        console.error("Invalid message payload");
      }
    return d(I.reverse()), () => {
      n.disconnect();
    };
  }, [l]), /* @__PURE__ */ F.jsx(Yx.Provider, { ...L, children: typeof r == "function" ? r(h) : r });
};
function On(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(i) {
    if (e == null || e(i), n === !1 || !i.defaultPrevented)
      return t == null ? void 0 : t(i);
  };
}
const Ule = A["useId".toString()] || (() => {
});
let Fle = 0;
function Wc(e) {
  const [t, n] = A.useState(Ule());
  return go(() => {
    e || n(
      (r) => r ?? String(Fle++)
    );
  }, [
    e
  ]), e || (t ? `radix-${t}` : "");
}
function IO({ prop: e, defaultProp: t, onChange: n = () => {
} }) {
  const [r, i] = Ble({
    defaultProp: t,
    onChange: n
  }), a = e !== void 0, o = a ? e : r, s = Nn(n), l = nn((c) => {
    if (a) {
      const d = typeof c == "function" ? c(e) : c;
      d !== e && s(d);
    } else
      i(c);
  }, [
    a,
    e,
    i,
    s
  ]);
  return [
    o,
    l
  ];
}
function Ble({ defaultProp: e, onChange: t }) {
  const n = De(e), [r] = n, i = Xe(r), a = Nn(t);
  return Be(() => {
    i.current !== r && (a(r), i.current = r);
  }, [
    r,
    i,
    a
  ]), n;
}
function zle(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Nn(e);
  Be(() => {
    const r = (i) => {
      i.key === "Escape" && n(i);
    };
    return t.addEventListener("keydown", r), () => t.removeEventListener("keydown", r);
  }, [
    n,
    t
  ]);
}
const vm = "dismissableLayer.update", Zle = "dismissableLayer.pointerDownOutside", qle = "dismissableLayer.focusOutside";
let h0;
const Wle = /* @__PURE__ */ _r({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Vle = /* @__PURE__ */ ze((e, t) => {
  var n;
  const { disableOutsidePointerEvents: r = !1, onEscapeKeyDown: i, onPointerDownOutside: a, onFocusOutside: o, onInteractOutside: s, onDismiss: l, ...c } = e, u = Er(Wle), [d, p] = De(null), f = (n = d == null ? void 0 : d.ownerDocument) !== null && n !== void 0 ? n : globalThis == null ? void 0 : globalThis.document, [, h] = De({}), m = nr(
    t,
    (M) => p(M)
  ), y = Array.from(u.layers), [g] = [
    ...u.layersWithOutsidePointerEventsDisabled
  ].slice(-1), v = y.indexOf(g), b = d ? y.indexOf(d) : -1, T = u.layersWithOutsidePointerEventsDisabled.size > 0, O = b >= v, S = Hle((M) => {
    const L = M.target, k = [
      ...u.branches
    ].some(
      (I) => I.contains(L)
    );
    !O || k || (a == null || a(M), s == null || s(M), M.defaultPrevented || l == null || l());
  }, f), P = Kle((M) => {
    const L = M.target;
    [
      ...u.branches
    ].some(
      (I) => I.contains(L)
    ) || (o == null || o(M), s == null || s(M), M.defaultPrevented || l == null || l());
  }, f);
  return zle((M) => {
    b === u.layers.size - 1 && (i == null || i(M), !M.defaultPrevented && l && (M.preventDefault(), l()));
  }, f), Be(() => {
    if (d)
      return r && (u.layersWithOutsidePointerEventsDisabled.size === 0 && (h0 = f.body.style.pointerEvents, f.body.style.pointerEvents = "none"), u.layersWithOutsidePointerEventsDisabled.add(d)), u.layers.add(d), m0(), () => {
        r && u.layersWithOutsidePointerEventsDisabled.size === 1 && (f.body.style.pointerEvents = h0);
      };
  }, [
    d,
    f,
    r,
    u
  ]), Be(() => () => {
    d && (u.layers.delete(d), u.layersWithOutsidePointerEventsDisabled.delete(d), m0());
  }, [
    d,
    u
  ]), Be(() => {
    const M = () => h({});
    return document.addEventListener(vm, M), () => document.removeEventListener(vm, M);
  }, []), /* @__PURE__ */ Ue(_n.div, ut({}, c, {
    ref: m,
    style: {
      pointerEvents: T ? O ? "auto" : "none" : void 0,
      ...e.style
    },
    onFocusCapture: On(e.onFocusCapture, P.onFocusCapture),
    onBlurCapture: On(e.onBlurCapture, P.onBlurCapture),
    onPointerDownCapture: On(e.onPointerDownCapture, S.onPointerDownCapture)
  }));
});
function Hle(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Nn(e), r = Xe(!1), i = Xe(() => {
  });
  return Be(() => {
    const a = (s) => {
      if (s.target && !r.current) {
        let c = function() {
          MO(Zle, n, l, {
            discrete: !0
          });
        };
        const l = {
          originalEvent: s
        };
        s.pointerType === "touch" ? (t.removeEventListener("click", i.current), i.current = c, t.addEventListener("click", i.current, {
          once: !0
        })) : c();
      }
      r.current = !1;
    }, o = window.setTimeout(() => {
      t.addEventListener("pointerdown", a);
    }, 0);
    return () => {
      window.clearTimeout(o), t.removeEventListener("pointerdown", a), t.removeEventListener("click", i.current);
    };
  }, [
    t,
    n
  ]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function Kle(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = Nn(e), r = Xe(!1);
  return Be(() => {
    const i = (a) => {
      a.target && !r.current && MO(qle, n, {
        originalEvent: a
      }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", i), () => t.removeEventListener("focusin", i);
  }, [
    t,
    n
  ]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function m0() {
  const e = new CustomEvent(vm);
  document.dispatchEvent(e);
}
function MO(e, t, n, { discrete: r }) {
  const i = n.originalEvent.target, a = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  t && i.addEventListener(e, t, {
    once: !0
  }), r ? TA(i, a) : i.dispatchEvent(a);
}
const Vp = "focusScope.autoFocusOnMount", Hp = "focusScope.autoFocusOnUnmount", g0 = {
  bubbles: !1,
  cancelable: !0
}, Gle = /* @__PURE__ */ ze((e, t) => {
  const { loop: n = !1, trapped: r = !1, onMountAutoFocus: i, onUnmountAutoFocus: a, ...o } = e, [s, l] = De(null), c = Nn(i), u = Nn(a), d = Xe(null), p = nr(
    t,
    (m) => l(m)
  ), f = Xe({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  Be(() => {
    if (r) {
      let m = function(b) {
        if (f.paused || !s)
          return;
        const T = b.target;
        s.contains(T) ? d.current = T : Ci(d.current, {
          select: !0
        });
      }, y = function(b) {
        if (f.paused || !s)
          return;
        const T = b.relatedTarget;
        T !== null && (s.contains(T) || Ci(d.current, {
          select: !0
        }));
      }, g = function(b) {
        const T = document.activeElement;
        for (const O of b)
          O.removedNodes.length > 0 && (s != null && s.contains(T) || Ci(s));
      };
      document.addEventListener("focusin", m), document.addEventListener("focusout", y);
      const v = new MutationObserver(g);
      return s && v.observe(s, {
        childList: !0,
        subtree: !0
      }), () => {
        document.removeEventListener("focusin", m), document.removeEventListener("focusout", y), v.disconnect();
      };
    }
  }, [
    r,
    s,
    f.paused
  ]), Be(() => {
    if (s) {
      v0.add(f);
      const m = document.activeElement;
      if (!s.contains(m)) {
        const g = new CustomEvent(Vp, g0);
        s.addEventListener(Vp, c), s.dispatchEvent(g), g.defaultPrevented || (Jle(tce(NO(s)), {
          select: !0
        }), document.activeElement === m && Ci(s));
      }
      return () => {
        s.removeEventListener(Vp, c), setTimeout(() => {
          const g = new CustomEvent(Hp, g0);
          s.addEventListener(Hp, u), s.dispatchEvent(g), g.defaultPrevented || Ci(m ?? document.body, {
            select: !0
          }), s.removeEventListener(Hp, u), v0.remove(f);
        }, 0);
      };
    }
  }, [
    s,
    c,
    u,
    f
  ]);
  const h = nn((m) => {
    if (!n && !r || f.paused)
      return;
    const y = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey, g = document.activeElement;
    if (y && g) {
      const v = m.currentTarget, [b, T] = Yle(v);
      b && T ? !m.shiftKey && g === T ? (m.preventDefault(), n && Ci(b, {
        select: !0
      })) : m.shiftKey && g === b && (m.preventDefault(), n && Ci(T, {
        select: !0
      })) : g === v && m.preventDefault();
    }
  }, [
    n,
    r,
    f.paused
  ]);
  return /* @__PURE__ */ Ue(_n.div, ut({
    tabIndex: -1
  }, o, {
    ref: p,
    onKeyDown: h
  }));
});
function Jle(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (Ci(r, {
      select: t
    }), document.activeElement !== n)
      return;
}
function Yle(e) {
  const t = NO(e), n = y0(t, e), r = y0(t.reverse(), e);
  return [
    n,
    r
  ];
}
function NO(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); )
    t.push(n.currentNode);
  return t;
}
function y0(e, t) {
  for (const n of e)
    if (!Xle(n, {
      upTo: t
    }))
      return n;
}
function Xle(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  for (; e; ) {
    if (t !== void 0 && e === t)
      return !1;
    if (getComputedStyle(e).display === "none")
      return !0;
    e = e.parentElement;
  }
  return !1;
}
function Qle(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function Ci(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({
      preventScroll: !0
    }), e !== n && Qle(e) && t && e.select();
  }
}
const v0 = ece();
function ece() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = b0(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = b0(e, t), (n = e[0]) === null || n === void 0 || n.resume();
    }
  };
}
function b0(e, t) {
  const n = [
    ...e
  ], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function tce(e) {
  return e.filter(
    (t) => t.tagName !== "A"
  );
}
function nce(e, t) {
  return A0((n, r) => {
    const i = t[n][r];
    return i ?? n;
  }, e);
}
const Qi = (e) => {
  const { present: t, children: n } = e, r = rce(t), i = typeof n == "function" ? n({
    present: r.isPresent
  }) : io.only(n), a = nr(r.ref, i.ref);
  return typeof n == "function" || r.isPresent ? /* @__PURE__ */ wd(i, {
    ref: a
  }) : null;
};
Qi.displayName = "Presence";
function rce(e) {
  const [t, n] = De(), r = Xe({}), i = Xe(e), a = Xe("none"), o = e ? "mounted" : "unmounted", [s, l] = nce(o, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return Be(() => {
    const c = hc(r.current);
    a.current = s === "mounted" ? c : "none";
  }, [
    s
  ]), go(() => {
    const c = r.current, u = i.current;
    if (u !== e) {
      const p = a.current, f = hc(c);
      e ? l("MOUNT") : f === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && p !== f ? "ANIMATION_OUT" : "UNMOUNT"), i.current = e;
    }
  }, [
    e,
    l
  ]), go(() => {
    if (t) {
      const c = (d) => {
        const f = hc(r.current).includes(d.animationName);
        d.target === t && f && $0(
          () => l("ANIMATION_END")
        );
      }, u = (d) => {
        d.target === t && (a.current = hc(r.current));
      };
      return t.addEventListener("animationstart", u), t.addEventListener("animationcancel", c), t.addEventListener("animationend", c), () => {
        t.removeEventListener("animationstart", u), t.removeEventListener("animationcancel", c), t.removeEventListener("animationend", c);
      };
    } else
      l("ANIMATION_END");
  }, [
    t,
    l
  ]), {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(s),
    ref: nn((c) => {
      c && (r.current = getComputedStyle(c)), n(c);
    }, [])
  };
}
function hc(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
let Kp = 0;
function ice() {
  Be(() => {
    var e, t;
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", (e = n[0]) !== null && e !== void 0 ? e : w0()), document.body.insertAdjacentElement("beforeend", (t = n[1]) !== null && t !== void 0 ? t : w0()), Kp++, () => {
      Kp === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(
        (r) => r.remove()
      ), Kp--;
    };
  }, []);
}
function w0() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none", e;
}
var Rr = function() {
  return Rr = Object.assign || function(t) {
    for (var n, r = 1, i = arguments.length; r < i; r++) {
      n = arguments[r];
      for (var a in n)
        Object.prototype.hasOwnProperty.call(n, a) && (t[a] = n[a]);
    }
    return t;
  }, Rr.apply(this, arguments);
};
function DO(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
}
function ace(e, t, n) {
  if (n || arguments.length === 2)
    for (var r = 0, i = t.length, a; r < i; r++)
      (a || !(r in t)) && (a || (a = Array.prototype.slice.call(t, 0, r)), a[r] = t[r]);
  return e.concat(a || Array.prototype.slice.call(t));
}
var Vc = "right-scroll-bar-position", Hc = "width-before-scroll-bar", oce = "with-scroll-bars-hidden", sce = "--removed-body-scroll-bar-size";
function lce(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function cce(e, t) {
  var n = De(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var i = n.value;
          i !== r && (n.value = r, n.callback(r, i));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
function uce(e, t) {
  return cce(t || null, function(n) {
    return e.forEach(function(r) {
      return lce(r, n);
    });
  });
}
function dce(e) {
  return e;
}
function fce(e, t) {
  t === void 0 && (t = dce);
  var n = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(a) {
      var o = t(a, r);
      return n.push(o), function() {
        n = n.filter(function(s) {
          return s !== o;
        });
      };
    },
    assignSyncMedium: function(a) {
      for (r = !0; n.length; ) {
        var o = n;
        n = [], o.forEach(a);
      }
      n = {
        push: function(s) {
          return a(s);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(a) {
      r = !0;
      var o = [];
      if (n.length) {
        var s = n;
        n = [], s.forEach(a), o = n;
      }
      var l = function() {
        var u = o;
        o = [], u.forEach(a);
      }, c = function() {
        return Promise.resolve().then(l);
      };
      c(), n = {
        push: function(u) {
          o.push(u), c();
        },
        filter: function(u) {
          return o = o.filter(u), n;
        }
      };
    }
  };
  return i;
}
function pce(e) {
  e === void 0 && (e = {});
  var t = fce(null);
  return t.options = Rr({ async: !0, ssr: !1 }, e), t;
}
var LO = function(e) {
  var t = e.sideCar, n = DO(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return A.createElement(r, Rr({}, n));
};
LO.isSideCarExport = !0;
function hce(e, t) {
  return e.useMedium(t), LO;
}
var jO = pce(), Gp = function() {
}, jf = A.forwardRef(function(e, t) {
  var n = A.useRef(null), r = A.useState({
    onScrollCapture: Gp,
    onWheelCapture: Gp,
    onTouchMoveCapture: Gp
  }), i = r[0], a = r[1], o = e.forwardProps, s = e.children, l = e.className, c = e.removeScrollBar, u = e.enabled, d = e.shards, p = e.sideCar, f = e.noIsolation, h = e.inert, m = e.allowPinchZoom, y = e.as, g = y === void 0 ? "div" : y, v = DO(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]), b = p, T = uce([n, t]), O = Rr(Rr({}, v), i);
  return A.createElement(
    A.Fragment,
    null,
    u && A.createElement(b, { sideCar: jO, removeScrollBar: c, shards: d, noIsolation: f, inert: h, setCallbacks: a, allowPinchZoom: !!m, lockRef: n }),
    o ? A.cloneElement(A.Children.only(s), Rr(Rr({}, O), { ref: T })) : A.createElement(g, Rr({}, O, { className: l, ref: T }), s)
  );
});
jf.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
jf.classNames = {
  fullWidth: Hc,
  zeroRight: Vc
};
var x0, mce = function() {
  if (x0)
    return x0;
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function gce() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = mce();
  return t && e.setAttribute("nonce", t), e;
}
function yce(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function vce(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var bce = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = gce()) && (yce(t, n), vce(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, wce = function() {
  var e = bce();
  return function(t, n) {
    A.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, UO = function() {
  var e = wce(), t = function(n) {
    var r = n.styles, i = n.dynamic;
    return e(r, i), null;
  };
  return t;
}, xce = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Jp = function(e) {
  return parseInt(e || "", 10) || 0;
}, _ce = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], i = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [Jp(n), Jp(r), Jp(i)];
}, Sce = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return xce;
  var t = _ce(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, Ece = UO(), kce = function(e, t, n, r) {
  var i = e.left, a = e.top, o = e.right, s = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(oce, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(s, "px ").concat(r, `;
  }
  body {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(a, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(s, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(s, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(Vc, ` {
    right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(Hc, ` {
    margin-right: `).concat(s, "px ").concat(r, `;
  }
  
  .`).concat(Vc, " .").concat(Vc, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Hc, " .").concat(Hc, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body {
    `).concat(sce, ": ").concat(s, `px;
  }
`);
}, Tce = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, i = r === void 0 ? "margin" : r, a = A.useMemo(function() {
    return Sce(i);
  }, [i]);
  return A.createElement(Ece, { styles: kce(a, !t, i, n ? "" : "!important") });
}, bm = !1;
if (typeof window < "u")
  try {
    var mc = Object.defineProperty({}, "passive", {
      get: function() {
        return bm = !0, !0;
      }
    });
    window.addEventListener("test", mc, mc), window.removeEventListener("test", mc, mc);
  } catch {
    bm = !1;
  }
var qa = bm ? { passive: !1 } : !1, Cce = function(e) {
  return e.tagName === "TEXTAREA";
}, FO = function(e, t) {
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !Cce(e) && n[t] === "visible")
  );
}, Oce = function(e) {
  return FO(e, "overflowY");
}, Ace = function(e) {
  return FO(e, "overflowX");
}, _0 = function(e, t) {
  var n = t;
  do {
    typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
    var r = BO(e, n);
    if (r) {
      var i = zO(e, n), a = i[1], o = i[2];
      if (a > o)
        return !0;
    }
    n = n.parentNode;
  } while (n && n !== document.body);
  return !1;
}, $ce = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, Rce = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, BO = function(e, t) {
  return e === "v" ? Oce(t) : Ace(t);
}, zO = function(e, t) {
  return e === "v" ? $ce(t) : Rce(t);
}, Pce = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, Ice = function(e, t, n, r, i) {
  var a = Pce(e, window.getComputedStyle(t).direction), o = a * r, s = n.target, l = t.contains(s), c = !1, u = o > 0, d = 0, p = 0;
  do {
    var f = zO(e, s), h = f[0], m = f[1], y = f[2], g = m - y - a * h;
    (h || g) && BO(e, s) && (d += g, p += h), s = s.parentNode;
  } while (
    // portaled content
    !l && s !== document.body || // self content
    l && (t.contains(s) || t === s)
  );
  return (u && (i && d === 0 || !i && o > d) || !u && (i && p === 0 || !i && -o > p)) && (c = !0), c;
}, gc = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, S0 = function(e) {
  return [e.deltaX, e.deltaY];
}, E0 = function(e) {
  return e && "current" in e ? e.current : e;
}, Mce = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, Nce = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, Dce = 0, Wa = [];
function Lce(e) {
  var t = A.useRef([]), n = A.useRef([0, 0]), r = A.useRef(), i = A.useState(Dce++)[0], a = A.useState(function() {
    return UO();
  })[0], o = A.useRef(e);
  A.useEffect(function() {
    o.current = e;
  }, [e]), A.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var m = ace([e.lockRef.current], (e.shards || []).map(E0), !0).filter(Boolean);
      return m.forEach(function(y) {
        return y.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), m.forEach(function(y) {
          return y.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var s = A.useCallback(function(m, y) {
    if ("touches" in m && m.touches.length === 2)
      return !o.current.allowPinchZoom;
    var g = gc(m), v = n.current, b = "deltaX" in m ? m.deltaX : v[0] - g[0], T = "deltaY" in m ? m.deltaY : v[1] - g[1], O, S = m.target, P = Math.abs(b) > Math.abs(T) ? "h" : "v";
    if ("touches" in m && P === "h" && S.type === "range")
      return !1;
    var M = _0(P, S);
    if (!M)
      return !0;
    if (M ? O = P : (O = P === "v" ? "h" : "v", M = _0(P, S)), !M)
      return !1;
    if (!r.current && "changedTouches" in m && (b || T) && (r.current = O), !O)
      return !0;
    var L = r.current || O;
    return Ice(L, y, m, L === "h" ? b : T, !0);
  }, []), l = A.useCallback(function(m) {
    var y = m;
    if (!(!Wa.length || Wa[Wa.length - 1] !== a)) {
      var g = "deltaY" in y ? S0(y) : gc(y), v = t.current.filter(function(O) {
        return O.name === y.type && O.target === y.target && Mce(O.delta, g);
      })[0];
      if (v && v.should) {
        y.cancelable && y.preventDefault();
        return;
      }
      if (!v) {
        var b = (o.current.shards || []).map(E0).filter(Boolean).filter(function(O) {
          return O.contains(y.target);
        }), T = b.length > 0 ? s(y, b[0]) : !o.current.noIsolation;
        T && y.cancelable && y.preventDefault();
      }
    }
  }, []), c = A.useCallback(function(m, y, g, v) {
    var b = { name: m, delta: y, target: g, should: v };
    t.current.push(b), setTimeout(function() {
      t.current = t.current.filter(function(T) {
        return T !== b;
      });
    }, 1);
  }, []), u = A.useCallback(function(m) {
    n.current = gc(m), r.current = void 0;
  }, []), d = A.useCallback(function(m) {
    c(m.type, S0(m), m.target, s(m, e.lockRef.current));
  }, []), p = A.useCallback(function(m) {
    c(m.type, gc(m), m.target, s(m, e.lockRef.current));
  }, []);
  A.useEffect(function() {
    return Wa.push(a), e.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", l, qa), document.addEventListener("touchmove", l, qa), document.addEventListener("touchstart", u, qa), function() {
      Wa = Wa.filter(function(m) {
        return m !== a;
      }), document.removeEventListener("wheel", l, qa), document.removeEventListener("touchmove", l, qa), document.removeEventListener("touchstart", u, qa);
    };
  }, []);
  var f = e.removeScrollBar, h = e.inert;
  return A.createElement(
    A.Fragment,
    null,
    h ? A.createElement(a, { styles: Nce(i) }) : null,
    f ? A.createElement(Tce, { gapMode: "margin" }) : null
  );
}
const jce = hce(jO, Lce);
var ZO = A.forwardRef(function(e, t) {
  return A.createElement(jf, Rr({}, e, { ref: t, sideCar: jce }));
});
ZO.classNames = jf.classNames;
const Uce = ZO;
var Fce = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, Va = /* @__PURE__ */ new WeakMap(), yc = /* @__PURE__ */ new WeakMap(), vc = {}, Yp = 0, qO = function(e) {
  return e && (e.host || qO(e.parentNode));
}, Bce = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = qO(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, zce = function(e, t, n, r) {
  var i = Bce(t, Array.isArray(e) ? e : [e]);
  vc[n] || (vc[n] = /* @__PURE__ */ new WeakMap());
  var a = vc[n], o = [], s = /* @__PURE__ */ new Set(), l = new Set(i), c = function(d) {
    !d || s.has(d) || (s.add(d), c(d.parentNode));
  };
  i.forEach(c);
  var u = function(d) {
    !d || l.has(d) || Array.prototype.forEach.call(d.children, function(p) {
      if (s.has(p))
        u(p);
      else {
        var f = p.getAttribute(r), h = f !== null && f !== "false", m = (Va.get(p) || 0) + 1, y = (a.get(p) || 0) + 1;
        Va.set(p, m), a.set(p, y), o.push(p), m === 1 && h && yc.set(p, !0), y === 1 && p.setAttribute(n, "true"), h || p.setAttribute(r, "true");
      }
    });
  };
  return u(t), s.clear(), Yp++, function() {
    o.forEach(function(d) {
      var p = Va.get(d) - 1, f = a.get(d) - 1;
      Va.set(d, p), a.set(d, f), p || (yc.has(d) || d.removeAttribute(r), yc.delete(d)), f || d.removeAttribute(n);
    }), Yp--, Yp || (Va = /* @__PURE__ */ new WeakMap(), Va = /* @__PURE__ */ new WeakMap(), yc = /* @__PURE__ */ new WeakMap(), vc = {});
  };
}, Zce = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), i = t || Fce(e);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), zce(r, i, n, "aria-hidden")) : function() {
    return null;
  };
};
const WO = "Dialog", [VO, hfe] = xd(WO), [qce, wi] = VO(WO), Wce = (e) => {
  const { __scopeDialog: t, children: n, open: r, defaultOpen: i, onOpenChange: a, modal: o = !0 } = e, s = Xe(null), l = Xe(null), [c = !1, u] = IO({
    prop: r,
    defaultProp: i,
    onChange: a
  });
  return /* @__PURE__ */ Ue(qce, {
    scope: t,
    triggerRef: s,
    contentRef: l,
    contentId: Wc(),
    titleId: Wc(),
    descriptionId: Wc(),
    open: c,
    onOpenChange: u,
    onOpenToggle: nn(
      () => u(
        (d) => !d
      ),
      [
        u
      ]
    ),
    modal: o
  }, n);
}, Vce = "DialogTrigger", Hce = /* @__PURE__ */ ze((e, t) => {
  const { __scopeDialog: n, ...r } = e, i = wi(Vce, n), a = nr(t, i.triggerRef);
  return /* @__PURE__ */ Ue(_n.button, ut({
    type: "button",
    "aria-haspopup": "dialog",
    "aria-expanded": i.open,
    "aria-controls": i.contentId,
    "data-state": xy(i.open)
  }, r, {
    ref: a,
    onClick: On(e.onClick, i.onOpenToggle)
  }));
}), Kce = "DialogPortal", [mfe, HO] = VO(Kce, {
  forceMount: void 0
}), wm = "DialogOverlay", Gce = /* @__PURE__ */ ze((e, t) => {
  const n = HO(wm, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, a = wi(wm, e.__scopeDialog);
  return a.modal ? /* @__PURE__ */ Ue(Qi, {
    present: r || a.open
  }, /* @__PURE__ */ Ue(Jce, ut({}, i, {
    ref: t
  }))) : null;
}), Jce = /* @__PURE__ */ ze((e, t) => {
  const { __scopeDialog: n, ...r } = e, i = wi(wm, n);
  return (
    // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
    // ie. when `Overlay` and `Content` are siblings
    /* @__PURE__ */ Ue(Uce, {
      as: Sm,
      allowPinchZoom: !0,
      shards: [
        i.contentRef
      ]
    }, /* @__PURE__ */ Ue(_n.div, ut({
      "data-state": xy(i.open)
    }, r, {
      ref: t,
      style: {
        pointerEvents: "auto",
        ...r.style
      }
    })))
  );
}), ol = "DialogContent", Yce = /* @__PURE__ */ ze((e, t) => {
  const n = HO(ol, e.__scopeDialog), { forceMount: r = n.forceMount, ...i } = e, a = wi(ol, e.__scopeDialog);
  return /* @__PURE__ */ Ue(Qi, {
    present: r || a.open
  }, a.modal ? /* @__PURE__ */ Ue(Xce, ut({}, i, {
    ref: t
  })) : /* @__PURE__ */ Ue(Qce, ut({}, i, {
    ref: t
  })));
}), Xce = /* @__PURE__ */ ze((e, t) => {
  const n = wi(ol, e.__scopeDialog), r = Xe(null), i = nr(t, n.contentRef, r);
  return Be(() => {
    const a = r.current;
    if (a)
      return Zce(a);
  }, []), /* @__PURE__ */ Ue(KO, ut({}, e, {
    ref: i,
    trapFocus: n.open,
    disableOutsidePointerEvents: !0,
    onCloseAutoFocus: On(e.onCloseAutoFocus, (a) => {
      var o;
      a.preventDefault(), (o = n.triggerRef.current) === null || o === void 0 || o.focus();
    }),
    onPointerDownOutside: On(e.onPointerDownOutside, (a) => {
      const o = a.detail.originalEvent, s = o.button === 0 && o.ctrlKey === !0;
      (o.button === 2 || s) && a.preventDefault();
    }),
    onFocusOutside: On(
      e.onFocusOutside,
      (a) => a.preventDefault()
    )
  }));
}), Qce = /* @__PURE__ */ ze((e, t) => {
  const n = wi(ol, e.__scopeDialog), r = Xe(!1), i = Xe(!1);
  return /* @__PURE__ */ Ue(KO, ut({}, e, {
    ref: t,
    trapFocus: !1,
    disableOutsidePointerEvents: !1,
    onCloseAutoFocus: (a) => {
      var o;
      if ((o = e.onCloseAutoFocus) === null || o === void 0 || o.call(e, a), !a.defaultPrevented) {
        var s;
        r.current || (s = n.triggerRef.current) === null || s === void 0 || s.focus(), a.preventDefault();
      }
      r.current = !1, i.current = !1;
    },
    onInteractOutside: (a) => {
      var o, s;
      (o = e.onInteractOutside) === null || o === void 0 || o.call(e, a), a.defaultPrevented || (r.current = !0, a.detail.originalEvent.type === "pointerdown" && (i.current = !0));
      const l = a.target;
      ((s = n.triggerRef.current) === null || s === void 0 ? void 0 : s.contains(l)) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && i.current && a.preventDefault();
    }
  }));
}), KO = /* @__PURE__ */ ze((e, t) => {
  const { __scopeDialog: n, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: a, ...o } = e, s = wi(ol, n), l = Xe(null), c = nr(t, l);
  return ice(), /* @__PURE__ */ Ue(Di, null, /* @__PURE__ */ Ue(Gle, {
    asChild: !0,
    loop: !0,
    trapped: r,
    onMountAutoFocus: i,
    onUnmountAutoFocus: a
  }, /* @__PURE__ */ Ue(Vle, ut({
    role: "dialog",
    id: s.contentId,
    "aria-describedby": s.descriptionId,
    "aria-labelledby": s.titleId,
    "data-state": xy(s.open)
  }, o, {
    ref: c,
    onDismiss: () => s.onOpenChange(!1)
  }))), !1);
}), eue = "DialogTitle", tue = /* @__PURE__ */ ze((e, t) => {
  const { __scopeDialog: n, ...r } = e, i = wi(eue, n);
  return /* @__PURE__ */ Ue(_n.h2, ut({
    id: i.titleId
  }, r, {
    ref: t
  }));
}), nue = "DialogClose", rue = /* @__PURE__ */ ze((e, t) => {
  const { __scopeDialog: n, ...r } = e, i = wi(nue, n);
  return /* @__PURE__ */ Ue(_n.button, ut({
    type: "button"
  }, r, {
    ref: t,
    onClick: On(
      e.onClick,
      () => i.onOpenChange(!1)
    )
  }));
});
function xy(e) {
  return e ? "open" : "closed";
}
const iue = Wce, aue = Hce, oue = Gce, sue = Yce, lue = tue, GO = rue;
function cue({
  title: e,
  titleId: t,
  ...n
}, r) {
  return /* @__PURE__ */ A.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    strokeWidth: 1.5,
    stroke: "currentColor",
    "aria-hidden": "true",
    ref: r,
    "aria-labelledby": t
  }, n), e ? /* @__PURE__ */ A.createElement("title", {
    id: t
  }, e) : null, /* @__PURE__ */ A.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    d: "M6 18L18 6M6 6l12 12"
  }));
}
const uue = A.forwardRef(cue), JO = uue;
function Ra({
  open: e,
  onOpenChange: t,
  children: n
}) {
  return /* @__PURE__ */ F.jsx(iue, { open: e, onOpenChange: t, children: n });
}
function due({ title: e, children: t }) {
  var r, i, a, o, s, l, c, u;
  const {
    theme: { modal: n }
  } = It();
  return /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
    /* @__PURE__ */ F.jsx(oue, { ...n == null ? void 0 : n.overlay }),
    /* @__PURE__ */ F.jsx("div", { ...n == null ? void 0 : n.container, children: /* @__PURE__ */ F.jsxs(sue, { ...(r = n == null ? void 0 : n.dialog) == null ? void 0 : r.container, children: [
      /* @__PURE__ */ F.jsxs("div", { ...(a = (i = n == null ? void 0 : n.dialog) == null ? void 0 : i.title) == null ? void 0 : a.container, children: [
        /* @__PURE__ */ F.jsx(lue, { ...(s = (o = n == null ? void 0 : n.dialog) == null ? void 0 : o.title) == null ? void 0 : s.text, children: e }),
        /* @__PURE__ */ F.jsx(GO, { children: /* @__PURE__ */ F.jsx(JO, { role: "button", tabIndex: 0, ...(c = (l = n == null ? void 0 : n.dialog) == null ? void 0 : l.title) == null ? void 0 : c.closeIcon }) })
      ] }),
      /* @__PURE__ */ F.jsx("div", { ...(u = n == null ? void 0 : n.dialog) == null ? void 0 : u.content, children: t })
    ] }) })
  ] });
}
Ra.Button = aue;
Ra.Close = GO;
Ra.Content = due;
const fue = ze(({ children: e, ...t }, n) => {
  const {
    theme: { container: r }
  } = It();
  return /* @__PURE__ */ F.jsxs("div", { ...t, ...r, ref: n, children: [
    /* @__PURE__ */ F.jsx(c2, {}),
    /* @__PURE__ */ F.jsxs(jle, { children: [
      /* @__PURE__ */ F.jsx(pue, {}),
      e
    ] })
  ] });
}), pue = () => {
  const {
    theme: { modal: e },
    state: { connected: t }
  } = It(), { showModal: n } = Jx();
  return Be(() => {
    var r, i, a, o;
    t || n({
      title: "Connection Error",
      content: /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
        /* @__PURE__ */ F.jsx("p", { ...(i = (r = e == null ? void 0 : e.dialog) == null ? void 0 : r.newConversation) == null ? void 0 : i.text, children: "There was an error connecting to the server. Please check your internet connection and try again." }),
        /* @__PURE__ */ F.jsx(Ra.Close, { asChild: !0, children: /* @__PURE__ */ F.jsx("button", { ...(o = (a = e == null ? void 0 : e.dialog) == null ? void 0 : a.newConversation) == null ? void 0 : o.button, onClick: () => window.location.reload(), children: "Restart" }) })
      ] })
    });
  }, [t]), /* @__PURE__ */ F.jsx(F.Fragment, {});
}, gfe = ze(({ children: e, onClick: t, ...n }, r) => {
  const {
    theme: { fab: i }
  } = It(), { container: a, icon: o } = i ?? {};
  return /* @__PURE__ */ F.jsx("div", { ...n, ...a, ref: r, onClick: t, children: /* @__PURE__ */ F.jsx("div", { ...o }) });
}), YO = "Collapsible", [hue, yfe] = xd(YO), [mue, _y] = hue(YO), gue = /* @__PURE__ */ ze((e, t) => {
  const { __scopeCollapsible: n, open: r, defaultOpen: i, disabled: a, onOpenChange: o, ...s } = e, [l = !1, c] = IO({
    prop: r,
    defaultProp: i,
    onChange: o
  });
  return /* @__PURE__ */ Ue(mue, {
    scope: n,
    disabled: a,
    contentId: Wc(),
    open: l,
    onOpenToggle: nn(
      () => c(
        (u) => !u
      ),
      [
        c
      ]
    )
  }, /* @__PURE__ */ Ue(_n.div, ut({
    "data-state": Sy(l),
    "data-disabled": a ? "" : void 0
  }, s, {
    ref: t
  })));
}), yue = "CollapsibleTrigger", vue = /* @__PURE__ */ ze((e, t) => {
  const { __scopeCollapsible: n, ...r } = e, i = _y(yue, n);
  return /* @__PURE__ */ Ue(_n.button, ut({
    type: "button",
    "aria-controls": i.contentId,
    "aria-expanded": i.open || !1,
    "data-state": Sy(i.open),
    "data-disabled": i.disabled ? "" : void 0,
    disabled: i.disabled
  }, r, {
    ref: t,
    onClick: On(e.onClick, i.onOpenToggle)
  }));
}), XO = "CollapsibleContent", bue = /* @__PURE__ */ ze((e, t) => {
  const { forceMount: n, ...r } = e, i = _y(XO, e.__scopeCollapsible);
  return /* @__PURE__ */ Ue(
    Qi,
    {
      present: n || i.open
    },
    ({ present: a }) => /* @__PURE__ */ Ue(wue, ut({}, r, {
      ref: t,
      present: a
    }))
  );
}), wue = /* @__PURE__ */ ze((e, t) => {
  const { __scopeCollapsible: n, present: r, children: i, ...a } = e, o = _y(XO, n), [s, l] = De(r), c = Xe(null), u = nr(t, c), d = Xe(0), p = d.current, f = Xe(0), h = f.current, m = o.open || s, y = Xe(m), g = Xe();
  return Be(() => {
    const v = requestAnimationFrame(
      () => y.current = !1
    );
    return () => cancelAnimationFrame(v);
  }, []), go(() => {
    const v = c.current;
    if (v) {
      g.current = g.current || {
        transitionDuration: v.style.transitionDuration,
        animationName: v.style.animationName
      }, v.style.transitionDuration = "0s", v.style.animationName = "none";
      const b = v.getBoundingClientRect();
      d.current = b.height, f.current = b.width, y.current || (v.style.transitionDuration = g.current.transitionDuration, v.style.animationName = g.current.animationName), l(r);
    }
  }, [
    o.open,
    r
  ]), /* @__PURE__ */ Ue(_n.div, ut({
    "data-state": Sy(o.open),
    "data-disabled": o.disabled ? "" : void 0,
    id: o.contentId,
    hidden: !m
  }, a, {
    ref: u,
    style: {
      "--radix-collapsible-content-height": p ? `${p}px` : void 0,
      "--radix-collapsible-content-width": h ? `${h}px` : void 0,
      ...e.style
    }
  }), m && i);
});
function Sy(e) {
  return e ? "open" : "closed";
}
const xue = gue, _ue = vue, Sue = bue, Eue = (e) => /* @__PURE__ */ A.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: 16, height: 16, fill: "none", viewBox: "0 0 16 16", ...e }, /* @__PURE__ */ A.createElement("path", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", d: "M15.5 5.5v-5m0 0h-5m5 0L8.833 7.167m-2.5-5H4.5c-1.4 0-2.1 0-2.635.272A2.5 2.5 0 0 0 .772 3.532C.5 4.066.5 4.767.5 6.167V11.5c0 1.4 0 2.1.272 2.635a2.5 2.5 0 0 0 1.093 1.092C2.4 15.5 3.1 15.5 4.5 15.5h5.333c1.4 0 2.1 0 2.635-.273a2.5 2.5 0 0 0 1.093-1.092c.272-.535.272-1.235.272-2.635V9.667" })), kue = ({ ...e }) => {
  var o, s;
  const {
    theme: { header: t, modal: n },
    client: r
  } = It(), { showModal: i } = Jx(), a = (l) => {
    var c, u, d, p;
    l.stopPropagation(), i({
      title: "Restart Conversation",
      content: /* @__PURE__ */ F.jsxs(F.Fragment, { children: [
        /* @__PURE__ */ F.jsx("p", { ...(u = (c = n == null ? void 0 : n.dialog) == null ? void 0 : c.newConversation) == null ? void 0 : u.text, children: "Are you sure you want to restart a new conversation?" }),
        /* @__PURE__ */ F.jsx(Ra.Close, { asChild: !0, children: /* @__PURE__ */ F.jsx("button", { ...(p = (d = n == null ? void 0 : n.dialog) == null ? void 0 : d.newConversation) == null ? void 0 : p.button, onClick: r == null ? void 0 : r.restartConversation, children: "Restart" }) })
      ] })
    });
  };
  return /* @__PURE__ */ F.jsx(
    H2,
    {
      ...e,
      ...(s = (o = t == null ? void 0 : t.content) == null ? void 0 : o.actions) == null ? void 0 : s.icons,
      role: "button",
      tabIndex: 0,
      onClick: a,
      onKeyDown: (l) => {
        l.key === "Enter" && a(l);
      }
    }
  );
}, Tue = ({ ...e }) => {
  var i, a;
  const {
    theme: { header: t },
    closeWindow: n
  } = It(), r = (o) => {
    o.stopPropagation(), n == null || n();
  };
  return /* @__PURE__ */ F.jsx(
    JO,
    {
      ...e,
      ...(a = (i = t == null ? void 0 : t.content) == null ? void 0 : i.actions) == null ? void 0 : a.icons,
      role: "button",
      tabIndex: 0,
      onClick: r,
      onKeyDown: (o) => {
        o.key === "Enter" && r(o);
      }
    }
  );
}, Cue = Bo(
  ze(({ defaultOpen: e, ...t }, n) => {
    const {
      theme: { header: r }
    } = It(), [i, a] = De(!!e);
    return /* @__PURE__ */ F.jsx(xue, { open: i, onOpenChange: a, ...t, ...r == null ? void 0 : r.container, ref: n });
  })
), Oue = ze((e, t) => {
  var r;
  const {
    theme: { header: n }
  } = It();
  return /* @__PURE__ */ F.jsx(_ue, { ...e, ...(r = n == null ? void 0 : n.content) == null ? void 0 : r.container, ref: t });
}), Aue = ze((e, t) => {
  var r;
  const {
    theme: { header: n }
  } = It();
  return /* @__PURE__ */ F.jsx(Sue, { ...e, ...(r = n == null ? void 0 : n.expandedContent) == null ? void 0 : r.container, ref: t });
}), $ue = ze(({ src: e, children: t }, n) => {
  var a;
  const {
    theme: { header: r },
    client: i
  } = It();
  return /* @__PURE__ */ F.jsx(j0, { ref: n, userId: i == null ? void 0 : i.clientId, children: t, src: e, ...(a = r == null ? void 0 : r.content) == null ? void 0 : a.avatar });
}), Rue = ze((e, t) => {
  var r;
  const {
    theme: { header: n }
  } = It();
  return /* @__PURE__ */ F.jsx("h2", { ...e, ...(r = n == null ? void 0 : n.content) == null ? void 0 : r.title, ref: t });
}), Pue = ze((e, t) => {
  var r;
  const {
    theme: { header: n }
  } = It();
  return /* @__PURE__ */ F.jsx("p", { ...e, ...(r = n == null ? void 0 : n.content) == null ? void 0 : r.description, ref: t });
}), Iue = ze((e, t) => {
  var r, i;
  const {
    theme: { header: n }
  } = It();
  return /* @__PURE__ */ F.jsx("div", { ...e, ...(i = (r = n == null ? void 0 : n.content) == null ? void 0 : r.actions) == null ? void 0 : i.container, ref: t });
}), Mue = ({ icon: e, title: t, link: n, ...r }) => {
  var s, l, c, u, d, p, f, h, m, y, g, v;
  const {
    theme: { header: i }
  } = It(), a = e ?? Eue, o = (b) => {
    b && vD(b);
  };
  return !n && !t ? null : n ? /* @__PURE__ */ F.jsxs(
    "a",
    {
      ...r,
      ...(l = (s = i == null ? void 0 : i.expandedContent) == null ? void 0 : s.descriptionItems) == null ? void 0 : l.container,
      href: n,
      target: "_blank",
      rel: "noopener",
      children: [
        /* @__PURE__ */ F.jsx(a, { ...(u = (c = i == null ? void 0 : i.expandedContent) == null ? void 0 : c.descriptionItems) == null ? void 0 : u.icon }),
        /* @__PURE__ */ F.jsx("p", { ...(p = (d = i == null ? void 0 : i.expandedContent) == null ? void 0 : d.descriptionItems) == null ? void 0 : p.link, children: t })
      ]
    }
  ) : /* @__PURE__ */ F.jsxs(
    "div",
    {
      ...r,
      ...(h = (f = i == null ? void 0 : i.expandedContent) == null ? void 0 : f.descriptionItems) == null ? void 0 : h.container,
      onClick: (b) => {
        o(b.currentTarget.textContent);
      },
      children: [
        /* @__PURE__ */ F.jsx(a, { ...(y = (m = i == null ? void 0 : i.expandedContent) == null ? void 0 : m.descriptionItems) == null ? void 0 : y.icon }),
        /* @__PURE__ */ F.jsx("p", { ...(v = (g = i == null ? void 0 : i.expandedContent) == null ? void 0 : g.descriptionItems) == null ? void 0 : v.text, children: t })
      ]
    }
  );
}, Gn = Object.assign(Cue, {
  Content: Oue,
  ExpandedContent: Aue,
  Avatar: $ue,
  Description: Pue,
  Title: Rue,
  Actions: Iue,
  DescriptionItem: Mue
}), Nue = () => {
  var i, a, o, s, l, c, u, d, p, f, h, m, y, g, v, b, T, O, S;
  const {
    configuration: e,
    closeWindow: t,
    theme: { header: n }
  } = It(), r = !!((i = e.email) != null && i.title) || !!((a = e.phone) != null && a.title) || !!((o = e.website) != null && o.title) || !!((s = e.termsOfService) != null && s.link) || !!((l = e.privacyPolicy) != null && l.link);
  return /* @__PURE__ */ F.jsxs(Gn, { open: r ? void 0 : !1, "data-disabled": r ? void 0 : "", children: [
    /* @__PURE__ */ F.jsxs(Gn.Content, { children: [
      /* @__PURE__ */ F.jsx(Gn.Avatar, { src: e.botAvatar, children: e.botName || "Bot" }),
      /* @__PURE__ */ F.jsx(Gn.Title, { children: e.botName || "Bot" }),
      e.botDescription && /* @__PURE__ */ F.jsx(Gn.Description, { children: e.botDescription }),
      /* @__PURE__ */ F.jsxs(Gn.Actions, { children: [
        /* @__PURE__ */ F.jsx(kue, {}),
        t && /* @__PURE__ */ F.jsx(Tue, {})
      ] })
    ] }),
    /* @__PURE__ */ F.jsxs(Gn.ExpandedContent, { children: [
      /* @__PURE__ */ F.jsxs("div", { "data-links": "", ...(c = n == null ? void 0 : n.expandedContent) == null ? void 0 : c.group, children: [
        /* @__PURE__ */ F.jsx(
          Gn.DescriptionItem,
          {
            "data-email": "",
            icon: YL,
            title: (u = e.email) == null ? void 0 : u.title,
            link: (d = e.email) == null ? void 0 : d.link
          }
        ),
        /* @__PURE__ */ F.jsx(
          Gn.DescriptionItem,
          {
            "data-phone": "",
            icon: oj,
            title: (p = e.phone) == null ? void 0 : p.title,
            link: (f = e.phone) == null ? void 0 : f.link
          }
        ),
        /* @__PURE__ */ F.jsx(
          Gn.DescriptionItem,
          {
            "data-website": "",
            link: (h = e.website) == null ? void 0 : h.link,
            icon: ej,
            title: (m = e.website) == null ? void 0 : m.title
          }
        )
      ] }),
      /* @__PURE__ */ F.jsxs("div", { "data-legal": "", ...(y = n == null ? void 0 : n.expandedContent) == null ? void 0 : y.group, children: [
        /* @__PURE__ */ F.jsx(
          Gn.DescriptionItem,
          {
            "data-terms": "",
            link: (g = e.termsOfService) == null ? void 0 : g.link,
            icon: KL,
            title: (v = e.termsOfService) == null ? void 0 : v.title
          }
        ),
        /* @__PURE__ */ F.jsx(
          Gn.DescriptionItem,
          {
            "data-privacy": "",
            link: (b = e.privacyPolicy) == null ? void 0 : b.link,
            icon: rj,
            title: (T = e.privacyPolicy) == null ? void 0 : T.title
          }
        )
      ] }),
      /* @__PURE__ */ F.jsx("div", { ...(S = (O = n == null ? void 0 : n.expandedContent) == null ? void 0 : O.descriptionItems) == null ? void 0 : S.poweredBy, children: " by Botpress" })
    ] })
  ] });
}, vfe = Gn, Due = Bo(({ ...e }) => {
  const {
    theme: { loadingIndicator: t }
  } = It();
  return /* @__PURE__ */ F.jsx("div", { ...e, ...t == null ? void 0 : t.container, children: /* @__PURE__ */ F.jsx("div", { ...t == null ? void 0 : t.loader }) });
}), k0 = ze(
  ({ direction: e, block: t, scroll: n, disableInput: r, children: i, sender: a, ...o }, s) => {
    var m, y, g, v;
    const [l, c] = De([]), {
      theme: { message: u },
      configuration: { botAvatar: d, botName: p },
      client: f
    } = It();
    uF(() => {
      n();
    }), Be(() => {
      l.length === 0 && n();
    }, [l.length]);
    const h = L0((f == null ? void 0 : f.clientId) ?? "", 15);
    return /* @__PURE__ */ F.jsx(Kx.Provider, { value: { isLoading: l, setIsLoading: c }, children: /* @__PURE__ */ F.jsxs(
      "div",
      {
        ...o,
        ...u == null ? void 0 : u.container,
        "data-loaded": l.length === 0,
        "data-disable-input": !!r,
        "data-direction": e,
        ref: s,
        children: [
          /* @__PURE__ */ F.jsxs(M0, { "data-color": h, ...(m = u == null ? void 0 : u.avatar) == null ? void 0 : m.container, children: [
            /* @__PURE__ */ F.jsx(N0, { ...(y = u == null ? void 0 : u.avatar) == null ? void 0 : y.image, src: (a == null ? void 0 : a.avatar) ?? d }),
            /* @__PURE__ */ F.jsx(D0, { ...(g = u == null ? void 0 : u.avatar) == null ? void 0 : g.fallback, children: (a == null ? void 0 : a.name[0]) ?? ((v = p ?? "Bot") == null ? void 0 : v[0]) })
          ] }),
          t && /* @__PURE__ */ F.jsx(yl, { block: t, styles: u == null ? void 0 : u.blocks }),
          i
        ]
      }
    ) });
  }
), Lue = /* @__PURE__ */ _r(void 0);
function jue(e) {
  const t = Er(Lue);
  return e || t || "ltr";
}
function Uue(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function Fue(e, t) {
  return A0((n, r) => {
    const i = t[n][r];
    return i ?? n;
  }, e);
}
const QO = "ScrollArea", [eA, bfe] = xd(QO), [Bue, dr] = eA(QO), zue = /* @__PURE__ */ ze((e, t) => {
  const { __scopeScrollArea: n, type: r = "hover", dir: i, scrollHideDelay: a = 600, ...o } = e, [s, l] = De(null), [c, u] = De(null), [d, p] = De(null), [f, h] = De(null), [m, y] = De(null), [g, v] = De(0), [b, T] = De(0), [O, S] = De(!1), [P, M] = De(!1), L = nr(
    t,
    (I) => l(I)
  ), k = jue(i);
  return /* @__PURE__ */ Ue(Bue, {
    scope: n,
    type: r,
    dir: k,
    scrollHideDelay: a,
    scrollArea: s,
    viewport: c,
    onViewportChange: u,
    content: d,
    onContentChange: p,
    scrollbarX: f,
    onScrollbarXChange: h,
    scrollbarXEnabled: O,
    onScrollbarXEnabledChange: S,
    scrollbarY: m,
    onScrollbarYChange: y,
    scrollbarYEnabled: P,
    onScrollbarYEnabledChange: M,
    onCornerWidthChange: v,
    onCornerHeightChange: T
  }, /* @__PURE__ */ Ue(_n.div, ut({
    dir: k
  }, o, {
    ref: L,
    style: {
      position: "relative",
      // Pass corner sizes as CSS vars to reduce re-renders of context consumers
      "--radix-scroll-area-corner-width": g + "px",
      "--radix-scroll-area-corner-height": b + "px",
      ...e.style
    }
  })));
}), Zue = "ScrollAreaViewport", que = /* @__PURE__ */ ze((e, t) => {
  const { __scopeScrollArea: n, children: r, ...i } = e, a = dr(Zue, n), o = Xe(null), s = nr(t, o, a.onViewportChange);
  return /* @__PURE__ */ Ue(Di, null, /* @__PURE__ */ Ue("style", {
    dangerouslySetInnerHTML: {
      __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
    }
  }), /* @__PURE__ */ Ue(_n.div, ut({
    "data-radix-scroll-area-viewport": ""
  }, i, {
    ref: s,
    style: {
      /**
      * We don't support `visible` because the intention is to have at least one scrollbar
      * if this component is used and `visible` will behave like `auto` in that case
      * https://developer.mozilla.org/en-US/docs/Web/CSS/overflowed#description
      *
      * We don't handle `auto` because the intention is for the native implementation
      * to be hidden if using this component. We just want to ensure the node is scrollable
      * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
      * the browser from having to work out whether to render native scrollbars or not,
      * we tell it to with the intention of hiding them in CSS.
      */
      overflowX: a.scrollbarXEnabled ? "scroll" : "hidden",
      overflowY: a.scrollbarYEnabled ? "scroll" : "hidden",
      ...e.style
    }
  }), /* @__PURE__ */ Ue("div", {
    ref: a.onContentChange,
    style: {
      minWidth: "100%",
      display: "table"
    }
  }, r)));
}), xi = "ScrollAreaScrollbar", Wue = /* @__PURE__ */ ze((e, t) => {
  const { forceMount: n, ...r } = e, i = dr(xi, e.__scopeScrollArea), { onScrollbarXEnabledChange: a, onScrollbarYEnabledChange: o } = i, s = e.orientation === "horizontal";
  return Be(() => (s ? a(!0) : o(!0), () => {
    s ? a(!1) : o(!1);
  }), [
    s,
    a,
    o
  ]), i.type === "hover" ? /* @__PURE__ */ Ue(Vue, ut({}, r, {
    ref: t,
    forceMount: n
  })) : i.type === "scroll" ? /* @__PURE__ */ Ue(Hue, ut({}, r, {
    ref: t,
    forceMount: n
  })) : i.type === "auto" ? /* @__PURE__ */ Ue(tA, ut({}, r, {
    ref: t,
    forceMount: n
  })) : i.type === "always" ? /* @__PURE__ */ Ue(Ey, ut({}, r, {
    ref: t
  })) : null;
}), Vue = /* @__PURE__ */ ze((e, t) => {
  const { forceMount: n, ...r } = e, i = dr(xi, e.__scopeScrollArea), [a, o] = De(!1);
  return Be(() => {
    const s = i.scrollArea;
    let l = 0;
    if (s) {
      const c = () => {
        window.clearTimeout(l), o(!0);
      }, u = () => {
        l = window.setTimeout(
          () => o(!1),
          i.scrollHideDelay
        );
      };
      return s.addEventListener("pointerenter", c), s.addEventListener("pointerleave", u), () => {
        window.clearTimeout(l), s.removeEventListener("pointerenter", c), s.removeEventListener("pointerleave", u);
      };
    }
  }, [
    i.scrollArea,
    i.scrollHideDelay
  ]), /* @__PURE__ */ Ue(Qi, {
    present: n || a
  }, /* @__PURE__ */ Ue(tA, ut({
    "data-state": a ? "visible" : "hidden"
  }, r, {
    ref: t
  })));
}), Hue = /* @__PURE__ */ ze((e, t) => {
  const { forceMount: n, ...r } = e, i = dr(xi, e.__scopeScrollArea), a = e.orientation === "horizontal", o = Ff(
    () => l("SCROLL_END"),
    100
  ), [s, l] = Fue("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  return Be(() => {
    if (s === "idle") {
      const c = window.setTimeout(
        () => l("HIDE"),
        i.scrollHideDelay
      );
      return () => window.clearTimeout(c);
    }
  }, [
    s,
    i.scrollHideDelay,
    l
  ]), Be(() => {
    const c = i.viewport, u = a ? "scrollLeft" : "scrollTop";
    if (c) {
      let d = c[u];
      const p = () => {
        const f = c[u];
        d !== f && (l("SCROLL"), o()), d = f;
      };
      return c.addEventListener("scroll", p), () => c.removeEventListener("scroll", p);
    }
  }, [
    i.viewport,
    a,
    l,
    o
  ]), /* @__PURE__ */ Ue(Qi, {
    present: n || s !== "hidden"
  }, /* @__PURE__ */ Ue(Ey, ut({
    "data-state": s === "hidden" ? "hidden" : "visible"
  }, r, {
    ref: t,
    onPointerEnter: On(
      e.onPointerEnter,
      () => l("POINTER_ENTER")
    ),
    onPointerLeave: On(
      e.onPointerLeave,
      () => l("POINTER_LEAVE")
    )
  })));
}), tA = /* @__PURE__ */ ze((e, t) => {
  const n = dr(xi, e.__scopeScrollArea), { forceMount: r, ...i } = e, [a, o] = De(!1), s = e.orientation === "horizontal", l = Ff(() => {
    if (n.viewport) {
      const c = n.viewport.offsetWidth < n.viewport.scrollWidth, u = n.viewport.offsetHeight < n.viewport.scrollHeight;
      o(s ? c : u);
    }
  }, 10);
  return Fo(n.viewport, l), Fo(n.content, l), /* @__PURE__ */ Ue(Qi, {
    present: r || a
  }, /* @__PURE__ */ Ue(Ey, ut({
    "data-state": a ? "visible" : "hidden"
  }, i, {
    ref: t
  })));
}), Ey = /* @__PURE__ */ ze((e, t) => {
  const { orientation: n = "vertical", ...r } = e, i = dr(xi, e.__scopeScrollArea), a = Xe(null), o = Xe(0), [s, l] = De({
    content: 0,
    viewport: 0,
    scrollbar: {
      size: 0,
      paddingStart: 0,
      paddingEnd: 0
    }
  }), c = aA(s.viewport, s.content), u = {
    ...r,
    sizes: s,
    onSizesChange: l,
    hasThumb: c > 0 && c < 1,
    onThumbChange: (p) => a.current = p,
    onThumbPointerUp: () => o.current = 0,
    onThumbPointerDown: (p) => o.current = p
  };
  function d(p, f) {
    return tde(p, o.current, s, f);
  }
  return n === "horizontal" ? /* @__PURE__ */ Ue(Kue, ut({}, u, {
    ref: t,
    onThumbPositionChange: () => {
      if (i.viewport && a.current) {
        const p = i.viewport.scrollLeft, f = T0(p, s, i.dir);
        a.current.style.transform = `translate3d(${f}px, 0, 0)`;
      }
    },
    onWheelScroll: (p) => {
      i.viewport && (i.viewport.scrollLeft = p);
    },
    onDragScroll: (p) => {
      i.viewport && (i.viewport.scrollLeft = d(p, i.dir));
    }
  })) : n === "vertical" ? /* @__PURE__ */ Ue(Gue, ut({}, u, {
    ref: t,
    onThumbPositionChange: () => {
      if (i.viewport && a.current) {
        const p = i.viewport.scrollTop, f = T0(p, s);
        a.current.style.transform = `translate3d(0, ${f}px, 0)`;
      }
    },
    onWheelScroll: (p) => {
      i.viewport && (i.viewport.scrollTop = p);
    },
    onDragScroll: (p) => {
      i.viewport && (i.viewport.scrollTop = d(p));
    }
  })) : null;
}), Kue = /* @__PURE__ */ ze((e, t) => {
  const { sizes: n, onSizesChange: r, ...i } = e, a = dr(xi, e.__scopeScrollArea), [o, s] = De(), l = Xe(null), c = nr(t, l, a.onScrollbarXChange);
  return Be(() => {
    l.current && s(getComputedStyle(l.current));
  }, [
    l
  ]), /* @__PURE__ */ Ue(rA, ut({
    "data-orientation": "horizontal"
  }, i, {
    ref: c,
    sizes: n,
    style: {
      bottom: 0,
      left: a.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
      right: a.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
      "--radix-scroll-area-thumb-width": Uf(n) + "px",
      ...e.style
    },
    onThumbPointerDown: (u) => e.onThumbPointerDown(u.x),
    onDragScroll: (u) => e.onDragScroll(u.x),
    onWheelScroll: (u, d) => {
      if (a.viewport) {
        const p = a.viewport.scrollLeft + u.deltaX;
        e.onWheelScroll(p), sA(p, d) && u.preventDefault();
      }
    },
    onResize: () => {
      l.current && a.viewport && o && r({
        content: a.viewport.scrollWidth,
        viewport: a.viewport.offsetWidth,
        scrollbar: {
          size: l.current.clientWidth,
          paddingStart: vd(o.paddingLeft),
          paddingEnd: vd(o.paddingRight)
        }
      });
    }
  }));
}), Gue = /* @__PURE__ */ ze((e, t) => {
  const { sizes: n, onSizesChange: r, ...i } = e, a = dr(xi, e.__scopeScrollArea), [o, s] = De(), l = Xe(null), c = nr(t, l, a.onScrollbarYChange);
  return Be(() => {
    l.current && s(getComputedStyle(l.current));
  }, [
    l
  ]), /* @__PURE__ */ Ue(rA, ut({
    "data-orientation": "vertical"
  }, i, {
    ref: c,
    sizes: n,
    style: {
      top: 0,
      right: a.dir === "ltr" ? 0 : void 0,
      left: a.dir === "rtl" ? 0 : void 0,
      bottom: "var(--radix-scroll-area-corner-height)",
      "--radix-scroll-area-thumb-height": Uf(n) + "px",
      ...e.style
    },
    onThumbPointerDown: (u) => e.onThumbPointerDown(u.y),
    onDragScroll: (u) => e.onDragScroll(u.y),
    onWheelScroll: (u, d) => {
      if (a.viewport) {
        const p = a.viewport.scrollTop + u.deltaY;
        e.onWheelScroll(p), sA(p, d) && u.preventDefault();
      }
    },
    onResize: () => {
      l.current && a.viewport && o && r({
        content: a.viewport.scrollHeight,
        viewport: a.viewport.offsetHeight,
        scrollbar: {
          size: l.current.clientHeight,
          paddingStart: vd(o.paddingTop),
          paddingEnd: vd(o.paddingBottom)
        }
      });
    }
  }));
}), [Jue, nA] = eA(xi), rA = /* @__PURE__ */ ze((e, t) => {
  const { __scopeScrollArea: n, sizes: r, hasThumb: i, onThumbChange: a, onThumbPointerUp: o, onThumbPointerDown: s, onThumbPositionChange: l, onDragScroll: c, onWheelScroll: u, onResize: d, ...p } = e, f = dr(xi, n), [h, m] = De(null), y = nr(
    t,
    (L) => m(L)
  ), g = Xe(null), v = Xe(""), b = f.viewport, T = r.content - r.viewport, O = Nn(u), S = Nn(l), P = Ff(d, 10);
  function M(L) {
    if (g.current) {
      const k = L.clientX - g.current.left, I = L.clientY - g.current.top;
      c({
        x: k,
        y: I
      });
    }
  }
  return Be(() => {
    const L = (k) => {
      const I = k.target;
      (h == null ? void 0 : h.contains(I)) && O(k, T);
    };
    return document.addEventListener("wheel", L, {
      passive: !1
    }), () => document.removeEventListener("wheel", L, {
      passive: !1
    });
  }, [
    b,
    h,
    T,
    O
  ]), Be(S, [
    r,
    S
  ]), Fo(h, P), Fo(f.content, P), /* @__PURE__ */ Ue(Jue, {
    scope: n,
    scrollbar: h,
    hasThumb: i,
    onThumbChange: Nn(a),
    onThumbPointerUp: Nn(o),
    onThumbPositionChange: S,
    onThumbPointerDown: Nn(s)
  }, /* @__PURE__ */ Ue(_n.div, ut({}, p, {
    ref: y,
    style: {
      position: "absolute",
      ...p.style
    },
    onPointerDown: On(e.onPointerDown, (L) => {
      L.button === 0 && (L.target.setPointerCapture(L.pointerId), g.current = h.getBoundingClientRect(), v.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", f.viewport && (f.viewport.style.scrollBehavior = "auto"), M(L));
    }),
    onPointerMove: On(e.onPointerMove, M),
    onPointerUp: On(e.onPointerUp, (L) => {
      const k = L.target;
      k.hasPointerCapture(L.pointerId) && k.releasePointerCapture(L.pointerId), document.body.style.webkitUserSelect = v.current, f.viewport && (f.viewport.style.scrollBehavior = ""), g.current = null;
    })
  })));
}), xm = "ScrollAreaThumb", Yue = /* @__PURE__ */ ze((e, t) => {
  const { forceMount: n, ...r } = e, i = nA(xm, e.__scopeScrollArea);
  return /* @__PURE__ */ Ue(Qi, {
    present: n || i.hasThumb
  }, /* @__PURE__ */ Ue(Xue, ut({
    ref: t
  }, r)));
}), Xue = /* @__PURE__ */ ze((e, t) => {
  const { __scopeScrollArea: n, style: r, ...i } = e, a = dr(xm, n), o = nA(xm, n), { onThumbPositionChange: s } = o, l = nr(
    t,
    (d) => o.onThumbChange(d)
  ), c = Xe(), u = Ff(() => {
    c.current && (c.current(), c.current = void 0);
  }, 100);
  return Be(() => {
    const d = a.viewport;
    if (d) {
      const p = () => {
        if (u(), !c.current) {
          const f = nde(d, s);
          c.current = f, s();
        }
      };
      return s(), d.addEventListener("scroll", p), () => d.removeEventListener("scroll", p);
    }
  }, [
    a.viewport,
    u,
    s
  ]), /* @__PURE__ */ Ue(_n.div, ut({
    "data-state": o.hasThumb ? "visible" : "hidden"
  }, i, {
    ref: l,
    style: {
      width: "var(--radix-scroll-area-thumb-width)",
      height: "var(--radix-scroll-area-thumb-height)",
      ...r
    },
    onPointerDownCapture: On(e.onPointerDownCapture, (d) => {
      const f = d.target.getBoundingClientRect(), h = d.clientX - f.left, m = d.clientY - f.top;
      o.onThumbPointerDown({
        x: h,
        y: m
      });
    }),
    onPointerUp: On(e.onPointerUp, o.onThumbPointerUp)
  }));
}), iA = "ScrollAreaCorner", Que = /* @__PURE__ */ ze((e, t) => {
  const n = dr(iA, e.__scopeScrollArea), r = !!(n.scrollbarX && n.scrollbarY);
  return n.type !== "scroll" && r ? /* @__PURE__ */ Ue(ede, ut({}, e, {
    ref: t
  })) : null;
}), ede = /* @__PURE__ */ ze((e, t) => {
  const { __scopeScrollArea: n, ...r } = e, i = dr(iA, n), [a, o] = De(0), [s, l] = De(0), c = !!(a && s);
  return Fo(i.scrollbarX, () => {
    var u;
    const d = ((u = i.scrollbarX) === null || u === void 0 ? void 0 : u.offsetHeight) || 0;
    i.onCornerHeightChange(d), l(d);
  }), Fo(i.scrollbarY, () => {
    var u;
    const d = ((u = i.scrollbarY) === null || u === void 0 ? void 0 : u.offsetWidth) || 0;
    i.onCornerWidthChange(d), o(d);
  }), c ? /* @__PURE__ */ Ue(_n.div, ut({}, r, {
    ref: t,
    style: {
      width: a,
      height: s,
      position: "absolute",
      right: i.dir === "ltr" ? 0 : void 0,
      left: i.dir === "rtl" ? 0 : void 0,
      bottom: 0,
      ...e.style
    }
  })) : null;
});
function vd(e) {
  return e ? parseInt(e, 10) : 0;
}
function aA(e, t) {
  const n = e / t;
  return isNaN(n) ? 0 : n;
}
function Uf(e) {
  const t = aA(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, r = (e.scrollbar.size - n) * t;
  return Math.max(r, 18);
}
function tde(e, t, n, r = "ltr") {
  const i = Uf(n), a = i / 2, o = t || a, s = i - o, l = n.scrollbar.paddingStart + o, c = n.scrollbar.size - n.scrollbar.paddingEnd - s, u = n.content - n.viewport, d = r === "ltr" ? [
    0,
    u
  ] : [
    u * -1,
    0
  ];
  return oA([
    l,
    c
  ], d)(e);
}
function T0(e, t, n = "ltr") {
  const r = Uf(t), i = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, a = t.scrollbar.size - i, o = t.content - t.viewport, s = a - r, l = n === "ltr" ? [
    0,
    o
  ] : [
    o * -1,
    0
  ], c = Uue(e, l);
  return oA([
    0,
    o
  ], [
    0,
    s
  ])(c);
}
function oA(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1])
      return t[0];
    const r = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + r * (n - e[0]);
  };
}
function sA(e, t) {
  return e > 0 && e < t;
}
const nde = (e, t = () => {
}) => {
  let n = {
    left: e.scrollLeft,
    top: e.scrollTop
  }, r = 0;
  return function i() {
    const a = {
      left: e.scrollLeft,
      top: e.scrollTop
    }, o = n.left !== a.left, s = n.top !== a.top;
    (o || s) && t(), n = a, r = window.requestAnimationFrame(i);
  }(), () => window.cancelAnimationFrame(r);
};
function Ff(e, t) {
  const n = Nn(e), r = Xe(0);
  return Be(
    () => () => window.clearTimeout(r.current),
    []
  ), nn(() => {
    window.clearTimeout(r.current), r.current = window.setTimeout(n, t);
  }, [
    n,
    t
  ]);
}
function Fo(e, t) {
  const n = Nn(t);
  go(() => {
    let r = 0;
    if (e) {
      const i = new ResizeObserver(() => {
        cancelAnimationFrame(r), r = window.requestAnimationFrame(n);
      });
      return i.observe(e), () => {
        window.cancelAnimationFrame(r), i.unobserve(e);
      };
    }
  }, [
    e,
    n
  ]);
}
const rde = zue, ide = que, ade = Wue, ode = Yue, sde = Que;
var lA = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(Je, function() {
    var n = 1e3, r = 6e4, i = 36e5, a = "millisecond", o = "second", s = "minute", l = "hour", c = "day", u = "week", d = "month", p = "quarter", f = "year", h = "date", m = "Invalid Date", y = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, g = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, v = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(z) {
      var D = ["th", "st", "nd", "rd"], j = z % 100;
      return "[" + z + (D[(j - 20) % 10] || D[j] || D[0]) + "]";
    } }, b = function(z, D, j) {
      var V = String(z);
      return !V || V.length >= D ? z : "" + Array(D + 1 - V.length).join(j) + z;
    }, T = { s: b, z: function(z) {
      var D = -z.utcOffset(), j = Math.abs(D), V = Math.floor(j / 60), W = j % 60;
      return (D <= 0 ? "+" : "-") + b(V, 2, "0") + ":" + b(W, 2, "0");
    }, m: function z(D, j) {
      if (D.date() < j.date())
        return -z(j, D);
      var V = 12 * (j.year() - D.year()) + (j.month() - D.month()), W = D.clone().add(V, d), de = j - W < 0, x = D.clone().add(V + (de ? -1 : 1), d);
      return +(-(V + (j - W) / (de ? W - x : x - W)) || 0);
    }, a: function(z) {
      return z < 0 ? Math.ceil(z) || 0 : Math.floor(z);
    }, p: function(z) {
      return { M: d, y: f, w: u, d: c, D: h, h: l, m: s, s: o, ms: a, Q: p }[z] || String(z || "").toLowerCase().replace(/s$/, "");
    }, u: function(z) {
      return z === void 0;
    } }, O = "en", S = {};
    S[O] = v;
    var P = "$isDayjsObject", M = function(z) {
      return z instanceof B || !(!z || !z[P]);
    }, L = function z(D, j, V) {
      var W;
      if (!D)
        return O;
      if (typeof D == "string") {
        var de = D.toLowerCase();
        S[de] && (W = de), j && (S[de] = j, W = de);
        var x = D.split("-");
        if (!W && x.length > 1)
          return z(x[0]);
      } else {
        var ie = D.name;
        S[ie] = D, W = ie;
      }
      return !V && W && (O = W), W || !V && O;
    }, k = function(z, D) {
      if (M(z))
        return z.clone();
      var j = typeof D == "object" ? D : {};
      return j.date = z, j.args = arguments, new B(j);
    }, I = T;
    I.l = L, I.i = M, I.w = function(z, D) {
      return k(z, { locale: D.$L, utc: D.$u, x: D.$x, $offset: D.$offset });
    };
    var B = function() {
      function z(j) {
        this.$L = L(j.locale, null, !0), this.parse(j), this.$x = this.$x || j.x || {}, this[P] = !0;
      }
      var D = z.prototype;
      return D.parse = function(j) {
        this.$d = function(V) {
          var W = V.date, de = V.utc;
          if (W === null)
            return /* @__PURE__ */ new Date(NaN);
          if (I.u(W))
            return /* @__PURE__ */ new Date();
          if (W instanceof Date)
            return new Date(W);
          if (typeof W == "string" && !/Z$/i.test(W)) {
            var x = W.match(y);
            if (x) {
              var ie = x[2] - 1 || 0, ve = (x[7] || "0").substring(0, 3);
              return de ? new Date(Date.UTC(x[1], ie, x[3] || 1, x[4] || 0, x[5] || 0, x[6] || 0, ve)) : new Date(x[1], ie, x[3] || 1, x[4] || 0, x[5] || 0, x[6] || 0, ve);
            }
          }
          return new Date(W);
        }(j), this.init();
      }, D.init = function() {
        var j = this.$d;
        this.$y = j.getFullYear(), this.$M = j.getMonth(), this.$D = j.getDate(), this.$W = j.getDay(), this.$H = j.getHours(), this.$m = j.getMinutes(), this.$s = j.getSeconds(), this.$ms = j.getMilliseconds();
      }, D.$utils = function() {
        return I;
      }, D.isValid = function() {
        return this.$d.toString() !== m;
      }, D.isSame = function(j, V) {
        var W = k(j);
        return this.startOf(V) <= W && W <= this.endOf(V);
      }, D.isAfter = function(j, V) {
        return k(j) < this.startOf(V);
      }, D.isBefore = function(j, V) {
        return this.endOf(V) < k(j);
      }, D.$g = function(j, V, W) {
        return I.u(j) ? this[V] : this.set(W, j);
      }, D.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, D.valueOf = function() {
        return this.$d.getTime();
      }, D.startOf = function(j, V) {
        var W = this, de = !!I.u(V) || V, x = I.p(j), ie = function(Ve, be) {
          var he = I.w(W.$u ? Date.UTC(W.$y, be, Ve) : new Date(W.$y, be, Ve), W);
          return de ? he : he.endOf(c);
        }, ve = function(Ve, be) {
          return I.w(W.toDate()[Ve].apply(W.toDate("s"), (de ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(be)), W);
        }, E = this.$W, ke = this.$M, Ze = this.$D, Pe = "set" + (this.$u ? "UTC" : "");
        switch (x) {
          case f:
            return de ? ie(1, 0) : ie(31, 11);
          case d:
            return de ? ie(1, ke) : ie(0, ke + 1);
          case u:
            var qe = this.$locale().weekStart || 0, rt = (E < qe ? E + 7 : E) - qe;
            return ie(de ? Ze - rt : Ze + (6 - rt), ke);
          case c:
          case h:
            return ve(Pe + "Hours", 0);
          case l:
            return ve(Pe + "Minutes", 1);
          case s:
            return ve(Pe + "Seconds", 2);
          case o:
            return ve(Pe + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, D.endOf = function(j) {
        return this.startOf(j, !1);
      }, D.$set = function(j, V) {
        var W, de = I.p(j), x = "set" + (this.$u ? "UTC" : ""), ie = (W = {}, W[c] = x + "Date", W[h] = x + "Date", W[d] = x + "Month", W[f] = x + "FullYear", W[l] = x + "Hours", W[s] = x + "Minutes", W[o] = x + "Seconds", W[a] = x + "Milliseconds", W)[de], ve = de === c ? this.$D + (V - this.$W) : V;
        if (de === d || de === f) {
          var E = this.clone().set(h, 1);
          E.$d[ie](ve), E.init(), this.$d = E.set(h, Math.min(this.$D, E.daysInMonth())).$d;
        } else
          ie && this.$d[ie](ve);
        return this.init(), this;
      }, D.set = function(j, V) {
        return this.clone().$set(j, V);
      }, D.get = function(j) {
        return this[I.p(j)]();
      }, D.add = function(j, V) {
        var W, de = this;
        j = Number(j);
        var x = I.p(V), ie = function(ke) {
          var Ze = k(de);
          return I.w(Ze.date(Ze.date() + Math.round(ke * j)), de);
        };
        if (x === d)
          return this.set(d, this.$M + j);
        if (x === f)
          return this.set(f, this.$y + j);
        if (x === c)
          return ie(1);
        if (x === u)
          return ie(7);
        var ve = (W = {}, W[s] = r, W[l] = i, W[o] = n, W)[x] || 1, E = this.$d.getTime() + j * ve;
        return I.w(E, this);
      }, D.subtract = function(j, V) {
        return this.add(-1 * j, V);
      }, D.format = function(j) {
        var V = this, W = this.$locale();
        if (!this.isValid())
          return W.invalidDate || m;
        var de = j || "YYYY-MM-DDTHH:mm:ssZ", x = I.z(this), ie = this.$H, ve = this.$m, E = this.$M, ke = W.weekdays, Ze = W.months, Pe = W.meridiem, qe = function(be, he, Oe, we) {
          return be && (be[he] || be(V, de)) || Oe[he].slice(0, we);
        }, rt = function(be) {
          return I.s(ie % 12 || 12, be, "0");
        }, Ve = Pe || function(be, he, Oe) {
          var we = be < 12 ? "AM" : "PM";
          return Oe ? we.toLowerCase() : we;
        };
        return de.replace(g, function(be, he) {
          return he || function(Oe) {
            switch (Oe) {
              case "YY":
                return String(V.$y).slice(-2);
              case "YYYY":
                return I.s(V.$y, 4, "0");
              case "M":
                return E + 1;
              case "MM":
                return I.s(E + 1, 2, "0");
              case "MMM":
                return qe(W.monthsShort, E, Ze, 3);
              case "MMMM":
                return qe(Ze, E);
              case "D":
                return V.$D;
              case "DD":
                return I.s(V.$D, 2, "0");
              case "d":
                return String(V.$W);
              case "dd":
                return qe(W.weekdaysMin, V.$W, ke, 2);
              case "ddd":
                return qe(W.weekdaysShort, V.$W, ke, 3);
              case "dddd":
                return ke[V.$W];
              case "H":
                return String(ie);
              case "HH":
                return I.s(ie, 2, "0");
              case "h":
                return rt(1);
              case "hh":
                return rt(2);
              case "a":
                return Ve(ie, ve, !0);
              case "A":
                return Ve(ie, ve, !1);
              case "m":
                return String(ve);
              case "mm":
                return I.s(ve, 2, "0");
              case "s":
                return String(V.$s);
              case "ss":
                return I.s(V.$s, 2, "0");
              case "SSS":
                return I.s(V.$ms, 3, "0");
              case "Z":
                return x;
            }
            return null;
          }(be) || x.replace(":", "");
        });
      }, D.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, D.diff = function(j, V, W) {
        var de, x = this, ie = I.p(V), ve = k(j), E = (ve.utcOffset() - this.utcOffset()) * r, ke = this - ve, Ze = function() {
          return I.m(x, ve);
        };
        switch (ie) {
          case f:
            de = Ze() / 12;
            break;
          case d:
            de = Ze();
            break;
          case p:
            de = Ze() / 3;
            break;
          case u:
            de = (ke - E) / 6048e5;
            break;
          case c:
            de = (ke - E) / 864e5;
            break;
          case l:
            de = ke / i;
            break;
          case s:
            de = ke / r;
            break;
          case o:
            de = ke / n;
            break;
          default:
            de = ke;
        }
        return W ? de : I.a(de);
      }, D.daysInMonth = function() {
        return this.endOf(d).$D;
      }, D.$locale = function() {
        return S[this.$L];
      }, D.locale = function(j, V) {
        if (!j)
          return this.$L;
        var W = this.clone(), de = L(j, V, !0);
        return de && (W.$L = de), W;
      }, D.clone = function() {
        return I.w(this.$d, this);
      }, D.toDate = function() {
        return new Date(this.valueOf());
      }, D.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, D.toISOString = function() {
        return this.$d.toISOString();
      }, D.toString = function() {
        return this.$d.toUTCString();
      }, z;
    }(), U = B.prototype;
    return k.prototype = U, [["$ms", a], ["$s", o], ["$m", s], ["$H", l], ["$W", c], ["$M", d], ["$y", f], ["$D", h]].forEach(function(z) {
      U[z[1]] = function(D) {
        return this.$g(D, z[0], z[1]);
      };
    }), k.extend = function(z, D) {
      return z.$i || (z(D, B, k), z.$i = !0), k;
    }, k.locale = L, k.isDayjs = M, k.unix = function(z) {
      return k(1e3 * z);
    }, k.en = S[O], k.Ls = S, k.p = {}, k;
  });
})(lA);
var lde = lA.exports;
const Bf = /* @__PURE__ */ Ki(lde);
var cA = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(Je, function() {
    return function(n, r, i) {
      r.prototype.isToday = function() {
        var a = "YYYY-MM-DD", o = i();
        return this.format(a) === o.format(a);
      };
    };
  });
})(cA);
var cde = cA.exports;
const ude = /* @__PURE__ */ Ki(cde);
var uA = { exports: {} };
(function(e, t) {
  (function(n, r) {
    e.exports = r();
  })(Je, function() {
    return function(n, r, i) {
      r.prototype.isYesterday = function() {
        var a = "YYYY-MM-DD", o = i().subtract(1, "day");
        return this.format(a) === o.format(a);
      };
    };
  });
})(uA);
var dde = uA.exports;
const fde = /* @__PURE__ */ Ki(dde);
Bf.extend(ude);
Bf.extend(fde);
function pde(e, t = "day") {
  if (!e || e.length === 0)
    return [];
  const n = [];
  n.push(C0(e[0].timestamp));
  for (let r = 0; r < e.length; r++)
    if (n.push(e[r]), r + 1 < e.length) {
      const i = e[r].timestamp, a = e[r + 1].timestamp;
      Bf(i).isSame(a, t) || n.push(C0(a));
    }
  return n;
}
function C0(e) {
  return {
    direction: "system",
    sender: { name: "system" },
    timestamp: e,
    block: {
      type: "text",
      text: hde(e)
    }
  };
}
function hde(e, t = !1) {
  const n = Bf(e), r = "h:mma";
  return n.isToday() ? t ? `Today  ${n.format(r)}` : "Today" : n.isYesterday() ? t ? `Yesterday  ${n.format(r)}` : "Yesterday" : t ? n.format(`YYYY-MM-DD  ${r}`) : n.format("YYYY-MM-DD");
}
const O0 = 10 * 1e3, mde = Bo(({ scrollDownButton: e, ...t }) => {
  var v, b, T, O, S, P, M, L, k, I, B, U, z;
  const {
    messages: n,
    setState: r,
    client: i,
    configuration: a,
    messageContainerRef: o,
    theme: { messageList: s }
  } = It(), l = va(() => pde(n), [n]), [c, u] = De(!0), { y: d } = gF(o), [p, f] = De(!1), [h, m] = vF(), y = () => {
    if (!o.current)
      return;
    const { scrollHeight: D } = o.current;
    c && o.current.scrollTo({ top: D });
  };
  Be(() => {
    const D = new Date(Date.now() - O0 + 2e3);
    n.length > 0 && n[n.length - 1].timestamp < D && f(!1);
  }, [h]), ha(() => i == null ? void 0 : i.on("messageSent", () => {
    f(!0), m(new Date(Date.now() + O0));
  })), ha(() => i == null ? void 0 : i.on("message", () => {
    f(!1);
  })), Be(() => {
    const D = n[n.length - 1];
    r({ disableComposer: !!(D != null && D.disableInput) });
  }, [n.length]), Be(() => {
    if (!o.current)
      return;
    const { offsetHeight: D, scrollHeight: j, scrollTop: V } = o.current;
    u(j <= V + D + 100);
  }, [d]);
  const g = e != null && e.icon ? e == null ? void 0 : e.icon : q2;
  return /* @__PURE__ */ F.jsxs(rde, { ...(v = s == null ? void 0 : s.scrollbar) == null ? void 0 : v.container, scrollHideDelay: 300, type: "hover", children: [
    /* @__PURE__ */ F.jsx(ide, { ...(b = s == null ? void 0 : s.scrollbar) == null ? void 0 : b.viewport, ref: o, children: /* @__PURE__ */ F.jsxs("ul", { ...t, ...s == null ? void 0 : s.container, children: [
      /* @__PURE__ */ F.jsxs("li", { ...(T = s == null ? void 0 : s.marquee) == null ? void 0 : T.container, children: [
        /* @__PURE__ */ F.jsx(j0, { userId: i == null ? void 0 : i.clientId, src: a.botAvatar, ...(O = s == null ? void 0 : s.marquee) == null ? void 0 : O.avatar, children: (a.botName || "Bot").slice(0, 1) }),
        /* @__PURE__ */ F.jsxs("div", { ...(S = s == null ? void 0 : s.marquee) == null ? void 0 : S.content, children: [
          /* @__PURE__ */ F.jsx("h1", { ...(P = s == null ? void 0 : s.marquee) == null ? void 0 : P.title, children: a.botName || "Bot" }),
          /* @__PURE__ */ F.jsx("p", { ...(M = s == null ? void 0 : s.marquee) == null ? void 0 : M.description, children: a.botDescription })
        ] })
      ] }),
      l.map((D, j) => /* @__PURE__ */ F.jsx(k0, { scroll: y, ...D }, j)),
      p && /* @__PURE__ */ F.jsx(k0, { scroll: y, direction: "incoming", children: /* @__PURE__ */ F.jsx(Due, {}) }),
      /* @__PURE__ */ F.jsx("li", { "data-is-at-bottom": c, ...(L = s == null ? void 0 : s.scrollDownButton) == null ? void 0 : L.container, children: !!n.length && /* @__PURE__ */ F.jsxs(
        "button",
        {
          "data-is-at-bottom": c,
          ...(k = s == null ? void 0 : s.scrollDownButton) == null ? void 0 : k.button,
          onClick: () => {
            var D, j;
            return (j = o.current) == null ? void 0 : j.scrollBy({ top: (D = o.current) == null ? void 0 : D.scrollHeight });
          },
          children: [
            (e == null ? void 0 : e.text) ?? "Back",
            " ",
            /* @__PURE__ */ F.jsx(g, { ...(I = s == null ? void 0 : s.scrollDownButton) == null ? void 0 : I.icon })
          ]
        }
      ) })
    ] }) }),
    /* @__PURE__ */ F.jsx(ade, { orientation: "vertical", ...(B = s == null ? void 0 : s.scrollbar) == null ? void 0 : B.background, children: /* @__PURE__ */ F.jsx(ode, { ...(U = s == null ? void 0 : s.scrollbar) == null ? void 0 : U.thumb }) }),
    /* @__PURE__ */ F.jsx(sde, { ...(z = s == null ? void 0 : s.scrollbar) == null ? void 0 : z.corner })
  ] });
}), wfe = () => /* @__PURE__ */ F.jsxs(fue, { children: [
  /* @__PURE__ */ F.jsx(Nue, {}),
  /* @__PURE__ */ F.jsx(mde, {}),
  /* @__PURE__ */ F.jsxs(Nle, { children: [
    /* @__PURE__ */ F.jsx(Dle, {}),
    /* @__PURE__ */ F.jsx(Lle, {})
  ] })
] }), ys = q.object({
  title: q.string(),
  link: q.string().optional()
}), gde = q.object({
  composerPlaceholder: q.string().optional(),
  botName: q.string().optional(),
  botAvatar: q.string().optional(),
  botDescription: q.string().optional(),
  website: ys.optional(),
  email: ys.optional(),
  phone: ys.optional(),
  privacyPolicy: ys.optional(),
  termsOfService: ys.optional()
}), yde = q.enum([
  "heading1",
  "heading2",
  "heading3",
  "text",
  "horizontalRule",
  "link",
  "italic",
  "bold",
  "orderedList",
  "unorderedList",
  "listItem",
  "lineBreak",
  "pre"
]), vde = q.object({}).passthrough().transform((e) => e), xe = q.object({
  className: q.string().optional(),
  style: vde.optional()
}), Xp = q.object({
  container: xe.optional(),
  image: xe.optional(),
  fallback: xe.optional()
}), bde = q.object({
  button: xe.optional(),
  text: q.record(yde, xe.optional()),
  image: q.object({
    image: xe.optional(),
    placeholder: xe.optional()
  }).optional(),
  audio: xe.optional(),
  video: xe.optional(),
  file: q.object({
    container: xe.optional(),
    title: xe.optional(),
    icon: xe.optional()
  }).optional(),
  location: q.object({
    container: xe.optional(),
    title: xe.optional(),
    icon: xe.optional()
  }).optional(),
  column: xe.optional(),
  row: xe.optional(),
  bubble: xe.optional(),
  carousel: q.object({
    container: xe.optional(),
    slidesContainer: xe.optional(),
    backButton: xe.optional(),
    nextButton: xe.optional()
  }).optional(),
  dropdown: q.object({
    button: q.object({
      container: xe.optional(),
      icon: xe.optional(),
      text: xe.optional()
    }).optional(),
    content: q.object({
      container: xe.optional(),
      item: xe.optional()
    }).optional()
  }).optional()
}), wde = q.object({
  container: xe.optional(),
  modal: q.object({
    overlay: xe.optional(),
    container: xe.optional(),
    dialog: q.object({
      container: xe.optional(),
      title: q.object({
        container: xe.optional(),
        text: xe.optional(),
        closeIcon: xe.optional()
      }).optional(),
      content: xe.optional(),
      newConversation: q.object({
        text: xe.optional(),
        button: xe.optional()
      }).optional()
    }).optional()
  }).optional(),
  notification: q.object({
    container: xe.optional(),
    title: xe.optional(),
    description: xe.optional(),
    icon: xe.optional(),
    closeIcon: xe.optional()
  }).optional(),
  header: q.object({
    container: xe.optional(),
    content: q.object({
      container: xe.optional(),
      title: xe.optional(),
      description: xe.optional(),
      avatar: Xp.optional(),
      actions: q.object({
        container: xe.optional(),
        icons: xe.optional()
      }).optional()
    }),
    expandedContent: q.object({
      container: xe.optional(),
      group: xe.optional(),
      descriptionItems: q.object({
        container: xe.optional(),
        icon: xe.optional(),
        text: xe.optional(),
        link: xe.optional(),
        poweredBy: xe.optional()
      }).optional()
    }).optional(),
    description: q.object({
      container: xe.optional(),
      title: xe.optional(),
      subtitle: xe.optional()
    }).optional(),
    newConversationIcon: xe.optional()
  }).optional(),
  composer: q.object({
    container: xe.optional(),
    input: xe.optional(),
    button: q.object({
      container: xe.optional(),
      icon: xe.optional()
    }).optional()
  }).optional(),
  fab: q.object({
    icon: xe.optional(),
    container: xe.optional()
  }).optional(),
  messageList: q.object({
    scrollbar: q.object({
      container: xe.optional(),
      viewport: xe.optional(),
      thumb: xe.optional(),
      corner: xe.optional(),
      background: xe.optional()
    }).optional(),
    container: xe.optional(),
    marquee: q.object({
      content: xe.optional(),
      title: xe.optional(),
      description: xe.optional(),
      avatar: Xp.optional(),
      container: xe.optional()
    }).optional(),
    scrollDownButton: q.object({
      container: xe.optional(),
      button: xe.optional(),
      icon: xe.optional()
    }).optional()
  }).optional(),
  message: q.object({
    container: xe.optional(),
    avatar: Xp.optional(),
    blocks: bde.optional()
  }).optional(),
  loadingIndicator: q.object({
    container: xe.optional(),
    loader: xe.optional()
  }).optional()
}), xde = q.enum(["opened", "closed", "initial"]), _de = q.object({
  data: q.record(q.unknown()).optional()
}), Sde = q.enum(["messaging", "pushpin"]), Ede = q.object({
  configuration: gde.optional().catch(void 0),
  theme: wde.optional().catch(void 0),
  style: q.string().optional().catch(void 0),
  user: _de.optional().catch(void 0)
}), xfe = Ede.extend({
  clientId: q.string(),
  botId: q.string(),
  selector: q.string().optional().catch(void 0),
  webchatScriptUrl: q.string().optional().catch(void 0),
  fabScriptUrl: q.string().optional().catch(void 0),
  messagingUrl: q.string().optional().catch(void 0),
  pushpinUrl: q.string().optional().catch(void 0),
  clientMode: Sde.optional().catch(void 0),
  defaultState: xde.optional().catch(void 0)
});
export {
  j0 as A,
  yl as B,
  Nle as C,
  Sde as D,
  Ede as E,
  gfe as F,
  xfe as G,
  Nue as H,
  Due as L,
  k0 as M,
  kue as R,
  wfe as W,
  Ki as a,
  Ile as b,
  Je as c,
  ffe as d,
  Dle as e,
  Lle as f,
  _m as g,
  fue as h,
  vfe as i,
  mde as j,
  Ra as k,
  q_ as l,
  jle as m,
  pfe as n,
  ys as o,
  gde as p,
  yde as q,
  qh as r,
  vde as s,
  xe as t,
  It as u,
  Xp as v,
  bde as w,
  wde as x,
  xde as y,
  _de as z
};
