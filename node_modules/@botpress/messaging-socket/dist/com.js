"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SocketComEmitter = exports.SocketComEvents = exports.SocketCom = void 0;
const messaging_base_1 = require("@botpress/messaging-base");
const socket_io_client_1 = __importDefault(require("socket.io-client"));
class SocketCom {
    constructor(url) {
        this.url = url;
        this.pending = {};
        this.emitter = new SocketComEmitter();
        this.events = this.emitter;
    }
    connect(auth, query) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.disconnect();
                this.socket = (0, socket_io_client_1.default)(this.url, {
                    transports: ['websocket'],
                    auth,
                    autoConnect: false,
                    query
                });
                const timeout = setTimeout(() => {
                    reject('connection timed out');
                }, 5000);
                this.socket.on('login', (message) => __awaiter(this, void 0, void 0, function* () {
                    clearTimeout(timeout);
                    resolve(message);
                }));
                this.socket.on('connect_error', (err) => {
                    var _a;
                    (_a = this.socket) === null || _a === void 0 ? void 0 : _a.close();
                    clearTimeout(timeout);
                    reject(err.message);
                });
                this.socket.on('message', (message) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    if (this.pending[message.request]) {
                        if ((_a = message.data) === null || _a === void 0 ? void 0 : _a.error) {
                            this.pending[message.request].reject(new Error(message.data.message));
                        }
                        else {
                            this.pending[message.request].resolve(message.data);
                        }
                        delete this.pending[message.request];
                    }
                    yield this.emitter.emit(SocketComEvents.Message, message);
                }));
                this.socket.connect();
            });
        });
    }
    disconnect() {
        var _a;
        if (this.socket && !((_a = this.socket) === null || _a === void 0 ? void 0 : _a.disconnected)) {
            this.socket.disconnect();
        }
    }
    request(type, data) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!((_a = this.socket) === null || _a === void 0 ? void 0 : _a.connected)) {
                throw new Error('Client is disconnected');
            }
            const request = this.random(32);
            const promise = new Promise((resolve, reject) => {
                this.pending[request] = { resolve, reject };
            });
            this.socket.send({ request, type, data });
            return promise;
        });
    }
    random(length) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let str = '';
        for (let i = 0; i < length; i++) {
            str += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return str;
    }
}
exports.SocketCom = SocketCom;
var SocketComEvents;
(function (SocketComEvents) {
    SocketComEvents["Message"] = "message";
})(SocketComEvents = exports.SocketComEvents || (exports.SocketComEvents = {}));
class SocketComEmitter extends messaging_base_1.Emitter {
}
exports.SocketComEmitter = SocketComEmitter;
